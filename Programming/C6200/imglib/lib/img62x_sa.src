!<arch>
boundary.sa/    1066929161  0     0     0       8423      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Mon Mar  4 02:24:11 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   NAME                                                                    *
*       IMG_boundary -- Returns coordinates of IMG_boundary pixels.         *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and is called as follows:               *
*                                                                           *
*           void IMG_boundary                                               *
*           (                                                               *
*               const unsigned char *restrict i_data,                       *
*               int rows, int cols,                                         *
*               int *restrict o_coord,                                      *
*               int *restrict o_grey                                        *
*           );                                                              *
*                                                                           *
*       The arguments are defined as follows:                               *
*                                                                           *
*           i_data   Input images that is cols-by-rows in size.             *
*           rows     Height of the input image                              *
*           cols     Width of the input image                               *
*           o_coord  Array to write output coordinates to                   *
*           o_grey   Array to write output grey levels to                   *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine scans an image looking for non-zero pixels.            *
*       The locations of those pixels are stored out to the o_coord         *
*       as packed Y/X pairs, with Y in the upper half, and X in             *
*       the lower half.  The grey levels encountered are stored             *
*       in the o_grey array in parallel.                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       At least one row is being processed.                                *
*       Input is word aligned.                                              *
*       Input is a multiple of 4 pixels wide.                               *
*       Output buffers o_coord and o_grey start in different banks          *
*       and are word-aligned.                                               *
*       No more than 32764 rows or 32764 columns are being processed.       *
*                                                                           *
*   TECHNIQUES                                                              *
*       Outer and inner loops are collapsed together.                       *
*       Inner loop is unrolled to process four pixels per iteration.        *
*       Packed coordinate value is updated directly, rather than            *
*       by repacking x, y every time it's needed.                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_boundary"
        .global _IMG_boundary
_IMG_boundary: .cproc  A_i_data,  B_rows,  A_cols,  B_o_coord, A_o_grey 
              .no_mdep
            .reg            A_cols4,    A_r_step,   A_x
            .reg            A_c0, A_c1, A_c2, A_c3, A_i
            .reg            B_p0, B_p1, B_p2, B_p3, B_p3210

            NEG     .1      A_cols,     A_r_step
            MVKLH   .1      0,          A_r_step    ; r_step = 0x10000-cols
            SHR     .1      A_cols,     2,          A_cols4
            MPYU    .1X     B_rows,     A_cols4,    A_i
            ZERO    .1      A_c0
            MV              A_cols4,    A_x

            .mptr   A_i_data,  input  + 0, 4
            .mptr   B_o_coord, output + 0, 0
            .mptr   A_o_grey,  output + 4, 0
loop:       .trip   4, 32764*32764/4, 1
            ADD     .1      A_c0,       1,          A_c1
            ADD     .1      A_c0,       2,          A_c2
            ADD     .1      A_c0,       3,          A_c3
            ;       ;       ;           ;           ;
            LDW     .D1T2   *A_i_data++,            B_p3210
            SHRU    .2      B_p3210,    24,         B_p3
            EXTU    .2      B_p3210,    8,  24,     B_p2
            EXTU    .2      B_p3210,    16, 24,     B_p1
            EXTU    .2      B_p3210,    24, 24,     B_p0
    [B_p0]  STW     .D1T2   B_p0,       *A_o_grey++
    [B_p0]  STW     .D2T1   A_c0,       *B_o_coord++
    [B_p1]  STW     .D1T2   B_p1,       *A_o_grey++
    [B_p1]  STW     .D2T1   A_c1,       *B_o_coord++
    [B_p2]  STW     .D1T2   B_p2,       *A_o_grey++
    [B_p2]  STW     .D2T1   A_c2,       *B_o_coord++
    [B_p3]  STW     .D1T2   B_p3,       *A_o_grey++
    [B_p3]  STW     .D2T1   A_c3,       *B_o_coord++
            ADD     .1      A_c0,       4,          A_c0
            SUB     .1      A_x,        1,          A_x
    [!A_x]  ADD     .1      A_c0,       A_r_step,   A_c0
    [!A_x]  MV      .1      A_cols4,    A_x

            SUB     .1      A_i,        1,          A_i
    [ A_i]  B               loop

            .return
            .endproc

* ========================================================================= *
*   End of file:  img_boundary.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

conv_3x3.sa/    1066929161  0     0     0       20018     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Tue Mar 12 04:18:35 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*  TEXAS INSTRUMENTS, INC.                                                  *
*                                                                           *
*   NAME                                                                    *
*       IMG_conv_3x3 -- 3x3 convolution  with part. serial assembly         *
*                                                                           *
*   REVISION DATE                                                           *
*       24-Jan-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_conv_3x3(    const unsigned char *restrict inptr,          *
*                                  unsigned char *restrict outptr,          *
*                                           int            x_dim,           *
*                            const          char *restrict mask,            *
*                                           int            shift)           *
*                                                                           *
*                                                                           *
*      The convolution routine accepts three rows of 'x_dim' input points   *
*      and performs some operation on each.  A total of 'x_dim' outputs     *
*      are written to the output array. The 'mask' array has the 3 by 3     *
*      array of coefficients.                                               *
*                                                                           *
*   DESCRIPTION                                                             *
*      The convolution kernel accepts three rows of 'x_dim' input points    *
*      and produces one output row of 'x_dim' points using the input mask   *
*      of 3 by 3. The user defined shift value is used to shift the convo-  *
*      lution value, down to the byte range. The convolution sum is also    *
*      range limited to 0..255. The shift amount is non-zero for low pass   *
*      filters, and zero for high pass and sharpening filters.              *
*                                                                           *
*      The following is the C code model for the algorithm:                 *
*                                                                           *
*                                                                           *
*      void IMG_conv_3x3(   const unsigned char *restrict inptr,            *
*                                unsigned char *restrict outptr,            *
*                                         int            x_dim,             *
*                          const          char *restrict mask,              *
*                                         int            shift)             *
*      {                                                                    *
*           const   unsigned char   *IN1,*IN2,*IN3;                         *
*           unsigned char           *OUT;                                   *
*                                                                           *
*           short    pix10,  pix20,  pix30;                                 *
*           short    mask10, mask20, mask30;                                *
*                                                                           *
*           int      sum,      sum00,  sum11;                               *
*           int      i;                                                     *
*           int      sum22,    j;                                           *
*                                                                           *
*           IN1      =   inptr;                                             *
*           IN2      =   IN1 + x_dim;                                       *
*           IN3      =   IN2 + x_dim;                                       *
*           OUT      =   outptr;                                            *
*                                                                           *
*           for (j = 0; j < x_dim ; j++)                                    *
*           {                                                               *
*               sum = 0;                                                    *
*                                                                           *
*               for (i = 0; i < 3; i++)                                     *
*               {                                                           *
*                   pix10  =   IN1[i];                                      *
*                   pix20  =   IN2[i];                                      *
*                   pix30  =   IN3[i];                                      *
*                                                                           *
*                   mask10 =   mask[i];                                     *
*                   mask20 =   mask[i + 3];                                 *
*                   mask30 =   mask[i + 6];                                 *
*                                                                           *
*                   sum00  =   pix10 * mask10;                              *
*                   sum11  =   pix20 * mask20;                              *
*                   sum22  =   pix30 * mask30;                              *
*                                                                           *
*                   sum   +=   sum00 + sum11+ sum22;                        *
*               }                                                           *
*                                                                           *
*               IN1++;                                                      *
*               IN2++;                                                      *
*               IN3++;                                                      *
*                                                                           *
*               sum = (sum >> shift);                                       *
*               if ( sum <  0  )       sum = 0;                             *
*               if ( sum > 255 )       sum = 255;                           *
*               *OUT++   =       sum;                                       *
*           }                                                               *
*      }                                                                    *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*      The inner loop that computes the correlation sum is completely       *
*      unrolled and two output pixels are computed together. The mask       *
*      values are loaded and packed as words to minimize register pre-      *
*      ssure. Input data is re-used between the computations of the         *
*      two output pixels, to minimize the number of loads.                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*      An even number of output pixels needs to be computed. The image      *
*      x dimension is even.                                                 *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_conv_3x3"
        .global _IMG_conv_3x3
_IMG_conv_3x3    .cproc  A_in,B_out,A_x_dim,B_mask, A_shift
                .no_mdep

                .reg       A_pix00,    A_pix01,    A_pix02
                .reg       B_pix20,    B_pix21,    B_pix22
                .reg       A_pix30,    B_pix31,    A_pix32
                .reg       A_pix03,    B_pix23,    B_pix33
                .reg       B_pix32,    B_sum22,    B_x_dim
                .reg       A_mask,     B_255

                .reg       A_mask0,    A_mask1,    B_mask2
                .reg       B_mask3,    A_mask4,    A_mask5
                .reg       B_mask6,    B_mask7,    A_mask8
                .reg       A_MASK,     A_mask1_s,  A_mask0_s
                .reg       A_mask10,   B_mask3_s,  B_mask2_s
                .reg       B_mask32,   A_mask5_s,  A_mask4_s
                .reg       A_mask54,   B_mask7_s,  B_mask6_s
                .reg       A_mask76,   A_mask98,   B_mask54
                .reg       B_mask76,   A_mask32,   B_shift

                .reg       A_sum00,   A_sum01, A_sum02
                .reg       B_sum10,   B_sum11, B_sum12
                .reg       A_sum20,   B_sum21, A_sum22

                .reg       A_sum0,     B_sum1, B_sum2

                .reg       A_count,  B_offset, B_sum
                .reg       A_IN1,       B_IN2, A_IN3
                .reg       A_outp
                .reg       A_mask_ptr, B_outp, B_pix
                .reg       B_pos,   A_neg

                MV.2x     A_shift,       B_shift
                MV.1x     B_mask,        A_mask
                LDB.D1T1  *+A_mask[0],     A_mask0       ;mask00 = mask[0]
                LDB.D1T1  *+A_mask[1],     A_mask1       ;mask01 = mask[1]
                LDB.D2T2  *+B_mask[2],     B_mask2       ;mask02 = mask[2]
                LDB.D2T2  *+B_mask[3],     B_mask3       ;mask20 = mask[3]
                LDB.D1T1  *+A_mask[4],     A_mask4       ;mask21 = mask[4]
                LDB.D1T1  *+A_mask[5],     A_mask5       ;mask22 = mask[5]
                LDB.D2T2  *+B_mask[6],     B_mask6       ;mask30 = mask[6]
                LDB.D2T2  *+B_mask[7],     B_mask7       ;mask31 = mask[7]
                LDB.D1T1  *+A_mask[8],     A_mask8       ;mask32 = mask[8]

                MVKL.1    0x0000FFFF,      A_MASK                  ;
                MVKH.1    0x0000FFFF,      A_MASK                  ;
                MVKL.2    0xFF,            B_255                   ;
                MVKH.2    0xFF,            B_255                   ;

                SHL.1     A_mask1,         16,          A_mask1_s  ;
                AND.1     A_mask0,         A_MASK,      A_mask0_s  ;
                ADD.1     A_mask1_s,       A_mask0_s,   A_mask10   ;

                SHL.2     B_mask3,         16,          B_mask3_s  ;
                AND.2     B_mask2,         A_MASK,      B_mask2_s  ;
                ADD.2     B_mask3_s,       B_mask2_s,   B_mask32   ;
                MV.1x     B_mask32,        A_mask32                ;

                SHL.1     A_mask5,         16,          A_mask5_s  ;
                AND.1     A_mask4,         A_MASK,      A_mask4_s  ;
                ADD.1     A_mask5_s,       A_mask4_s,   A_mask54   ;
                MV.2x     A_mask54,        B_mask54                ;

                SHL.2     B_mask7,         16,          B_mask7_s  ;
                AND.2x    B_mask6,         A_MASK,      B_mask6_s  ;
                ADD.2     B_mask7_s,       B_mask6_s,   B_mask76   ;
                MV.1x     B_mask76,        A_mask76                ;

                MV.1      A_mask8,         A_mask98                ;


                MV.2x     A_x_dim,         B_x_dim                 ;
                SHRU.1    A_x_dim,         1,           A_count    ;

                ADD.1     A_in,            0,           A_IN1      ;
                ADD.2x    A_IN1,           B_x_dim,     B_IN2      ;
                ADD.1x    B_IN2,           A_x_dim,     A_IN3      ;
                ADD.2     B_out,           0,           B_outp     ;

                .mptr         A_IN1,in1+0,1
                .mptr         B_IN2,in2+0,1
                .mptr         A_IN3,in3+0,1
                .mptr         A_outp,out+0,1



                LDBU.D1T1 *A_IN1++, A_pix02             ;a01     = pix00
                LDBU.D1T1 *A_IN1++, A_pix03             ;a02     = pix01
                LDBU.D2T2 *B_IN2++, B_pix22             ;a21     = pix20
                LDBU.D2T2 *B_IN2++, B_pix23             ;a22     = pix21
                LDBU.D1T1 *A_IN3++, A_pix32             ;a31     = pix30
                LDBU.D1T2 *A_IN3++, B_pix33             ;a32     = pix31


LOOP:           .trip     8                             ;LOOP:
                MV.1      A_pix02, A_pix00              ; a00    = a01
                MV.1      A_pix03, A_pix01              ; a01    = a02
                MV.2      B_pix22, B_pix20              ; a20    = a21
                MV.2      B_pix23, B_pix21              ; a21    = a22
                MV.1      A_pix32, A_pix30              ; a30    = a31
                MV.2      B_pix33, B_pix31              ; a31    = a32

                LDBU.D1T1 *A_IN1++[2], A_pix02              ; a02    = pix02
                LDBU.D2T2 *B_IN2++[2], B_pix22              ; a22    = pix22
                LDBU.D1T1 *A_IN3++[2], A_pix32              ; a32    = pix32

                LDBU.D1T1 *-A_IN1[1], A_pix03              ; a03    = pix02
                LDBU.D2T2 *-B_IN2[1], B_pix23              ; a23    = pix22
                LDBU.D1T2 *-A_IN3[1], B_pix33              ; a33    = pix32



                MPY.1     A_pix00, A_mask10, A_sum00    ; c00    = (a00*mask00)
                MPYLH.1   A_pix01, A_mask10, A_sum01    ; c01    = (a01*mask01)
                MPY.1     A_pix02, A_mask32, A_sum02    ; c02    = (a02*mask02)

                ADD.1     A_sum00, A_sum01,  A_sum0     ; sum0   = (c00+c01)
                ADD.1     A_sum0,  A_sum02,  A_sum0     ; sum0   = (c00+c01+c02)

                MPYLH.2   B_pix20, B_mask32, B_sum10    ; c00    = (a20*mask20)
                MPY.2     B_pix21, B_mask54, B_sum11    ; c01    = (a21*mask21)
                MPYLH.2   B_pix22, B_mask54, B_sum12    ; c02    = (a22*mask22)

                ADD.2     B_sum10, B_sum11,  B_sum1     ; sum1   = (c00+c01)
                ADD.2     B_sum1,  B_sum12,  B_sum1     ; sum1   = (c00+c01+c02)
                ADD.2     B_sum1,  A_sum0,   B_sum      ; sum1   = sum1+ sum0

                MPY.1x    A_pix30, B_mask76, A_sum20    ; c00    = (a30*mask30)
                MPYLH.2   B_pix31, B_mask76, B_sum21    ; c01    = (a31*mask31)
                MPY.1     A_pix32, A_mask98, A_sum22    ; c02    = (a32*mask32)

                ADD.2x    A_sum20, B_sum21,  B_sum2     ; sum2   = c00+c01
                ADD.2x    B_sum2,  A_sum22,  B_sum2     ; sum2   = c00+c01+c02
                ADD.2     B_sum,   B_sum2,   B_sum      ; sum2   = sum2+sum1

                SHR .2    B_sum,   B_shift,  B_pix      ; sum2>>shiftval
                CMPGT.2   B_pix,   B_255,    B_pos      ;
                CMPGT.1x    0,       B_pix,    A_neg    ;

[B_pos]         MV.2      B_255,   B_pix                ;
[A_neg]         ZERO.2    B_pix                         ;

                STB.D2T2  B_pix,  *B_outp++             ; *outp++= sum2

                MPY.1     A_pix01, A_mask10, A_sum00    ; c00    = (a00*mask00)
                MPYLH.1   A_pix02, A_mask10, A_sum01    ; c01    = (a01*mask01)
                MPY.1     A_pix03, A_mask32, A_sum02    ; c02    = (a02*mask02)

                ADD.1     A_sum00, A_sum01,  A_sum0     ; sum0   = (c00+c01)
                ADD.1     A_sum0,  A_sum02,  A_sum0     ; sum0   = (c00+c01+c02)

                MPYLH.2   B_pix21, B_mask32, B_sum10    ; c00    = (a20*mask20)
                MPY.2     B_pix22, B_mask54, B_sum11    ; c01    = (a21*mask21)
                MPYLH.2   B_pix23, B_mask54, B_sum12    ; c02    = (a22*mask22)

                ADD.2     B_sum10, B_sum11,  B_sum1     ; sum1   = (c00+c01)
                ADD.2     B_sum1,  B_sum12,  B_sum1     ; sum1   = (c00+c01+c02)
                ADD.2     B_sum1,  A_sum0,   B_sum      ; sum1   = sum1+ sum0

                MPY.2     B_pix31, B_mask76, B_sum21    ; c00    = (a30*mask30)
                MPYLH.1x  A_pix32, B_mask76, A_sum20    ; c01    = (a31*mask31)
                MPY.2x    B_pix33, A_mask98, B_sum22    ; c02    = (a32*mask32)

                ADD.2     B_sum22, B_sum21,  B_sum2     ; sum2   = c00+c01
                ADD.2x    B_sum2,  A_sum20,  B_sum2     ; sum2   = c00+c01+c02
                ADD.2     B_sum,   B_sum2,   B_sum      ; sum2   = sum2+sum1

                SHR .2    B_sum,   B_shift,  B_pix     ; sum2   = sum2>>shiftval
                CMPGT.2   B_pix,   B_255,    B_pos      ;
                CMPGT.1x  0,       B_pix,    A_neg      ;

[B_pos]         MV.2      B_255,   B_pix                ;
[A_neg]         ZERO.2    B_pix                         ;

                STB.D2T2  B_pix,  *B_outp++             ; *outp++= sum2

   [A_count]    SUB.1     A_count, 1,       A_count     ; count--
   [A_count]    B.1       LOOP;                         ;  if(count) B LOOP

                .return;                                ;  return
                .endproc;                               ;

* ========================================================================= *
*   End of file:  img_conv_3x3.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

corr_3x3.sa/    1066929161  0     0     0       13718     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.1     Fri Mar 15 19:57:33 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       corr_3x3: 3x3 correlation with rounding for 8 bit data              *
*                                                                           *
*   REVISION DATE                                                           *
*       15-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void IMG_corr_3x3                                               *
*           (                                                               *
*               const unsigned char *i_data,       // input image       //  *
*               int        *restrict o_data,       // output image      //  *
*               const unsigned char  mask[3][3],   // convolution mask  //  *
*               int                  x_dim,        // width of image    //  *
*               int                  n_out         // number of outputs //  *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       The correlation performs a point by point multiplication of the     *
*       3 by 3 mask with the input image.  The result of the nine           *
*       multiplications are then summed up together to produce a            *
*       convolution sum.  This sum is then stored to the output array.      *
*                                                                           *
*       The image mask to be correlated is typically part of the input      *
*       image and indicates the area of the best match between the          *
*       input image and mask.  The mask is moved one column at a time,      *
*       advancing the mask over the portion of the row specified by         *
*       'n_out'.  When 'n_out' is larger than 'x_dim', multiple rows        *
*       will be processed.                                                  *
*                                                                           *
*       An application may call this kernel once per row to calculate       *
*       the correlation for an entire image:                                *
*                                                                           *
*           for (i = 0; i < rows; i++)                                      *
*           {                                                               *
*               IMG_corr_3x3(&i_data[i * x_dim], &o_data[i * n_out],        *
*                           mask, x_dim, n_out);                            *
*           }                                                               *
*                                                                           *
*       Alternately, the kernel may be invoked for multiple rows at         *
*       a time, although the two outputs at the end of each row will        *
*       have meaningless values.  For example:                              *
*                                                                           *
*           IMG_corr_3x3(i_data, o_data, mask, x_dim, 2 * x_dim);           *
*                                                                           *
*       This will produce two rows of outputs into 'o_data'.  The           *
*       outputs at locations o_data[x_dim - 2], o_data[x_dim - 1],          *
*       o_data[2*x_dim - 2] and o_data[2*x_dim - 1] will have               *
*       meaningless values.  This is harmless, although the application     *
*       will have to account for this when interpreting the results.        *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The array pointed to by o_data does not alias with the array        *
*       pointed to by i_data or mask.                                       *
*                                                                           *
*       The number of outputs 'n_out' must be a multiple of 2.  In cases    *
*       where 'n_out' is not a multiple of 2, most applications can safely  *
*       round 'n_out' up to the next multiple of 2 and ignore the extra     *
*       outputs.  This kernel does not round 'n_out' up for the user.       *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The mask[] array must be word aligned.  No other restrictions       *
*       are placed on the alignments of the inputs.                         *
*                                                                           *
*                                                                           *
*       This code assumes a LITTLE ENDIAN configuration.                    *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loops are unrolled completely.  The outer loop is         *
*       unrolled 2 times.                                                   *
*                                                                           *
*       To save register pressure, we store our mask values packed in       *
*       registers.  This allows us to store our 9 element mask in 5         *
*       registers.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .sect ".text:_corr_3x3_32"
        .global _IMG_corr_3x3
_IMG_corr_3x3     .cproc  A_i0, B_o, A_mask, B_x_dim, A_n_out
            .reg            A_k0F0F, A_i1, A_i2, A_p, B_i
            .reg            A_m01m20m10m00, B_m12m02m21m11
            .reg            A_m20m00, A_m01m10, A_m02m11
            .reg            B_m12m21, B____m22
            .reg            A_x0,  A_x1,  A_x2,  B_x0,  B_x1,  B_x2
            .reg            A_p00, A_p01, A_p02, B_p00, B_p01, B_p02
            .reg            A_p10, A_p11, A_p12, B_p10, B_p11, B_p12
            .reg            A_p20, A_p21, A_p22, B_p20, B_p21, B_p22
            .reg            A_s0b, A_s0c,        B_s0b, B_s0c
            .reg            A_s1a, A_s1b, A_s1c, B_s1a, B_s1b, B_s1c
            .reg            A_s2a, A_s2b, A_s2,  B_s2a, B_s2b, B_s2
            .no_mdep

;  Mask:      Words:
;  00 10 20   01 20 10 00   12 02 21 11   __ __ __ 22
;  01 11 21
;  02 12 22
;
;  Registers: __ 20 __ 00   __ 02 __ 11   __ __ __ 22
;             __ 01 __ 10   __ 12 __ 21
;

;  A_m20m00
;  A_m01m10
;  A_m02m11
;  B_m12m21
;  B____m22

            MVKL    .1      0x00FF00FF, A_k0F0F
            MVKH    .1      0x00FF00FF, A_k0F0F

            LDW     .D1T1   *A_mask(0), A_m01m20m10m00
            LDW     .D1T2   *A_mask(4), B_m12m02m21m11
            LDBU    .D1T2   *A_mask(8), B____m22

            AND     .1      A_m01m20m10m00, A_k0F0F,  A_m20m00
            XOR     .1      A_m01m20m10m00, A_m20m00, A_m01m10
            SHRU    .1      A_m01m10,       8,        A_m01m10

            AND     .1X     B_m12m02m21m11, A_k0F0F,  A_m02m11
            XOR     .2X     B_m12m02m21m11, A_m02m11, B_m12m21
            SHRU    .2      B_m12m21,       8,        B_m12m21

            MVK     .1      1,          A_p

            ADD     .1X     A_i0,       B_x_dim,    A_i1
            ADD     .1X     A_i1,       B_x_dim,    A_i2

            SHR     .2X     A_n_out,    1,          B_i
            ADD     .2      B_i,        1,          B_i

            .mptr           A_i0,       i + 0,      2
            .mptr           A_i1,       j + 0,      2
            .mptr           A_i2,       k + 0,      2
            .mptr           B_o,        o + 0,      8
loop:       .trip   1
            LDBU    .D1T1   *A_i0++,    A_x0
            LDBU    .D1T1   *A_i1++,    A_x1
            LDBU    .D1T1   *A_i2++,    A_x2

            MPYU    .1      A_x0,       A_m20m00,   A_p00
            MPYLHU  .1      A_x1,       A_m01m10,   A_p01
            MPYLHU  .1      A_x2,       A_m02m11,   A_p02

            MPYU    .1      A_x0,       A_m01m10,   A_p10
            MPYU    .1      A_x1,       A_m02m11,   A_p11
            MPYLHU  .1X     A_x2,       B_m12m21,   A_p12

            MPYLHU  .1      A_x0,       A_m20m00,   A_p20
            MPYU    .1X     A_x1,       B_m12m21,   A_p21
            MPYU    .1X     A_x2,       B____m22,   A_p22

            ADD     .1X     A_p20,      B_s1c,      A_s2a
            ADD     .1      A_p21,      A_s2a,      A_s2b
            ADD     .1      A_p22,      A_s2b,      A_s2

            ADD     .1X     A_p10,      B_s0c,      A_s1a
            ADD     .1      A_p11,      A_s1a,      A_s1b
            ADD     .1      A_p12,      A_s1b,      A_s1c

            ADD     .1      A_p01,      A_p00,      A_s0b
            ADD     .1      A_p02,      A_s0b,      A_s0c

     [!A_p] STW     .D2T1   A_s2,       *B_o++

            LDBU    .D1T2   *A_i0++,    B_x0
            LDBU    .D1T2   *A_i1++,    B_x1
            LDBU    .D1T2   *A_i2++,    B_x2

            MPYU    .2X     B_x0,       A_m20m00,   B_p00
            MPYLHU  .2X     B_x1,       A_m01m10,   B_p01
            MPYLHU  .2X     B_x2,       A_m02m11,   B_p02

            MPYU    .2X     B_x0,       A_m01m10,   B_p10
            MPYU    .2X     B_x1,       A_m02m11,   B_p11
            MPYLHU  .2      B_x2,       B_m12m21,   B_p12

            MPYLHU  .2X     B_x0,       A_m20m00,   B_p20
            MPYU    .2      B_x1,       B_m12m21,   B_p21
            MPYU    .2      B_x2,       B____m22,   B_p22

            ADD     .2X     B_p20,      A_s1c,      B_s2a
            ADD     .2      B_p21,      B_s2a,      B_s2b
            ADD     .2      B_p22,      B_s2b,      B_s2

            ADD     .2X     B_p10,      A_s0c,      B_s1a
            ADD     .2      B_p11,      B_s1a,      B_s1b
            ADD     .2      B_p12,      B_s1b,      B_s1c

            ADD     .2      B_p01,      B_p00,      B_s0b
            ADD     .2      B_p02,      B_s0b,      B_s0c


     [!A_p] STW     .D2T2   B_s2,       *B_o++

     [ A_p] SUB     .1      A_p,        1,          A_p

            SUB             B_i,        1,          B_i
     [ B_i] B               loop

            .return
            .endproc

* ========================================================================= *
*   End of file:  img_corr_3x3.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
corr_gen.sa/    1066929161  0     0     0       21751     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Thu Sep 26 05:40:48 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_corr_gen : Generalized Correlatoion                             *
*                                                                           *
*   REVISION DATE                                                           *
*       26-Sep-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_corr_gen                                                   *
*       (                                                                   *
*           short *in_data,      //  Input: pixel array           //        *
*           short *h,            //  Input: 1-by-M mask           //        *
*           short *out_data,     //  Output: correlation sum      //        *
*           int M,               //  Input: # of filter taps      //        *
*           int cols             //  Input: Width of input image  //        *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine performs a generalized correlation with a 1 by M       *
*       tap filter. It can be called repetitively to form an arbitrary      *
*       M by n 2D generalized correlation kernel.  The correlation sum      *
*       is currently stored as half words.  The input pixel, and mask       *
*       data is assumed to come in as shorts.  No restrictions are          *
*       placed cols and M.                                                  *
*                                                                           *
*   C CODE                                                                  *
*       The C code is a general implementation without restrictions.        *
*       The assembly code may have some restrictions, as noted below.       *
*                                                                           *
*       void IMG_corr_gen(short *in_data, short *h, short *out_data,int M,  *
*       int cols)                                                           *
*       {                                                                   *
*                                                                           *
*          //--------------------------------------------------------//     *
*          // For all columns compute a M tap fir                    //     *
*          // Add correlation sum to existing value to allow for a   //     *
*          // generalized 2D correlation to be built using several   //     *
*          // 1D correlations                                        //     *
*          //--------------------------------------------------------//     *
*                                                                           *
*          for (j = 0; j < cols - M; j++)                                   *
*          {                                                                *
*             sum =  out_data[j];                                           *
*             for (i = 0; i < M; i++)                                       *
*             {                                                             *
*                sum += in_data[i + j] * h[i];                              *
*             }                                                             *
*             out_data[j] = sum;                                            *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Since this kernel is a generalized correlation kernel the # of      *
*       filter taps can be as small as 1.  Hence it is not beneficial       *
*       to pipeline this loop.  In addition collapsing both the loops       *
*       causes data dependencies and degrades the performance.  However     *
*       this is one of the few cases where loop order interchange can       *
*       be used effectively.  In this case the outer loop of the            *
*       natural C code is exchanged to be the inner loop that is to be      *
*       software pipe- lined.  it is beneficial to pieline this loop        *
*       because typical image dimensions are larger than the # of           *
*       filter taps.  Notice however that the # of loads and stores do      *
*       go up within this loop as compared to the natural C code.           *
*                                                                           *
*       The hand assembly version of the code tries to balance the          *
*       computing with the loads/stores that have to be performed           *
*       because of the loop order interchange.  In order to do this         *
*       word-wide loads are used.  In addition the outer loop that          *
*       computes one filter-tap at a time is unrolled and computes two      *
*       filter taps at a time.  This has certain ramifications that are     *
*       discussed later.  In order to decrease the # of loads the first     *
*       word is pre-loaded outside the j loop and data is re-used           *
*       within the j loop.  The updating of the present correl- ation       *
*       sum with the previous correlation sum is done using the add2        *
*       instruction.  In addition to get better multiplier utilization      *
*       the inner loop is unrolled four times and four outputs are          *
*       computed together.  The inner loop unrolling also has certain       *
*       ramifications that are explained below.                             *
*                                                                           *
*       Special Cases                                                       *
*                                                                           *
*       Unrolling the outer loop assumes that there are an even number      *
*       of filter taps.  Two cases arise:                                   *
*                                                                           *
*       a) M = 1.  In this case a seperate version that does just 1 tap     *
*       needs to be used and the code should directly start from this       *
*       loop without executing the even version.                            *
*                                                                           *
*       b) M is odd.  In this case the evn version of the loop is used      *
*       for as many even taps as possible and then the last tap is          *
*       computed using the odd tap special version created for M = 1.       *
*                                                                           *
*       In this way problems associated with unrolling the outer loop       *
*       are overcome.                                                       *
*                                                                           *
*       Unrolling the inner loop four times assumes that the loop           *
*       iteration cols - M is a multiple of four.  In most typical          *
*       images cols is a multiple of 8 but since M is totally general       *
*       cols - M is definitely not a multiple of 4.  In addition if cols    *
*       - M is not a multiple of 4 then the inner loop iterates fewer       *
*       times than required and certain output pixels will not be           *
*       computed.  This problem is overcome as foll                         *
*                                                                           *
*       a) Increment (cols - M) by 4 so that the next higher multiple of    *
*       4 is computed.  This implies that in certain cases up to 4          *
*       extra pixels may be computed if cols - M is an exact multiple of    *
*       4.  In other cases 1,2 or 3 extra pixels may be computed.  In       *
*       order to annull this extra computation 4 locations starting at      *
*       x[cols-M] are zeroed out before returning to ensure identical       *
*       behaviour with the natural C code.                                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       a) input image, output array must be word-alligned                  *
*                                                                           *
*       b) output array must have at-least a dimension of cols -            *
*       M + 4                                                               *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts should occurr in this kernel.                     *
*       This code is ENDIAN NEUTRAL                                         *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_corr_gen"
        .global _IMG_corr_gen
_IMG_corr_gen:.cproc   A_x, B_h, A_y, B_m,  A_x_dim

            .no_mdep
            .reg   B_hptr,     A_hptr,       A_tmp0
            .reg   A_tmp1,     A_iters,      A_k
            .reg                             B_i
            .reg   A_j,        B_h0,         A_h1
            .reg   A_h0,       B_h1,         A_xptr
            .reg   A_x1x0,     B_xptr,       A_yiptr
            .reg   B_ziptr,    B_yiptr,      A_ziptr
            .reg   B_x3x2,     A_x5x4,       A_h0x0
            .reg   A_h0x1,     B_h0x2,       B_h0x3
            .reg   A_h1x1,     B_h1x2,       B_h1x3
            .reg   A_h1x4,     A_sum0,       A_sum1
            .reg   B_sum2,     B_sum3,       A_sum1_s
            .reg   B_sum3_s,   A_sum_zero,   B_sum_one
            .reg   A_y1y0,     B_y3y2,       A_z1z0
            .reg   B_z3z2,     B_tmp1
            .reg   A_od,       A_tmp
            .reg   B_xword0,   A_xword1,     A_jmp


         MV.2     B_h,          B_hptr                   ; Odd filter ptr
         ADD.1x   B_h,          2,              A_hptr   ; Even filter ptr

         SUB.1x   A_x_dim,      B_m,            A_tmp0   ; tmp0 = x - m
         AND.1    A_tmp0,       1,              A_tmp1   ; odd/even
         SUB.1    A_tmp0,       A_tmp1,         A_iters  ; deduct 1 if odd

         ZERO.1   A_k                                    ; k = 0


         SUB.2x   B_m,          A_tmp1,         B_i      ; deduct 1 if odd
         SHRU.2   B_i,          1,              B_i      ; Process 2 filt taps

         SUB.2    B_m,          1,              A_jmp    ;
[!A_jmp] B.2      SKIP                                   ;

LOOPI:

         LDH.D2T2   *B_hptr++[2], B_h0                    ; h0 even filter tap
         LDH.D1T1   *A_hptr++[2], A_h1                    ; h1 odd  filter tap
         MV.1x       B_h0,        A_h0                    ; h0 cpy  to A side
         MV.2x       A_h1,        B_h1                    ; h1 cpy  to B side

         ADD.1       A_x,         A_k,          A_xptr    ; Word-wide loads of x

         LDW.D1T1   *A_xptr++,   A_x1x0                   ; x1x0 load
         MV.2x       A_xptr,      B_xptr                  ; Bxptr--->x[0], x[1]
         ADD.1       A_xptr,      4,            A_xptr    ; Axptr--->x[2], x[4]
         ADD.1       A_k,         4,            A_k       ; k inc. by 1 word

         MV.1        A_y,         A_yiptr                 ; A_yiptr= &y[0]
         ADD.2x      A_y,         4,            B_yiptr   ; B_yiptr= &y[1]
         MV.1        A_y,         A_ziptr                 ; A_ziptr= &y[0]
         ADD.2X      A_y,         4,            B_ziptr   ; B_ziptr= &y[1]

         ADD.1       A_iters,     4,            A_j       ; j += iters
         SHRU.1      A_j,         2,            A_j       ; j >> 2

         .mptr B_xptr,  x+0, 8                            ; &x[4*i + 0]
         .mptr A_xptr,  x+4, 8                            ; &x[4*i + 2]
         .mptr A_yiptr, y+0, 8                            ; &y[4*i + 0]
         .mptr B_yiptr, y+4, 8                            ; &y[4*i + 2]
         .mptr A_ziptr, y+0, 8                            ; &y[4*i + 0]
         .mptr B_ziptr, y+4, 8                            ; &y[4*i + 2]

LOOPJ:   .trip 16

         LDW.D2T2   *B_xptr++[2], B_x3x2                  ; x3x2 load
         LDW.D1T1   *A_xptr++[2], A_x5x4                  ; x5x4 load

         MPY.1       A_h0,        A_x1x0,        A_h0x0   ; h0x0 = h0 * x0
         MPYLH.1     A_h0,        A_x1x0,        A_h0x1   ; h0x1 = h0 * x1
         MPY.2       B_h0,        B_x3x2,        B_h0x2   ; h0x2 = h0 * x2
         MPYLH.2     B_h0,        B_x3x2,        B_h0x3   ; h0x3 = h0 * x3

         MPYLH.1     A_h1,        A_x1x0,        A_h1x1   ; h1x1 = h1 * x1
         MPY.2       B_h1,        B_x3x2,        B_h1x2   ; h1x2 = h1 * x2
         MPYLH.2     B_h1,        B_x3x2,        B_h1x3   ; h1x3 = h1 * x3
         MPY.1       A_h1,        A_x5x4,        A_h1x4   ; h1x4 = h1 * x4

         ADD.1       A_h0x0,      A_h1x1,        A_sum0   ; sum0 = h0x0 + h1x1
         ADD.1       A_h0x1,      B_h1x2,        A_sum1   ; sum1 = h0x1 + h1x2
         ADD.2       B_h0x2,      B_h1x3,        B_sum2   ; sum2 = h0x2 + h1x3
         ADD.2       B_h0x3,      A_h1x4,        B_sum3   ; sum3 = h0x3 + h1x4

         SHL.1       A_sum1,      16,            A_sum1_s  ; sum1_s = sum1 >> 16
         SHL.2       B_sum3,      16,            B_sum3_s  ; sum3_s = sum3 >> 16
         ADD.1       A_sum1_s,    A_sum0,        A_sum_zero; sum1_s + sum0
         ADD.2       B_sum3_s,    B_sum2,        B_sum_one ; sum3_s + sum2

         LDW.D1T1    *A_yiptr++[2],              A_y1y0    ; prev0
         LDW.D2T2    *B_yiptr++[2],              B_y3y2    ; prev1

         ADD2.1      A_y1y0,     A_sum_zero,     A_z1z0    ;add2(prev0,sum_zero)
         ADD2.2      B_y3y2,     B_sum_one,      B_z3z2    ;add2(prev1,sum_one)

         STW.D1T1    A_z1z0,    *A_ziptr++[2]              ; Store pres0
         STW.D2T2    B_z3z2,    *B_ziptr++[2]              ; Store pres1

         MV.1        A_x5x4,        A_x1x0                 ; x1x0 = x5x4

[A_j]    SUB.1       A_j,           1,           A_j       ; if (j) j--
[A_j]    B.1         LOOPJ                                 ; if (j) B LOOPJ

[B_i]    SUB.2       B_i,           1,             B_i     ; if (i) i--
[B_i]    B.2         LOOPI                                 ; if (i) B LOOPI


[!A_tmp1] B.2        END                                   ; if (even) end

SKIP:
         SUB.1x      B_m,           1,             A_tmp   ; tmp = m - 1
         MPY.1       A_tmp,         2,             A_tmp   ; Scale for HWORD
         ADD.1       A_x,           A_tmp,         A_xptr  ; xptr = &x[m-1]
         ADD.2       B_h,           A_tmp,         B_hptr  ; hptr = &h[m-1]

         LDH.D2T2   *B_hptr,       B_h0                    ; h0 = h[m-1]
         MV.1x       B_h0,          A_h0                   ; Make h0 copy

         MV.2x       A_xptr,        B_xptr                 ; Make xptr copy
         ADD.1       A_xptr,        4,             A_xptr  ; A_xptr = &x[2]

         MV.1        A_y,           A_yiptr                ; A_yiptr = &y[0]
         ADD.2x      A_y,           4,             B_yiptr ; B_yiptr = &y[2]
         MV .1       A_y,           A_ziptr                ; A_ziptr = &y[0]
         ADD.2X      A_y,           4,             B_ziptr ; B_ziptr = &y[2]


         ADD.1       A_iters,       4,             A_od    ; Iterate 4M times
         SHRU.1      A_od,          2,             A_od    ; od >> 2


         .mptr B_xptr,  x+0, 8                            ; &x[4*i + 0]
         .mptr A_xptr,  x+4, 8                            ; &x[4*i + 2]
         .mptr A_yiptr, y+0, 8                            ; &y[4*i + 0]
         .mptr B_yiptr, y+4, 8                            ; &y[4*i + 2]
         .mptr A_ziptr, y+0, 8                            ; &y[4*i + 0]
         .mptr B_ziptr, y+4, 8                            ; &y[4*i + 2]
LOOPOD:     .trip  16

         LDW.D2T2   *B_xptr++[2],  B_xword0                ; x1x0 load
         LDW.D1T1   *A_xptr++[2],  A_xword1                ; x3x2 load

         MPY.1       A_h0,         B_xword0,      A_h0x0   ; h0x0 = h0 * x0
         MPYLH.1     A_h0,         B_xword0,      A_h0x1   ; h0x1 = h0 * x1
         MPY.2       B_h0,         A_xword1,      B_h0x2   ; h0x2 = h0 * x2
         MPYLH.2     B_h0,         A_xword1,      B_h0x3   ; h0x3 = h0 * x3

         SHL.1       A_h0x1,       16,            A_sum1_s ; h0x1 << 16
         ADD.1       A_sum1_s,     A_h0x0,        A_sum_zero; h0x1 | h0x0
         SHL.2       B_h0x3,       16,            B_sum3_s  ; h0x3 << 16
         ADD.2       B_sum3_s,     B_h0x2,        B_sum_one ; h0x3 | h0x2

         LDW.D1T1   *A_yiptr++[2], A_y1y0                  ; prev0
         LDW.D2T2   *B_yiptr++[2], B_y3y2                  ; prev1

         ADD2.1     A_y1y0,        A_sum_zero,    A_z1z0   ; add2 to prev0
         ADD2.2     B_y3y2,        B_sum_one,     B_z3z2   ; add2 to prev1

         STW.D1T1   A_z1z0,       *A_ziptr++[2]            ; pres0 store
         STW.D2T2   B_z3z2,       *B_ziptr++[2]            ; pres1 store

[A_od]   SUB.1      A_od,          1,             A_od     ; if (od) od--
[A_od]   B.1        LOOPOD                                 ; if (od) B LOOPOD

END:

         SUB.1x     A_x_dim,         B_m,          A_h0
         ZERO.1     A_z1z0
         ZERO.2     B_z3z2
         ADDAH.1    A_y,             A_h0,         A_xptr
         ADD.2x     A_xptr,          2,            B_xptr
         STH.D1T1   A_z1z0,          *A_xptr++[2]
         STH.D2T2   B_z3z2,          *B_xptr++[2]
         STH.D1T1   A_z1z0,          *A_xptr++[2]
         STH.D2T2   B_z3z2,          *B_xptr++[2]

         .return                                     ; return
         .endproc                                    ; end

* ========================================================================= *
*   End of file:  img_corr_gen.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

dilate_bin.sa/  1066929161  0     0     0       14439     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Tue Mar 12 04:26:45 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_dilate_bin-- This code performs 3x3 binary dilation             *
*                                                                           *
*   REVISION DATE                                                           *
*       20-Oct-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_dilate_bin                                                 *
*       (                                                                   *
*           const unsigned char *restrict in_data,   /* Incoming image  */  *
*           unsigned char       *restrict out_data,  /* Filtered output */  *
*           const char          *restrict mask,      /* Filter mask     */  *
*           int cols  /* Number of columns to process, in bytes.        */  *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_dilate_bin() implements binary dilation using an   *
*       arbitrary 3x3 mask.  The dilation operator generates output pixels  *
*       by ORing the pixels under the input mask together to generate       *
*       the output pixel.  The input mask specifies whether one or more     *
*       pixels from the input are to be ignored.                            *
*                                                                           *
*       In pseudo-code, the filtering operation for a pixel at (x, y)       *
*       works like so:                                                      *
*                                                                           *
*           result = 0;                                                     *
*           if (mask[0][0] != DONT_CARE) result |= input[y + 0][x + 0];     *
*           if (mask[0][1] != DONT_CARE) result |= input[y + 1][x + 1];     *
*           if (mask[0][2] != DONT_CARE) result |= input[y + 2][x + 2];     *
*           if (mask[1][0] != DONT_CARE) result |= input[y + 0][x + 0];     *
*           if (mask[1][1] != DONT_CARE) result |= input[y + 1][x + 1];     *
*           if (mask[1][2] != DONT_CARE) result |= input[y + 2][x + 2];     *
*           if (mask[2][0] != DONT_CARE) result |= input[y + 0][x + 0];     *
*           if (mask[2][1] != DONT_CARE) result |= input[y + 1][x + 1];     *
*           if (mask[2][2] != DONT_CARE) result |= input[y + 2][x + 2];     *
*           output[y][x] = result;                                          *
*                                                                           *
*       For this code, "DONT_CARE" is specified by a negative value         *
*       in the input mask.  Non-negative values in the mask cause the       *
*       corresponding pixel to be included in the dilation operation.       *
*                                                                           *
*       Note that this code operates on a bitmap where each pixel is        *
*       represented as a single bit within a byte or word.  Although        *
*       the pseudo-code above operates only on one pixel at a time,         *
*       with a single pixel in each array element, this implementation      *
*       operates on a bitmap which contains 8 pixels in each byte.          *
*                                                                           *
*       Pixels are organized within each byte such that the pixel with      *
*       the smallest index is in the LSB position, and the pixel with       *
*       the largest index is in the MSB position.  (That is, the code       *
*       assumes a LITTLE ENDIAN bit ordering.)                              *
*                                                                           *
*       Note that the "cols" argument actually specifies the number of      *
*       BYTES in the output, not the number of columns.  The number of      *
*       columns is 8 times this argument.                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The 3x3 dilation mask is applied to 32 output pixels                *
*       simultaneously.  This is done with 32-bit-wide bitwise              *
*       operators in the register file.  In order to do this, the code      *
*       reads in a 34-bit-wide input window, and 40-bit operations          *
*       are used to manipulate the pixels initially.                        *
*                                                                           *
*       Because the code reads a 34-bit context for each 32-bits of         *
*       output, the input needs to be one byte longer than the output       *
*       in order to make the rightmost two pixels well-defined.             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1.  Negative values in the mask specify "DONT_CARE", and non-       *
*           negative values specify that pixels are included in the         *
*           dilation operation.                                             *
*                                                                           *
*       2.  The input image needs to have a multiple of 64 pixels(bits)     *
*           per row.  Therefore, "cols" must be a multiple of 8.            *
*                                                                           *
*   NOTES                                                                   *
*       Little Endian                                                       *
*                                                                           *
*       "Digital Image Processing: Principles and Applications"             *
*       by Gregory A. Baxes, Chapter 5                                      *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


            .sect ".data:copyright_p"

        .sect ".text:_dilate_bin"
        .global _IMG_dilate_bin
_IMG_dilate_bin: .cproc  A_ir0,  B_out_data,  A_mask, B_cols

        .no_mdep

        .reg  B_q8:B_p8, B_t8
        .reg  B_q7:B_p7
        .reg  B_q5:B_p5
        .reg  B_p6h:B_p6, B_p6_
        .reg  B_p3h:B_p3, B_p3_
        .reg  A_q4:A_p4, A_t4
        .reg  A_q2:A_p2
        .reg  A_q1:A_p1
        .reg  A_p3h:A_p3, A_p3_
        .reg  A_p0h:A_p0, A_p0_
        .reg  B_m8
        .reg  B_m7654
        .reg  B_m7
        .reg  B_m6
        .reg  B_m5
        .reg  B_ir1
        .reg  B_rA
        .reg  B_rB
        .reg  B_rC
        .reg  B_rD
        .reg  B_i
        .reg  B_c4
        .reg  A_m4
        .reg  B_m3
        .reg  A_m2
        .reg  A_m1
        .reg  A_m0
        .reg  A_out_data
        .reg  A_rA
        .reg  A_rB
        .reg  A_rC
        .reg  A_rD
        .reg  A_rslt
        .reg  A_k1
        .reg  B_k1
        .reg  B_mask

        MVK  .1     1,          A_k1
        MVK  .2     1,          B_k1

        MV   .2X    A_mask,     B_mask

        LDB  .D1T2  *A_mask[8], B_m8
        LDB  .D2T2  *B_mask[7], B_m7
        LDB  .D2T2  *B_mask[6], B_m6
        LDB  .D1T2  *A_mask[5], B_m5
        LDB  .D1T1  *A_mask[4], A_m4
        LDB  .D2T2  *B_mask[3], B_m3
        LDB  .D2T1  *B_mask[2], A_m2
        LDB  .D1T1  *A_mask[1], A_m1
        LDB  .D1T1  *A_mask[0], A_m0

        MPYHL       B_m8,       B_k1,       B_m8
        MPYHL       B_m7,       B_k1,       B_m7
        MPYHL       B_m6,       B_k1,       B_m6
        MPYHL       B_m5,       B_k1,       B_m5

        MPYHL       A_m4,       A_k1,       A_m4
        MPYHL       B_m3,       B_k1,       B_m3
        MPYHL       A_m2,       A_k1,       A_m2
        MPYHL       A_m1,       A_k1,       A_m1
        MPYHL       A_m0,       A_k1,       A_m0

        NOT         B_m8,       B_m8
        NOT         B_m6,       B_m6
        NOT         A_m4,       A_m4
        NOT         B_m3,       B_m3
        NOT         A_m0,       A_m0

        MV   .2X    A_ir0,      B_ir1
        ADDAH.2     B_ir1,      B_cols,     B_ir1       ; Row 1 ptr
        ADD         B_out_data, B_cols,     B_out_data
        MV   .1X    B_out_data, A_out_data

        SHR  .2     B_cols,     2,          B_c4
        MV   .2     B_c4,       B_i
        LDBU .D2T2  *+B_ir1[B_cols],        B_p6h
        LDBU .D2T2  * B_ir1,                B_p3h
        LDBU .D2T1  *-B_ir1[B_cols],        A_p0h
        LDBU .D2T1  * B_ir1--(4),           A_p3h

        .mptr       B_ir1,      ir1,        -4
        .mptr       A_out_data, out,        -4
loop:
        ; Even iterations of 'i'
        LDW  .D2T2  *+B_ir1[B_c4],          B_p6        ; p6 = in[2*cols + i]
        LDW  .D2T1  *-B_ir1[B_c4],          A_p0        ; p0 = in[0*cols + i]
        LDW  .D2T2  *B_ir1,                 B_p3        ; p3 = in[1*cols + i]
        LDW  .D2T1  *B_ir1--(4),            A_p3        ; p3 = in[1*cols + i]

        SHR  .2     B_p6h:B_p6, 2,          B_q8:B_p8   ; p8 = p6l >> 2
        SHR  .2     B_p6h:B_p6, 1,          B_q7:B_p7   ; p7 = p6l >> 1
        SHR  .2     B_p3h:B_p3, 2,          B_q5:B_p5   ; p5 = p3l >> 2
        SHR  .1     A_p3h:A_p3, 1,          A_q4:A_p4   ; p4 = p3l >> 1
        SHR  .1     A_p0h:A_p0, 2,          A_q2:A_p2   ; p2 = p0l >> 2
        SHR  .1     A_p0h:A_p0, 1,          A_q1:A_p1   ; p1 = p0l >> 1

        MPY  .2     B_p6,       1,          B_p6_
        MPY  .2     B_p3,       1,          B_p3_
        MPY  .1     A_p3,       1,          A_p3_
        MPY  .1     A_p0,       1,          A_p0_

        MPY  .2     B_p6_,      1,          B_p6h
        MPY  .2     B_p3_,      1,          B_p3h
        MPY  .1     A_p3_,      1,          A_p3h
        MPY  .1     A_p0_,      1,          A_p0h

        AND  .2     B_p6,       B_m6,       B_rA        ; rA = p6 | m6
        AND  .2     B_p3,       B_m3,       B_rB        ; rB = p3 | m3
        AND  .1     A_p0,       A_m0,       A_rC        ; rC = p0 | m0
        AND  .2     B_p8,       B_m8,       B_t8        ; t8 = p8 | m8
        AND  .1     A_p4,       A_m4,       A_t4        ; t4 = p4 | m4

        OR   .2     B_t8,       B_rA,       B_rA        ; if (!m8) rA &= p8
[!B_m7] OR   .2     B_p7,       B_rA,       B_rA        ; if (!m7) rA &= p7
[!B_m5] OR   .2     B_p5,       B_rB,       B_rB        ; if (!m5) rB &= p5
        OR   .1X    A_t4,       B_rB,       A_rB        ; if (!m4) rB &= p4
[!A_m2] OR   .1     A_p2,       A_rC,       A_rC        ; if (!m2) rC &= p2
[!A_m1] OR   .1     A_p1,       A_rC,       A_rC        ; if (!m1) rC &= p1
        OR   .1X    B_rA,       A_rB,       A_rD
        OR   .1     A_rC,       A_rD,       A_rslt      ; rslt = rA & rB & rC

        STW  .D1T1  A_rslt,     *--A_out_data(4)        ; out[i] = rslt;

        SUB  .2     B_i,        1,          B_i
 [B_i]  B           loop

        .return
        .endproc

* ========================================================================= *
*   End of file:  img_dilate_bin.sa                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

erode_bin.sa/   1066929161  0     0     0       14245     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Tue Mar 12 04:27:25 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_erode_bin-- This code performs 3x3 binary dilation              *
*                                                                           *
*   REVISION DATE                                                           *
*       20-Oct-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_erode_bin                                                  *
*       (                                                                   *
*           const unsigned char *restrict in_data,   /* Incoming image  */  *
*           unsigned char       *restrict out_data,  /* Filtered output */  *
*           const char          *restrict mask,      /* Filter mask     */  *
*           int cols  /* Number of columns to process, in bytes.        */  *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_erode_bin() implements binary erosion using an     *
*       arbitrary 3x3 mask.  The erosion operator generates output pixels   *
*       by ANDing the pixels under the input mask together to generate      *
*       the output pixel.  The input mask specifies whether one or more     *
*       pixels from the input are to be ignored.                            *
*                                                                           *
*       In pseudo-code, the filtering operation for a pixel at (x, y)       *
*       works like so:                                                      *
*                                                                           *
*           result = 1;                                                     *
*           if (mask[0][0] != DONT_CARE) result &= input[y + 0][x + 0];     *
*           if (mask[0][1] != DONT_CARE) result &= input[y + 1][x + 1];     *
*           if (mask[0][2] != DONT_CARE) result &= input[y + 2][x + 2];     *
*           if (mask[1][0] != DONT_CARE) result &= input[y + 0][x + 0];     *
*           if (mask[1][1] != DONT_CARE) result &= input[y + 1][x + 1];     *
*           if (mask[1][2] != DONT_CARE) result &= input[y + 2][x + 2];     *
*           if (mask[2][0] != DONT_CARE) result &= input[y + 0][x + 0];     *
*           if (mask[2][1] != DONT_CARE) result &= input[y + 1][x + 1];     *
*           if (mask[2][2] != DONT_CARE) result &= input[y + 2][x + 2];     *
*           output[y][x] = result;                                          *
*                                                                           *
*       For this code, "DONT_CARE" is specified by a negative value         *
*       in the input mask.  Non-negative values in the mask cause the       *
*       corresponding pixel to be included in the erosion operation.        *
*                                                                           *
*       Note that this code operates on a bitmap where each pixel is        *
*       represented as a single bit within a byte or word.  Although        *
*       the pseudo-code above operates only on one pixel at a time,         *
*       with a single pixel in each array element, this implementation      *
*       operates on a bitmap which contains 8 pixels in each byte.          *
*                                                                           *
*       Pixels are organized within each byte such that the pixel with      *
*       the smallest index is in the LSB position, and the pixel with       *
*       the largest index is in the MSB position.  (That is, the code       *
*       assumes a LITTLE ENDIAN bit ordering.)                              *
*                                                                           *
*       Note that the "cols" argument actually specifies the number of      *
*       BYTES in the output, not the number of columns.  The number of      *
*       columns is 8 times this argument.                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The 3x3 erosion mask is applied to 32 output pixels                 *
*       simultaneously.  This is done with 32-bit-wide bitwise              *
*       operators in the register file.  In order to do this, the code      *
*       reads in a 34-bit-wide input window, and 40-bit operations          *
*       are used to manipulate the pixels initially.                        *
*                                                                           *
*       Because the code reads a 34-bit context for each 32-bits of         *
*       output, the input needs to be one byte longer than the output       *
*       in order to make the rightmost two pixels well-defined.             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1.  Negative values in the mask specify "DONT_CARE", and non-       *
*           negative values specify that pixels are included in the         *
*           erosion operation.                                              *
*                                                                           *
*       2.  The input image needs to have a multiple of 64 pixels(bits)     *
*           per row.  Therefore, "cols" must be a multiple of 8.            *
*                                                                           *
*   NOTES                                                                   *
*       Little Endian                                                       *
*                                                                           *
*       "Digital Image Processing: Principles and Applications"             *
*       by Gregory A. Baxes, Chapter 5                                      *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


            .sect ".data:copyright_p"

        .sect ".text:_erode_bin"
        .global _IMG_erode_bin
_IMG_erode_bin: .cproc  A_ir0,  B_out_data,  A_mask, B_cols 

        .no_mdep

        .reg  B_q8:B_p8, B_t8
        .reg  B_q7:B_p7
        .reg  B_q5:B_p5
        .reg  B_p6h:B_p6, B_p6_
        .reg  B_p3h:B_p3, B_p3_
        .reg  A_q4:A_p4, A_t4
        .reg  A_q2:A_p2
        .reg  A_q1:A_p1
        .reg  A_p3h:A_p3, A_p3_
        .reg  A_p0h:A_p0, A_p0_
        .reg  B_m8
        .reg  B_m7654
        .reg  B_m7
        .reg  B_m6
        .reg  B_m5
        .reg  B_ir1
        .reg  B_rA
        .reg  B_rB
        .reg  B_rC
        .reg  B_rD
        .reg  B_i
        .reg  B_c4
        .reg  A_m4
        .reg  B_m3
        .reg  A_m2
        .reg  A_m1
        .reg  A_m0
        .reg  A_out_data
        .reg  A_rA
        .reg  A_rB
        .reg  A_rC
        .reg  A_rD
        .reg  A_rslt
        .reg  A_k1
        .reg  B_k1
        .reg  B_mask

        MVK  .1     1,          A_k1
        MVK  .2     1,          B_k1

        MV   .2X    A_mask,     B_mask

        LDB  .D1T2  *A_mask[8], B_m8
        LDB  .D2T2  *B_mask[7], B_m7
        LDB  .D2T2  *B_mask[6], B_m6
        LDB  .D1T2  *A_mask[5], B_m5
        LDB  .D1T1  *A_mask[4], A_m4
        LDB  .D2T2  *B_mask[3], B_m3
        LDB  .D2T1  *B_mask[2], A_m2
        LDB  .D1T1  *A_mask[1], A_m1
        LDB  .D1T1  *A_mask[0], A_m0

        MPYHL       B_m8,       B_k1,       B_m8
        MPYHL       B_m7,       B_k1,       B_m7
        MPYHL       B_m6,       B_k1,       B_m6
        MPYHL       B_m5,       B_k1,       B_m5

        MPYHL       A_m4,       A_k1,       A_m4
        MPYHL       B_m3,       B_k1,       B_m3
        MPYHL       A_m2,       A_k1,       A_m2
        MPYHL       A_m1,       A_k1,       A_m1
        MPYHL       A_m0,       A_k1,       A_m0

        MV   .2X    A_ir0,      B_ir1
        ADDAH.2     B_ir1,      B_cols,     B_ir1       ; Row 1 ptr
        ADD         B_out_data, B_cols,     B_out_data
        MV   .1X    B_out_data, A_out_data

        SHR  .2     B_cols,     2,          B_c4
        MV   .2     B_c4,       B_i
        LDBU .D2T2  *+B_ir1[B_cols],        B_p6h
        LDBU .D2T2  * B_ir1,                B_p3h
        LDBU .D2T1  *-B_ir1[B_cols],        A_p0h
        LDBU .D2T1  * B_ir1--(4),           A_p3h

        .mptr       B_ir1,      ir1,        -4
        .mptr       A_out_data, out,        -4
loop:
        ; Even iterations of 'i'
        LDW  .D2T2  *+B_ir1[B_c4],          B_p6        ; p6 = in[2*cols + i]
        LDW  .D2T1  *-B_ir1[B_c4],          A_p0        ; p0 = in[0*cols + i]
        LDW  .D2T2  *B_ir1,                 B_p3        ; p3 = in[1*cols + i]
        LDW  .D2T1  *B_ir1--(4),            A_p3        ; p3 = in[1*cols + i]

        SHR  .2     B_p6h:B_p6, 2,          B_q8:B_p8   ; p8 = p6l >> 2
        SHR  .2     B_p6h:B_p6, 1,          B_q7:B_p7   ; p7 = p6l >> 1
        SHR  .2     B_p3h:B_p3, 2,          B_q5:B_p5   ; p5 = p3l >> 2
        SHR  .1     A_p3h:A_p3, 1,          A_q4:A_p4   ; p4 = p3l >> 1
        SHR  .1     A_p0h:A_p0, 2,          A_q2:A_p2   ; p2 = p0l >> 2
        SHR  .1     A_p0h:A_p0, 1,          A_q1:A_p1   ; p1 = p0l >> 1

        MPY  .2     B_p6,       1,          B_p6_
        MPY  .2     B_p3,       1,          B_p3_
        MPY  .1     A_p3,       1,          A_p3_
        MPY  .1     A_p0,       1,          A_p0_

        MPY  .2     B_p6_,      1,          B_p6h
        MPY  .2     B_p3_,      1,          B_p3h
        MPY  .1     A_p3_,      1,          A_p3h
        MPY  .1     A_p0_,      1,          A_p0h

        OR   .2     B_p6,       B_m6,       B_rA        ; rA = p6 | m6
        OR   .2     B_p3,       B_m3,       B_rB        ; rB = p3 | m3
        OR   .1     A_p0,       A_m0,       A_rC        ; rC = p0 | m0
        OR   .2     B_p8,       B_m8,       B_t8        ; t8 = p8 | m8
        OR   .1     A_p4,       A_m4,       A_t4        ; t4 = p4 | m4

        AND  .2     B_t8,       B_rA,       B_rA        ; if (!m8) rA &= p8
[!B_m7] AND  .2     B_p7,       B_rA,       B_rA        ; if (!m7) rA &= p7
[!B_m5] AND  .2     B_p5,       B_rB,       B_rB        ; if (!m5) rB &= p5
        AND  .1X    A_t4,       B_rB,       A_rB        ; if (!m4) rB &= p4
[!A_m2] AND  .1     A_p2,       A_rC,       A_rC        ; if (!m2) rC &= p2
[!A_m1] AND  .1     A_p1,       A_rC,       A_rC        ; if (!m1) rC &= p1
        AND  .1X    B_rA,       A_rB,       A_rD
        AND  .1     A_rC,       A_rD,       A_rslt      ; rslt = rA & rB & rC

        STW  .D1T1  A_rslt,     *--A_out_data(4)        ; out[i] = rslt;

        SUB  .2     B_i,        1,          B_i
 [B_i]  B           loop

        .return
        .endproc

* ========================================================================= *
*   End of file:  img_erode_bin.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

errdif_bin.sa/  1066929161  0     0     0       19423     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.9     Mon Jan  7 20:24:06 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_errdif_bin -- Binary Floyd-Steinberg Error Diffusion.           *
*                     Endian neutral.                                       *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*               void IMG_errdif_bin                                         *
*               (                                                           *
*                   unsigned char *restrict errdif_data,                    *
*                   int           cols,                                     *
*                   int           rows,                                     *
*                   short         *restrict err_buf,                        *
*                   unsigned char thresh                                    *
*               )                                                           *
*                                                                           *
*       errdif_data:     Input/Output image ptr                             *
*       cols:            Number of columns (Width)                          *
*       rows:            Number of rows    (Height)                         *
*       err_buf:         Buffer where one row of errors is to be saved      *
*       thresh:          Threshold in the range [0x00, 0xFF]                *
*                                                                           *
*       errdif_data[] is used for both input and output and the number      *
*       of colums, cols, must be at least 4.  No restriction on number      *
*       of rows.                                                            *
*                                                                           *
*       err_buf[], additional buffer, should be provided with               *
*       initialized to all-zero's for the first call with an image.         *
*       The subsequent call with the same image should provide this         *
*       kernel the returned err_buf The size of err_buf should be           *
*       (cols+1)*Half-Word.                                                 *
*                                                                           *
*   DESCRIPTION                                                             *
*       The code implements the Binary Floyd-Steinberg error diffusion      *
*       filter.  The filter kernel used is this one:                        *
*                                                                           *
*                                   +---+                                   *
*                                 P | 7 |                                   *
*                           +---+---+---+                                   *
*                           | 3 | 5 | 1 |                                   *
*                           +---+---+---+                                   *
*                                                                           *
*                                                                           *
*       Pixels are processed from left-to-right, top-to-bottom.  Each       *
*       pixel is compared against a user-defined threshold.  Pixels         *
*       that are larger than the threshold are set to 255, and pixels       *
*       that are smaller or equal to the threshold are set to 0.  The       *
*       error value for the pixel (eg. the difference between the           *
*       thresholded pixel and its original grey level) is propagated to     *
*       the neighboring pixels according to the filter above.  This         *
*       error propagation diffuses the error over a larger area, hence      *
*       the term "error diffusion."                                         *
*                                                                           *
*       The following C code illustrates the algorithm.  The C code is      *
*       a general implementation without restrictions.  This version        *
*       may have restriction as noted in the ASSUMPTIONS below.             *
*                                                                           *
*       void IMG_errdif_bin                                                 *
*       (                                                                   *
*          unsigned char *restrict                                          *
*                        errdif_data,    /* Input/Output image ptr      */  *
*          int           cols,           /* Number of columns (Width)   */  *
*          int           rows,           /* Number of rows    (Height)  */  *
*          short         *restrict                                          *
*                        err_buf,        /* row-to-row error buffer.    */  *
*          unsigned char thresh          /* Threshold from [0x00, 0xFF] */  *
*       )                                                                   *
*       {                                                                   *
*          int   x, i, y;        /* Loop counters                       */  *
*          int   F;              /* Current pixel value at [x,y]        */  *
*          int   errA;           /* Error value at [x-1, y-1]           */  *
*          int   errB;           /* Error value at [  x, y-1]           */  *
*          int   errC;           /* Error value at [x+1, y-1]           */  *
*          int   errE;           /* Error value at [x-1,   y]           */  *
*          int   errF;           /* Error value at [  x,   y]           */  *
*                                                                           *
*          /* --------------------------------------------------------- */  *
*          /*  Step through rows of pixels.                             */  *
*          /* --------------------------------------------------------- */  *
*          for (y = 0, i = 0; y < rows; y++)                                *
*          {                                                                *
*             /* ------------------------------------------------------ */  *
*             /*  Start off with our initial errors set to zero at      */  *
*             /*  the start of the line since we do not have any        */  *
*             /*  pixels to the left of the row.  These error terms     */  *
*             /*  are maintained within the inner loop.                 */  *
*             /* ------------------------------------------------------ */  *
*             errA = 0; errE = 0;                                           *
*             errB = err_buf[0];                                            *
*                                                                           *
*             /* ------------------------------------------------------ */  *
*             /*  Step through pixels in each row.                      */  *
*             /* ------------------------------------------------------ */  *
*             for (x = 0; x < cols; x++, i++)                               *
*             {                                                             *
*                /* --------------------------------------------------- */  *
*                /*  Load the error being propagated from pixel 'C'     */  *
*                /*  from our error buffer.  This was calculated        */  *
*                /*  during the previous line.                          */  *
*                /* --------------------------------------------------- */  *
*                errC = err_buf[x+1];                                       *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Load our pixel value to quantize.                  */  *
*                /* --------------------------------------------------- */  *
*                F = errdif_data[i];                                        *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Calculate our resulting pixel.  If we assume       */  *
*                /*  that this pixel will be set to zero, this also     */  *
*                /*  doubles as our error term.                         */  *
*                /* --------------------------------------------------- */  *
*                errF = F + ((errE*7 + errA + errB*5 + errC*3) >> 4);       *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Set pixels that are larger than the threshold to   */  *
*                /*  255, and pixels that are smaller than the          */  *
*                /*  threshold to 0.                                    */  *
*                /* --------------------------------------------------- */  *
*                if (errF > thresh)  errdif_data[i] = 0xFF;                 *
*                else                errdif_data[i] = 0;                    *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  If the pixel was larger than the threshold, then   */  *
*                /*  we need subtract 255 from our error.  In any       */  *
*                /*  case, store the error to the error buffer.         */  *
*                /* --------------------------------------------------- */  *
*                if (errF > thresh)  err_buf[x] = errF = errF - 0xFF;       *
*                else                err_buf[x] = errF;                     *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Propagate error terms for the next pixel.          */  *
*                /* --------------------------------------------------- */  *
*                errE = errF;                                               *
*                errA = errB;                                               *
*                errB = errC;                                               *
*             }                                                             *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Constants, 7, 5, 3, 1 for multiplication are shifted left 12 to     *
*       avoid 'SHR 4' operation in the critical path.                       *
*                                                                           *
*       The processing of the filter itself is inverted so that the         *
*       errors from previous pixels "propagate into" a given pixel at       *
*       the time the pixel is processed, rather than "accumulate into"      *
*       a pixel as its neighbors are processed.  This allows us to          *
*       keep our image as an 8-bit image, and reduces the number of         *
*       accesses to the image array.  The inverted filter kernel            *
*       performs identically to the kernel's original form.  In this        *
*       form, the weights specify the weighting assigned to the errors      *
*       coming from the neighboring pixels.                                 *
*                                                                           *
*                           +---+---+---+                                   *
*                           | 1 | 5 | 3 |                                   *
*                           +---+---+---+                                   *
*                           | 7 | P                                         *
*                           +---+                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The number of columns must be at least 4.                           *
*                                                                           *
*       err_buf[] must be initialized to zeros for the first call and       *
*       the returned err_buf should be provided for the next call.          *
*                                                                           *
*   NOTES                                                                   *
*       No special alignment of data arrays is expected.                    *
*                                                                           *
*   SOURCE                                                                  *
*       Floyd-Steinberg Error Diffusion.                                    *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .sect ".text:_errdif_bin"
        .global _IMG_errdif_bin
_IMG_errdif_bin:       .cproc  A_rgb0, A_w, B_h, B_errbuf0, B_thrsh
*---------------------------- *Uchar  int  int  *short     Uchar
        .no_mdep

        .reg  B_errbuf_r, B_errbuf_w, A_rgb_r, A_rgb_w, B_y, A_x
        .reg  A_errA, B_errE, B_errB, B_errC, B_errE_, B_out, B_outX
        .reg  A_eE7, A_errEA, A_eB5, B_eC3, A_errEAC, A_errAll
        .reg  B_errSft, B_F, B_big, B_F7, B_eC3F7
        .reg  A_k5, B_k3, B_k7, A_k7, A_neg

;------- Set up addresses and loop counters

        MV      .1      A_rgb0,       A_rgb_r
        MV      .1      A_rgb0,       A_rgb_w
        MV      .2      B_h,          B_y

        MVK     .1      -1785,        A_neg
        SHL     .1      A_neg,        12,         A_neg

        MVK     .1      5000h,        A_k5      ; 5 << 12
        MVK     .2      3000h,        B_k3      ; 3 << 12
        MVK     .1      7000h,        A_k7      ; 7 << 12
        MVK     .2      7000h,        B_k7      ; 7 << 12

y_start:
        MV      .1      A_w,          A_x
        ADD     .2      B_errbuf0,    2,        B_errbuf_r
        MV      .2      B_errbuf0,              B_errbuf_w

        ZERO    .1      A_errA
        ZERO    .1      A_errAll
        ZERO    .2      B_F7
        LDH     .D2T2   *B_errbuf0, B_errB
        ZERO    .2      B_big

x_start: .trip 4

        LDH     .D2T2   *B_errbuf_r++,          B_errC
        LDBU    .D1T2   *A_rgb_r++,             B_F

        MPY     .1      B_errB,     A_k5,       A_eB5
        MPY     .2      B_errC,     B_k3,       B_eC3
        ADD     .1      A_eB5,      A_errA,     A_errEA
        ADD     .2      B_eC3,      B_F7,       B_eC3F7
        ADD     .1X     A_errEA,    B_eC3F7,    A_errEAC

        MPYHL   .1      A_errAll,   A_k7,       A_eE7
        MPY     .2      B_F,        B_k7,       B_F7
        ADD     .1      A_errEAC,   A_eE7,      A_errAll
 [B_big]ADD     .1      A_neg,      A_errAll,   A_errAll

        SHR     .2X     A_errAll,   16 ,         B_errSft
        ADD     .2      B_errSft,   B_F,        B_errE

        CMPGT   .2      B_errE,     B_thrsh,    B_big
        SUB     .2      B_thrsh,    B_errE,     B_outX
        SHRU    .2      B_outX,     24,         B_out
        SUB     .2      B_errE,     B_out,      B_errE_

        STH     .D2T2   B_errE_,    *B_errbuf_w++
        STB     .D1T2   B_out,      *A_rgb_w++

        SHL     .1X     B_errB,     12,         A_errA
        MV      .2      B_errC,     B_errB

        SUB     .1      A_x,        1,          A_x
  [A_x] B               x_start

        SUB     .2      B_y,        1,          B_y
  [B_y] B               y_start

        .return
        .endproc

* ========================================================================== *
*   End of file:  img_errdif_bin.sa                                          *
* -------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================== *

fdct_8x8.sa/    1066929161  0     0     0       39905     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Mon May  1 07:01:31 2000 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_fdct_8x8 -- 8x8 Block FDCT With Rounding, Endian Neutral        *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       01-May-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           void IMG_fdct_8x8(short fdct_data[], unsigned num_fdcts)        *
*                                                                           *
*       The fdct routine accepts a list of 8x8 pixel blocks and performs    *
*       FDCTs on each.  The array should be laid out identically to         *
*       "fdct_data[num_fdcts][8][8]".  All operations in this array are     *
*       performed entirely in-place.                                        *
*                                                                           *
*       Input values are stored in shorts, and may be in the range          *
*       [-512,511].  Larger input values may result in overflow.            *
*                                                                           *
*   DESCRIPTION                                                             *
*       The IMG_fdct_8x8 function implements a Chen FDCT. Output values are *
*       rounded, providing improved accuracy.  Input terms are expected     *
*       to be signed 11Q0 values, producing signed 15Q0 results.  (A        *
*       smaller dynamic range may be used on the input, producing a         *
*       correspondingly smaller output range.  Typical applications         *
*       include processing signed 9Q0 and unsigned 8Q0 pixel data,          *
*       producing signed 13Q0 or 12Q0 outputs, respectively.)  No           *
*       saturation is performed.                                            *
*                                                                           *
*       void IMG_fdct_8x8(short *dct_data, unsigned num_fdcts)              *
*       {                                                                   *
*         /* -------------------------------------------------------- */    *
*         /*  Set up the cosine coefficients c0..c7.                  */    *
*         /* -------------------------------------------------------- */    *
*         const unsigned short c1 = 0x2C62, c3 = 0x25A0;                    *
*         const unsigned short c5 = 0x1924, c7 = 0x08D4;                    *
*         const unsigned short c0 = 0xB505, c2 = 0x29CF;                    *
*         const unsigned short c6 = 0x1151;                                 *
*                                                                           *
*         /* -------------------------------------------------------- */    *
*         /*  Intermediate calculations.                              */    *
*         /* -------------------------------------------------------- */    *
*         short f0, f1, f2, f3,                                             *
*               f4, f5, f6, f7;       /* Spatial domain samples.      */    *
*         int   g0, g1, h0, h1,                                             *
*               p0, p1;               /* Even-half intermediate.      */    *
*         short r0, r1;               /* Even-half intermediate.      */    *
*         int   P0, P1, R0, R1;       /* Even-half intermediate.      */    *
*         short g2, g3, h2, h3;       /* Odd-half intermediate.       */    *
*         short q0a,s0a,q0, q1,                                             *
*               s0, s1;               /* Odd-half intermediate.       */    *
*         short Q0, Q1, S0, S1;       /* Odd-half intermediate.       */    *
*         int   F0, F1, F2, F3,                                             *
*               F4, F5, F6, F7;       /* Freq. domain results.        */    *
*         int   F0r,F1r,F2r,F3r,                                            *
*               F4r,F5r,F6r,F7r;      /* Rounded, truncated results.  */    *
*                                                                           *
*         /* -------------------------------------------------------- */    *
*         /*  Input and output pointers, loop control.                */    *
*         /* -------------------------------------------------------- */    *
*         unsigned i, j;                                                    *
*         short    *dct_io_ptr;                                             *
*                                                                           *
*         /* -------------------------------------------------------- */    *
*         /*  Outer vertical loop -- Process each 8x8 block.          */    *
*         /* -------------------------------------------------------- */    *
*         dct_io_ptr = dct_data;                                            *
*         for (i = 0; i < num_fdcts; i++)                                   *
*         {                                                                 *
*             /* ---------------------------------------------------- */    *
*             /*  Perform Vert 1-D FDCT on columns within each block. */    *
*             /* ---------------------------------------------------- */    *
*             for (j = 0; j < 8; j++)                                       *
*             {                                                             *
*                 /* ------------------------------------------------ */    *
*                 /*  Load the spatial-domain samples.                */    *
*                 /* ------------------------------------------------ */    *
*                 f0 = dct_io_ptr[ 0];                                      *
*                 f1 = dct_io_ptr[ 8];                                      *
*                 f2 = dct_io_ptr[16];                                      *
*                 f3 = dct_io_ptr[24];                                      *
*                 f4 = dct_io_ptr[32];                                      *
*                 f5 = dct_io_ptr[40];                                      *
*                 f6 = dct_io_ptr[48];                                      *
*                 f7 = dct_io_ptr[56];                                      *
*                                                                           *
*                 /* ------------------------------------------------ */    *
*                 /*  Stage 1:  Separate into even and odd halves.    */    *
*                 /* ------------------------------------------------ */    *
*                 g0 = f0 + f7;               h2 = f0 - f7;                 *
*                 g1 = f1 + f6;               h3 = f1 - f6;                 *
*                 h1 = f2 + f5;               g3 = f2 - f5;                 *
*                 h0 = f3 + f4;               g2 = f3 - f4;                 *
*                                                                           *
*                 /* ------------------------------------------------ */    *
*                 /*  Stage 2                                         */    *
*                 /* ------------------------------------------------ */    *
*                 p0 = g0 + h0;               r0 = g0 - h0;                 *
*                 p1 = g1 + h1;               r1 = g1 - h1;                 *
*                 q1 = g2;                    s1 = h2;                      *
*                                                                           *
*                 s0a= h3 + g3;               q0a= h3 - g3;                 *
*                 s0 = (s0a * c0 + 0x7FFF) >> 16;                           *
*                 q0 = (q0a * c0 + 0x7FFF) >> 16;                           *
*                                                                           *
*                 /* ------------------------------------------------ */    *
*                 /*  Stage 3                                         */    *
*                 /* ------------------------------------------------ */    *
*                 P0 = p0 + p1;               P1 = p0 - p1;                 *
*                 R1 = c6 * r1 + c2 * r0;     R0 = c6 * r0 - c2 * r1;       *
*                                                                           *
*                 Q1 = q1 + q0;               Q0 = q1 - q0;                 *
*                 S1 = s1 + s0;               S0 = s1 - s0;                 *
*                                                                           *
*                 /* ------------------------------------------------ */    *
*                 /*  Stage 4                                         */    *
*                 /* ------------------------------------------------ */    *
*                 F0 = P0;                    F4 = P1;                      *
*                 F2 = R1;                    F6 = R0;                      *
*                                                                           *
*                 F1 = c7 * Q1 + c1 * S1;     F7 = c7 * S1 - c1 * Q1;       *
*                 F5 = c3 * Q0 + c5 * S0;     F3 = c3 * S0 - c5 * Q0;       *
*                                                                           *
*                 /* ------------------------------------------------ */    *
*                 /*  Store the frequency domain results.             */    *
*                 /* ------------------------------------------------ */    *
*                 dct_io_ptr[ 0] = F0;                                      *
*                 dct_io_ptr[ 8] = F1 >> 13;                                *
*                 dct_io_ptr[16] = F2 >> 13;                                *
*                 dct_io_ptr[24] = F3 >> 13;                                *
*                 dct_io_ptr[32] = F4;                                      *
*                 dct_io_ptr[40] = F5 >> 13;                                *
*                 dct_io_ptr[48] = F6 >> 13;                                *
*                 dct_io_ptr[56] = F7 >> 13;                                *
*                                                                           *
*                 dct_io_ptr++;                                             *
*             }                                                             *
*             /* ---------------------------------------------------- */    *
*             /*  Update pointer to next 8x8 FDCT block.              */    *
*             /* ---------------------------------------------------- */    *
*             dct_io_ptr += 56;                                             *
*         }                                                                 *
*                                                                           *
*         /* -------------------------------------------------------- */    *
*         /*  Perform Horizontal 1-D FDCT on each 8x8 block.          */    *
*         /* -------------------------------------------------------- */    *
*         dct_io_ptr = dct_data;                                            *
*         for (i = 0; i < 8 * num_fdcts; i++)                               *
*         {                                                                 *
*             /* ---------------------------------------------------- */    *
*             /*  Load the spatial-domain samples.                    */    *
*             /* ---------------------------------------------------- */    *
*             f0 = dct_io_ptr[0];                                           *
*             f1 = dct_io_ptr[1];                                           *
*             f2 = dct_io_ptr[2];                                           *
*             f3 = dct_io_ptr[3];                                           *
*             f4 = dct_io_ptr[4];                                           *
*             f5 = dct_io_ptr[5];                                           *
*             f6 = dct_io_ptr[6];                                           *
*             f7 = dct_io_ptr[7];                                           *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Stage 1:  Separate into even and odd halves.        */    *
*             /* ---------------------------------------------------- */    *
*             g0 = f0 + f7;               h2 = f0 - f7;                     *
*             g1 = f1 + f6;               h3 = f1 - f6;                     *
*             h1 = f2 + f5;               g3 = f2 - f5;                     *
*             h0 = f3 + f4;               g2 = f3 - f4;                     *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Stage 2                                             */    *
*             /* ---------------------------------------------------- */    *
*             p0 = g0 + h0;               r0 = g0 - h0;                     *
*             p1 = g1 + h1;               r1 = g1 - h1;                     *
*             q1 = g2;                    s1 = h2;                          *
*                                                                           *
*             s0a= h3 + g3;               q0a= h3 - g3;                     *
*             q0 = (q0a * c0 + 0x7FFF) >> 16;                               *
*             s0 = (s0a * c0 + 0x7FFF) >> 16;                               *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Stage 3                                             */    *
*             /* ---------------------------------------------------- */    *
*             P0 = p0 + p1;               P1 = p0 - p1;                     *
*             R1 = c6 * r1 + c2 * r0;     R0 = c6 * r0 - c2 * r1;           *
*                                                                           *
*             Q1 = q1 + q0;               Q0 = q1 - q0;                     *
*             S1 = s1 + s0;               S0 = s1 - s0;                     *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Stage 4                                             */    *
*             /* ---------------------------------------------------- */    *
*             F0 = P0;                    F4 = P1;                          *
*             F2 = R1;                    F6 = R0;                          *
*                                                                           *
*             F1 = c7 * Q1 + c1 * S1;     F7 = c7 * S1 - c1 * Q1;           *
*             F5 = c3 * Q0 + c5 * S0;     F3 = c3 * S0 - c5 * Q0;           *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Round and truncate values.                          */    *
*             /*                                                      */    *
*             /*  Note: F0 and F4 have different rounding since no    */    *
*             /*  MPYs have been applied to either term.  Also, F0's  */    *
*             /*  rounding is slightly different to offset the        */    *
*             /*  truncation effects from the horizontal pass (which  */    *
*             /*  does not round).                                    */    *
*             /* ---------------------------------------------------- */    *
*             F0r = (F0 + 0x0006) >>  3;                                    *
*             F1r = (F1 + 0x7FFF) >> 16;                                    *
*             F2r = (F2 + 0x7FFF) >> 16;                                    *
*             F3r = (F3 + 0x7FFF) >> 16;                                    *
*             F4r = (F4 + 0x0004) >>  3;                                    *
*             F5r = (F5 + 0x7FFF) >> 16;                                    *
*             F6r = (F6 + 0x7FFF) >> 16;                                    *
*             F7r = (F7 + 0x7FFF) >> 16;                                    *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Store the results                                   */    *
*             /* ---------------------------------------------------- */    *
*             dct_io_ptr[0] = F0r;                                          *
*             dct_io_ptr[1] = F1r;                                          *
*             dct_io_ptr[2] = F2r;                                          *
*             dct_io_ptr[3] = F3r;                                          *
*             dct_io_ptr[4] = F4r;                                          *
*             dct_io_ptr[5] = F5r;                                          *
*             dct_io_ptr[6] = F6r;                                          *
*             dct_io_ptr[7] = F7r;                                          *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Update pointer to next FDCT row.                    */    *
*             /* ---------------------------------------------------- */    *
*             dct_io_ptr += 8;                                              *
*         }                                                                 *
*                                                                           *
*         return;                                                           *
*       }                                                                   *
*                                                                           *
*                                                                           *
*       Note:  This code guarantees correct operation, even in the case     *
*       that 'num_fdcts == 0'.  The early-exit case performs no accesses    *
*       to the fdct_data[] array.                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop nest in the vertical pass has been collapsed into a        *
*       single-level loop.  Both vertical and horizontal loops have         *
*       been software pipelined.                                            *
*                                                                           *
*       For performance, portions of the code outside the loops have been   *
*       inter-scheduled with the prolog and epilog code of the loops.       *
*       Finally, pointer values and cosine term registers are reused        *
*       between the horizontal and vertical loops to reduce the impact of   *
*       pointer and constant reinitialization.                              *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts should occur within the loops, regardless of      *
*       fdct_data[]'s alignment.                                            *
*                                                                           *
*   NOTES                                                                   *
*       The cosine terms have all been scaled by sqrt(2), so that the       *
*       "c4" term is basically an even power of 2.                          *
*                                                                           *
*       The code is completely endian neutral.                              *
*                                                                           *
*   SOURCE                                                                  *
*       Chen FDCT.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

                .sect ".data:copyright_p"

        .sect ".text:_fdct_8x8"
        .global _IMG_fdct_8x8
_IMG_fdct_8x8   .cproc  A_dct_data,     B_num_dcts
; =========================== MEMORY DEPENDENCIES ============================
        .no_mdep                        ; Assume "don't alias" by default.
        .mdep           s0, l0          ;\
        .mdep           s1, l0          ; |
        .mdep           s2, l0          ; |
        .mdep           s3, l0          ; |__ Final v_loop stores to first
        .mdep           s4, l0          ; |   h_loop load.
        .mdep           s5, l0          ; |
        .mdep           s6, l0          ; |
        .mdep           s7, l0          ;/
        .mdep           s0, l1          ;\
        .mdep           s1, l1          ; |
        .mdep           s2, l1          ; |
        .mdep           s3, l1          ; |__ Final v_loop stores to second
        .mdep           s4, l1          ; |   h_loop load.
        .mdep           s5, l1          ; |
        .mdep           s6, l1          ; |
        .mdep           s7, l1          ;/
        .mdep           s0, l2          ;\
        .mdep           s1, l2          ; |
        .mdep           s2, l2          ; |
        .mdep           s3, l2          ; |__ Final v_loop stores to third
        .mdep           s4, l2          ; |   h_loop load.
        .mdep           s5, l2          ; |
        .mdep           s6, l2          ; |
        .mdep           s7, l2          ;/
        .mdep           s0, l3          ;\
        .mdep           s1, l3          ; |
        .mdep           s2, l3          ; |
        .mdep           s3, l3          ; |__ Final v_loop stores to fourth
        .mdep           s4, l3          ; |   h_loop load.
        .mdep           s5, l3          ; |
        .mdep           s6, l3          ; |
        .mdep           s7, l3          ;/
        .mdep           s0, l4          ;\
        .mdep           s1, l4          ; |
        .mdep           s2, l4          ; |
        .mdep           s3, l4          ; |__ Final v_loop stores to fifth
        .mdep           s4, l4          ; |   h_loop load.
        .mdep           s5, l4          ; |
        .mdep           s6, l4          ; |
        .mdep           s7, l4          ;/
        .mdep           s0, l5          ;\
        .mdep           s1, l5          ; |
        .mdep           s2, l5          ; |
        .mdep           s3, l5          ; |__ Final v_loop stores to sixth
        .mdep           s4, l5          ; |   h_loop load.
        .mdep           s5, l5          ; |
        .mdep           s6, l5          ; |
        .mdep           s7, l5          ;/
        .mdep           s0, l6          ;\
        .mdep           s1, l6          ; |
        .mdep           s2, l6          ; |
        .mdep           s3, l6          ; |__ Final v_loop stores to seventh
        .mdep           s4, l6          ; |   h_loop load.
        .mdep           s5, l6          ; |
        .mdep           s6, l6          ; |
        .mdep           s7, l6          ;/
        .mdep           s0, l7          ;\
        .mdep           s1, l7          ; |
        .mdep           s2, l7          ; |
        .mdep           s3, l7          ; |__ Final v_loop stores to eighth
        .mdep           s4, l7          ; |   h_loop load.
        .mdep           s5, l7          ; |
        .mdep           s6, l7          ; |
        .mdep           s7, l7          ;/
; ============================ SYMBOLIC CONSTANTS ============================
        .asg            0xB505,     cst_c0  ; Cosine term c0
        .asg            0x2C62,     cst_c1  ; Cosine term c1
        .asg            0x29CF,     cst_c2  ; Cosine term c2
        .asg            0x25A0,     cst_c3  ; Cosine term c3
        .asg            0x1924,     cst_c5  ; Cosine term c5
        .asg            0x1151,     cst_c6  ; Cosine term c6
        .asg            0x08D4,     cst_c7  ; Cosine term c7
; =============== SYMBOLIC REGISTER ASSIGNMENTS FOR HORIZ LOOP ===============
        .reg            A_i_ptr,    B_o_ptr
        .reg            A_f0, B_f1, B_f2, A_f3, A_f4, B_f5, B_f6, A_f7
        .reg            A_g0, B_g1, B_h1, A_h0, A_s1, B_h3, B_g3, A_q1
        .reg            A_p0, B_p1, B_s0, B_s0a,B_s0b
        .reg            A_r0, B_r1, A_q0, B_q0a,A_q0b
        .reg            B_P0, A_P1, A_Q1, B_S1, A_Q0, B_S0
        .reg            A_c2r0,     A_c6r0,     B_c2r1,     B_c6r1
        .reg            A_c1Q1,     A_c7Q1,     A_c3Q0,     A_c5Q0
        .reg            B_c1S1,     B_c7S1,     B_c3S0,     B_c5S0
        .reg            B_F0, A_F1, A_F2, B_F3, A_F4, A_F5, A_F6, B_F7
        .reg            B_F0t,A_F1t,A_F2t,B_F3t,A_F4t,A_F5t,A_F6t,B_F7t
        .reg            A_i,  B_i,  B_o
        .reg            A_c1c7,     A_c3c5,     B_c1c7,     B_c3c5
        .reg            A_k1c0,     B_k1c0,     A_c2c6,     B_c2c6
; ================ SYMBOLIC REGISTER ASSIGNMENTS FOR VERT LOOP ==============
        .reg            B_i_ptr,    A_o_ptr,    A_o
        .reg            B_k_rnd,    A_k_rnd
        .reg            B_F2,       B_F2t,      B_s0c,      A_q0c
        .reg            B_F0r,A_F1r,B_F2r,B_F3r,A_F4r,A_F5r,A_F6r,B_F7r
; ==================== SYMBOLIC REGISTERS -- MISCELLANEOUS ===================
        .reg            B_ok

        MV      .2      B_num_dcts, B_ok

 [!B_ok] B              abort

        MVKL    .1      cst_c7,     A_c1c7
        MVKL    .1      cst_c6,     A_c2c6
        MVKL    .1      cst_c5,     A_c3c5
        MVKLH   .1      cst_c3,     A_c3c5
        MVKLH   .1      cst_c2,     A_c2c6
        MVKLH   .1      cst_c1,     A_c1c7
        MVKL    .1      cst_c0,     A_k1c0
        MVKLH   .1      1,          A_k1c0

        MVKL    .2      cst_c7,     B_c1c7
        MVKL    .2      cst_c6,     B_c2c6
        MVKL    .2      cst_c5,     B_c3c5
        MVKL    .2      cst_c0,     B_k1c0
        MVKLH   .2      cst_c3,     B_c3c5
        MVKLH   .2      cst_c2,     B_c2c6
        MVKLH   .2      cst_c1,     B_c1c7
        MVKL    .2      cst_c0,     B_k1c0
        MVKLH   .2      1,          B_k1c0

        ADDAW   .1      A_dct_data, 12,         A_i_ptr
        MV      .2X     A_i_ptr,    B_o_ptr

        MVK     .1      4,          A_i
        MVK     .2      4,          B_i

        SHL     .2      B_num_dcts, 3,          B_o

        .mptr           A_i_ptr,    dct_data + 24,  2
        .mptr           B_o_ptr,    dct_data + 24,  2

        ;  Vertical loop
v_loop: .trip   8
        LDH     .D1T1   *-A_i_ptr  [24],        A_f0
        LDH     .D1T2   *-A_i_ptr  [16],        B_f1
        LDH     .D1T2   *-A_i_ptr  [ 8],        B_f2
        LDH     .D1T1   * A_i_ptr++[ 1],        A_f3
        LDH     .D1T1   *+A_i_ptr  [ 7],        A_f4
        LDH     .D1T2   *+A_i_ptr  [15],        B_f5
        LDH     .D1T2   *+A_i_ptr  [23],        B_f6
        LDH     .D1T1   *+A_i_ptr  [31],        A_f7

        MPY     .2      B_i,        4,          B_i
 [!B_i] ADDK    .1      112,        A_i_ptr
 [!B_i] ADD     .2      B_i,        4,          B_i

        ;  Stage 1
        ADD     .1      A_f0,       A_f7,       A_g0
        ADD     .2      B_f1,       B_f6,       B_g1
        ADD     .2      B_f2,       B_f5,       B_h1
        ADD     .1      A_f3,       A_f4,       A_h0

        SUB     .1      A_f0,       A_f7,       A_s1
        SUB     .2      B_f1,       B_f6,       B_h3
        SUB     .2      B_f2,       B_f5,       B_g3
        SUB     .1      A_f3,       A_f4,       A_q1


        ;  Stage 2
        ADD     .1      A_g0,       A_h0,       A_p0
        ADD     .2      B_g1,       B_h1,       B_p1
        ADD     .2      B_h3,       B_g3,       B_s0a
        MPYSU   .2      B_s0a,      B_k1c0,     B_s0b
        ADDK    .2      0x7FFF,     B_s0b
        MPYH    .2      B_s0b,      B_k1c0,     B_s0

        SUB     .1      A_g0,       A_h0,       A_r0
        SUB     .2      B_g1,       B_h1,       B_r1
        SUB     .2      B_h3,       B_g3,       B_q0a
        MPYSU   .1X     B_q0a,      A_k1c0,     A_q0b
        ADDK    .1      0x7FFF,     A_q0b
        MPYH    .1      A_q0b,      A_k1c0,     A_q0

        ;  Stage 3
        ADD     .2X     A_p0,       B_p1,       B_F0
        SUB     .1X     A_p0,       B_p1,       A_F4

        MPYLH   .1      A_r0,       A_c2c6,     A_c2r0
        MPY     .1      A_r0,       A_c2c6,     A_c6r0
        MPYLH   .2      B_r1,       B_c2c6,     B_c2r1
        MPY     .2      B_r1,       B_c2c6,     B_c6r1

        ADD     .1X     B_c6r1,     A_c2r0,     A_F2
        SUB     .1X     A_c6r0,     B_c2r1,     A_F6

        ADD     .1      A_q1,       A_q0,       A_Q1
        ADD     .2X     A_s1,       B_s0,       B_S1
        SUB     .1      A_q1,       A_q0,       A_Q0
        SUB     .2X     A_s1,       B_s0,       B_S0

        ;  Stage 4

        MPYLH   .1      A_Q1,       A_c1c7,     A_c1Q1
        MPY     .1      A_Q1,       A_c1c7,     A_c7Q1
        MPYLH   .1      A_Q0,       A_c3c5,     A_c3Q0
        MPY     .1      A_Q0,       A_c3c5,     A_c5Q0

        MPYLH   .2      B_S1,       B_c1c7,     B_c1S1
        MPY     .2      B_S1,       B_c1c7,     B_c7S1
        MPYLH   .2      B_S0,       B_c3c5,     B_c3S0
        MPY     .2      B_S0,       B_c3c5,     B_c5S0

        ADD     .1X     A_c7Q1,     B_c1S1,     A_F1
        ADD     .1X     A_c3Q0,     B_c5S0,     A_F5

        SUB     .2X     B_c7S1,     A_c1Q1,     B_F7
        SUB     .2X     B_c3S0,     A_c5Q0,     B_F3

        ;  Truncate to 16 bits
        SHR     .1      A_F1,       13,         A_F1t
        SHR     .1      A_F2,       13,         A_F2t
        SHR     .2      B_F3,       13,         B_F3t
        SHR     .1      A_F5,       13,         A_F5t
        SHR     .1      A_F6,       13,         A_F6t
        SHR     .2      B_F7,       13,         B_F7t


        ;  Store results
        STH     .D2T2   B_F0,       *-B_o_ptr  [24]{s0}
        STH     .D2T1   A_F1t,      *-B_o_ptr  [16]{s1}
        STH     .D2T1   A_F2t,      *-B_o_ptr  [ 8]{s2}
        STH     .D2T2   B_F3t,      * B_o_ptr++[ 1]{s3}
        STH     .D2T1   A_F4,       *+B_o_ptr  [ 7]{s4}
        STH     .D2T1   A_F5t,      *+B_o_ptr  [15]{s5}
        STH     .D2T1   A_F6t,      *+B_o_ptr  [23]{s6}
        STH     .D2T2   B_F7t,      *+B_o_ptr  [31]{s7}

        MPY     .1      A_i,        4,          A_i
 [!A_i] ADDK    .2      112,        B_o_ptr
 [!A_i] ADD     .1      A_i,        4,          A_i

        SUB     .2      B_o,        1,          B_o
 [ B_o] B               v_loop

******************************************************************************
        ADDAH           A_dct_data, 7,          A_o_ptr
        MV              A_o_ptr,    B_i_ptr
        SHL     .1      B_num_dcts, 3,          A_o
        MVK     .1      0x7FFF,     A_k_rnd
        MVK     .2      0x7FFF,     B_k_rnd

        .mptr           B_i_ptr,    dct_data + 14,  16
        .mptr           A_o_ptr,    dct_data + 14,  16

h_loop: .trip   8
        LDH     .D2T1   *-B_i_ptr  [ 7]{l0},    A_f0
        LDH     .D2T2   *-B_i_ptr  [ 6]{l1},    B_f1
        LDH     .D2T2   *-B_i_ptr  [ 5]{l2},    B_f2
        LDH     .D2T1   *-B_i_ptr  [ 4]{l3},    A_f3
        LDH     .D2T1   *-B_i_ptr  [ 3]{l4},    A_f4
        LDH     .D2T2   *-B_i_ptr  [ 2]{l5},    B_f5
        LDH     .D2T2   *-B_i_ptr  [ 1]{l6},    B_f6
        LDH     .D2T1   * B_i_ptr++[ 8]{l7},    A_f7

        ;  Stage 1
        ADD     .1      A_f0,       A_f7,       A_g0
        ADD     .2      B_f1,       B_f6,       B_g1
        ADD     .2      B_f2,       B_f5,       B_h1
        ADD     .1      A_f3,       A_f4,       A_h0

        SUB     .1      A_f0,       A_f7,       A_s1
        SUB     .2      B_f1,       B_f6,       B_h3
        SUB     .2      B_f2,       B_f5,       B_g3
        SUB     .1      A_f3,       A_f4,       A_q1


        ;  Stage 2
        ADD     .1      A_g0,       A_h0,       A_p0
        ADD     .2      B_g1,       B_h1,       B_p1
        ADD     .2      B_h3,       B_g3,       B_s0a
        MPYSU   .2      B_s0a,      B_k1c0,     B_s0b
        ADD     .2      B_s0b,      B_k_rnd,    B_s0c
        MPYH    .2      B_s0c,      B_k1c0,     B_s0

        SUB     .1      A_g0,       A_h0,       A_r0
        SUB     .2      B_g1,       B_h1,       B_r1
        SUB     .2      B_h3,       B_g3,       B_q0a
        MPYSU   .1X     B_q0a,      A_k1c0,     A_q0b
        ADD     .1      A_q0b,      A_k_rnd,    A_q0c
        MPYH    .1      A_q0c,      A_k1c0,     A_q0

        ;  Stage 3
        ADD     .2X     A_p0,       B_p1,       B_F0
        SUB     .1X     A_p0,       B_p1,       A_F4

        MPYLH   .1      A_r0,       A_c2c6,     A_c2r0
        MPY     .1      A_r0,       A_c2c6,     A_c6r0
        MPYLH   .2      B_r1,       B_c2c6,     B_c2r1
        MPY     .2      B_r1,       B_c2c6,     B_c6r1

        ADD     .2X     B_c6r1,     A_c2r0,     B_F2
        SUB     .1X     A_c6r0,     B_c2r1,     A_F6

        ADD     .1      A_q1,       A_q0,       A_Q1
        ADD     .2X     A_s1,       B_s0,       B_S1
        SUB     .1      A_q1,       A_q0,       A_Q0
        SUB     .2X     A_s1,       B_s0,       B_S0

        ;  Stage 4

        MPYLH   .1      A_Q1,       A_c1c7,     A_c1Q1
        MPY     .1      A_Q1,       A_c1c7,     A_c7Q1
        MPYLH   .1      A_Q0,       A_c3c5,     A_c3Q0
        MPY     .1      A_Q0,       A_c3c5,     A_c5Q0

        MPYLH   .2      B_S1,       B_c1c7,     B_c1S1
        MPY     .2      B_S1,       B_c1c7,     B_c7S1
        MPYLH   .2      B_S0,       B_c3c5,     B_c3S0
        MPY     .2      B_S0,       B_c3c5,     B_c5S0

        ADD     .1X     A_c7Q1,     B_c1S1,     A_F1
        ADD     .1X     A_c3Q0,     B_c5S0,     A_F5

        SUB     .2X     B_c7S1,     A_c1Q1,     B_F7
        SUB     .2X     B_c3S0,     A_c5Q0,     B_F3

        ;  Rounding
        ADD     .2      B_F0,       6,          B_F0r
        ADD     .1      A_F1,       A_k_rnd,    A_F1r
        ADD     .2      B_F2,       B_k_rnd,    B_F2r
        ADD     .2      B_F3,       B_k_rnd,    B_F3r
        ADD     .1      A_F4,       4,          A_F4r
        ADD     .1      A_F5,       A_k_rnd,    A_F5r
        ADD     .1      A_F6,       A_k_rnd,    A_F6r
        ADD     .2      B_F7,       B_k_rnd,    B_F7r

        ; Truncate to 16 bits

        SHR     .2      B_F0r,      3,          B_F0t
        MPYH    .1      A_F1r,      A_k1c0,     A_F1t
        SHR     .2      B_F2r,      16,         B_F2t
        SHR     .2      B_F3r,      16,         B_F3t
        SHR     .1      A_F4r,      3,          A_F4t
        SHR     .1      A_F5r,      16,         A_F5t
        SHR     .1      A_F6r,      16,         A_F6t
        MPYH    .2      B_F7r,      B_k1c0,     B_F7t

        ;  Store results
        STH     .D1T2   B_F0t,      *-A_o_ptr  [7]
        STH     .D1T1   A_F1t,      *-A_o_ptr  [6]
        STH     .D1T2   B_F2t,      *-A_o_ptr  [5]
        STH     .D1T2   B_F3t,      *-A_o_ptr  [4]
        STH     .D1T1   A_F4t,      *-A_o_ptr  [3]
        STH     .D1T1   A_F5t,      *-A_o_ptr  [2]
        STH     .D1T1   A_F6t,      *-A_o_ptr  [1]
        STH     .D1T2   B_F7t,      * A_o_ptr++[8]

        SUB             A_o,        1,          A_o
 [ A_o] B               h_loop


abort:
        .return
        .endproc

* ========================================================================= *
*   End of file:  img_fdct_8x8.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

histogram.sa/   1066929161  0     0     0       27022     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Thu Jan 24 00:27:26 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_histogram                                                       *
*                                                                           *
*   REVISION DATE                                                           *
*       01-May-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_histogram                                                  *
*       (                                                                   *
*           unsigned char * in_data,  // input data to IMG_histogram   //   *
*           int n,                    // number of points              //   *
*           int accumulate,           // sign of accumulation (+1/-1)  //   *
*           unsigned short * t_hist,  // temporary IMG_histogram buffer //  *
*           unsigned short * hist     // final IMG_histogram output    //   *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This code takes a IMG_histogram of an array of n, 8 bit inputs.  It *
*       returns the IMG_histogram of 256 bins at 16 bit precision.  It can  *
*       either add or subtract to an existing IMG_histogram, using the      *
*       'accumulate' control.                                               *
*                                                                           *
*       It requires some temporary storage for 4 temporary histograms,      *
*       which are later summed together.                                    *
*                                                                           *
*     C CODE                                                                *
*         void IMG_histogram                                                *
*         (                                                                 *
*             unsigned char * in_data,  // input data to IMG_histogram   // *
*             int n,                    // number of points              // *
*             int accumulate,           // sign of accumulation (+1/-1)  // *
*             unsigned short * t_hist,  // temporary IMG_histogram buffer // *
*             unsigned short * hist     // final IMG_histogram output    // *
*         )                                                                 *
*         {                                                                 *
*            int pixel, j;                                                  *
*            for (j = 0; j < n; j++)                                        *
*            {                                                              *
*               pixel = (int) in_data[j];                                   *
*               hist[data] += accumulate;                                   *
*            }                                                              *
*         }                                                                 *
*                                                                           *
*         The above C code is a general implementation without              *
*         restrictions.  The assembly code may have some restrictions, as   *
*         noted below.                                                      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       It is assumed that the temporary array of data, t_hist is           *
*       initialised to zero.                                                *
*                                                                           *
*       The input array of in_data data must be aligned to a 4 byte         *
*       boundary and n must be a multiple of 8.                             *
*                                                                           *
*       The maximum number of pixels that can be profiled in each bin       *
*       is 65535 in the main IMG_histogram and the maximum n is 262143.     *
*                                                                           *
*   TECHNIQUES                                                              *
*       This code operates on four interleaved IMG_histogram bins.  The     *
*       loop is divided into two halves.  The even half operates on         *
*       even words full of pixels and the odd half operates on odd          *
*       words.  Both halves operate on the same 4 IMG_histogram bins.  This *
*       introduces a memory dependency which ordinarily would degrade       *
*       performance.  To break the memory depenencies, the two halves       *
*       forward their results to each other.  Exact memory access           *
*       ordering obviates the need to predicate stores The algorithm is     *
*       ordered as follows:                                                 *
*                                                                           *
*       1.  Load from IMG_histogram for even half                           *
*                                                                           *
*       2.  Store odd_bin to IMG_histogram for odd half (previous itn.)     *
*                                                                           *
*       3.  if data_even == previous data_odd increment even_bin by 2       *
*           else increment even_bin by 1, forward to odd                    *
*                                                                           *
*       4.  Load from IMG_histogram for odd half (current itn.)             *
*                                                                           *
*       5.  Store even_bin to IMG_histogram for even half                   *
*                                                                           *
*       6.  if data_odd == previous data_even increment odd_bin by 2        *
*       else increment odd_bin by 1, forward to even                        *
*                                                                           *
*       7.  goto 1.                                                         *
*                                                                           *
*       With this particular ordering, forwarding is necessary between      *
*       even/odd halves when pixels in adjacent halves need to be           *
*       placed in the same bin.  The store is never predicated and          *
*       occurs speculatively as it will be overwritten by the next          *
*       value containing the extra forwarded value.                         *
*                                                                           *
*       The four histograms are interleaved with each bin spaced four       *
*       half-words apart and each IMG_histogram starting in a different     *
*       memory bank.  This allows the four IMG_histogram accesses to        *
*       proceed in any order without worrying about bank conflicts.         *
*       The diagram below illustrates this: (addresses are halfword         *
*       offsets)                                                            *
*                                                                           *
*              0       1       2       3       4       5       6   ...      *
*          | hst 0 | hst 1 | hst 2 | hst 3 | hst 0 | hst 1 | ...   ...      *
*          | bin 0 | bin 0 | bin 0 | bin 0 | bin 1 | bin 1 | ...   ...      *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts should occur in this code in the optimized        *
*       forms of hand assembly and serial assembly.                         *
*                                                                           *
*   NOTE                                                                    *
*       With small modification this code can be used without the           *
*       summing stage.  The sparse IMG_histogram can be accumulated into    *
*       and the final summing loop left until the end of a series of        *
*       histograms.                                                         *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_histogram"
        .global _IMG_histogram
_IMG_histogram: .cproc  A_img, B_n, A_accumulate, B_t_hist, A_hist 
*==============================================================================*
    .no_mdep
    .mdep  x0, y0
    .mdep  y0, z0
    .mdep  z0, w0
    .mdep  w0, x0
    .mdep  y0, x0
    .mdep  z0, y0
    .mdep  w0, z0
    .mdep  x0, w0

    .mdep  x1, y1
    .mdep  y1, z1
    .mdep  z1, w1
    .mdep  w1, x1
    .mdep  y1, x1
    .mdep  z1, y1
    .mdep  w1, z1
    .mdep  x1, w1

    .mdep  x2, y2
    .mdep  y2, z2
    .mdep  z2, w2
    .mdep  w2, x2
    .mdep  y2, x2
    .mdep  z2, y2
    .mdep  w2, z2
    .mdep  x2, w2

    .mdep  x3, y3
    .mdep  y3, z3
    .mdep  z3, w3
    .mdep  w3, x3
    .mdep  y3, x3
    .mdep  z3, y3
    .mdep  w3, z3
    .mdep  x3, w3

    .mdep  _z0, w0
    .mdep  _z0, y0
    .mdep  _z1, w1
    .mdep  _z1, y1
    .mdep  _z2, w2
    .mdep  _z2, y2
    .mdep  _z3, w3
    .mdep  _z3, y3

    .mdep  x0, _y0
    .mdep  z0, _y0
    .mdep  x1, _y1
    .mdep  z1, _y1
    .mdep  x2, _y2
    .mdep  z2, _y2
    .mdep  x3, _y3
    .mdep  z3, _y3

    .mdep  w0, i0
    .mdep  w0, i2
    .mdep  w1, i1
    .mdep  w1, i3
    .mdep  w2, i0
    .mdep  w2, i2
    .mdep  w3, i1
    .mdep  w3, i3

    .mdep  y0, i0
    .mdep  y0, i2
    .mdep  y1, i1
    .mdep  y1, i3
    .mdep  y2, i0
    .mdep  y2, i2
    .mdep  y3, i1
    .mdep  y3, i3

    .mdep  w0, _y0
    .mdep  w1, _y1
    .mdep  w2, _y2
    .mdep  w3, _y3

    .mdep  _y0, i0
    .mdep  _y0, i2
    .mdep  _y1, i1
    .mdep  _y1, i3
    .mdep  _y2, i0
    .mdep  _y2, i2
    .mdep  _y3, i1
    .mdep  _y3, i3
*==============================================================================*
   ;.reg   A_img   ; pointer to even words in in_data
    .reg   B_img   ; pointer to odd words in in_data
    .reg   A_pix   ; 4 packed even pixels
    .reg   B_pix   ; 4 packed odd pixels
    .reg   A_hst0  ; pointer to interleaved IMG_histogram 0
    .reg   A_hst1  ; pointer to interleaved IMG_histogram 1
    .reg   B_hst2  ; pointer to interleaved IMG_histogram 2
    .reg   B_hst3  ; pointer to interleaved IMG_histogram 3

    .reg   A_px0e  ; pixel 0 in "even" half of IMG_histogram process
    .reg   A_px1e  ; pixel 1 in "even" half of IMG_histogram process
    .reg   A_px2e  ; pixel 2 in "even" half of IMG_histogram process
    .reg   B_px3e  ; pixel 3 in "even" half of IMG_histogram process
    .reg   A_bn0e  ; bin for pixel 0 in "even" half of hist proc
    .reg   A_bn1e  ; bin for pixel 1 in "even" half of hist process
    .reg   B_bn2e  ; bin for pixel 2 in "even" half of hist process
    .reg   B_bn3e  ; bin for pixel 3 in "even" half of hist process
    .reg   A_bc0e  ; bin copy for pixel 0 in "even" half of hist process
    .reg   A_bc1e  ; bin copy for pixel 1 in "even" half of hist process
    .reg   B_bc2e  ; bin copy for pixel 2 in "even" half of hist process
    .reg   B_bc3e  ; bin copy for pixel 3 in "even" half of hist process
    .reg   A_eq0e  ; equality detection for hist 0 odd->even forwarding
    .reg   A_eq1e  ; equality detection for hist 1 odd->even forwarding
    .reg   B_eq2e  ; equality detection for hist 2 odd->even forwarding
    .reg   B_eq3e  ; equality detection for hist 3 odd->even forwarding
    .reg   A_hs0e  ; hist 0 value for "even" half
    .reg   A_hs1e  ; hist 1 value for "even" half
    .reg   B_hs2e  ; hist 2 value for "even" half
    .reg   B_hs3e  ; hist 3 value for "even" half
    .reg   A_hf0e  ; hist 0 value for "even" half with forwarding added
    .reg   A_hf1e  ; hist 1 value for "even" half with forwarding added
    .reg   B_hf2e  ; hist 2 value for "even" half with forwarding added
    .reg   B_hf3e  ; hist 3 value for "even" half with forwarding added
    .reg   A_ha0e  ; hist 0 value for "even" half after accumulation
    .reg   A_ha1e  ; hist 1 value for "even" half after accumulation
    .reg   B_ha2e  ; hist 2 value for "even" half after accumulation
    .reg   B_ha3e  ; hist 3 value for "even" half after accumulation

    .reg   B_px0o  ; pixel 0 in "odd" half of IMG_histogram process
    .reg   B_px1o  ; pixel 1 in "odd" half of IMG_histogram process
    .reg   B_px2o  ; pixel 2 in "odd" half of IMG_histogram process
    .reg   B_px3o  ; pixel 3 in "odd" half of IMG_histogram process
    .reg   A_bn0o  ; bin for pixel 0 in "odd" half of hist process
    .reg   A_bn1o  ; bin for pixel 1 in "odd" half of hist process
    .reg   B_bn2o  ; bin for pixel 2 in "odd" half of hist process
    .reg   B_bn3o  ; bin for pixel 3 in "odd" half of hist process
    .reg   A_bc0o  ; bin copy for pixel 0 in "odd" half of hist process
    .reg   A_bc1o  ; bin copy for pixel 1 in "odd" half of hist process
    .reg   B_bc2o  ; bin copy for pixel 2 in "odd" half of hist process
    .reg   B_bc3o  ; bin copy for pixel 3 in "odd" half of hist process
    .reg   A_eq0o  ; equality detection for hist 0 even->odd forwarding
    .reg   A_eq1o  ; equality detection for hist 1 even->odd forwarding
    .reg   B_eq2o  ; equality detection for hist 2 even->odd forwarding
    .reg   B_eq3o  ; equality detection for hist 3 even->odd forwarding
    .reg   A_hs0o  ; hist 0 value for "odd" half
    .reg   A_hs1o  ; hist 1 value for "odd" half
    .reg   B_hs2o  ; hist 2 value for "odd" half
    .reg   B_hs3o  ; hist 3 value for "odd" half
    .reg   A_hf0o  ; hist 0 value for "odd" half with forwarding added
    .reg   A_hf1o  ; hist 1 value for "odd" half with forwarding added
    .reg   B_hf2o  ; hist 2 value for "odd" half with forwarding added
    .reg   B_hf3o  ; hist 3 value for "odd" half with forwarding added
    .reg   A_ha0o  ; hist 0 value for "odd" half after accumulation
    .reg   A_ha1o  ; hist 1 value for "odd" half after accumulation
    .reg   B_ha2o  ; hist 2 value for "odd" half after accumulation
    .reg   B_ha3o  ; hist 3 value for "odd" half after accumulation

    .reg   A_255   ; constant 255 words
    .reg   A_i     ; loop counter
    .reg   B_hist_in_o              ; pntr to odd IMG_histogram addresses
    .reg   A_hist_in_e              ; pntr to even IMG_histogram addresses

    .reg   A_bin10, B_bin32         ; Even IMG_histogram bins
    .reg   A_bin, A_bin_b, A_bin_ba ; IMG_histogram data accumulation

    .reg   A_hist_e_r               ; Even total hist ptnr read
    .reg   A_hist_e_w               ; Even total hist ptnr write
    .reg   A_main_bin               ; Old contents of even bin
    .reg   A_s_bin                  ; * -1/+1 using accumulate
    .reg   A_new_bin                ; New contents of even bin
    .reg   B_bin76, A_bin54         ; Odd IMG_histogram bins
    .reg   B_bin_b, B_bin, B_bin_ba ; IMG_histogram data accumulation
    .reg   B_hist_o_r               ; Even total hist ptnr read
    .reg   B_hist_o_w               ; Even total hist ptnr write
    .reg   B_main_bin               ; Old contents of even bin
    .reg   B_s_bin                  ; * -1/+1 using accumulate
    .reg   B_new_bin                ; New contents of even bin
*==============================================================================*
        MVK  .1    1023,     A_255
        MV   .1X   B_n,      A_i
        ADD  .2X   A_img,    4,   B_img
        MV   .1X   B_t_hist, A_hst0
        ADD  .1X   B_t_hist, 2,   A_hst1
        ADD  .2    B_t_hist, 4,   B_hst2
        ADD  .2    B_t_hist, 6,   B_hst3

        LDH  .D1T1 *A_hst0[1],         A_ha0o  ; Load odd hist0
        LDH  .D1T1 *A_hst1[1],         A_ha1o  ; Load odd hist1
        LDH  .D2T2 *B_hst2[1],         B_ha2o  ; Load odd hist2
        LDH  .D2T2 *B_hst3[1],         B_ha3o  ; Load odd hist3
        MVK  .1    1,        A_bc0o
        MV   .1    A_bc0o,   A_bc1o
        MVK  .2    1,        B_bc2o
        MV   .2    B_bc2o,   B_bc3o

        .mptr A_img, a+0, 0   ;bank 0-1: stride 2 words
        .mptr B_img, a+4, 8   ;bank 2-3: stride 2 words

        .mptr A_hist0, b+0, 0 ;bank 0: stride 0 shorts
        .mptr A_hist1, b+2, 0 ;bank 1: stride 0 shorts
        .mptr B_hist2, b+4, 0 ;bank 2: stride 0 shorts
        .mptr B_hist3, b+6, 0 ;bank 3: stride 0 shorts
LOOP_H: .trip 16
        LDW  .D1T1 *A_img++[2], A_pix            ; Load even-word pixels

        EXTU .1    A_pix,    24, 24,   A_px0e    ; Extract pixel 0
        MPY  .1    4,        A_px0e,   A_bn0e    ; Set offset into hist0

        EXTU .1    A_pix,    16, 24,   A_px1e    ; Extract pixel 1
        MPY  .1    4,        A_px1e,   A_bn1e    ; Set offset into hist1

        EXTU .1    A_pix,    8, 24,    A_px2e    ; Extract pixel 2
        MPY  .2X   4,        A_px2e,   B_bn2e    ; Set offset into hist2

        SHRU .2X   A_pix,    24,       B_px3e    ; Extract pixel 3
        MPY  .2    4,        B_px3e,   B_bn3e    ; Set offset into hist3

        CMPEQ.1    A_bn0e,   A_bc0o,   A_eq0e    ; Odd->Even fwd comp 0
        CMPEQ.1    A_bn1e,   A_bc1o,   A_eq1e    ; Odd->Even fwd comp 1
        CMPEQ.2    B_bn2e,   B_bc2o,   B_eq2e    ; Odd->Even fwd comp 2
        CMPEQ.2    B_bn3e,   B_bc3o,   B_eq3e    ; Odd->Even fwd comp 3

        LDH  .D1T1 *A_hst0[A_bn0e]{x0}, A_hs0e   ;@10  Load from hist0
        LDH  .D1T1 *A_hst1[A_bn1e]{x1}, A_hs1e   ;@14  Load from hist1
        LDH  .D2T2 *B_hst2[B_bn2e]{x2}, B_hs2e   ;@18  Load from hist2
        LDH  .D2T2 *B_hst3[B_bn3e]{x3}, B_hs3e   ;@1C  Load from hist3

        STH  .D1T1 A_ha0o, *A_hst0[A_bc0o]{y0}   ;@10  Store odd hist0
        STH  .D1T1 A_ha1o, *A_hst1[A_bc1o]{y1}   ;@14  Store odd hist1
        STH  .D2T2 B_ha2o, *B_hst2[B_bc2o]{y2}   ;@18  Store odd hist2
        STH  .D2T2 B_ha3o, *B_hst3[B_bc3o]{y3}   ;@1C  Store odd hist3

        ADD  .1    A_hs0e,   A_eq0e,   A_hf0e    ; forwarding for hist0
        ADD  .1    A_hs1e,   A_eq1e,   A_hf1e    ; forwarding for hist1
        ADD  .2    B_hs2e,   B_eq2e,   B_hf2e    ; forwarding for hist2
        ADD  .2    B_hs3e,   B_eq3e,   B_hf3e    ; forwarding for hist3

        ADD  .1    A_hf0e,   1,        A_ha0e    ; Accumulate for hist0
        ADD  .1    A_hf1e,   1,        A_ha1e    ; Accumulate for hist1
        ADD  .2    B_hf2e,   1,        B_ha2e    ; Accumulate for hist2
        ADD  .2    B_hf3e,   1,        B_ha3e    ; Accumulate for hist3

        MPY  .1    1,        A_bn0e,   A_bc0e    ; copy of bin 0 (l2l)
        MPY  .1    1,        A_bn1e,   A_bc1e    ; copy of bin 1 (l2l)
        MPY  .2    1,        B_bn2e,   B_bc2e    ; copy of bin 2 (l2l)
        MPY  .2    1,        B_bn3e,   B_bc3e    ; copy of bin 3 (l2l)

        LDW  .D2T2 *B_img++[2],        B_pix     ; Load odd-word pixels

        EXTU .2    B_pix,    24, 24,   B_px0o    ; Extract pixel 0
        MPY  .1X   4,        B_px0o,   A_bn0o    ; Set offset into hist0

        EXTU .2    B_pix,    16, 24,   B_px1o    ; Extract pixel 1
        MPY  .1X   4,        B_px1o,   A_bn1o    ; Set offset into hist1

        EXTU .2    B_pix,    8, 24,    B_px2o    ; Extract pixel 2
        MPY  .2    4,        B_px2o,   B_bn2o    ; Set offset into hist2
        SHRU .2    B_pix,    24,       B_px3o    ; Extract pixel 3
        MPY  .2    4,        B_px3o,   B_bn3o    ; Set offset into hist3

        CMPEQ.1    A_bn0o,   A_bc0e,   A_eq0o    ; Even->Odd fwd comp 0
        CMPEQ.1    A_bn1o,   A_bc1e,   A_eq1o    ; Even->Odd fwd comp 1
        CMPEQ.2    B_bn2o,   B_bc2e,   B_eq2o    ; Even->Odd fwd comp 2
        CMPEQ.2    B_bn3o,   B_bc3e,   B_eq3o    ; Even->Odd fwd comp 3

        LDH  .D1T1 *A_hst0[A_bn0o]{z0}, A_hs0o   ;@10 Load odd histo 0
        LDH  .D1T1 *A_hst1[A_bn1o]{z1}, A_hs1o   ;@14 Load odd histo 1
        LDH  .D2T2 *B_hst2[B_bn2o]{z2}, B_hs2o   ;@18 Load odd histo 2
        LDH  .D2T2 *B_hst3[B_bn3o]{z3}, B_hs3o   ;@1C Load odd histo 3

        STH  .D1T1 A_ha0e,   *A_hst0[A_bc0e]{w0} ;@10 Store even hist0
        STH  .D1T1 A_ha1e,   *A_hst1[A_bc1e]{w1} ;@14 Store even hist1
        STH  .D2T2 B_ha2e,   *B_hst2[B_bc2e]{w2} ;@18 Store even hist2
        STH  .D2T2 B_ha3e,   *B_hst3[B_bc3e]{w3} ;@1C Store even hist3

        ADD  .1    A_hs0o,   A_eq0o,   A_hf0o    ; forwarding for hist0
        ADD  .1    A_hs1o,   A_eq1o,   A_hf1o    ; forwarding for hist1
        ADD  .2    B_hs2o,   B_eq2o,   B_hf2o    ; forwarding for hist2
        ADD  .2    B_hs3o,   B_eq3o,   B_hf3o    ; forwarding for hist3

        ADD  .1    A_hf0o,   1,        A_ha0o    ; Accumulate for hist0
        ADD  .1    A_hf1o,   1,        A_ha1o    ; Accumulate for hist1
        ADD  .2    B_hf2o,   1,        B_ha2o    ; Accumulate for hist2
        ADD  .2    B_hf3o,   1,        B_ha3o    ; Accumulate for hist3

        MPY  .1    1,        A_bn0o,   A_bc0o    ; copy of bin 0 (l2l)
        MPY  .1    1,        A_bn1o,   A_bc1o    ; copy of bin 1 (l2l)
        MPY  .2    1,        B_bn2o,   B_bc2o    ; copy of bin 2 (l2l)
        MPY  .2    1,        B_bn3o,   B_bc3o    ; copy of bin 3 (l2l)

[A_i]   SUB  .1    A_i,      8,        A_i       ; Loop control.
[A_i]   B          LOOP_H

        STH  .D1T1 A_ha0o, *A_hst0[A_bc0o]{_y0}  ;@10  Store odd hist0
        STH  .D1T1 A_ha1o, *A_hst1[A_bc1o]{_y1}  ;@14  Store odd hist1
        STH  .D2T2 B_ha2o, *B_hst2[B_bc2o]{_y2}  ;@18  Store odd hist2
        STH  .D2T2 B_ha3o, *B_hst3[B_bc3o]{_y3}  ;@1C  Store odd hist3

        MVK  .1    256, A_i
        MV   .1    A_hst0, A_hist_in_e
        ADD  .2X   A_hst0, 4, B_hist_in_o

        MV   .1    A_hist, A_hist_e_r
        MV   .1    A_hist, A_hist_e_w
        ADD  .2X   A_hist, 2, B_hist_o_r
        ADD  .2X   A_hist, 2, B_hist_o_w

        .mptr A_hist_in_e, a+0, 16 ;bank 0-1: stride 2 words
        .mptr B_hist_in_o, a+4, 16 ;bank 2-3: stride 2 words
        .mptr A_hist_e_r,  b+0, 4  ;bank 0: stride 2 shorts
        .mptr A_hist_e_w,  b+0, 4  ;bank 0: stride 2 shorts
        .mptr B_hist_o_r,  b+2, 4  ;bank 1: stride 2 shorts
        .mptr B_hist_o_w,  b+2, 4  ;bank 1: stride 2 shorts
LOOP_S: .trip 32
        LDW  .D1T1 *A_hist_in_e++[2]{i0}, A_bin10
        LDW  .D2T2 *B_hist_in_o++[2]{i1}, B_bin32

        ADD2 .1X   A_bin10, B_bin32, A_bin_ba
        SHRU .1    A_bin_ba, 16, A_bin_b
        ADD  .1    A_bin_ba, A_bin_b, A_bin

        LDH  .D1T1 *A_hist_e_r++[2], A_main_bin
        MPY  .1    A_accumulate, A_bin, A_s_bin
        ADD  .1    A_main_bin, A_s_bin, A_new_bin
        STH  .D1T1 A_new_bin, *A_hist_e_w++[2]

        LDW  .D1T1 *A_hist_in_e++[2]{i2}, A_bin54
        LDW  .D2T2 *B_hist_in_o++[2]{i3}, B_bin76

        ADD2 .2X   B_bin76, A_bin54, B_bin_ba
        SHRU .2    B_bin_ba, 16, B_bin_b
        ADD  .2    B_bin_ba, B_bin_b, B_bin

        LDH  .D2T2 *B_hist_o_r++[2], B_main_bin
        MPY  .2X   B_bin, A_accumulate, B_s_bin
        ADD  .2    B_main_bin, B_s_bin, B_new_bin
        STH  .D2T2 B_new_bin, *B_hist_o_w++[2]

 [A_i]  SUB  .1    A_i, 2, A_i
 [A_i]  B          LOOP_S
* ========================================================================= *
        .endproc

* ========================================================================= *
*   End of file:  img_histogram.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
idct_8x8.sa/    1066929161  0     0     0       62263     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Thu Mar 14 14:06:51 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_idct_8x8 -- IEEE-1180 Compliant IDCT                            *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       01-May-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           void IMG_idct_8x8(short idct_data[], unsigned num_idcts)        *
*                                                                           *
*       The IMG_idct_8x8 routine accepts a list of 8x8 DCT coeffient blocks *
*       and performs IDCTs on each.  The array should be aligned to a       *
*       32-bit boundary, and be laid out equivalently to the C array        *
*       idct_data[num_idcts+1][8][8].                                       *
*                                                                           *
*       The routine requires one 8x8-block's worth of extra storage at      *
*       the end of the list of DCT blocks.  When processing 'num_idcts'     *
*       blocks, an area of length 'num_idcts + 1' must be provided.  The    *
*       contents of the extra block are ignored and overwritten with        *
*       intermediate results by IMG_idct_8x8().                             *
*                                                                           *
*       This code requires '62 + 168 * num_idcts' cycles to process         *
*       'num_idcts' blocks, including 6 cycles of function call overhead.   *
*                                                                           *
*   DESCRIPTION                                                             *
*       The IMG_idct_8x8 algorithm performs an IEEE-1180 compliant IDCT,    *
*       complete with rounding and saturation to signed 9-bit quantities.   *
*       The input coefficients are assumed to be signed 12-bit cosine       *
*       terms.                                                              *
*                                                                           *
*       void IMG_idct_8x8(short *idct_data, unsigned num_dcts)              *
*       {                                                                   *
*         const short c1 = 0x0B19, c2 = 0x0A74, c3 = 0x0968;                *
*         const short c5 = 0x0649, c6 = 0x0454, c7 = 0x0235;                *
*         const int   c4_shift = 11;                                        *
*         const int   round1 = 256, round2 = 32768;                         *
*         const int   trunc1 = 9, trunc2 = 16;                              *
*         const short *i_ptr;                                               *
*         short       *o_ptr;                                               *
*         unsigned    i, j;                                                 *
*         short X0, X1, X2, X3, X4, X5, X6, X7;   /* Freq domain terms  */  *
*         int   P0, P1, p0, p1, r0, r1;           /* Even-half temp     */  *
*         int   g0, g1, h1, h0;                   /* Even-half result   */  *
*         int   g2, g3, h3, h2;                   /* Odd-half result    */  *
*         int   x0, x1, x2, x3, x4, x5, x6, x7;   /* Resulting samples  */  *
*         int   x0t,x1t,x2t,x3t,x4t,x5t,x6t,x7t;  /* Truncated result   */  *
*         int   x0s,x1s,x2s,x3s,x4s,x5s,x6s,x7s;  /* Saturated result   */  *
*                                                                           *
*         /* ---------------------------------------------------------- */  *
*         /*  Avoid running the code if we don't have any IDCTs to do.  */  *
*         /* ---------------------------------------------------------- */  *
*         if (!num_dcts) return;                                            *
*                                                                           *
*         /* ---------------------------------------------------------- */  *
*         /*  Set up pointers.                                          */  *
*         /* ---------------------------------------------------------- */  *
*         i_ptr = idct_data + num_dcts * 64 - 8;                            *
*         o_ptr = idct_data + num_dcts * 64 + 7;                            *
*                                                                           *
*         for (j = 0; j < num_dcts; j++)                                    *
*         {                                                                 *
*           /* -------------------------------------------------------- */  *
*           /*  Perform Horizontal 1-D IDCT on each 8x8 block.  Store   */  *
*           /*  out the results transposed.                             */  *
*           /* -------------------------------------------------------- */  *
*           for (i = 0; i < 8; i++)                                         *
*           {                                                               *
*               /* ---------------------------------------------------- */  *
*               /*  Load the freq-domain coefficients.                  */  *
*               /* ---------------------------------------------------- */  *
*               X0 = i_ptr[0];                                              *
*               X1 = i_ptr[1];                                              *
*               X2 = i_ptr[2];                                              *
*               X3 = i_ptr[3];                                              *
*               X4 = i_ptr[4];                                              *
*               X5 = i_ptr[5];                                              *
*               X6 = i_ptr[6];                                              *
*               X7 = i_ptr[7];                                              *
*                                                                           *
*               i_ptr -= 8;             /* decr pointer to next row     */  *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Even part of decomp.  Add rounding to DC term.      */  *
*               /* ---------------------------------------------------- */  *
*               P0 = (((int)X0) << c4_shift) + round1;                      *
*               P1 = (((int)X4) << c4_shift);                               *
*                                                                           *
*               p0 = P0 + P1;                                               *
*               p1 = P0 - P1;                                               *
*                                                                           *
*               r1 = X2*c6 - X6*c2;                                         *
*               r0 = X2*c2 + X6*c6;                                         *
*                                                                           *
*               g0 = p0 + r0;                                               *
*               g1 = p1 + r1;                                               *
*               h1 = p1 - r1;                                               *
*               h0 = p0 - r0;                                               *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Odd part of decomp.                                 */  *
*               /* ---------------------------------------------------- */  *
*               g2 = (X1*c7 - X3*c5) + (X5*c3 - X7*c1);                     *
*               g3 = (X1*c5 - X3*c1) + (X5*c7 + X7*c3);                     *
*               h3 = (X1*c3 - X3*c7) - (X5*c1 + X7*c5);                     *
*               h2 = (X1*c1 + X3*c3) + (X5*c5 + X7*c7);                     *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Final butterfly.                                    */  *
*               /* ---------------------------------------------------- */  *
*               x0 = g0 + h2;                                               *
*               x1 = g1 + h3;                                               *
*               x2 = h1 + g3;                                               *
*               x3 = h0 + g2;                                               *
*               x4 = h0 - g2;                                               *
*               x5 = h1 - g3;                                               *
*               x6 = g1 - h3;                                               *
*               x7 = g0 - h2;                                               *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Truncate to fit back into 16 bits.                  */  *
*               /* ---------------------------------------------------- */  *
*               x0t = x0 >> trunc1;                                         *
*               x1t = x1 >> trunc1;                                         *
*               x2t = x2 >> trunc1;                                         *
*               x3t = x3 >> trunc1;                                         *
*               x4t = x4 >> trunc1;                                         *
*               x5t = x5 >> trunc1;                                         *
*               x6t = x6 >> trunc1;                                         *
*               x7t = x7 >> trunc1;                                         *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Store the results transposed.                       */  *
*               /* ---------------------------------------------------- */  *
*               o_ptr[ 0] = x0t;                                            *
*               o_ptr[ 8] = x1t;                                            *
*               o_ptr[16] = x2t;                                            *
*               o_ptr[24] = x3t;                                            *
*               o_ptr[32] = x4t;                                            *
*               o_ptr[40] = x5t;                                            *
*               o_ptr[48] = x6t;                                            *
*               o_ptr[56] = x7t;                                            *
*                                                                           *
*               o_ptr--;                /* decrement ptr to next column */  *
*           }                                                               *
*                                                                           *
*           /* -------------------------------------------------------- */  *
*           /*  Update output pointer to point to next block.           */  *
*           /* -------------------------------------------------------- */  *
*                                                                           *
*           o_ptr = o_ptr + 8 - 64;                                         *
*         }                                                                 *
*                                                                           *
*         /* ---------------------------------------------------------- */  *
*         /*  Reset our pointers for the vertical pass.                 */  *
*         /* ---------------------------------------------------------- */  *
*         i_ptr = idct_data + 64;                                           *
*         o_ptr = idct_data;                                                *
*                                                                           *
*         for (j = 0; j < num_dcts; j++)                                    *
*         {                                                                 *
*           /* -------------------------------------------------------- */  *
*           /*  Perform Vertical 1-D IDCT on each 8x8 block.  Store     */  *
*           /*  out the results transposed.                             */  *
*           /* -------------------------------------------------------- */  *
*           for (i = 0; i < 8; i++)                                         *
*           {                                                               *
*               /* ---------------------------------------------------- */  *
*               /*  Load the freq-domain coefficients.                  */  *
*               /* ---------------------------------------------------- */  *
*               X0 = i_ptr[0];                                              *
*               X1 = i_ptr[1];                                              *
*               X2 = i_ptr[2];                                              *
*               X3 = i_ptr[3];                                              *
*               X4 = i_ptr[4];                                              *
*               X5 = i_ptr[5];                                              *
*               X6 = i_ptr[6];                                              *
*               X7 = i_ptr[7];                                              *
*               i_ptr += 8;             /* increment ptr to next row    */  *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Even part of decomp.  Add rouding term to DC.       */  *
*               /* ---------------------------------------------------- */  *
*               P0 = (((int)X0) << c4_shift) + round2; /* c4 is a shift */  *
*               P1 = (((int)X4) << c4_shift);          /* c4 is a shift */  *
*                                                                           *
*               p0 = P0 + P1;                                               *
*               p1 = P0 - P1;                                               *
*                                                                           *
*               r1 = X2*c6 - X6*c2;                                         *
*               r0 = X2*c2 + X6*c6;                                         *
*                                                                           *
*               g0 = p0 + r0;                                               *
*               g1 = p1 + r1;                                               *
*               h1 = p1 - r1;                                               *
*               h0 = p0 - r0;                                               *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Odd part of decomp.                                 */  *
*               /* ---------------------------------------------------- */  *
*               g2 = (X1*c7 - X3*c5) + (X5*c3 - X7*c1);                     *
*               g3 = (X1*c5 - X3*c1) + (X5*c7 + X7*c3);                     *
*               h3 = (X1*c3 - X3*c7) - (X5*c1 + X7*c5);                     *
*               h2 = (X1*c1 + X3*c3) + (X5*c5 + X7*c7);                     *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Final butterfly.                                    */  *
*               /* ---------------------------------------------------- */  *
*               x0 = g0 + h2;                                               *
*               x1 = g1 + h3;                                               *
*               x2 = h1 + g3;                                               *
*               x3 = h0 + g2;                                               *
*               x4 = h0 - g2;                                               *
*               x5 = h1 - g3;                                               *
*               x6 = g1 - h3;                                               *
*               x7 = g0 - h2;                                               *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Truncate and saturate final results.                */  *
*               /* ---------------------------------------------------- */  *
*               x0t = x0 >> trunc2;                                         *
*               x1t = x1 >> trunc2;                                         *
*               x2t = x2 >> trunc2;                                         *
*               x3t = x3 >> trunc2;                                         *
*               x4t = x4 >> trunc2;                                         *
*               x5t = x5 >> trunc2;                                         *
*               x6t = x6 >> trunc2;                                         *
*               x7t = x7 >> trunc2;                                         *
*                                                                           *
*               x0s = x0t < -256 ? -256 : x0t > 255 ? 255 : x0t;            *
*               x1s = x1t < -256 ? -256 : x1t > 255 ? 255 : x1t;            *
*               x2s = x2t < -256 ? -256 : x2t > 255 ? 255 : x2t;            *
*               x3s = x3t < -256 ? -256 : x3t > 255 ? 255 : x3t;            *
*               x4s = x4t < -256 ? -256 : x4t > 255 ? 255 : x4t;            *
*               x5s = x5t < -256 ? -256 : x5t > 255 ? 255 : x5t;            *
*               x6s = x6t < -256 ? -256 : x6t > 255 ? 255 : x6t;            *
*               x7s = x7t < -256 ? -256 : x7t > 255 ? 255 : x7t;            *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Store the results transposed in the result area.    */  *
*               /* ---------------------------------------------------- */  *
*               o_ptr[ 0] = x0s;                                            *
*               o_ptr[ 8] = x1s;                                            *
*               o_ptr[16] = x2s;                                            *
*               o_ptr[24] = x3s;                                            *
*               o_ptr[32] = x4s;                                            *
*               o_ptr[40] = x5s;                                            *
*               o_ptr[48] = x6s;                                            *
*               o_ptr[56] = x7s;                                            *
*                                                                           *
*               o_ptr++;                /* increment ptr to next column */  *
*           }                                                               *
*           /* -------------------------------------------------------- */  *
*           /*  Update output pointer to point to next block.           */  *
*           /* -------------------------------------------------------- */  *
*           o_ptr = o_ptr - 8 + 64;                                         *
*         }                                                                 *
*       }                                                                   *
*                                                                           *
*                                                                           *
*       Note:  This code guarantees correct operation, even in the case     *
*       that 'num_idcts == 0'.  In that case, the function runs for only    *
*       23 cycles (counting 6 cycles of function-call overhead), due to     *
*       early-exit code.                                                    *
*                                                                           *
*   TECHNIQUES                                                              *
*       All levels of looping are collapsed into single loops which are     *
*       pipelined.  The outer loop focuses on 8-pt IDCTs, whereas the       *
*       inner loop controls the column-pointer to handle jumps between      *
*       IDCT blocks.                                                        *
*                                                                           *
*       For speed, cosine term registers are reused between the horiz.      *
*       and vertical loops to save the need for messy constant              *
*       reinitialization.  Also, .mptr and .no_mdep have been used          *
*       to avoid bank-conflicts and to signify that no memory               *
*       dependencies need to be tracked.                                    *
*                                                                           *
*       The IDCTs cannot be performed completely in-place due to the        *
*       transpose that each pass performs.  In order to save data memory,   *
*       the horizontal pass works from the end of the array towards the     *
*       beginning, writing its result one IDCT block later in memory,       *
*       thus performing the IDCT nearly-in-place.  The vertical pass        *
*       performs its IDCTs in the opposite direction, working from the      *
*       start of the array towards the end, writing the result in-place.    *
*       A nice side effect of this is that the pointer values at the        *
*       end of the horizontal loop are a fixed offset relative to their     *
*       required values for the vertical loop, regardless of the number     *
*       of IDCTs performed.  This makes the pointer reinitialization        *
*       exceptionally cheap.                                                *
*                                                                           *
*       Additional section-specific optimization notes are provided below.  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input array must be aligned on a word boundary, and one         *
*       extra block's worth of storage must be present after the list       *
*       of IDCT input blocks.                                               *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*                                                                           *
*       For correct operation, the input array must be aligned to a word    *
*       boundary.                                                           *
*                                                                           *
*   NOTES                                                                   *
*       This is a LITTLE ENDIAN implementation.                             *
*                                                                           *
*       The cosine terms have all been scaled by sqrt(2), so that the       *
*       "c4" term is basically an even power of 2.                          *
*                                                                           *
*       The precision of the final results can be changed by modifying      *
*       the constants at the top of the code and reassembling.  Usually,    *
*       modifying the final-shift constants in the "Symbolic Constants"     *
*       section is sufficient.                                              *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_idct_8x8"
        .global _IMG_idct_8x8
_IMG_idct_8x8 .cproc A_i_data, B_num_dcts
; =========================== MEMORY DEPENDENCIES ============================
            .no_mdep                    ; Assume "don't alias" by default.
            .no_mdep                    ; Assume "don't alias" by default.
            .mdep   s0, l0              ;\
            .mdep   s1, l0              ; |
            .mdep   s2, l0              ; |
            .mdep   s3, l0              ; |__ Final h_loop stores to first
            .mdep   s4, l0              ; |   v_loop load.
            .mdep   s5, l0              ; |
            .mdep   s6, l0              ; |
            .mdep   s7, l0              ;/
            .mdep   s0, l1              ;\
            .mdep   s1, l1              ; |
            .mdep   s2, l1              ; |
            .mdep   s3, l1              ; |__ Final h_loop stores to second
            .mdep   s4, l1              ; |   v_loop load.
            .mdep   s5, l1              ; |
            .mdep   s6, l1              ; |
            .mdep   s7, l1              ;/
            .mdep   s0, l2              ;\
            .mdep   s1, l2              ; |
            .mdep   s2, l2              ; |
            .mdep   s3, l2              ; |__ Final h_loop stores to third
            .mdep   s4, l2              ; |   v_loop load.
            .mdep   s5, l2              ; |
            .mdep   s6, l2              ; |
            .mdep   s7, l2              ;/
            .mdep   s0, l3              ;\
            .mdep   s1, l3              ; |
            .mdep   s2, l3              ; |
            .mdep   s3, l3              ; |__ Final h_loop stores to fourth
            .mdep   s4, l3              ; |   v_loop load.
            .mdep   s5, l3              ; |
            .mdep   s6, l3              ; |
            .mdep   s7, l3              ;/
; ============================ SYMBOLIC CONSTANTS ============================
            .asg    0x0B19,     cst_c1  ; Cosine term c1
            .asg    0x0A74,     cst_c2  ; Cosine term c2
            .asg    0x0968,     cst_c3  ; Cosine term c3
            .asg    0x0800,     cst_c4  ; Cosine term c4
            .asg    0x0649,     cst_c5  ; Cosine term c5
            .asg    0x0454,     cst_c6  ; Cosine term c6
            .asg    0x0235,     cst_c7  ; Cosine term c7
            .asg    11,         q_pt    ; Q-point for calculations
            .asg    16,         kq_a    ; Extract const for c4 "mpy"
            .asg    16-q_pt,    kq_b    ; Extract const for c4 "mpy"
            .asg    9,          trunc1  ; Truncation after horizontal pass
            .asg    9,          results ; Final precision of results
            .asg    32-results, trunc2  ; Final truncation right-shift
            .asg    16-results, satl    ; Final saturation left-shift
; =============== SYMBOLIC REGISTER ASSIGNMENTS FOR SETUP CODE ===============
            .reg    B_size  ; Total size of input (except for extra block)
            .reg    B_eob   ; Ptr to end-of-buffer (first byte of extra block)
; =============== SYMBOLIC REGISTER ASSIGNMENTS FOR HORIZ LOOP ===============
            .reg    B_c7c5  ; Cosine terms c7, c5   (packed)
            .reg    A_c7c5  ; Cosine terms c7, c5   (packed)
            .reg    B_c3c1  ; Cosine terms c3, c1   (packed)
            .reg    A_c3c1  ; Cosine terms c3, c1   (packed)
            .reg    B_c6c2  ; Cosine terms c6, c2   (packed)
            .reg    A_i_ptr ; Input pointer #1
            .reg    B_i_ptr ; Input pointer #2
            .reg    A_o_ptr ; Output pointer #1
            .reg    B_o_ptr ; Output pointer #2
            .reg    B_o     ; Outer loop counter
            .reg    A_X1X0  ; Incoming coefs X1, X0 (packed)
            .reg    A_X3X2  ; Incoming coefs X3, X2 (packed)
            .reg    B_X5X4  ; Incoming coefs X5, X4 (packed)
            .reg    B_X7X6  ; Incoming coefs X7, X6 (packed)
            .reg    A_X2c6  ; X2 * c6
            .reg    B_X6c2  ; X6 * c2
            .reg    A_X2c2  ; X2 * c2
            .reg    B_X6c6  ; X6 * c6
            .reg    A_P0    ; Node P0 in signal flow graph
            .reg    B_P1    ; Node P1 in signal flow graph
            .reg    A_p0    ; Node p0 in signal flow graph
            .reg    A_p1    ; Node p1 in signal flow graph
            .reg    B_r1    ; Node r1 in signal flow graph
            .reg    B_r0    ; Node r0 in signal flow graph
            .reg    B_g0    ; Node g0 in signal flow graph
            .reg    B_g1    ; Node g1 in signal flow graph
            .reg    A_h1    ; Node h1 in signal flow graph
            .reg    A_h0    ; Node h0 in signal flow graph
            .reg    A_X1c1  ; X1 * c1
            .reg    A_X1c3  ; X1 * c3
            .reg    A_X1c5  ; X1 * c5
            .reg    A_X1c7  ; X1 * c7
            .reg    A_X3c1  ; X3 * c1
            .reg    A_X3c3  ; X3 * c3
            .reg    A_X3c5  ; X3 * c5
            .reg    A_X3c7  ; X3 * c7
            .reg    B_X5c1  ; X5 * c1
            .reg    B_X5c3  ; X5 * c3
            .reg    B_X5c5  ; X5 * c5
            .reg    B_X5c7  ; X5 * c7
            .reg    B_X7c1  ; X7 * c1
            .reg    B_X7c3  ; X7 * c3
            .reg    B_X7c5  ; X7 * c5
            .reg    B_X7c7  ; X7 * c7
            .reg    A_g2a   ; X1 * c7 - X3 * c5
            .reg    B_g2b   ; X5 * c3 - X7 * c1
            .reg    A_g2    ; Node g2 in signal flow graph
            .reg    A_g3a   ; X1 * c5 - X3 * c1
            .reg    B_g3b   ; X5 * c7 + X7 * c3
            .reg    A_g3    ; Node g3 in signal flow graph
            .reg    A_h3a   ; X1 * c3 - X2 * c7
            .reg    B_h3b   ; X5 * c1 + X7 * c5
            .reg    B_h3n   ; Node h3, negated.
            .reg    A_h2a   ; X1 * c1 + X3 * c3
            .reg    B_h2b   ; X5 * c5 + X7 * c7
            .reg    B_h2    ; Node h2 in signal flow graph
            .reg    B_x0    ; Output x0, pre-truncation
            .reg    B_x1    ; Output x1, pre-truncation
            .reg    A_x2    ; Output x2, pre-truncation
            .reg    A_x3    ; Output x3, pre-truncation
            .reg    A_x4    ; Output x4, pre-truncation
            .reg    A_x5    ; Output x5, pre-truncation
            .reg    B_x6    ; Output x6, pre-truncation
            .reg    B_x7    ; Output x7, pre-truncation
            .reg    B_x0t   ; Output x0, truncated to 16 bits
            .reg    B_x1t   ; Output x1, truncated to 16 bits
            .reg    A_x2t   ; Output x2, truncated to 16 bits
            .reg    A_x3t   ; Output x3, truncated to 16 bits
            .reg    A_x4t   ; Output x4, truncated to 16 bits
            .reg    A_x5t   ; Output x5, truncated to 16 bits
            .reg    B_x6t   ; Output x6, truncated to 16 bits
            .reg    B_x7t   ; Output x7, truncated to 16 bits
            .reg    A_i     ; Inner-loop counter.
; =============== SYMBOLIC REGISTER ASSIGNMENTS FOR VERT LOOP ================
            .reg    A_c6c3  ; Cosine terms c6, c3   (packed)
            .reg    B_c2c1  ; Cosine terms c2, c1   (packed)
            .reg    A_c4    ; Cosine term  c4
            .reg    A_o     ; Outer loop counter
            .reg    B_i     ; Inner loop counter
            .reg    A_X7X6  ; Incoming coefs X7, X6 (packed)
            .reg    A_X5X4  ; Incoming coefs X5, X4 (packed)
            .reg    B_X3X2  ; Incoming coefs X3, X2 (packed)
            .reg    B_X1X0  ; Incoming coefs X1, X0 (packed)
            .reg    B_rnd   ; Rounding value applied to P0
            .reg    B_P0_t  ; Node P0, temporary pre-rounding
            .reg    B_P0    ; Rounded value of Node P0
            .reg    A_P1    ; Node P1 in signal flow graph
            .reg    B_X2c2  ; X2 * c2
            .reg    B_X2c6  ; X2 * c6
            .reg    A_X6c2  ; X6 * c2
            .reg    A_X6c6  ; X6 * c6
            .reg    A_g1    ; Node g1 in signal flow graph
            .reg    B_h1    ; Node h1 in signal flow graph
            .reg    B_X1c1  ; X1 * c1
            .reg    B_X1c3  ; X1 * c3
            .reg    B_X1c5  ; X1 * c5
            .reg    B_X1c7  ; X1 * c7
            .reg    B_X3c1  ; X3 * c1
            .reg    B_X3c3  ; X3 * c3
            .reg    B_X3c5  ; X3 * c5
            .reg    B_X3c7  ; X3 * c7
            .reg    A_X5c1  ; X5 * c1
            .reg    A_X5c3  ; X5 * c3
            .reg    A_X5c5  ; X5 * c5
            .reg    A_X5c7  ; X5 * c7
            .reg    A_X7c1  ; X7 * c1
            .reg    A_X7c3  ; X7 * c3
            .reg    A_X7c5  ; X7 * c5
            .reg    A_X7c7  ; X7 * c7
            .reg    A_h3    ; Node h3 in signal flow graph
            .reg    B_g3    ; Node g3 in signal flow graph
            .reg    A_x1    ; Output x1, pre-saturate/truncate
            .reg    B_x2    ; Output x2, pre-saturate/truncate
            .reg    B_x5    ; Output x5, pre-saturate/truncate
            .reg    A_x6    ; Output x6, pre-saturate/truncate
            .reg    B_x0s   ; Output x0, saturated to 9 bits
            .reg    A_x1s   ; Output x1, saturated to 9 bits
            .reg    B_x2s   ; Output x2, saturated to 9 bits
            .reg    A_x3s   ; Output x3, saturated to 9 bits
            .reg    A_x4s   ; Output x4, saturated to 9 bits
            .reg    B_x5s   ; Output x5, saturated to 9 bits
            .reg    A_x6s   ; Output x6, saturated to 9 bits
            .reg    B_x7s   ; Output x7, saturated to 9 bits
            .reg    A_x1t   ; Output x1, saturated/truncated to 9 bits
            .reg    B_x2t   ; Output x2, saturated/truncated to 9 bits
            .reg    B_x5t   ; Output x5, saturated/truncated to 9 bits
            .reg    A_x6t   ; Output x6, saturated/truncated to 9 bits
; ============================================================================


            ; ========================================================= ;
            ;  Set up Cosine terms.                                     ;
            ; ========================================================= ;
            MVK     .1  cst_c1,     A_c3c1              ; Cosine term c1
            MVK     .2  cst_c1,     B_c3c1              ; Cosine term c1
            MVKLH   .1  cst_c3,     A_c3c1              ; Cosine term c3
            MVKLH   .2  cst_c3,     B_c3c1              ; Cosine term c3
            MVK     .1  cst_c5,     A_c7c5              ; Cosine term c5
            MVK     .2  cst_c5,     B_c7c5              ; Cosine term c5
            MVKLH   .1  cst_c7,     A_c7c5              ; Cosine term c7
            MVKLH   .2  cst_c7,     B_c7c5              ; Cosine term c7
            MVK     .2  cst_c2,     B_c6c2              ; Cosine term c2
            MVKLH   .2  cst_c6,     B_c6c2              ; Cosine term c6

            ; ========================================================= ;
            ;  Set up input and output pointers.  Abort if we notice    ;
            ;  that num_idcts == 0.                                     ;
            ; ========================================================= ;
            SHL     .2  B_num_dcts, 7,          B_size
            ADD     .2x B_size,     A_i_data,   B_eob   ; End of Blocks ptr
[!B_size]   B           idct_8x8_abort

            SUB     .2  B_eob,      8,          B_i_ptr ; Point to X5X4, row 7
            SUB     .1x B_i_ptr,    8,          A_i_ptr ; Point to X1X0, row 7

            MV      .1x B_eob,      A_o_ptr
            ADDK    .1  78,         A_o_ptr             ; Point to x4, col7
            ADDAH   .2  B_eob,      31,         B_o_ptr ; Point to x3, col7

            ; ========================================================= ;
            ;  Use .mptr to avoid bank conflicts.                       ;
            ; ========================================================= ;
            .mptr       A_i_ptr,    i_data +  0, -16
            .mptr       B_i_ptr,    i_data +  8, -16
            .mptr       A_o_ptr,    i_data + 14, -2
            .mptr       B_o_ptr,    i_data + 14, -2

            ; ========================================================= ;
            ;  Initialize inner (A_i) and outer (B_o) loop counters.    ;
            ; ========================================================= ;
            ZERO    .1  A_i
            SHL     .2  B_num_dcts, 3,          B_o
            MV      .1x B_o,        A_o

; =========================== HORIZONTAL LOOP ================================
h_loop:      .trip       8

            ; ========================================================= ;
            ;   Load the Coefficients.                                  ;
            ; ========================================================= ;
            LDW  .D2T2  *+B_i_ptr  [1],         B_X7X6
            LDW  .D2T2  * B_i_ptr--[4],         B_X5X4
            LDW  .D1T1  *+A_i_ptr  [1],         A_X3X2
            LDW  .D1T1  * A_i_ptr--[4],         A_X1X0

            ; ========================================================= ;
            ;   Upper (even) half of signal flow graph                  ;
            ; ========================================================= ;

            ; --------------------------------------------------------- ;
            ;   Build up the products first.                            ;
            ; --------------------------------------------------------- ;
            MPYLH  .1x  A_X3X2,     B_c6c2,     A_X2c6
            MPY    .2   B_X7X6,     B_c6c2,     B_X6c2
            MPY    .1x  A_X3X2,     B_c6c2,     A_X2c2
            MPYLH  .2   B_X7X6,     B_c6c2,     B_X6c6

            ; --------------------------------------------------------- ;
            ;   P0 = X0c4 (+ 0.5 for rounding)                          ;
            ;   P1 = X4c4                                               ;
            ; --------------------------------------------------------- ;
            EXT    .1   A_X1X0,     kq_a, kq_b, A_P0
            EXT    .2   B_X5X4,     kq_a, kq_b, B_P1

            ADDK   .1   256,        A_P0

            ; --------------------------------------------------------- ;
            ;   p0 = P0 + P1                                            ;
            ;   p1 = P0 - P1                                            ;
            ; --------------------------------------------------------- ;
            ADD    .1x  A_P0,       B_P1,       A_p0
            SUB    .1x  A_P0,       B_P1,       A_p1

            ; --------------------------------------------------------- ;
            ;   r1 = X2c6 - X6c2                                        ;
            ;   r0 = X2c2 + X6c6                                        ;
            ; --------------------------------------------------------- ;
            SUB    .2x  A_X2c6,     B_X6c2,     B_r1
            ADD    .2x  A_X2c2,     B_X6c6,     B_r0

            ; --------------------------------------------------------- ;
            ;   g0 = p0 + r0                                            ;
            ;   g1 = p1 + r1                                            ;
            ;   h1 = p1 - r1                                            ;
            ;   h0 = p0 - r0                                            ;
            ; --------------------------------------------------------- ;
            ADD    .2x  A_p0,       B_r0,       B_g0
            ADD    .2x  A_p1,       B_r1,       B_g1
            SUB    .1x  A_p1,       B_r1,       A_h1
            SUB    .1x  A_p0,       B_r0,       A_h0

            ; ========================================================= ;
            ;   Lower (odd) half of signal flow graph                   ;
            ; ========================================================= ;

            ; --------------------------------------------------------- ;
            ;   Build up all of the products first.                     ;
            ; --------------------------------------------------------- ;
            MPYHL  .1   A_X1X0,     A_c3c1,     A_X1c1
            MPYH   .1   A_X1X0,     A_c3c1,     A_X1c3
            MPYHL  .1   A_X1X0,     A_c7c5,     A_X1c5
            MPYH   .1   A_X1X0,     A_c7c5,     A_X1c7

            MPYHL  .1   A_X3X2,     A_c3c1,     A_X3c1
            MPYH   .1   A_X3X2,     A_c3c1,     A_X3c3
            MPYHL  .1   A_X3X2,     A_c7c5,     A_X3c5
            MPYH   .1   A_X3X2,     A_c7c5,     A_X3c7

            MPYHL  .2   B_X5X4,     B_c3c1,     B_X5c1
            MPYH   .2   B_X5X4,     B_c3c1,     B_X5c3
            MPYHL  .2   B_X5X4,     B_c7c5,     B_X5c5
            MPYH   .2   B_X5X4,     B_c7c5,     B_X5c7

            MPYHL  .2   B_X7X6,     B_c3c1,     B_X7c1
            MPYH   .2   B_X7X6,     B_c3c1,     B_X7c3
            MPYHL  .2   B_X7X6,     B_c7c5,     B_X7c5
            MPYH   .2   B_X7X6,     B_c7c5,     B_X7c7

            ; --------------------------------------------------------- ;
            ;   g2a = X1c7 - X3c5                                       ;
            ;   g2b = X5c3 - X7c1                                       ;
            ;   g2  =  g2a + g2b  = X1c7 - X3c5 + X5c3 - X7c1           ;
            ; --------------------------------------------------------- ;
            SUB    .1   A_X1c7,     A_X3c5,     A_g2a
            SUB    .2   B_X5c3,     B_X7c1,     B_g2b
            ADD    .1x  A_g2a,      B_g2b,      A_g2

            ; --------------------------------------------------------- ;
            ;   g3a = X1c5 - X3c1                                       ;
            ;   g3b = X5c7 + X7c3                                       ;
            ;   g3  =  g3a + g3b  = X1c5 - X3c1 + X5c7 + X7c3           ;
            ; --------------------------------------------------------- ;
            SUB    .1   A_X1c5,     A_X3c1,     A_g3a
            ADD    .2   B_X5c7,     B_X7c3,     B_g3b
            ADD    .1x  A_g3a,      B_g3b,      A_g3

            ; --------------------------------------------------------- ;
            ;   h3a = X1c3 - X3c7                                       ;
            ;   h3b = X5c1 + X7c5                                       ;
            ;   h3  =  h3a - h3b  =   X1c3 - X3c7 - X5c1 - X7c5         ;
            ;   h3n =  h3b - h3a  = - X1c3 + X3c7 + X5c1 + X7c5 = -h3   ;
            ; --------------------------------------------------------- ;
            SUB    .1   A_X1c3,     A_X3c7,     A_h3a
            ADD    .2   B_X5c1,     B_X7c5,     B_h3b
            SUB    .2x  B_h3b,      A_h3a,      B_h3n

            ; --------------------------------------------------------- ;
            ;   h2a = X1c1 + X3c3                                       ;
            ;   h2b = X5c5 + X7c7                                       ;
            ;   h2  =  h2a + h2b  = X1c1 + X3c3 + X5c5 + X7c7           ;
            ; --------------------------------------------------------- ;
            ADD    .1   A_X1c1,     A_X3c3,     A_h2a
            ADD    .2   B_X5c5,     B_X7c7,     B_h2b
            ADD    .2x  A_h2a,      B_h2b,      B_h2


            ; --------------------------------------------------------- ;
            ; Final butterfly (the grand finale)                        ;
            ;                                                           ;
            ;   x0 = g0 + h2   x7 = g0 - h2                             ;
            ;   x1 = g1 - h3n  x6 = g1 + h3n                            ;
            ;   x2 = h1 + g3   x5 = h1 - g3                             ;
            ;   x3 = h0 + g2   x4 = h0 - g2                             ;
            ; --------------------------------------------------------- ;
            ADD    .2   B_g0,       B_h2,       B_x0
            SUB    .2   B_g1,       B_h3n,      B_x1
            ADD    .1   A_h1,       A_g3,       A_x2
            ADD    .1   A_h0,       A_g2,       A_x3
            SUB    .1   A_h0,       A_g2,       A_x4
            SUB    .1   A_h1,       A_g3,       A_x5
            ADD    .2   B_g1,       B_h3n,      B_x6
            SUB    .2   B_g0,       B_h2,       B_x7

            ; ========================================================= ;
            ;   Truncate to fit back into shorts.                       ;
            ; ========================================================= ;
            SHR    .2   B_x0,       trunc1,     B_x0t
            SHR    .2   B_x1,       trunc1,     B_x1t
            SHR    .1   A_x2,       trunc1,     A_x2t
            SHR    .1   A_x3,       trunc1,     A_x3t
            SHR    .1   A_x4,       trunc1,     A_x4t
            SHR    .1   A_x5,       trunc1,     A_x5t
            SHR    .2   B_x6,       trunc1,     B_x6t
            SHR    .2   B_x7,       trunc1,     B_x7t

            ; ========================================================= ;
            ;   Store the results.                                      ;
            ; ========================================================= ;
            STH .D1T2   B_x7t,      *+A_o_ptr  [24]{s0}
            STH .D1T2   B_x6t,      *+A_o_ptr  [16]{s1}
            STH .D1T1   A_x5t,      *+A_o_ptr  [ 8]{s2}
            STH .D1T1   A_x4t,      * A_o_ptr--[ 1]{s3}
            STH .D2T2   B_x0t,      *-B_o_ptr  [24]{s4}
            STH .D2T2   B_x1t,      *-B_o_ptr  [16]{s5}
            STH .D2T1   A_x2t,      *-B_o_ptr  [ 8]{s6}
            STH .D2T1   A_x3t,      * B_o_ptr--[ 1]{s7}

            ; ========================================================= ;
            ;   Loop control.                                           ;
            ; ========================================================= ;

            ADD    .1   A_i,        1,          A_i
            AND    .1   A_i,        7,          A_i
     [!A_i] SUBAW  .1   A_o_ptr,    28,         A_o_ptr
     [!A_i] SUBAW  .2   B_o_ptr,    28,         B_o_ptr

     [ B_o] SUB    .2   B_o,        1,          B_o
     [ B_o] B           h_loop
; ============================================================================


            ; ========================================================= ;
            ;  Set up new pointers for second loop.  We do this from    ;
            ;  scratch to avoid having live-out pointers from the       ;
            ;  horizontal pass above, allowing more compiler freedom.   ;
            ; ========================================================= ;
            MV     .1   A_i_data,   A_i_ptr
            MV     .2x  A_i_data,   B_i_ptr
            ADDAW  .2   B_i_ptr,    12,         B_o_ptr
            ADDAW  .1   A_i_ptr,    16,         A_o_ptr
            ADDK   .1   128 + 8,    A_i_ptr
            ADDK   .2   128 + 4,    B_i_ptr

            .mptr       A_i_ptr,    i_data + 8, 16
            .mptr       B_i_ptr,    i_data + 4, 16
            .mptr       A_o_ptr,    i_data + 0, 2
            .mptr       B_o_ptr,    i_data + 0, 2


            ; ========================================================= ;
            ;  Set up modified cosine terms for second loop.            ;
            ; ========================================================= ;
            MVK    .1   cst_c3,     A_c6c3
            MVKLH  .1   cst_c6,     A_c6c3

            MV     .2   B_c3c1,     B_c2c1
            MVKLH  .2   cst_c2,     B_c2c1

            ; ========================================================= ;
            ;  Initialize inner loop count.  (Outer loop count was set  ;
            ;  at the same time the horizontal loop's count was set.)   ;
            ; ========================================================= ;
            ZERO   .2   B_i
; ============================ VERTICAL LOOP =================================
v_loop:      .trip   8

            ; ========================================================= ;
            ;   Load the Coefficients.                                  ;
            ; ========================================================= ;
            LDW .D1T1   *+A_i_ptr  [1]{l0},     A_X7X6
            LDW .D1T1   * A_i_ptr++[4]{l1},     A_X5X4
            LDW .D2T2   *-B_i_ptr  [1]{l2},     B_X1X0
            LDW .D2T2   * B_i_ptr++[4]{l3},     B_X3X2

            ; ========================================================= ;
            ;   Upper (even) half of signal flow graph                  ;
            ; ========================================================= ;

            ; --------------------------------------------------------- ;
            ;   Build up the products first.  Include rounding on P0.   ;
            ; --------------------------------------------------------- ;
            MPYLH  .M2  B_X3X2,     B_c2c1,     B_X2c2
            MPYLH  .M2X B_X3X2,     A_c6c3,     B_X2c6
            MPYLH  .M1  A_X7X6,     A_c6c3,     A_X6c6
            MPYLH  .M1X A_X7X6,     B_c2c1,     A_X6c2

            ; --------------------------------------------------------- ;
            ;  Note:  Since MVK's seem to get hoisted out of the loop,  ;
            ;  the second version of this butterfly seems to schedule   ;
            ;  better in the assembly optimizer.                        ;
            ; --------------------------------------------------------- ;
    .if 0
            MVK    .1   cst_c4,     A_c4
            MPY    .2x  B_X1X0,     A_c4,       B_P0_t
            MPY    .1   A_X5X4,     A_c4,       A_P1
    .else
            EXT    .2   B_X1X0,     kq_a, kq_b, B_P0_t
            EXT    .1   A_X5X4,     kq_a, kq_b, A_P1
    .endif

            MVK    .2   -32768,     B_rnd
            SUB    .2   B_P0_t,     B_rnd,      B_P0


            ; --------------------------------------------------------- ;
            ;   p0 = P0 + P1                                            ;
            ;   p1 = P0 - P1                                            ;
            ; --------------------------------------------------------- ;
            ADD    .1x  B_P0,       A_P1,       A_p0
            SUB    .1X  B_P0,       A_P1,       A_p1

            ; --------------------------------------------------------- ;
            ;   r1 = X2c6 - X6c2                                        ;
            ;   r0 = X2c2 + X6c6                                        ;
            ; --------------------------------------------------------- ;
            SUB    .2x  B_X2c6,     A_X6c2,     B_r1
            ADD    .2x  B_X2c2,     A_X6c6,     B_r0

            ; --------------------------------------------------------- ;
            ;   g0 = p0 + r0                                            ;
            ;   g1 = p1 + r1                                            ;
            ;   h1 = p1 - r1                                            ;
            ;   h0 = p0 - r0                                            ;
            ; --------------------------------------------------------- ;
            ADD    .2x  A_p0,       B_r0,       B_g0
            ADD    .1x  A_p1,       B_r1,       A_g1
            SUB    .2X  A_p1,       B_r1,       B_h1
            SUB    .1x  A_p0,       B_r0,       A_h0


            ; ========================================================= ;
            ;   Lower (odd) half of signal flow graph                   ;
            ; ========================================================= ;

            ; --------------------------------------------------------- ;
            ;   Build up all of the products first.                     ;
            ; --------------------------------------------------------- ;
            MPYHL  .M2  B_X1X0,     B_c2c1,     B_X1c1
            MPYHL  .M2X B_X1X0,     A_c6c3,     B_X1c3
            MPYHL  .M2  B_X1X0,     B_c7c5,     B_X1c5
            MPYH   .M2  B_X1X0,     B_c7c5,     B_X1c7

            MPYHL  .M2  B_X3X2,     B_c2c1,     B_X3c1
            MPYHL  .M2X B_X3X2,     A_c6c3,     B_X3c3
            MPYHL  .M2  B_X3X2,     B_c7c5,     B_X3c5
            MPYH   .M2  B_X3X2,     B_c7c5,     B_X3c7

            MPYHL  .M1X A_X5X4,     B_c2c1,     A_X5c1
            MPYHL  .M1  A_X5X4,     A_c6c3,     A_X5c3
            MPYHL  .M1  A_X5X4,     A_c7c5,     A_X5c5
            MPYH   .M1  A_X5X4,     A_c7c5,     A_X5c7

            MPYHL  .M1X A_X7X6,     B_c2c1,     A_X7c1
            MPYHL  .M1  A_X7X6,     A_c6c3,     A_X7c3
            MPYHL  .M1  A_X7X6,     A_c7c5,     A_X7c5
            MPYH   .M1  A_X7X6,     A_c7c5,     A_X7c7

            ; --------------------------------------------------------- ;
            ;   g2b = X1c7 - X3c5                                       ;
            ;   g2a = X5c3 - X7c1                                       ;
            ;   g2  =  g2b + g2a  = X1c7 - X3c5 + X5c3 - X7c1           ;
            ; --------------------------------------------------------- ;
            SUB    .2   B_X1c7,     B_X3c5,     B_g2b
            SUB    .1   A_X5c3,     A_X7c1,     A_g2a
            ADD    .1x  B_g2b,      A_g2a,      A_g2

            ; --------------------------------------------------------- ;
            ;   g3b = X1c5 - X3c1                                       ;
            ;   g3a = X5c7 + X7c3                                       ;
            ;   g3  =  g3b + g3a  = X1c5 - X3c1 + X5c7 + X7c3           ;
            ; --------------------------------------------------------- ;
            SUB    .2   B_X1c5,     B_X3c1,     B_g3b
            ADD    .1   A_X5c7,     A_X7c3,     A_g3a
            ADD    .2x  B_g3b,      A_g3a,      B_g3

            ; --------------------------------------------------------- ;
            ;   h3b = X1c3 - X3c7                                       ;
            ;   h3a = X5c1 + X7c5                                       ;
            ;   h3  =  h3b - h3a  = X1c3 - X3c7 - X5c1 - X7c5           ;
            ; --------------------------------------------------------- ;
            SUB    .2   B_X1c3,     B_X3c7,     B_h3b
            ADD    .1   A_X5c1,     A_X7c5,     A_h3a
            SUB    .1X  B_h3b,      A_h3a,      A_h3

            ; --------------------------------------------------------- ;
            ;   h2b = X1c1 + X3c3                                       ;
            ;   h2a = X5c5 + X7c7                                       ;
            ;   h2  =  h2b + h2a  = X1c1 + X3c3 + X5c5 + X7c7           ;
            ; --------------------------------------------------------- ;
            ADD    .2   B_X1c1,     B_X3c3,     B_h2b
            ADD    .1   A_X5c5,     A_X7c7,     A_h2a
            ADD    .2x  B_h2b,      A_h2a,      B_h2


            ; --------------------------------------------------------- ;
            ; Final butterfly (the grand finale)                        ;
            ;                                                           ;
            ;   x0 = g0 + h2   x7 = g0 - h2                             ;
            ;   x1 = g1 + h3   x6 = g1 - h3                             ;
            ;   x2 = h1 + g3   x5 = h1 - g3                             ;
            ;   x3 = h0 + g2   x4 = h0 - g2                             ;
            ; --------------------------------------------------------- ;
            ADD    .2   B_g0,       B_h2,       B_x0
            ADD    .1   A_g1,       A_h3,       A_x1
            ADD    .2   B_h1,       B_g3,       B_x2
            ADD    .1   A_h0,       A_g2,       A_x3
            SUB    .1   A_h0,       A_g2,       A_x4
            SUB    .2   B_h1,       B_g3,       B_x5
            SUB    .1   A_g1,       A_h3,       A_x6
            SUB    .2   B_g0,       B_h2,       B_x7

            ; ========================================================= ;
            ;   Saturate results to 9 bits.                             ;
            ; ========================================================= ;
            SSHL   .2   B_x0,       satl,       B_x0s
            SSHL   .1   A_x1,       satl,       A_x1s
            SSHL   .2   B_x2,       satl,       B_x2s
            SSHL   .1   A_x3,       satl,       A_x3s
            SSHL   .1   A_x4,       satl,       A_x4s
            SSHL   .2   B_x5,       satl,       B_x5s
            SSHL   .1   A_x6,       satl,       A_x6s
            SSHL   .2   B_x7,       satl,       B_x7s

            ; ========================================================= ;
            ;   Truncate to fit back into shorts.                       ;
            ; ========================================================= ;
            SHR    .2   B_x0s,      trunc2,     B_x0t
            SHR    .1   A_x1s,      trunc2,     A_x1t
            SHR    .2   B_x2s,      trunc2,     B_x2t
            SHR    .1   A_x3s,      trunc2,     A_x3t
            SHR    .1   A_x4s,      trunc2,     A_x4t
            SHR    .2   B_x5s,      trunc2,     B_x5t
            SHR    .1   A_x6s,      trunc2,     A_x6t
            SHR    .2   B_x7s,      trunc2,     B_x7t

            ; ========================================================= ;
            ;   Store the results.                                      ;
            ; ========================================================= ;
            STH .D1T2   B_x7t,      *+A_o_ptr  [24]
            STH .D1T1   A_x6t,      *+A_o_ptr  [16]
            STH .D1T2   B_x5t,      *+A_o_ptr  [ 8]
            STH .D1T1   A_x4t,      * A_o_ptr++[ 1]
            STH .D2T2   B_x0t,      *-B_o_ptr  [24]
            STH .D2T1   A_x1t,      *-B_o_ptr  [16]
            STH .D2T2   B_x2t,      *-B_o_ptr  [ 8]
            STH .D2T1   A_x3t,      * B_o_ptr++[ 1]

            ; ========================================================= ;
            ;   Loop control.                                           ;
            ; ========================================================= ;
            ADD    .2   B_i,        1,          B_i
            AND    .2   B_i,        7,          B_i
 [!B_i]     ADDAW  .1   A_o_ptr,    28,         A_o_ptr
 [!B_i]     ADDAW  .2   B_o_ptr,    28,         B_o_ptr

 [A_o]      SUB    .1   A_o,        1,          A_o
 [A_o]      B           v_loop
; ============================================================================


idct_8x8_abort:
            .endproc

* ========================================================================= *
*   End of file:  img_idct_8x8.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mad_16x16.sa/   1066929161  0     0     0       22283     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.12    Fri Sep 27 09:52:45 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mad_16x16 Mean absolute Difference                              *
*                                                                           *
*   REVISION DATE                                                           *
*       27-Sep-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_mad_16x16                                                  *
*       (                                                                   *
*           const unsigned char *refImg,// reference image                  *
*           const unsigned char *srcImg,// 16x16 block image to look for    *
*           int pitch,                  // Width of reference image         *
*           int                 h,      // horiz. size of search area       *
*           int                 v,      // vert.  size of search area       *
*           unsigned            *match  // Result                           *
*       )                               //     match[0] is packed x, y.     *
*                                       //     match[1] is MAD value.       *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine returns the location of the minimum absolute           *
*       difference between a 16x16 search block and some block in a         *
*       (h + 16) x (v + 16) search area. h and v are the sizes of the       *
*       search space for the top left coordinate of the search block.       *
*       refImg points to the top left pixel of the search area.             *
*                                                                           *
*            (0,0)          (h,0)      (h+16,0)                             *
*              ;--------------+--------;                                    *
*              ;    search    |        ;                                    *
*              ;    space     |        ;                                    *
*              ;              |        ;        search area                 *
*              ;--------------+        ;                                    *
*            (0,v)          (h,v)      ;                                    *
*              ;                       ;                                    *
*              ;-----------------------;                                    *
*            (0, v+16)                 (v+16,h+16)                          *
*                                                                           *
*       The location is returned relative to the above coordinate system    *
*       as x and y packed in two 16-bit quantities in a 32-bit word:        *
*                                                                           *
*                   31             16 15             0                      *
*                   +----------------+----------------+                     *
*        match[0]:  |       x        |       y        |                     *
*                   +----------------+----------------+                     *
*                                                                           *
*                   31                               0                      *
*                   +---------------------------------+                     *
*        match[1]:  |   SAD value at location x, y    |                     *
*                   +---------------------------------+                     *
*                                                                           *
*   C Code                                                                  *
*                                                                           *
*       void IMG_mad_16x16                                                  *
*       (                                                                   *
*           const unsigned char *restrict refImg,                           *
*           const unsigned char *restrict srcImg,                           *
*           int pitch,                                                      *
*           unsigned int *restrict match,                                   *
*           int h, int v                                                    *
*       )                                                                   *
*       {                                                                   *
*           int i, j, x, y, matx, maty;                                     *
*           unsigned matpos, matval;                                        *
*                                                                           *
*           matval = ~0U;                                                   *
*           matx   = maty = 0;                                              *
*                                                                           *
*           for (x = 0; x < h; x++)                                         *
*               for (y = 0; y < v; y++)                                     *
*               {                                                           *
*                   unsigned acc = 0;                                       *
*                                                                           *
*                   for (i = 0; i < 16; i++)                                *
*                       for (j = 0; j < 16; j++)                            *
*                           acc += abs(srcImg[i*16 + j]                     *
*                               - refImg[(i+y)*pitch + x + j]);             *
*                                                                           *
*                   if (acc < matval)                                       *
*                   {                                                       *
*                       matval = acc;                                       *
*                       matx   = x;                                         *
*                       maty   = y;                                         *
*                   }                                                       *
*               }                                                           *
*                                                                           *
*           matpos = (0xffff0000 & (matx << 16)) | (0x0000ffff & maty);     *
*           match[0] = matpos;                                              *
*           match[1] = matval;                                              *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Every inner loop iteration computes 4 pixel differences each for    *
*       two vertically adjacent search locations. 4 iterations are          *
*       therefore required to compute one line and 4*16=64 iterations       *
*       to compute the complete SADs of the two search locations.           *
*       Delay slot stuffing and outer loop branch overhead is minimized.    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       v must be a multiple of 2.                                          *
*       srcImg and refImg do not alias in memory                            *
*       No special alignment of src_data or ref_data is expected.           *
*                                                                           *
*   NOTES                                                                   *
*       This code is Little Endian.                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_mad_16x16"
        .global _IMG_mad_16x16
_IMG_mad_16x16: .cproc    A_refImg, B_srcImg, A_pitch, B_h, A_v, B_match
               .no_mdep

        .reg    A_vl,      A_bptch,     A_patch,    A_vptch,     A_srcImg,  A_i
        .reg    B_s0,      B_p0,        A_t0,       A_p1,        A_vl1t
        .reg    B_matchi0, A_matchi1,   B_sgn
        .reg    A_srcIm,   A_ffff,      B_ro
        .reg    B_madval0, A_madval1
        .reg    A_vl1,     B_matval,    B_best,     B_hl,        A_w
        .reg    A_refImg1, B_refImg,    A_subtract
        .reg    A_matpos,  A_best,      B_ml,       B_i2,        B_pitch_16
        .reg    B_img_i0,  A_img_ip0,   B_hlt,      B_srcImg_,   B_srcIm

        ;----------------------------------------------------;
        ;                                                    ;
        ; set up loop counters                               ;
        ;                                                    ;
        ; Vertical loop goes from v...1                      ;
        ; Horizontal loop goes from 0..h                     ;
        ; Collapsed loop goes from hv...1                    ;
        ; Copy master loop counter to avoid recurrence       ;
        ;                                                    ;
        ;----------------------------------------------------;

        MV.1      A_v,            A_vl                       ; vl  = v
        MV.1      A_v,            A_vl1                      ; vl1 = v
        ZERO.2                    B_hl                       ; hl  = 0
        MPY.2x    A_v,            B_h,             B_ml      ; ml  = h * v

        ;------------------------------------------------;
        ;                                                ;
        ; Set up backward address patchup                ;
        ; Each  pair of MADs step forward by 16 rows     ;
        ; when we really want to step forward by 1 rows  ;
        ; per each successive MAD pair.                  ;
        ; This back-patch is for stepping back by 15.)   ;
        ; Set up vertical loop address patchup           ;
        ; After each column of MADs, we need to step back;
        ; 16+v; rows.                                    ;
        ;                                                ;
        ;------------------------------------------------;

        MPY.1   14,        A_pitch,   A_bptch           ; bptch = 6*pitch
        ADD.1   A_v,       14,        A_w               ; Vertical
        MPY.1   A_w,       A_pitch,   A_vptch           ; vptch = w*pitch
        ADD.1  -1,         A_vptch,   A_vptch           ; vptch--

        ; max out match value, zero position

        OR.2    -1,       B_matval,  B_matval           ; matval = 0xFFFFFFFF
        ZERO.1  A_matpos                                ; matpos = 0
        MVK.1   -1,       A_ffff                        ;
        SHRU.1  A_ffff,   16,        A_ffff             ; A-ffff = 0x0000FFFF

        ADD.1   A_refImg, A_pitch,   A_refImg1          ; refImg1=refImg[pitch]
        MV.2x   A_refImg, B_refImg                      ; make copy to B side
        SUB.2x  A_pitch,  16,        B_pitch_16         ; pitch_16 = pitch - 16

m_loop  .trip 2     ; h*v

        ;-----------------------------------------------;
        ;                                               ;
        ; One collapsed horizontal and vertical loop    ;
        ; This collpased loop iterates (H*V) >>1        ;
        ; For inner vertical loop patch = bptch         ;
        ; For last iteration of vertical loop fly back  ;
        ; vptch. Decrement vertical loop count and reset;
        ; on     zero                                   ;
        ;                                               ;
        ;-----------------------------------------------;


        ADD.1   -2,        A_vl,    A_vl                ; if (vl) vl-=2
        MV.1    A_bptch,   A_patch                      ; patch = bptch
[!A_vl] MV.1    A_vptch,   A_patch                      ; if (!vl) patch = vptch
[!A_vl] MV.1    A_v,       A_vl                         ; if (!vl) vl = V

        ;-----------------------------------------------;
        ;                                               ;
        ; 2,16x16 blocks calculated through to packed 16;
        ; bit. Zero out the accumulators for doing MAD  ;
        ; Inner loop iterates 64 times. Use twin pointer;
        ; on source to load even and odd pixels. The    ;
        ; horizontal loop is i2 and is reset to zero.   ;
        ;                                               ;
        ;-----------------------------------------------;

        ZERO.2  B_matchi0                               ; matchi0 = 0
        ZERO.1  A_matchi1                               ; matchi1 = 0
        MVK.1   256,        A_i                         ;      i  = 64
        ZERO.2  B_i2                                    ;      i2 = 0
        MV.1x   B_srcImg,  A_srcImg                     ; srcImg  = src[0]
        ADD.2   B_srcImg,  1,          B_srcImg_        ; srcImg- = src[1]

        ;-----------------------------------------------;
        ;                                               ;
        ; The foll:sequence of operations is done twice ;
        ; a) Load even src pixel                        ;
        ; b) Load ref  pixel [i][j]                     ;
        ; c) Load ref  pixel [i+1][j]                   ;
        ; d) Perform difference ref0 -src               ;
        ; e) Absolute value of diference                ;
        ; f) Accumulate into mad value                  ;
        ; g) Load odd src  pixel                        ;
        ; h) Load ref pixel [i] [j+1]                   ;
        ; i) Load ref pixel [i+1][j+1]                  ;
        ; j) Perform difference ref1 -src               ;
        ; k) Absolute value of difference               ;
        ; l) Accumulate into mad value1                 ;
        ;                                               ;
        ;-----------------------------------------------;

        .mptr A_srcImg , src + 0, 4
        .mptr B_srcImg_, src + 1, 4
        .mptr B_refImg , ref + 0, 4
        .mptr A_refImg1, ref + 0, 4

LOOP_X:

        LDBU.D1T1   *A_srcImg++[2],  A_srcIm                 ; src0 (even)
        LDBU.D2T2   *B_refImg++,     B_img_i0                ; ref00
        LDBU.D1T1   *A_refImg1++,    A_img_ip0               ; ref10

        SUB.2        B_img_i0,        A_srcIm,     B_s0      ; s0 = ref00-src00
        ABS.2        B_s0, B_p0                              ; p0 = abs(s0)
        ADD.2        B_p0, B_matchi0, B_matchi0              ; matchi0 += p0

        SUB.1        A_img_ip0,       A_srcIm,     A_t0      ; t0 = ref10-src00
        ABS.1        A_t0, A_p1                              ;   p1 = abs(t0)
        ADD.1        A_p1, A_matchi1, A_matchi1              ; matchi1 += p1

        LDBU.D2T2   *B_srcImg_++[2], B_srcIm                 ; src1 (odd)
        LDBU.D2T2   *B_refImg++,     B_img_i0                ; ref01
        LDBU.D1T1   *A_refImg1++,    A_img_ip0               ; ref11

        SUB.2        B_img_i0,        B_srcIm,     B_s0      ; s0 = ref01 - src1
        ABS.2        B_s0, B_p0                              ; p0 = abs(s0)
        ADD.2        B_p0, B_matchi0, B_matchi0              ; matchi0  +=p0

        SUB.1x       A_img_ip0,       B_srcIm,     A_t0      ; t0 = ref11 - src1
        ABS.1        A_t0,            A_p1                   ; p1 = abs(t0)
        ADD.1        A_p1, A_matchi1, A_matchi1              ; matchi1 +=p1

        LDBU.D1T1   *A_srcImg++[2],  A_srcIm                 ; src2 ( even)
        LDBU.D2T2   *B_refImg++,     B_img_i0                ; ref02
        LDBU.D1T1   *A_refImg1++,    A_img_ip0               ; ref12

        SUB.2x       B_img_i0,        A_srcIm,     B_s0      ; s0 = ref02 - src
        ABS.2        B_s0, B_p0                              ; p0 = abs(s0)
        ADD.2        B_p0, B_matchi0, B_matchi0              ; matchi0 +=p0

        SUB.1        A_img_ip0,       A_srcIm,     A_t0      ; t0 = ref12 - src
        ABS.1        A_t0,            A_p1                   ; p1 = abs(t0)
        ADD.1        A_p1, A_matchi1, A_matchi1              ; matchi1 += p1

        LDBU.D2T2   *B_srcImg_++[2], B_srcIm                 ; src3(odd)
        LDBU.D2T2   *B_refImg++,     B_img_i0                ; ref03
        LDBU.D1T1   *A_refImg1++,    A_img_ip0               ; ref13

        SUB.2        B_img_i0,        B_srcIm,     B_s0      ; s0 = ref03 - src3
        ABS.2        B_s0,            B_p0                   ; p0 = abs(s0)
        ADD.2        B_p0, B_matchi0, B_matchi0              ; matchi0 += p0

        SUB.1X       A_img_ip0,       B_srcIm,     A_t0      ; t0 = ref13 - src3
        ABS.1        A_t0,            A_p1                   ; p1 = abs(t0)
        ADD.1        A_p1,            A_matchi1,   A_matchi1 ; matchi1 += p1

        ADD.2        B_i2,            4,           B_i2      ; i2 += 4
        AND.2        15,              B_i2,        B_ro      ; if (i2>7) ro = 1
 [!B_ro]ADD.2        B_refImg,        B_pitch_16, B_refImg   ; if (!ro)rmg+=pitch16
 [!B_ro]ADD.1X       A_refImg1,       B_pitch_16, A_refImg1  ;

 [A_i]  SUB.1        A_i,             4,          A_i        ; if (i) i-=4
 [A_i]  B            LOOP_X                                  ; if (i) B LOOP

    ; perform vertical patch adjustment

        SUB.2x     B_refImg,       A_patch,     B_refImg
        SUB.1      A_refImg1,      A_patch,     A_refImg1

    ; Now compare madval against our best match

        ADD.1      -1,             A_vl1,        A_vl1
        SHL.2      B_hl,           16,           B_hlt
        CMPLTU.2   B_matchi0,      B_matval,     B_best
 [B_best]MV.2      B_matchi0,      B_matval
 [B_best]AND.1     A_ffff,         A_vl1,        A_vl1t
 [B_best]OR.1x     A_vl1t,         B_hlt,        A_matpos

        ADD.1      -1,             A_vl1,        A_vl1
        CMPLTU.1x  A_matchi1,      B_matval,     A_best
 [A_best]MV.1x     A_matchi1,      B_matval
 [A_best]AND.1     A_ffff,         A_vl1,        A_vl1t
 [A_best]OR.1x     A_vl1t,         B_hlt,        A_matpos

 [!A_vl1]ADD.2     1,          B_hl,         B_hl
 [!A_vl1]MV.1      A_v,         A_vl1

 [B_ml]  ADD.2     -2,          B_ml,         B_ml
 [B_ml]  B.2       m_loop

    ; only 1 fine grained search is required here

        MV         A_v,             A_subtract
        SUB        A_subtract,     1,           A_subtract
        AND        A_matpos,       A_ffff,      A_vl
        SUB        A_subtract,     A_vl,        A_vl
        SHL        A_ffff,         16,          A_ffff
        AND        A_matpos,       A_ffff,      A_matpos
        ADD        A_matpos,       A_vl,        A_matpos

        STW.D2     A_matpos,      *B_match++
        STW.D2     B_matval,      *B_match++

    .return
    .endproc
* ========================================================================= *
*   End of file:  img_mad_16x16.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mad_8x8.sa/     1066929161  0     0     0       26445     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.11    Tue Mar 12 04:59:31 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mad_8x8  - 8x8 Minimum Absolute Differences                     *
*                                                                           *
*   REVISION DATE                                                           *
*       28-Apr-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_mad_8x8                                                    *
*       (                                                                   *
*           const unsigned char *restrict refImg,                           *
*           const unsigned char *restrict srcImg,                           *
*           int pitch,                                                      *
*           int                 h,                                          *
*           int                 v,                                          *
*           unsigned            *restrict match                             *
*       )                                                                   *
*                                                                           *
*       refImg          Reference image.                                    *
*       srcImg[64]      8x8 block image to look for.                        *
*       pitch           Width of reference image.                           *
*       h               Horiz. size of search area.                         *
*       v               Vert.  size of search area.                         *
*                       Must be multiple of 2.                              *
*       match[2]        Result:                                             *
*                           match[0] is packed x, y.                        *
*                           match[1] is MAD value.                          *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine returns the location of the minimum absolute           *
*       difference between a 8x8 search block and some block in a           *
*       (h + 8) x (v + 8) search area. h and v are the sizes of the         *
*       search space for the top left coordinate of the search block.       *
*       refImg points to the top left pixel of the search area.             *
*                                                                           *
*            (0,0)          (h,0)      (h+8,0)                              *
*              ;--------------+--------;                                    *
*              ;    search    |        ;                                    *
*              ;    space     |        ;                                    *
*              ;              |        ;        search area                 *
*              ;--------------+        ;        within reference image      *
*            (0,v)          (h,v)      ;                                    *
*              ;                       ;                                    *
*              ;-----------------------;                                    *
*            (0, v+8)                 (v+8,h+8)                             *
*                                                                           *
*       The location is returned relative to the above coordinate system    *
*       as x and y packed in two 16-bit quantities in a 32-bit word:        *
*                                                                           *
*                   31             16 15             0                      *
*                   +----------------+----------------+                     *
*        match[0]:  |       x        |       y        |                     *
*                   +----------------+----------------+                     *
*                                                                           *
*                   31                               0                      *
*                   +---------------------------------+                     *
*        match[1]:  |   SAD value at location x, y    |                     *
*                   +---------------------------------+                     *
*                                                                           *
*   C Code                                                                  *
*                                                                           *
*       void IMG_mad_8x8                                                    *
*       (                                                                   *
*           const unsigned char *restrict refImg,                           *
*           const unsigned char *restrict srcImg,                           *
*           unsigned int pitch,                                             *
*           unsigned int h,                                                 *
*           unsigned int v,                                                 *
*           unsigned int *restrict match                                    *
*       )                                                                   *
*       {                                                                   *
*           int    i,         j,        x,     y;                           *
*           int              matx,      maty;                               *
*           unsigned int     matpos,    matval;                             *
*                                                                           *
*           matval  =   ~0U;               // init. set to MAXPOS           *
*           matx = maty = 0;                                                *
*                                                                           *
*           for (x = 0; x < h ; x++)                                        *
*           {                                                               *
*               for (y = 0; y < v ; y++)                                    *
*               {                                                           *
*                   unsigned acc = 0;                                       *
*                                                                           *
*                   for (i = 0; i < 8; i++)                                 *
*                   {                                                       *
*                       for (j = 0; j < 8; j++)                             *
*                       {                                                   *
*                            acc += abs(srcImg[i*8 + j]                     *
*                                - refImg[(i+y)*pitch + x + j]);            *
*                       }                                                   *
*                   }                                                       *
*                                                                           *
*                   if (acc < matval)                                       *
*                   {                                                       *
*                       matval = acc;                                       *
*                       matx   = x;                                         *
*                       maty   = y;                                         *
*                   }                                                       *
*               }                                                           *
*           }                                                               *
*                                                                           *
*                                                                           *
*           matpos   = (0xffff0000 & (matx << 16)) | (0x0000ffff & maty);   *
*           match[0] = matpos;                                              *
*           match[1] = matval;                                              *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Every inner loop iteration computes 4 pixel differences each for    *
*       two vertically adjacent search locations. 4 iterations are          *
*       therefore required to compute one line and 4*16=64 iterations       *
*       to compute the complete SADs of the two search locations.           *
*       Delay slot stuffing and outer loop branch overhead is minimized.    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       v must be a multiple of 2.                                          *
*       srcImg and refImg do not alias in memory                            *
*       No special alignment of srcImg or refImg is expected.               *
*                                                                           *
*   NOTES                                                                   *
*       This code is Little Endian.                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_mad_8x8"
        .global _IMG_mad_8x8
_IMG_mad_8x8: .cproc    A_refImg, B_srcImg, A_pitch,  B_h, A_v, B_match
             .no_mdep

        .reg    A_vl,        A_bptch,     A_patch,     A_vptch
        .reg    A_srcImg,    A_i,         A_vl1t,      A_ffff
        .reg    B_matchi0,   A_matchi1,   B_sgn,       B_ro
        .reg    B_madval0,   A_madval1,   A_refImg1,   B_refImg
        .reg    A_vl1,       B_matval,    B_bst,       B_hl
        .reg    A_matpos,    A_best,      B_ml,        B_i2
        .reg    B_hlt,       B_srcImg_,   A_w,         B_pitch_16
        .reg    A_bst

        .reg    A_srcIm0,    B_img_i0,    A_img_ip0,   A_subtract
        .reg    B_srcIm1,    B_img_i1,    A_img_ip1
        .reg    A_srcIm2,    B_img_i2,    A_img_ip2
        .reg    B_srcIm3,    B_img_i3,    A_img_ip3

        .reg    B_s0,        B_p0,       A_t0,         A_p0
        .reg    B_s1,        B_p1,       A_t1,         A_p1
        .reg    B_s2,        B_p2,       A_t2,         A_p2
        .reg    B_s3,        B_p3,       A_t3,         A_p3


        ;----------------------------------------------------;
        ;                                                    ;
        ; set up loop counters                               ;
        ;                                                    ;
        ; Vertical loop goes from v...1                      ;
        ; Horizontal loop goes from 0..h                     ;
        ; Collapsed loop goes from hv...1                    ;
        ; Copy master loop counter to avoid recurrence       ;
        ;                                                    ;
        ;----------------------------------------------------;

        MV.1    A_v,       A_vl                ; vert loop goes from v .. 1
        ZERO.2  B_hl                           ; horiz loop goes from 0 .. h
        MPY.2x  B_h,       A_v,      B_ml      ; master loop goes from h*v .. 1
        MV.1    A_v,       A_vl1               ; copy of master loop ctr


        ;------------------------------------------------;
        ;                                                ;
        ; Set up backward address patchup                ;
        ; Each  pair of MADs step forward by 8 rows      ;
        ; when we really want to step forward by 1 rows  ;
        ; per each successive MAD pair.                  ;
        ; This back-patch is for stepping back by 15.)   ;
        ; Set up vertical loop address patchup           ;
        ; After each column of MADs, we need to step back;
        ; 16+v; rows.                                    ;
        ;                                                ;
        ;------------------------------------------------;

        MPY.1   6,        A_pitch,   A_bptch            ; bptch = 6*pitch
        ADD.1   A_v,      6,         A_w                ; w     = v + 6
        MPY.1   A_w,      A_pitch,   A_vptch            ; vptch = w*pitch
        ADD     -1,       A_vptch,   A_vptch            ; vptch--

        ; max out match value, zero position

        OR.2    -1,       B_matval,  B_matval           ; matval = 0xFFFFFFFF
        ZERO.1   A_matpos                                ; matpos = 0
        MVK.1   -1,       A_ffff                        ;
        SHRU.1  A_ffff,   16,        A_ffff             ; A-ffff = 0x0000FFFF

        ADD.1   A_refImg, A_pitch,   A_refImg1          ; refImg1=refImg[pitch]
        MV.2x   A_refImg, B_refImg                      ; make copy to B side
        SUB.2x  A_pitch,  8,         B_pitch_16         ; pitch_16 = pitch - 8

m_loop

        ;-----------------------------------------------;
        ;                                               ;
        ; One collapsed horizontal and vertical loop    ;
        ; This collpased loop iterates (H*V) >>1        ;
        ; For inner vertical loop patch = bptch         ;
        ; For last iteration of vertical loop fly back  ;
        ; vptch. Decrement vertical loop count and reset;
        ; on     zero                                   ;
        ;                                               ;
        ;-----------------------------------------------;


        ADD.1   -2,        A_vl,        A_vl            ; if (vl) vl-=2
        MV.1    A_bptch,   A_patch                      ; patch = bptch
[!A_vl] MV.1    A_vptch,   A_patch                      ; if (!vl) patch = vptch
[!A_vl] MV.1    A_v,       A_vl                         ; if (!vl) vl = V

        ;-----------------------------------------------;
        ;                                               ;
        ; 2,16x16 blocks calculated through to packed 16;
        ; bit. Zero out the accumulators for doing MAD  ;
        ; Inner loop iterates 64 times. Use twin pointer;
        ; on source to load even and odd pixels. The    ;
        ; horizontal loop is i2 and is reset to zero.   ;
        ;                                               ;
        ;-----------------------------------------------;

        ZERO.2  B_matchi0                               ; matchi0 = 0
        ZERO.1  A_matchi1                               ; matchi1 = 0
        MVK.1   64,        A_i                          ;      i  = 64
        ZERO.2  B_i2                                    ;      i2 = 0
        MV.1x   B_srcImg,  A_srcImg                     ; srcImg  = src[0]
        ADD.2   B_srcImg,  1,          B_srcImg_        ; srcImg- = src[1]

        ;-----------------------------------------------;
        ;                                               ;
        ; The foll:sequence of operations is done twice ;
        ; a) Load even src pixel                        ;
        ; b) Load ref  pixel [i][j]                     ;
        ; c) Load ref  pixel [i+1][j]                   ;
        ; d) Perform difference ref0 -src               ;
        ; e) Absolute value of diference                ;
        ; f) Accumulate into mad value                  ;
        ; g) Load odd src  pixel                        ;
        ; h) Load ref pixel [i] [j+1]                   ;
        ; i) Load ref pixel [i+1][j+1]                  ;
        ; j) Perform difference ref1 -src               ;
        ; k) Absolute value of difference               ;
        ; l) Accumulate into mad value1                 ;
        ;                                               ;
        ;-----------------------------------------------;

        ;-----------------------------------------------;
        ;                                               ;
        ; Assume that srcImg and refImg can have bank   ;
        ; conflicts.                                    ;
        ;                                               ;
        ;-----------------------------------------------;

        .mptr A_srcImg, src + 0, 2
        .mptr B_srcImg_,src + 0, 2
        .mptr B_refImg, src + 0, 1
        .mptr A_refImg1,src + 0, 1

LOOP_X: .trip   16

        LDBU.D1T1 *A_srcImg++[2],   A_srcIm0               ; src0 (even)
        LDBU.D2T2 *B_refImg++,      B_img_i0               ; ref00
        LDBU.D1T1 *A_refImg1++,     A_img_ip0              ; ref10

        SUB.2x     B_img_i0,        A_srcIm0,    B_s0      ; s0 = ref00 - src00
        ABS.2      B_s0,            B_p0                   ; p0 = abs(s0)
        ADD.2      B_p0,            B_matchi0,   B_matchi0 ; matchi0 += p0

        SUB.1      A_img_ip0,       A_srcIm0,    A_t0      ; t0 = ref10 - src00
        ABS.1      A_t0,            A_p0                   ;   p1 = abs(t0)
        ADD.1      A_p0,            A_matchi1,   A_matchi1 ; matchi1 += p1

        LDBU.D2T2  *B_srcImg_++[2], B_srcIm1               ; src1 (odd)
        LDBU.D2T2  *B_refImg++,     B_img_i1               ; ref01
        LDBU.D1T1  *A_refImg1++,    A_img_ip1              ; ref11

        SUB.2      B_img_i1,        B_srcIm1,    B_s1      ; s0 = ref01 - src1
        ABS.2      B_s1,            B_p1                   ; p0 = abs(s0)
        ADD.2      B_p1,            B_matchi0,   B_matchi0 ; matchi0  +=p0

        SUB.1      A_img_ip1,       B_srcIm1,    A_t1      ; t0 = ref11 - src1
        ABS.1      A_t1,            A_p1                   ; p1 = abs(t0)
        ADD.1      A_p1,            A_matchi1,   A_matchi1 ; matchi1 +=p1

        LDBU.D1T1  *A_srcImg++[2],  A_srcIm2               ; src2 ( even)
        LDBU.D2T2  *B_refImg++,     B_img_i2               ; ref02
        LDBU.D1T1  *A_refImg1++,    A_img_ip2              ; ref12

        SUB.2x     B_img_i2,        A_srcIm2,    B_s2      ; s0 = ref02 - src
        ABS.2      B_s2,            B_p2                   ; p0 = abs(s0)
        ADD.2      B_p2,            B_matchi0,   B_matchi0 ; matchi0 +=p0

        SUB.1      A_img_ip2,       A_srcIm2,    A_t2      ; t0 = ref12 - src
        ABS.1      A_t2,            A_p2                   ; p1 = abs(t0)
        ADD.1      A_p2,            A_matchi1,   A_matchi1 ; matchi1 += p1

        LDBU.D2T2 *B_srcImg_++[2],  B_srcIm3               ; src3(odd)
        LDBU.D2T2 *B_refImg++,      B_img_i3               ; ref03
        LDBU.D1T1 *A_refImg1++,     A_img_ip3              ; ref13

        SUB.2     B_img_i3,         B_srcIm3,    B_s3      ; s0 = ref03 - src3
        ABS.2     B_s3,             B_p3                   ; p0 = abs(s0)
        ADD.2     B_p3,             B_matchi0,   B_matchi0 ; matchi0 += p0

        SUB.1x    A_img_ip3,        B_srcIm3,    A_t3      ; t0 = ref13 - src3
        ABS.1     A_t3,             A_p3                   ; p1 = abs(t0)
        ADD.1     A_p3,             A_matchi1,   A_matchi1 ; matchi1 += p1

        ADD.2     B_i2,             4,           B_i2      ; i2 += 4
        AND.2     7,                B_i2,        B_ro      ; if ( i2 > 7) ro = 1
[!B_ro] ADD.2     B_refImg,         B_pitch_16,  B_refImg  ; if (!ro)rmg+=pitch16
[!B_ro] ADD.1x    A_refImg1,        B_pitch_16,  A_refImg1 ;

[A_i]   SUB.1     A_i,              4,           A_i       ; if (i) i-=4
[A_i]   B.1       LOOP_X                                   ; if (i) B LOOP


        ;-------------------------------------------------;
        ;                                                 ;
        ; perform vertical patch adjustment               ;
        ; Now compare madval against our best match       ;
        ;                                                 ;
        ; If matchi0 is saller than madval store off      ;
        ; coordinates into matpos and register the        ;
        ; associated match value in matval.               ;
        ;                                                 ;
        ; If the second MAD computation matchi1           ;
        ; results ina better match use it to store off    ;
        ; coordinates and associated match value into     ;
        ; matval.                                         ;
        ;                                                 ;
        ;-------------------------------------------------;

        SUB.2x    B_refImg,       A_patch,     B_refImg   ;
        SUB.1     A_refImg1,      A_patch,     A_refImg1  ;

        ADD.1     -1,             A_vl1,        A_vl1     ;
        SHL.2     B_hl,           16,           B_hlt     ;

        CMPLTU.2  B_matchi0,      B_matval,     B_bst     ;
[B_bst] MV.2      B_matchi0,      B_matval                ;
[B_bst] AND.1     A_ffff,         A_vl1,        A_vl1t    ;
[B_bst] OR.1x     A_vl1t,         B_hlt,        A_matpos  ;

        ADD.1     -1,             A_vl1,        A_vl1     ;

        CMPLTU.1x A_matchi1,      B_matval,     A_bst     ;
[A_bst] MV.2x     A_matchi1,      B_matval                ;
[A_bst] AND.1     A_ffff,         A_vl1,        A_vl1t    ;
[A_bst] OR.1x     A_vl1t,         B_hlt,        A_matpos  ;


        ;-------------------------------------------------;
        ;                                                 ;
        ; Use copy of vertical loop counter to re-adjust  ;
        ; hl:horizontal and vl1: vertical loop counter    ;
        ; Also deduct off 2 iterations for the large      ;
        ; macro loop that does horizontal and vertical    ;
        ; passes together.                                ;
        ;                                                 ;
        ;-------------------------------------------------;

[!A_vl1]ADD.1    1,              B_hl,         B_hl       ;
[!A_vl1]MV.1     A_v,            A_vl1                    ;

[B_ml]  ADD.2    -2,             B_ml,         B_ml       ;
[B_ml]  B.1      m_loop                                   ;

        ;-------------------------------------------------;
        ;                                                 ;
        ; Store off the resulting position and madval     ;
        ; found at the end of all the loops into          ;
        ; motionvector array                              ;
        ;                                                 ;
        ; Motionvector[0]: hl:vl                          ;
        ; Motionvector[1]: madval                         ;
        ;                                                 ;
        ;-------------------------------------------------;

        MV.1    A_v,            A_subtract
        SUB.1   A_subtract,     1,           A_subtract
        AND.1   A_matpos,       A_ffff,      A_vl
        SUB.1   A_subtract,     A_vl,        A_vl
        SHL.1   A_ffff,         16,          A_ffff
        AND.1   A_matpos,       A_ffff,      A_matpos
        ADD.1   A_matpos,       A_vl,        A_matpos

        STW.D2T1 A_matpos,      *B_match++
        STW.D2T2 B_matval,      *B_match++

        .return
        .endproc

* ========================================================================= *
*   End of file:  img_mad_8x8.sa                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

median_3x3.sa/  1066929161  0     0     0       18645     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Thu Jan 31 21:29:54 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*  TEXAS INSTRUMENTS, INC.                                                  *
*                                                                           *
*  NAME                                                                     *
*      IMG_median_3x3                                                       *
*                                                                           *
*                                                                           *
*  REVISION DATE                                                            *
*      10-Jul-1999                                                          *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_median_3x3                                                 *
*       (                                                                   *
*           unsigned char   *in_data,                                       *
*           int             cols,                                           *
*           unsigned char   *out_data                                       *
*       );                                                                  *
*                                                                           *
*       in_data  : Pointer to input array of unsigned chars                 *
*       cols     : Width of in_data                                         *
*       out_data : Pointer to output array of unsigned chars                *
*                                                                           *
*   DESCRIPTION                                                             *
*       The routine performs a 3x3 median filtering algorithm. It comes     *
*       under the class of non-linear signal processing algorithms.         *
*       Rather than replace the gray level at a pixel by a weighted         *
*       average of the nine pixels including and surrounding it, the gray   *
*       level at each pixel is replaced by the median of the nine values.   *
*       The median of a set of nine numbers is the middle element so that   *
*       half of the elements in the list are larger and half are smoother.  *
*       Median filtering removes the effect of extreme values from data.    *
*       Using a wide mask to reduce the effect of noise results in          *
*       unacceptable blurring of sharp edges in the original image.         *
*                                                                           *
*       void IMG_median_3x3()                                               *
*       {                                                                   *
*           read new vertical column of data into moving 3 column window    *
*                                                                           *
*           l00 = *IN1++;                                                   *
*           l10 = *IN2++;                                                   *
*           l20 = *IN3++;                                                   *
*                                                                           *
*           The data is pre-arranged as follows                             *
*               l00, l01, l02           MAX                                 *
*               l10, l11, l12           MED                                 *
*               l20, l21, l22           MIN                                 *
*                                                                           *
*           First sort l00,l10,l20 into MAX, MED, MIN                       *
*                                                                           *
*           Compare l00,l10 and sort into MAX, MIN                          *
*           Compare l10,l20 and sort into MAX, MIN                          *
*           Compare l00,l10 and sort into MAX, MIN                          *
*                                                                           *
*           3 compares and 6 moves                                          *
*           Now sort l00,l01,l02 to find out minimum of max                 *
*               sort l10,l11,l12 to find ot median of median                *
*               sort l20,l21,l22 to find out maximum of min                 *
*                                                                           *
*           Now sort these three values, the middle value                   *
*           of these three is the minimum.                                  *
*       }                                                                   *
*                                                                           *
*   C CODE                                                                  *
*       void IMG_median_3x3(unsigned char *in_data, int cols,               *
*                       unsigned char *out_data)                            *
*       {                                                                   *
*       unsigned char   * line0, * line1, *line2;                           *
*       int    l00_0, l01_0, l02_0, l10_0, l11_0, l12_0, l20_0, l21_0,      *
*              l22_0;                                                       *
*       int    l00_1, l10_1, l10_2, l10_3, l20_1, l20_2;                    *
*       int    t0_1, t1_1, t1_2;                                            *
*       int    i, minmax_0, maxmin_0, medmed_0;                             *
*       int    minmax_1, medmed_1, medmed_2, medmed_3;                      *
*                                                                           *
*       line0 = in_data;                                                    *
*       line1 = line0 + cols;                                               *
*       line2 = line1 + cols;                                               *
*                                                                           *
*       //    l00   l01  l02        max's           //                      *
*       //    l10   l11  l12        med's           //                      *
*       //    l20   l21  l22        min's           //                      *
*                                                                           *
*       l01_0 = l11_0 = l21_0 = 127;                                        *
*       l02_0 = l12_0 = l22_0 = 127;                                        *
*                                                                           *
*       minmax_0 = l02_0;                                                   *
*       maxmin_0 = l22_0;                                                   *
*                                                                           *
*       for (i = 0; i < cols; i++)                                          *
*       {                                                                   *
*            l00_0 = *line0++;                                              *
*            l10_0 = *line1++;                                              *
*            l20_0 = *line2++;                                              *
*                                                                           *
*            // sort l00_0, l10_0, l20_0                                    *
*                                                                           *
*            l20_1 = l20_0; l10_1 = l10_0;                                  *
*            if (l20_0 > l10_0) { l10_1 = l20_0;  l20_1 = l10_0; }          *
*                                                                           *
*            l00_1 = l00_0; l10_2 = l10_1;                                  *
*            if (l10_1 > l00_0) { l00_1 = l10_1;  l10_2 = l00_0; }          *
*                                                                           *
*            l20_2 = l20_1;  l10_3 = l10_2;                                 *
*            if (l20_1 > l10_2) { l10_3 = l20_1;  l20_2 = l10_2; }          *
*                                                                           *
*            if (l01_0 < minmax_0) minmax_0 = l01_0;                        *
*            if (l00_1 < minmax_0) minmax_0 = l00_1;                        *
*                                                                           *
*            if (l21_0 > maxmin_0) maxmin_0 = l21_0;                        *
*            if (l20_2 > maxmin_0) maxmin_0 = l20_2;                        *
*                                                                           *
*            // sort l10 l11 l12                                            *
*                                                                           *
*            t0_1 = l10_3;                                                  *
*            t1_1 = l11_0;                                                  *
*            if (l10_3 > l11_0)                                             *
*            {                                                              *
*              t0_1 = l11_0;                                                *
*              t1_1 = l10_3;                                                *
*            }                                                              *
*            t1_2 = t1_1;                                                   *
*            if (t1_1 > l12_0)                                              *
*            {                                                              *
*              t1_2 = l12_0;                                                *
*            }                                                              *
*                                                                           *
*            medmed_0  = t1_2;                                              *
*            if (t0_1 > t1_2) { medmed_0 = t0_1; } // swap                  *
*                                                                           *
*            // minmax, medmed, maxmin                                      *
*                                                                           *
*            medmed_1 = medmed_0; minmax_1 = minmax_0;                      *
*            if (minmax_0 > medmed_0)                                       *
*               { medmed_1 = minmax_0; minmax_1 = medmed_0; }               *
*                                                                           *
*            medmed_2 = medmed_1;                                           *
*            if (medmed_1 > maxmin_0)                                       *
*               { medmed_2 = maxmin_0; }                                    *
*                                                                           *
*            medmed_3 = medmed_2;                                           *
*            if (minmax_1 > medmed_2)                                       *
*               { medmed_3 = minmax_1; }                                    *
*                                                                           *
*            // Move data along by one column              //               *
*                                                                           *
*            minmax_0 = l01_0;                                              *
*            l12_0 = l11_0;                                                 *
*            maxmin_0 = l21_0;                                              *
*            l01_0 = l00_1;                                                 *
*            l11_0 = l10_3;                                                 *
*            l21_0 = l20_2;                                                 *
*                                                                           *
*            *out_data++ = medmed_3;                                        *
*        }                                                                  *
*   }                                                                       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       No allignment restrictions.                                         *
*       The code is ENDIAN NEUTRAL.                                         *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_median_3x3"
        .global _IMG_median_3x3
_IMG_median_3x3: .cproc  in_data, n, out_data
            .no_mdep
            .reg    line0, line1, line2
            .reg    l00_0, l01_0, l02_0, l10_0, l11_0, l12_0, l20_0
            .reg    l00_1, l10_1, l10_2, l10_3, l20_1, l20_2, l21_0
            .reg    t0_0, t1_0, t2_0, t0_1, t1_1, t1_2
            .reg    minmax_0, maxmin_0, medmed_0
            .reg    minmax_1, medmed_1, medmed_2, medmed_3
            .reg    i, p0, p1, p2, q0, q1, q2
            .reg    q3, r0, r1, r2, s0, s1, s2

         MV    .1   in_data, line0
         ADD   .2   line0, n, line1
         ADD   .2   line1, n, line2

*    l00   l01  l02        max's     *
*    l10   l11  l12        med's     *
*    l20   l21  l22        min's     *

         MVK   .1   127, l01_0
         MVK   .2   127, l11_0
         MVK   .1   127, l21_0
         MVK   .1   127, minmax_0
         MVK   .2   127, l12_0
         MVK   .1   127, maxmin_0

         MV    .1X  n, i
LOOP:
         LDBU  .D1T1  *line0++, l00_0
         LDBU  .D2T2  *line1++, l10_0
         LDBU  .D2T2  *line2++, l20_0

         ; sort l00_0, l10_0, l20_0

         MV    .2   l20_0, l20_1
         MV    .2   l10_0, l10_1
         CMPGTU.2   l20_0, l10_0, p0
     [p0]MV    .2   l20_0, l10_1
     [p0]MV    .2   l10_0, l20_1 ; swap

         MV    .1   l00_0, l00_1
         MV    .2   l10_1, l10_2
         CMPGTU.2X  l10_1, l00_0, p1
     [p1]MV    .1X  l10_1, l00_1
     [p1]MV    .2X  l00_0, l10_2  ; swap

         MV    .2   l20_1, l20_2
         MV    .2   l10_2, l10_3
         CMPGTU.2   l20_1, l10_2, p2
     [p2]MV    .2   l20_1, l10_3
     [p2]MV    .2   l10_2, l20_2  ; swap

         CMPLTU.1   l01_0, minmax_0, q0
     [q0]MV    .1   l01_0, minmax_0
         CMPLTU.1   l00_1, minmax_0, q1
     [q1]MV    .1   l00_1, minmax_0

         CMPGTU.1   l21_0, maxmin_0, q2
     [q2]MV    .1   l21_0, maxmin_0
         CMPGTU.2X  l20_2, maxmin_0, q3
     [q3]MV    .1X  l20_2, maxmin_0

         ; sort l10 l11 l12
         MV    .2   l10_3, t0_1
         MV    .2   l11_0, t1_1
         CMPGTU.2   l10_3, l11_0, r0
     [r0]MV    .2   l11_0, t0_1
     [r0]MV    .2   l10_3, t1_1  ; swap

         MV    .1X  t1_1, t1_2
         CMPGTU.2   t1_1, l12_0, r1
     [r1]MV    .1X  l12_0, t1_2

         MV    .1   t1_2, medmed_0
         CMPGTU.2X  t0_1, t1_2, r2
     [r2]MV    .1X  t0_1, medmed_0 ; swap

         ; minmax, medmed, maxmin

         MV    .1   medmed_0, medmed_1
         MPY   .1   1, minmax_0, minmax_1
         CMPGTU.1   minmax_0, medmed_0, s0
     [s0]MV    .1   minmax_0, medmed_1
     [s0]MPY   .1   1,  medmed_0, minmax_1

         MV    .1   medmed_1, medmed_2
         CMPGTU.1   medmed_1, maxmin_0, s1
     [s1]MV    .1   maxmin_0, medmed_2

         MPY   .1   1, medmed_2, medmed_3
         CMPGTU.1   minmax_1, medmed_2, s2
     [s2]MPY   .1   1, minmax_1, medmed_3

         MPY   .1    1, l01_0, minmax_0
         MPY   .2    1, l11_0, l12_0
         MPY   .1    1, l21_0, maxmin_0
         MPY   .1    1, l00_1, l01_0
         MPY   .2    1, l10_3, l11_0
         MPY   .1X   1, l20_2, l21_0

         STB   .D1T1 medmed_3, *out_data++

     [i] SUB   .1    i, 1, i
     [i] B   LOOP
            .endproc
*==============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*==============================================================================*

mpeg2_vld0.sa/  1066929161  0     0     0       31136     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.9     Sun Mar 17 04:51:48 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mpeg2_vld_inter                                                 *
*                                                                           *
*   PLATFORM                                                                *
*       C6200                                                               *
*                                                                           *
*   REVISION DATE                                                           *
*       11-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*         void IMG_mpeg2_vld_inter                                          *
*         (                                                                 *
*             const short   *restrict Wptr,                                 *
*             short         *restrict outi,                                 *
*             IMG_mpeg2_vld *restrict Mpeg2v                                *
*         );                                                                *
*                                                                           *
*         Wptr:       Pointer to the quantization matrix.  Must be in       *
*                     the scan order corresponding to the inverse scan      *
*                     matrix.                                               *
*                                                                           *
*         outi[6*64]: Pointer to the output array where the decoded and     *
*                     dequantized IDCT coefficients are placed.             *
*                     Elements assumed to be set to zero prior to           *
*                     function call.  The routine assumes 6 8x8 blocks      *
*                     per MB, i.e. 4:2:0 format.                            *
*                                                                           *
*         Mpeg2v:     Pointer to the context object, which includes the     *
*                     input buffer variables.  The structure Mpeg2v is      *
*                     defined as follows:                                   *
*                                                                           *
*C          #ifndef IMG_MPEG2_VLD_STRUCT_                                   *
*C          #define IMG_MPEG2_VLD_STRUCT_ 1                                 *
*C                                                                          *
*C          typedef struct {                                                *
*C            unsigned int  *bsbuf;      // pointer to bitstream buffer     *
*C            unsigned int  next_wptr;   // next word to read from buffer   *
*C            unsigned int  bptr;        // bit position within word        *
*C            unsigned int  word1;       // word aligned buffer             *
*C            unsigned int  word2;       // word aligned buffer             *
*C            unsigned int  top0;        // top 32 bits of bitstream        *
*C            unsigned int  top1;        // next 32 bits of bitstream       *
*C            const unsigned char *scan; // inverse zigzag scan matrix      *
*C            unsigned int  intravlc;    // intra_vlc_format                *
*C            unsigned int  quant_scale; // quant_scale                     *
*C            unsigned int  dc_prec;     // intra_dc_precision              *
*C            unsigned int  cbp;         // coded_block_pattern             *
*C            unsigned int  fault;       // fault condition (returned)      *
*C            unsigned int  reserved;                                       *
*C          } IMG_mpeg2_vld;                                                *
*C                                                                          *
*C          #endif                                                          *
*                                                                           *
*         All variables in this structure must have the layout as shown     *
*         since they are being accessed by this routine through             *
*         appropriate offsets.  Other variables may be appended to the      *
*         structure.                                                        *
*                                                                           *
*         The routine sets the fault flag Mpeg2v.fault to 1 if an invalid   *
*         VLC code was encountered or the total run for a block exceeded    *
*         63.  In theses cases the decoder has to resynchronize.            *
*                                                                           *
*       The routine requires proprietary variable length decoding           *
*       look-up tables.  The tables are based on Table B-14 and B-15 in     *
*       the MPEG-2 standard text.                                           *
*                                                                           *
*       The required lookup tables for this routine are provided in         *
*       IMGLIB and are linked in automatically when linking against         *
*       IMGLIB.                                                             *
*                                                                           *
*       Before calling the routine the bitstream varaibles in Mpeg2v have   *
*       to be initialized.  If bsbuf[] is a circular buffer of size         *
*       BSBUF_SIZE words and bsptr contains the number of bits in the       *
*       buffer that already have been consumed, then next_wptr, bptr,       *
*       word1, word2, top0 and top1 are initialized as follows:             *
*                                                                           *
*       1. nextwptr:  bsptr may not be a multiple of 32 (e.g. it points     *
*          to bit number 40 in the bitstream), therefore set it to the      *
*          next lower multiple of 32 by shift left by 5 (divide by 32).     *
*          In case of 40 this yields 1.  Since memory is addressed in       *
*          units of bytes this needs to be multiplied by 4 to get the       *
*          address pointer.  Use next_wptr as index into bsbuf[].           *
*                                                                           *
*              next_wptr = (bsptr >> 5);                                    *
*                                                                           *
*       2. bptr:  bptr is the bit pointer which points to the current       *
*          bit WITHIN the word pointed to by next_wptr.                     *
*                                                                           *
*             bptr = bsptr & 31;                                            *
*             bptr_cmpl = 32 - bptr;                                        *
*                                                                           *
*       3. word1 and word2:  read next 3 words from the bitstream buffer    *
*          (word0 is a temporary variable).                                 *
*                                                                           *
*             word0 = bsbuf[next_wptr];                                     *
*             next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 *
*                                                                           *
*             word1 = bsbuf[next_wptr];                                     *
*             next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 *
*                                                                           *
*             word2 = bsbuf[next_wptr];                                     *
*             next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 *
*                                                                           *
*       4. top0 and top1:  Shift words word0, word1, word2 by bptr to       *
*          the left so that the current bit becomes the MSB in word0.       *
*          word0 can simply be shifted by bptr; the then empty LSBs of      *
*          word0 have to be filled with the MSBs of word1.  To do that      *
*          the required MSBs are brought into the position of empty         *
*          LSBs of word0 by shifting word1 to the right by (32-bptr).       *
*          The result is then copied into word0 by an addition.  Rather     *
*          than overwriting word0, top0 is used to hold the new bit         *
*          aligned word.  The same procedure is used to obtain top1.        *
*          top0 and top1 contain the next 64 bits of the bitstream.         *
*                                                                           *
*             s1 = SHL(word0, bptr);                                        *
*             s2 = SHR(word1, bptr_cmpl);  // unsigned right-shift          *
*             top0 = s1 + s2;                                               *
*                                                                           *
*             s3 = SHL(word1, bptr);                                        *
*             s4 = SHR(word2, bptr_cmpl);  //  unsigned right-shift         *
*             top1 = s3 + s4;                                               *
*                                                                           *
*         SHL/SHR are macros that simulate C6000 shift functions if the     *
*         routine is to be run on a PC or UNIX platform. They are           *
*         defined as follows:                                               *
*                                                                           *
*             #ifdef _TMS320C6X                                             *
*             # define SHL(x,y) ( (x) << (y) )                              *
*             # define SHR(x,y) ( (x) >> (y) )                              *
*             #else                                                         *
*             # define SHL(x,y) ( ((y) & 32) ? 0 : ((x) << (y)) )           *
*             # define SHR(x,y) ( ((y) & 32) ? 0 : ((x) >> (y)) )           *
*             #endif                                                        *
*                                                                           *
*   DESCRIPTION                                                             *
*       Decodes all coefficients of an MPEG-2 non-intra coded macroblock.   *
*                                                                           *
*       Checks coded block pattern (cbp), performs DC and AC decoding       *
*       inlcuding, variable length decode, run-length expansion,            *
*       inverse zigzag, dequantization, saturation and mismatch             *
*       control.                                                            *
*                                                                           *
*   ASSUMPTIONS                                                             *
*     - bitstream buffer is set to 512 32-bit words (=2048 bytes),          *
*       buffer needs to be aligned at a 2048 boundary because it is         *
*       circular.  If this needs to be changed, AMR register setup has to   *
*       be modified  and alignment changed accordingly. Register B7 is      *
*       used as the address pointer to the bitstream buffer in              *
*       circular addressing mode with a size of 2^(10+1) bytes = 2048       *
*       bytes = 512 words. Accordingly, AMR is set to 0x000A0004. Note      *
*       that the AMR register is set to zero on exit.                       *
*                                                                           *
*     - zigzag matrix (Zptr) is 64 bytes circularly addressed and needs to  *
*       be aligned at a 64 byte boundary (serves protection from random     *
*       stores into memory)                                                 *
*                                                                           *
*     - inside the routine word1 (next_wptr-2) and word2 (next_wptr-1)      *
*       are reconstructed from the bitstream buffer and therfore have to    *
*       be kept alive in the bitstream buffer. For instance, in a double    *
*       buffering scheme the bitstream buffer can only be updated when      *
*       next_wptr-2 (and not next_wptr) has crossed the half buffer         *
*       boundary.                                                           *
*                                                                           *
*     - look-up tables len and len_c should be offset against each other    *
*       so that they start in different memory banks to avoid bank          *
*       conflicts.                                                          *
*                                                                           *
*   NOTES                                                                   *
*     - little endian                                                       *
*                                                                           *
*     - 4:2:0 color format supported only                                   *
*                                                                           *
*     - Wptr is allowed to overrun once (to detect total run overrun), so   *
*       maximum overrun that can occur is 66 (Error mark). Therefore,       *
*       in memory 66+1 half-words behind the weighting matrix should be     *
*       valid (e.g. no cache or peripherals). No memory is overwritten,     *
*       only loads occurr.                                                  *
*                                                                           *
*   DATA SIZE                                                               *
*       2176 bytes for the lookup tables                                    *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .global _IMG_len_c_tbl0
        .global _IMG_len_tbl0
        .global _IMG_rld_table0

        .sect ".text:_mpeg2_vld_inter"
        .global _IMG_mpeg2_vld_inter
_IMG_mpeg2_vld_inter .cproc Wptr, outi, Mpeg2v
                    .no_mdep
;                          A4,   B4,   A6

* =========================================================================
*  Registers
* ========================================================================= *
    .reg block  ; block number (0-3: lum, 4, 5: chrom)
    .reg cnt, cnt_sav
    .reg flag
    .reg const1, const24, const31, const32, const63, const65, const128
    .reg amr_config, csr_bk, no_gie

* -------------------------------------------------------------------------
*  coded block pattern
* ------------------------------------------------------------------------- *
    .reg cbp, bcomp, cbp_mask, coded

* -------------------------------------------------------------------------
*  Decoding of the first coefficient
* ------------------------------------------------------------------------- *
    .reg tm

* -------------------------------------------------------------------------
*  32-bit words at 32-bit boundaries from bitstream buffer bsbuf[]
* ------------------------------------------------------------------------- *
    .reg bsbuf, word0, word1, word2, next_wptr, byte_diff, fault

* -------------------------------------------------------------------------
*  bptr points to the current bit position within the current 32-bit
*  aligned word
* ------------------------------------------------------------------------- *
    .reg bptr, bptr1, bptr_cmpl

* ------------------------------------------------------------------------
*  top0 and top1 contain the bitstream aligned at the beginning of the
*  VLC to decode
* ------------------------------------------------------------------------ *
    .reg top0, top1, top0_bk

* ------------------------------------------------------------------------
*  Variables for intra DC decoding
* ------------------------------------------------------------------------ *
    .reg cc, a_cc0, a_cc1, b, c, d, dc_size, b_1
    .reg dc_diff, val, half_range, pred, test0

* ------------------------------------------------------------------------
*  Variables for length, run and level decoding
* ------------------------------------------------------------------------ *
    .reg len_tbl_adr, len_c_tbl_adr
    .reg t1, t2, t4, t4b, t5, t7, t8, t9
    .reg sign, rld_left, rld_table_adr, rld_table_adr_1
    .reg run_level
    .reg run, run_bk, len, len_c, len_1
    .reg t3, t3b
    .reg level
    .reg s1, s2, s3, s4, eob_err, nrm
    .reg no_esc, test2, test3

* ------------------------------------------------------------------------
*  Variables for de-quantization
* ------------------------------------------------------------------------ *
    .reg level2, level3, level4, level5, level_f
    .reg neg, pos, f1, f3, f5, f4, qW, sum, odd, last_coeff
    .reg Wptr_origin, Wptr_end, Zptr_origin, Zptr
    .reg W, Z, qscl

* ======================================================================== *
*  Disable interrupts
* ======================================================================== *
    MVC         CSR,        csr_bk                ; Get CSR's state
    AND         csr_bk,     -2,         no_gie    ; Clear GIE
    MVC         no_gie,     CSR

* ======================================================================== *
*  Get bitstream info
* ======================================================================== *
    LDW        *+Mpeg2v[0], bsbuf
    LDW        *+Mpeg2v[1], next_wptr
    LDW        *+Mpeg2v[2], bptr
    LDW        *+Mpeg2v[3], word1
    LDW        *+Mpeg2v[4], word2
    LDW        *+Mpeg2v[5], top0
    LDW        *+Mpeg2v[6], top1
    LDW        *+Mpeg2v[7], Zptr
    LDW        *+Mpeg2v[9], qscl
    LDW        *+Mpeg2v[11], cbp

* ======================================================================== *
*  Setup
* ======================================================================== *
     MVKL    _IMG_len_tbl0,   len_tbl_adr    ; length table
     MVKH    _IMG_len_tbl0,   len_tbl_adr
     MVKL    _IMG_len_c_tbl0, len_c_tbl_adr  ; 32-length table
     MVKH    _IMG_len_c_tbl0, len_c_tbl_adr
     MVKL    _IMG_rld_table0, rld_table_adr
     MVKH    _IMG_rld_table0, rld_table_adr

     ADD     1,      rld_table_adr,   rld_table_adr_1

     MVK     1,      const1
     MVK     24,     const24
     MVK     31,     const31
     MVK     32,     const32
     MVK     63,     const63
     MVK     65,     const65
     MVK    128,     const128

     ADD     Wptr, const128, Wptr_end
     MV      Wptr,           Wptr_origin
     MV      Zptr,           Zptr_origin

     .reserve A5
     MVKL    0x000A0004, amr_config     ; A5 circular mode, 2^(10+1) bytes
     MVKH    0x000A0004, amr_config     ; (=2048 bytes=512 words x 32 bit)
     MVC     amr_config, AMR

* ======================================================================== *
*  Setup bitstream pointers
*   to do: convert to circular buffer support
* ======================================================================== *

        ADDAW   bsbuf,      next_wptr,  A5

* ======================================================================== *
*  Block loop setup
* ======================================================================== *

        MVK     6,  cnt                     ; dec cnt for block loop (6)

block_loop:
         SUB    cnt,  1,          bcomp
         SHL    const1,  bcomp,   cbp_mask
         AND    cbp_mask,   cbp,  coded
         ZERO   sum
[!coded] MVK    1,       sum                ; prevent mism for !coded
[!coded] B      mismatch

        MV      Zptr_origin,        Zptr    ; reset Zptr
        MV      Wptr_origin,        Wptr    ; reset Wptr

        ZERO    eob_err

* ========================================================================= *
*  Decode first coefficient
* ========================================================================= *
        SHRU    top0, 31, tm
[!tm]   B       ac_loop

* ----------------------------------------------------------------
*  Length computation: len=2, len_c=30
* ---------------------------------------------------------------- *

* --------------------------------------------------------------------
*  advance bitstream
* -------------------------------------------------------------------- *
            SHL     top0,       2,          t5
            SHRU    top1,       30,         t7
            MV      top0,       top0_bk
            ADD     t5,         t7,         top0

            ADD     bptr,       2,          bptr1
            CMPGT   bptr1,      const31,    test2

[test2]     MV      word2,      word1
[test2]     LDW     *A5++,      word2

            AND     bptr1,      const31,    bptr
            SUB     const32,    bptr,       bptr_cmpl

            SHL     word1,      bptr,       t8
            SHRU    word2,      bptr_cmpl,  t9
            ADD     t8,         t9,         top1

* ----------------------------------------------------------------
*  Run-Level "normal" code decode: run=0, level=1
* ---------------------------------------------------------------- *
            EXTU    top0_bk, 1, 31, neg         ; extract sign bit

* ----------------------------------------------------------------
*  De-quantization
* ---------------------------------------------------------------- *

            MVK      3,     level2
[neg]       MVK     -3,     level2

            LDH     *Wptr++,  W

            MPY     qscl,     W,        qW
            MPY     qW,       level2,   level4

[neg]       ADD     level4,   const31,  level4  ; add rounding constant
            SSHL    level4,   15,       level5  ; saturate
            SHR     level5,   20,       level_f

            ADD     sum,      level_f,  sum     ; for mismatch contol

            ADD     Zptr,     1,        Zptr

            STH     level_f,  *outi

* ========================================================================= *
*  Decode AC coefficients
* ========================================================================= *

ac_loop:    .trip 64                                     ; while (!eob_err)

* ----------------------------------------------------------------
*  Length computation
* ---------------------------------------------------------------- *
            NORM    top0,   nrm

            SHL     top0,   nrm,    t1      ; get rid of all leading 0s/1s
            SHL     nrm,    4,      t2      ; determine sub-table index

            ADD     len_tbl_adr,   t2, t3
            ADD     len_c_tbl_adr, t2, t3b

            SHRU    t1, 28, t4              ; 4 extra bits after leading bits
            SHRU    t1, 28, t4b             ; parallelize LDBU's

            LDBU    *t3[t4],    len         ; get length
            LDBU    *t3b[t4b],   len_c      ; get 32-length

* --------------------------------------------------------------------
*  advance bitstream
* -------------------------------------------------------------------- *
            SHL     top0,       len,        t5
            SHRU    top1,       len_c,      t7
            MV      top0,       top0_bk
            ADD     t5,         t7,         top0

            ADD     bptr,       len,        bptr1
            CMPGT   bptr1,      const31,    test2

[test2]     MV      word2,      word1
[test2]     LDW     *A5++,      word2

            AND     bptr1,      const31,    bptr
            SUB     const32,    bptr,       bptr_cmpl

            SHL     word1,      bptr,       t8
            SHRU    word2,      bptr_cmpl,  t9
            ADD     t8,         t9,         top1

* ----------------------------------------------------------------
*  Run-Level escape code decode
* ---------------------------------------------------------------- *
            SUB     len,        const24,        no_esc
            EXTU    top0_bk,    6,      26,     run
            EXT     top0_bk,    12,     20,     level

* ----------------------------------------------------------------
*  Run-Level "normal" code decode
* ---------------------------------------------------------------- *
            SUB     len,        5,          rld_left
            CMPLT   len,        5,          test3
[test3]     ZERO    rld_left

            SHL     len,        5,          t2
            SHL     top0_bk,    rld_left,   t3    ; align last 5 bits to MSB
            SHRU    t3,         27,         t3    ; keep last 5 bits inc sign
            ADD     t2,         t3,         t4    ; add to sub-table index

            ADD     t4,         t4,         t4b   ; entries are half-words
[no_esc]    LDB     *rld_table_adr[t4b],    level ; access
[no_esc]    LDB     *rld_table_adr_1[t4b],  run   ; A_rld_table_adr+1

* ---------------------------------------------------------------- *

            CMPGT   run,    const63,     eob_err

* ----------------------------------------------------------------
*  De-quantization
* ---------------------------------------------------------------- *

            CMPLT   level,    0,        sign

            MPY     level,    2,        level2

[!sign]     ADD     level2,   1,        level3
[sign]      SUB     level2,   1,        level3

            LDH     *++Wptr[run],       W
            ADD     Wptr,     2,        Wptr

            MPY     qscl,     W,        qW
            MPY     qW,       level3,   level4

[sign]      ADD     level4,   const31,  level4  ; add rounding constant
            SSHL    level4,   15,       level5  ; saturate
            SHR     level5,   20,       level_f

[!eob_err]  ADD     sum,      level_f,  sum     ; for mismatch contol

            LDB     *++Zptr[run],       Z
            ADD     Zptr,     1,        Zptr

[!eob_err]  STH     level_f,  *+outi[Z]

[!eob_err]  B       ac_loop

* ------------------------------------------------------------------------
*  Block loop:
* ------------------------------------------------------------------------ *
mismatch:
            ADD     outi,  const128,     outi    ; start of next 8x8 block

* ------------------------------------------------------------------------
*  Mismatch control: if sum is even, toggle last bit of last coefficient
* ------------------------------------------------------------------------ *
            AND     0x01,   sum,        odd
[!odd]      LDH     *-outi[1],          last_coeff
[!odd]      XOR     0x01,   last_coeff, last_coeff
[!odd]      STH     last_coeff,         *-outi[1]

            SUB     cnt,    1,           cnt
[cnt]       B       block_loop

* ------------------------------------------------------------------------
*  Exit: update bistream pointer
* ------------------------------------------------------------------------ *
        CMPGT      run,     const65,    fault
[!fault]CMPGT      Wptr,    Wptr_end,   fault

        SUB        A5,          bsbuf,      byte_diff
        SHR        byte_diff,   2,          next_wptr
        STW        next_wptr,   *+Mpeg2v[1]
        STW        bptr,        *+Mpeg2v[2]
        STW        word1,       *+Mpeg2v[3]
        STW        word2,       *+Mpeg2v[4]
        STW        top0,        *+Mpeg2v[5]
        STW        top1,        *+Mpeg2v[6]
        STW        fault,       *+Mpeg2v[12]

        ZERO       amr_config
        MVC        amr_config, AMR

* ======================================================================== *
*  Re-enable interrupts
* ======================================================================== *
        MVC        csr_bk,     CSR

    .endproc

* ========================================================================= *
*   End of file:  img_mpeg2_vld_inter.sa                                    *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
mpeg2_vld1.sa/  1066929162  0     0     0       35824     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.10    Sun Mar 17 04:52:26 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mpeg2_vld_intra                                                 *
*                                                                           *
*   PLATFORM                                                                *
*       C6200                                                               *
*                                                                           *
*   REVISION DATE                                                           *
*       11-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*         void IMG_mpeg2_vld_intra                                          *
*         (                                                                 *
*             const short   *restrict Wptr,                                 *
*             short         *restrict outi,                                 *
*             IMG_mpeg2_vld *restrict Mpeg2v,                               *
*             int                     dc_pred[3]                            *
*         );                                                                *
*                                                                           *
*         Wptr:       Pointer to the quantization matrix.  Must be in       *
*                     the scan order corresponding to the inverse scan      *
*                     matrix.                                               *
*                                                                           *
*         outi[6*64]: Pointer to the output array where the decoded and     *
*                     dequantized IDCT coefficients are placed.             *
*                     Elements assumed to be set to zero prior to           *
*                     function call.  The routine assumes 6 8x8 blocks      *
*                     per MB, i.e. 4:2:0 format.                            *
*                                                                           *
*         Mpeg2v:     Pointer to the context object, which includes the     *
*                     input buffer variables.  The structure Mpeg2v is      *
*                     defined as follows:                                   *
*                                                                           *
*C          #ifndef IMG_MPEG2_VLD_STRUCT_                                   *
*C          #define IMG_MPEG2_VLD_STRUCT_ 1                                 *
*C                                                                          *
*C          typedef struct {                                                *
*C            unsigned int  *bsbuf;      // pointer to bitstream buffer     *
*C            unsigned int  next_wptr;   // next word to read from buffer   *
*C            unsigned int  bptr;        // bit position within word        *
*C            unsigned int  word1;       // word aligned buffer             *
*C            unsigned int  word2;       // word aligned buffer             *
*C            unsigned int  top0;        // top 32 bits of bitstream        *
*C            unsigned int  top1;        // next 32 bits of bitstream       *
*C            const unsigned char *scan; // inverse zigzag scan matrix      *
*C            unsigned int  intravlc;    // intra_vlc_format                *
*C            unsigned int  quant_scale; // quant_scale                     *
*C            unsigned int  dc_prec;     // intra_dc_precision              *
*C            unsigned int  cbp;         // coded_block_pattern             *
*C            unsigned int  fault;       // fault condition (returned)      *
*C            unsigned int  reserved;                                       *
*C          } IMG_mpeg2_vld;                                                *
*C                                                                          *
*C          #endif                                                          *
*                                                                           *
*         All variables in this strucure must have the layout as shown      *
*         since they are being accessed by this routine through             *
*         appropriate offsets.  Other variables may be appended to the      *
*         structure.                                                        *
*                                                                           *
*         The routine sets the fault flag Mpeg2v.fault to 1 if an invalid   *
*         VLC code was encountered or the total run for a block exceeded    *
*         63.  In theses cases the decoder has to resynchronize.            *
*                                                                           *
*         dc_pred[3]: Intra DC prediction array.  The first element of      *
*                     dc_pred is the DC prediction for Y, the second        *
*                     for Cr and the third for Cb.                          *
*                                                                           *
*       The routine requires proprietary variable length decoding           *
*       look-up tables.  The tables are based on Table B-14 and B-15 in     *
*       the MPEG-2 standard text.                                           *
*                                                                           *
*       The required lookup tables for this routine are provided in         *
*       IMGLIB and are linked in automatically when linking against         *
*       IMGLIB.                                                             *
*                                                                           *
*       Before calling the routine the bitstream varaibles in Mpeg2v have   *
*       to be initialized.  If bsbuf[] is a circular buffer of size         *
*       BSBUF_SIZE words and bsptr contains the number of bits in the       *
*       buffer that already have been consumed, then next_wptr, bptr,       *
*       word1, word2, top0 and top1 are initialized as follows:             *
*                                                                           *
*       1. nextwptr:  bsptr may not be a multiple of 32 (e.g. it points     *
*          to bit number 40 in the bitstream), therefore set it to the      *
*          next lower multiple of 32 by shift left by 5 (divide by 32).     *
*          In case of 40 this yields 1.  Since memory is addressed in       *
*          units of bytes this needs to be multiplied by 4 to get the       *
*          address pointer.  Use next_wptr as index into bsbuf[].           *
*                                                                           *
*              next_wptr = (bsptr >> 5);                                    *
*                                                                           *
*       2. bptr:  bptr is the bit pointer which points to the current       *
*          bit WITHIN the word pointed to by next_wptr.                     *
*                                                                           *
*             bptr = bsptr & 31;                                            *
*             bptr_cmpl = 32 - bptr;                                        *
*                                                                           *
*       3. word1 and word2:  read next 3 words from the bitstream buffer    *
*          (word0 is a temporary variable).                                 *
*                                                                           *
*             word0 = bsbuf[next_wptr];                                     *
*             next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 *
*                                                                           *
*             word1 = bsbuf[next_wptr];                                     *
*             next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 *
*                                                                           *
*             word2 = bsbuf[next_wptr];                                     *
*             next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 *
*                                                                           *
*       4. top0 and top1:  Shift words word0, word1, word2 by bptr to       *
*          the left so that the current bit becomes the MSB in word0.       *
*          word0 can simply be shifted by bptr; the then empty LSBs of      *
*          word0 have to be filled with the MSBs of word1.  To do that      *
*          the required MSBs are brought into the position of empty         *
*          LSBs of word0 by shifting word1 to the right by (32-bptr).       *
*          The result is then copied into word0 by an addition.  Rather     *
*          than overwriting word0, top0 is used to hold the new bit         *
*          aligned word.  The same procedure is used to obtain top1.        *
*          top0 and top1 contain the next 64 bits of the bitstream.         *
*                                                                           *
*             s1 = SHL(word0, bptr);                                        *
*             s2 = SHR(word1, bptr_cmpl);  // unsigned right-shift          *
*             top0 = s1 + s2;                                               *
*                                                                           *
*             s3 = SHL(word1, bptr);                                        *
*             s4 = SHR(word2, bptr_cmpl);  //  unsigned right-shift         *
*             top1 = s3 + s4;                                               *
*                                                                           *
*         SHL/SHR are macros that simulate C6000 shift functions if the     *
*         routine is to be run on a PC or UNIX platform. They are           *
*         defined as follows:                                               *
*                                                                           *
*             #ifdef _TMS320C6X                                             *
*             # define SHL(x,y) ( (x) << (y) )                              *
*             # define SHR(x,y) ( (x) >> (y) )                              *
*             #else                                                         *
*             # define SHL(x,y) ( ((y) & 32) ? 0 : ((x) << (y)) )           *
*             # define SHR(x,y) ( ((y) & 32) ? 0 : ((x) >> (y)) )           *
*             #endif                                                        *
*                                                                           *
*   DESCRIPTION                                                             *
*       Decodes all coefficients of an MPEG-2 intra coded macroblock.       *
*                                                                           *
*       Checks coded block pattern (cbp), performs DC and AC decoding       *
*       inlcuding, variable length decode, run-length expansion,            *
*       inverse zigzag, dequantization, saturation and mismatch             *
*       control.                                                            *
*                                                                           *
*   ASSUMPTIONS                                                             *
*     - bitstream buffer is set to 512 32-bit words (=2048 bytes),          *
*       buffer needs to be aligned at a 2048 boundary because it is         *
*       circular.  If this needs to be changed, AMR register setup has to   *
*       be modified  and alignment changed accordingly. Register B7 is      *
*       used as the address pointer to the bitstream buffer in              *
*       circular addressing mode with a size of 2^(10+1) bytes = 2048       *
*       bytes = 512 words. Accordingly, AMR is set to 0x000A0004. Note      *
*       that the AMR register is set to zero on exit.                       *
*                                                                           *
*     - The bitstream must be stored in memory in 32-bit words which        *
*       are in little Endian byte order.                                    *
*                                                                           *
*     - zigzag matrix (Zptr) is 64 bytes circularly addressed and needs     *
*       to be aligned at a 64 byte boundary (serves protection from         *
*       random stores into memory)                                          *
*                                                                           *
*     - inside the routine word1 (next_wptr-2) and word2 (next_wptr-1)      *
*       are reconstructed from the bitstream buffer and therfore have       *
*       to be kept alive in the bitstream buffer.  For instance, in a       *
*       double buffering scheme the bitstream buffer can only be            *
*       updated when next_wptr-2 (and not next_wptr) has crossed the        *
*       half buffer boundary.                                               *
*                                                                           *
*   NOTES                                                                   *
*     - little endian                                                       *
*                                                                           *
*     - 4:2:0 color format supported only                                   *
*                                                                           *
*     - Wptr is allowed to overrun once (to detect total run overrun),      *
*       so maximum overrun that can occur is 66 (Error mark).               *
*       Therefore, in memory 66+1 half-words behind the weighting           *
*       matrix should be valid (e.g. no cache or peripherals).  No          *
*       memory is overwritten, only loads occur.                            *
*                                                                           *
*     - look-up tables len and len_c are offset against each other so       *
*       that they start in different memory banks to reduce bank            *
*       conflicts.                                                          *
*                                                                           *
*   DATA SIZE                                                               *
*       4352 bytes for lookup tables                                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


            .ref _IMG_len_c_tbl0
            .ref _IMG_len_tbl0
            .ref _IMG_rld_table0

            .ref _IMG_len_c_tbl1
            .ref _IMG_len_tbl1
            .ref _IMG_rld_table1

        .sect ".text:_mpeg2_vld_intra"
        .global _IMG_mpeg2_vld_intra
_IMG_mpeg2_vld_intra .cproc Wptr, outi, Mpeg2v, dc_pred
                    .no_mdep
;                          A4,   B4,   A6,     B6
* ========================================================================= *
*  Registers                                                                *
* ========================================================================= *
    .reg block                      ; block number (0-3: lum, 4, 5: chrom)
    .reg cnt, cnt_sav
    .reg flag
    .reg const1, const24, const31, const32, const63, const65, const128
    .reg amr_config, csr_bk, no_gie

* ------------------------------------------------------------------------- *
*  coded block pattern                                                      *
* ------------------------------------------------------------------------- *
    .reg cbp, bcomp, cbp_mask, coded

* ------------------------------------------------------------------------- *
*  32-bit words at 32-bit boundaries from bitstream buffer bsbuf[]          *
* ------------------------------------------------------------------------- *
    .reg word0, word1, word2, next_wptr, byte_diff, fault
    .reg bsbuf

* ------------------------------------------------------------------------- *
*  bptr points to the current bit position within the current 32-bit        *
*  aligned word                                                             *
* ------------------------------------------------------------------------- *
    .reg bptr, bptr1, bptr_cmpl

* ------------------------------------------------------------------------- *
*  top0 and top1 contain the bitstream aligned at the beginning of the      *
*  VLC to decode                                                            *
* ------------------------------------------------------------------------- *
    .reg top0, top1, top0_bk

* ------------------------------------------------------------------------- *
*  Variables for intra DC decoding                                          *
* ------------------------------------------------------------------------- *
    .reg cc, a_cc0, a_cc1, b, c, d, dc_size, b_1
    .reg dc_diff, val, half_range, pred, test0
    .reg intra_vlc_format, intra_dc_precision

* ------------------------------------------------------------------------- *
*  Variables for length, run and level decoding                             *
* ------------------------------------------------------------------------- *
    .reg len_tbl_adr, len_c_tbl_adr
    .reg t1, t2, t4, t4b, t5, t7, t8, t9
    .reg sign, rld_left, rld_table_adr, rld_table_adr_1
    .reg run_level
    .reg run, run_bk, len, len_c, len_1
    .reg t3, t3b
    .reg level
    .reg s1, s2, s3, s4, eob_err, nrm
    .reg no_esc, test2, test3

* ------------------------------------------------------------------------ *
*  Variables for de-quantization                                           *
* ------------------------------------------------------------------------ *
    .reg level2, level3, level4, level5, level_f
    .reg neg, pos, f1, f3, f5, f4, qW, sum, odd, last_coeff
    .reg Wptr_origin, Wptr_end, Zptr_origin, Zptr
    .reg W, Z, qscl

* ======================================================================== *
*  Disable interrupts
* ======================================================================== *
    MVC         CSR,        csr_bk                ; Get CSR's state
    AND         csr_bk,     -2,         no_gie    ; Clear GIE
    MVC         no_gie,     CSR

* ======================================================================== *
*  Get bitstream info                                                      *
* ======================================================================== *
    LDW        *+Mpeg2v[0], bsbuf
    LDW        *+Mpeg2v[1], next_wptr
    LDW        *+Mpeg2v[2], bptr
    LDW        *+Mpeg2v[3], word1
    LDW        *+Mpeg2v[4], word2
    LDW        *+Mpeg2v[5], top0
    LDW        *+Mpeg2v[6], top1
    LDW        *+Mpeg2v[7], Zptr
    LDW        *+Mpeg2v[8], intra_vlc_format
    LDW        *+Mpeg2v[9], qscl
    LDW        *+Mpeg2v[10], intra_dc_precision
    LDW        *+Mpeg2v[11], cbp

* ======================================================================== *
*  Setup Table and Constants                                               *
* ======================================================================== *
[!intra_vlc_format] MVKL    _IMG_len_tbl0,   len_tbl_adr    ; length table
[!intra_vlc_format] MVKH    _IMG_len_tbl0,   len_tbl_adr
[!intra_vlc_format] MVKL    _IMG_len_c_tbl0, len_c_tbl_adr  ; 32-length table
[!intra_vlc_format] MVKH    _IMG_len_c_tbl0, len_c_tbl_adr
[!intra_vlc_format] MVKL    _IMG_rld_table0, rld_table_adr
[!intra_vlc_format] MVKH    _IMG_rld_table0, rld_table_adr

[intra_vlc_format]  MVKL    _IMG_len_tbl1,   len_tbl_adr    ; length table
[intra_vlc_format]  MVKH    _IMG_len_tbl1,   len_tbl_adr
[intra_vlc_format]  MVKL    _IMG_len_c_tbl1, len_c_tbl_adr  ; 32-length table
[intra_vlc_format]  MVKH    _IMG_len_c_tbl1, len_c_tbl_adr
[intra_vlc_format]  MVKL    _IMG_rld_table1, rld_table_adr
[intra_vlc_format]  MVKH    _IMG_rld_table1, rld_table_adr

        ADD     1,      rld_table_adr,   rld_table_adr_1

        MVK     1,      const1
        MVK     24,     const24
        MVK     31,     const31
        MVK     32,     const32
        MVK     63,     const63
        MVK     65,     const65
        MVK    128,     const128

        ADD     Wptr, const128, Wptr_end
        MV      Wptr,           Wptr_origin
        MV      Zptr,           Zptr_origin

        .reserve A5
        MVKL    0x000A0004, amr_config     ; A5 circular mode, 2^(10+1) bytes
        MVKH    0x000A0004, amr_config     ; (=2048 bytes=512 words x 32 bit)
        MVC     amr_config, AMR

* ======================================================================== *
*  Setup bitstream pointers                                                *
*   to do: convert to circular buffer support                              *
* ======================================================================== *
        ADDAW   bsbuf,      next_wptr,  A5

* ======================================================================== *
*  Block loop setup                                                        *
* ======================================================================== *

         ; calculate block from cnt, need count for [!cnt] B; block=6-cnt
         ; so only one reg. need to be spilled
         MVK     6,  cnt                     ; dec cnt for block loop (6)

block_loop:
         SUB    cnt,  1,          bcomp
         SHL    const1,  bcomp,   cbp_mask
         AND    cbp_mask,   cbp,  coded
         ZERO   sum
[!coded] MVK    1,          sum              ; prevent mism for !coded
[!coded] B      mismatch

         MV      Zptr_origin,        Zptr    ; reset Zptr
         MV      Wptr_origin,        Wptr    ; reset Wptr

         SUB     6,  cnt,    block
         CMPLT   block,      4,      flag    ; determine cc
         ZERO    cc
[!flag]  AND     block,      1,      cc
[!flag]  ADD     cc,         1,      cc

         ZERO    eob_err

* ========================================================================= *
*  Decode intra DC coefficient                                              *
* ========================================================================= *
* ------------------------------------------------------------------------- *
*  Intra DC: decode dct_size and len (luminance and chrominance)            *
* ------------------------------------------------------------------------- *
        ZERO    a_cc0
        ZERO    a_cc1
        LMBD    0,          top0,   b
        SHRU    top0,       30,     c
        SHRU    top0,       29,     d

        ADD     b,          1,      len

[!cc]   ADD     b,          2,      dc_size
[!cc]   CMPGT   b,          8,      a_cc0                 ; >=9
[!cc]   SHRU    b,          1,      b
[!cc]   SUB     d,          4,      d

[cc]    ADD     b,          1,      dc_size
[cc]    CMPGT   b,          9,      a_cc1                 ; >=10
[cc]    MVK     1,          d                             ; anything !=0

[!b]    ADD     len,        1,      len
[!c]    SUB     dc_size,    1,      dc_size
[!d]    SUB     dc_size,    3,      dc_size
[a_cc0] MVK     9,          len
[a_cc0] MVK     11,         dc_size
[a_cc1] MVK     10,         len
[a_cc1] MVK     11,         dc_size

* ------------------------------------------------------------------------- *
*  Intra DC: obtain QFS[0] from dc_size and dc_differential                 *
* ------------------------------------------------------------------------- *
            ZERO    dc_diff
            SHL     top0,       len,        t1
[dc_size]   SUB     dc_size,    1,          t2
[dc_size]   SHL     const1,     t2,         half_range
[dc_size]   SUB     const32,    dc_size,    t3
[dc_size]   SHRU    t1,         t3,         dc_diff

            ZERO    test0
[dc_size]   CMPLT   dc_diff,    half_range, test0
[test0]     ADD     dc_diff,    1,          t4
[test0]     SHL     half_range, 1,          t5
[test0]     SUB     t4,         t5,         dc_diff

            LDW     *dc_pred[cc], pred
            ADD     pred,         dc_diff,  val
            STW     val,          *dc_pred[cc]

* ------------------------------------------------------------------------- *
*  Intra DC: de-quantization and store result                               *
* ------------------------------------------------------------------------- *
           SUB     3,          intra_dc_precision,     t1
           SHL     val,        t1,     val
           STH     val,        *outi

* ------------------------------------------------------------------------- *
*  Intra DC: mismatch control                                               *
* ------------------------------------------------------------------------- *
            ADD     sum,    val,    sum

* ------------------------------------------------------------------------- *
*  Intra DC: advance bitstream                                              *
* ------------------------------------------------------------------------- *
            ADD     len,        dc_size,    len
            SUB     const32,    len,        len_c

            SHL     top0,       len,        t5
            SHRU    top1,       len_c,      t7
            ADD     t5,         t7,         top0

            ADD     bptr,       len,        bptr
            CMPGT   bptr,       const31,    test2

[test2]     MV      word2,      word1
[test2]     LDW     *A5++,      word2

            AND     bptr,       const31,    bptr;
            SUB     const32,    bptr,       bptr_cmpl

            SHL     word1,      bptr,       t8
            SHRU    word2,      bptr_cmpl,  t9
            ADD     t8,         t9,         top1

* ------------------------------------------------------------------------- *
*  Intra DC: update pointers  (can be done before)                          *
* ------------------------------------------------------------------------- *
            ADD     Wptr,   2,  Wptr
            ADD     Zptr,   1,  Zptr

* ========================================================================= *
*  Decode AC coefficients                                                   *
* ========================================================================= *

ac_loop:                                         ; while (!eob_err)

* ------------------------------------------------------------------------- *
*  Length computation                                                       *
* ------------------------------------------------------------------------- *
            NORM    top0,   nrm

            SHL     top0,   nrm,    t1      ; get rid of all leading 0s/1s
            SHL     nrm,    4,      t2      ; determine sub-table index

            ADD     len_tbl_adr,   t2, t3
            ADD     len_c_tbl_adr, t2, t3b

            SHRU    t1, 28, t4              ; 4 extra bits after leading bits
            SHRU    t1, 28, t4b             ; to parallelize LDBUs

            LDBU    *t3[t4],    len          ; get length
            LDBU    *t3b[t4b],   len_c       ; get 32-length

* ------------------------------------------------------------------------- *
*  advance bitstream                                                        *
* ------------------------------------------------------------------------- *
            SHL     top0,       len,        t5
            SHRU    top1,       len_c,      t7
            MV      top0,       top0_bk
            ADD     t5,         t7,         top0

            ADD     bptr,       len,        bptr1
            CMPGT   bptr1,      const31,    test2

[test2]     MV      word2,      word1
[test2]     LDW     *A5++,      word2

            AND     bptr1,      const31,    bptr
            SUB     const32,    bptr,       bptr_cmpl

            SHL     word1,      bptr,       t8
            SHRU    word2,      bptr_cmpl,  t9
            ADD     t8,         t9,         top1

* ------------------------------------------------------------------------- *
*  Run-Level escape code decode                                             *
* ------------------------------------------------------------------------- *
            SUB     len,        const24,        no_esc
            EXTU    top0_bk,    6,      26,     run
            EXT     top0_bk,    12,     20,     level

* ------------------------------------------------------------------------- *
*  Run-Level "normal" code decode                                           *
* ------------------------------------------------------------------------- *
            SUB     len,        5,          rld_left
            CMPLT   len,        5,          test3
[test3]     ZERO    rld_left

            SHL     len,        5,          t2
            SHL     top0_bk,    rld_left,   t3    ; align last 5 bits to MSB
            SHRU    t3,         27,         t3    ; keep last 5 bits inc sign
            ADD     t2,         t3,         t4    ; add to sub-table index

            ADD     t4,         t4,         t4b   ; entries are half-words
[no_esc]    LDB     *rld_table_adr[t4b],    level ; access
[no_esc]    LDB     *rld_table_adr_1[t4b],  run   ; A_rld_table_adr+1

* ------------------------------------------------------------------------- *

            CMPGT   run,    const63,     eob_err

* ------------------------------------------------------------------------- *
*  De-quantization                                                          *
* ------------------------------------------------------------------------- *

            CMPLT   level,    0,        sign

            MPY     level,    2,        level2

[!eob_err]  LDH     *++Wptr[run],       W
[!eob_err]  ADD     Wptr,     2,        Wptr

            MPY     qscl,     W,        qW
            MPY     qW,       level2,   level4

[sign]      ADD     level4,   const31,  level4  ; add rounding constant
            SSHL    level4,   15,       level5  ; saturate
            SHR     level5,   20,       level_f

[!eob_err]  ADD     sum,      level_f,  sum     ; for mismatch contol

            LDB     *++Zptr[run],       Z
            ADD     Zptr,     1,        Zptr

[!eob_err]  STH     level_f,  *+outi[Z]

[!eob_err]  B       ac_loop

* ------------------------------------------------------------------------- *
*  Block loop:                                                              *
* ------------------------------------------------------------------------- *
mismatch:
            ADD     outi,  const128,     outi    ; start of next 8x8 block

* ------------------------------------------------------------------------- *
*  Mismatch control: if sum is even, toggle last bit of last coefficient    *
* ------------------------------------------------------------------------- *
            AND     0x01,   sum,        odd
[!odd]      LDH     *-outi[1],          last_coeff
[!odd]      XOR     0x01,   last_coeff, last_coeff
[!odd]      STH     last_coeff,         *-outi[1]

            SUB     cnt,    1,           cnt
[cnt]       B       block_loop

* ------------------------------------------------------------------------- *
*  Exit: update bitstream info                                              *
* ------------------------------------------------------------------------- *
        CMPGT      run,     const65,    fault
[!fault]CMPGT      Wptr,    Wptr_end,   fault

        SUB        A5,          bsbuf,      byte_diff
        SHR        byte_diff,   2,          next_wptr
        STW        next_wptr,   *+Mpeg2v[1]
        STW        bptr,        *+Mpeg2v[2]
        STW        word1,       *+Mpeg2v[3]
        STW        word2,       *+Mpeg2v[4]
        STW        top0,        *+Mpeg2v[5]
        STW        top1,        *+Mpeg2v[6]
        STW        fault,       *+Mpeg2v[12]

        ZERO    amr_config
        MVC     amr_config, AMR

* ======================================================================== *
*  Re-enable interrupts
* ======================================================================== *
        MVC        csr_bk,     CSR

    .endproc

* ========================================================================= *
*   End of file:  img_mpeg2_vld_intra.sa                                    *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
perimeter.sa/   1066929162  0     0     0       14152     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Thu Sep 26 05:19:48 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       Perimeter  detection of a boundary image                            *
*                                                                           *
*   REVISION DATE                                                           *
*       26-Sep-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       int IMG_perimeter(unsigned char *in_data, int  cols, unsigned char  *
*       *out_data );                                                        *
*                                                                           *
*       in_data  : Input binary image                                       *
*       cols     : Number of cols. Must be >= 3.                            *
*       out_data : Output boundary image                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine produces the IMG_perimeter of a binary image, by       *
*       counting the number of boundary pixels of the input image.  It      *
*       echoes the boundary pixels with a value of 0xFF and sets the        *
*       other pixels as 0.  Detection of the boundary of a binary image     *
*       is a segmentation problem and is done by examining spatial          *
*       locality of the neighboring pixels.  This is done by using the      *
*       four connectivity algorithm:                                        *
*                                                                           *
*                        pix_up                                             *
*               pix_lft pix_cent pix_rgt                                    *
*                        pix_dn                                             *
*                                                                           *
*       The output pixel at location pix_cent is echoed as a boundary       *
*       pixel if pix_cent is non-zero and any one of its four neighbors     *
*       is zero.  The four neighbors are shown and stand for the            *
*       following:                                                          *
*                                                                           *
*               pix_up:  top pixel                                          *
*               pix_lft: left pixel                                         *
*               pix_rgt: right pixel                                        *
*               pix_dn:  bottom pixel                                       *
*                                                                           *
*    CODE                                                                   *
*       This is the C equivalent of the assembly code without               *
*       restrictions: Note that the assembly code is hand optimized and     *
*       restrictions may apply.                                             *
*                                                                           *
*       int IMG_perimeter(unsigned char *in_data, int  cols, unsigned char  *
*       *out_data)                                                          *
*       {                                                                   *
*           int icols;                                                      *
*           int count;                                                      *
*                                                                           *
*           unsigned char pix_lft, pix_rgt, pix_top;                        *
*           unsigned char pix_bot, pix_cent;                                *
*                                                                           *
*           count = 0;                                                      *
*                                                                           *
*           for(icols = 1; icols < (cols-1); icols++ )                      *
*           {                                                               *
*               pix_lft = in_data[icols - 1];                               *
*               pix_cent= in_data[icols + 0];                               *
*               pix_rgt = in_data[icols + 1];                               *
*                                                                           *
*               pix_top = in_data[icols - cols];                            *
*               pix_bot = in_data[icols + cols];                            *
*                                                                           *
*               if ( ( (pix_lft == 0) ||                                    *
*                      (pix_rgt == 0) ||                                    *
*                      (pix_top == 0) ||                                    *
*                      (pix_bot == 0) ) && (pix_cent > 0) )                 *
*               {                                                           *
*                   out_data[icols] = pix_cent;                             *
*                   count++;                                                *
*               }                                                           *
*               else                                                        *
*               {                                                           *
*                   out_data[icols] = 0;                                    *
*               }                                                           *
*           }                                                               *
*                                                                           *
*           return(count);                                                  *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       No specific alignment is expected for the input or output array     *
*       cols can be either even or odd.                                     *
*                                                                           *
*       This code expects three input lines each of cols pixels and         *
*       produces one output line of cols - 1 pixels.                        *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts are expected for this kernel.  In addition        *
*       notice that the # of loads that have be performed is reduced        *
*       because of data re-use within the loop. This is also beneficial     *
*       because bank conflicts can be eliminated Notice that pix_cent of    *
*       the present iteration is the pix_lft of the next iteration. Hence   *
*       these can be obtained by moves rather than fresh loads. The set of  *
*       moves are indicated below                                           *
*                                                                           *
*       pix_cent ---> pix_lft                                               *
*       pix_rgt  ---> pix_cent                                              *
*                                                                           *
*       In order for this to be done at the start of the kernel the values  *
*       of pix_cent and pix_rgt are pre-loaded before the start of the      *
*       loop                                                                *
*                                                                           *
*       This code is ENDIAN NEUTRAL                                         *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_perimeter"
        .global _IMG_perimeter
_IMG_perimeter   .cproc   A_in, B_cols, A_out

             .no_mdep

             .reg  B_i
             .reg  A_img,       B_imgup,   B_imgdn
             .reg  A_imgle,     A_imgrt
             .reg  A_IMGPTR,    B_IMGPTR
             .reg  A_out_ptr,   A_b
             .reg  B_resud,     A_reslr,   A_res
             .reg  B_bcount,    A_out_pix
             .reg  A_res_not,   A_ff
             .reg  B_imgc, B_img

             MV.1         A_out,       A_out_ptr             ; Make outptr
             MV.1         A_in,        A_IMGPTR              ; Image pointer
             ZERO.2       B_bcount                           ; Boundary count
             SUB.2        B_cols,      2,         B_i        ; Loop iters
             ADD.1        A_IMGPTR,    1,         A_IMGPTR   ; Image pointer++
             ADD.1        A_out_ptr,   1,         A_out_ptr  ; outptr++
             MVK.1        0xFF,        A_ff                  ; constant FF

             LDBU.D1T1   *-A_IMGPTR[1],           A_img      ; preload imglft
             LDBU.D1T1   *A_IMGPTR,               A_imgrt    ; preload imgrt
             MV.2x        A_IMGPTR,               B_IMGPTR   ; 2nd copy of imgptr

             .mptr        B_IMGPTR,    A_in+0, 1
             .mptr        A_IMGPTR,    A_in+0, 1
             .mptr        A_out_ptr,   A_in+0, 1

LOOP:
            ;           ;           ;           ;           ;
            MV.1        A_img,      A_imgle                 ; Move imgle
            MV.1        A_imgrt,    A_img                   ; Move img
            MPY.2x      1,          A_img,      B_imgc
            MPY.2       1,          B_imgc,     B_img
            LDBU.D2T2   *-B_IMGPTR[B_cols],     B_imgup     ; Load imgup
            LDBU.D2T2   *+B_IMGPTR[B_cols],     B_imgdn     ; Load imgdn
            LDBU.D1T1   *++A_IMGPTR,            A_imgrt     ; Load imgrt
            ADD.2       B_IMGPTR,   1,          B_IMGPTR    ; Incr imgptr

            MPYU.2      B_imgup,    B_imgdn,    B_resud     ; resud
            MPYU.1      A_imgrt,    A_imgle,    A_reslr     ; reslr
            MPYU.1x     B_resud,    A_reslr,    A_res       ; res

            CMPEQ.1     A_res,      0,          A_res_not   ; resnot
            MPYU.1      A_res_not,  B_img,      A_b         ; is boundary?

            ZERO.1      A_out_pix                           ; outpix = 0
 [A_b]      MV.1        B_img,                  A_out_pix   ; outpux = FF
 [A_b]      ADD.2       B_bcount,   1,          B_bcount    ; bcount++
            STB.D1T1    A_out_pix,  *A_out_ptr++            ; Store outpix

 [B_i]      SUB.2       B_i,        1,          B_i         ; B_i--
 [B_i]      B.2         LOOP                                ; B LOOP

            .return     B_bcount                            ;
            .endproc                                        ;

* ========================================================================= *
*   End of file:  img_perimeter.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
pix_expand.sa/  1066929162  0     0     0       10565     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Wed Dec 15 11:27:16 1999 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_pix_expand                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       06-Nov-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_pix_expand(int n,unsigned char *in_data,short *out_data);  *
*                                                                           *
*           n       = length of array                                       *
*           in_data  = pointer to input array of unsigned chars             *
*           out_data = pointer to output array of shorts                    *
*                                                                           *
*       (See the C compiler reference guide.)                               *
*                                                                           *
*   DESCRIPTION                                                             *
*       The code takes an array of unsingd chars (pixels) and zero          *
*       extends them up to 16 bits to form shorts.                          *
*                                                                           *
*       This is the C equivalent of the assembly code, without              *
*       restrictions.  The assembly code imposes various restrictions,      *
*       as noted under 'ASSUMPTIONS'.                                       *
*                                                                           *
*           void IMG_pix_expand(int n, unsigned char *in_data,              *
*                             short *out_data)                              *
*           {                                                               *
*               int j;                                                      *
*               for (j = 0; j < n; j++)                                     *
*                   out_data[j] = (short) in_data[j];                       *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS:                                                            *
*       Input and Output arrays must be aligned on at least 4 byte          *
*       boundaries.                                                         *
*                                                                           *
*       Input array must be a multiple of 8 elements long and contain       *
*       at least 8 elements.                                                *
*                                                                           *
*       This code is LITTLE ENDIAN.                                         *
*                                                                           *
*   MEMORY NOTE:                                                            *
*       No memory bank hits should occur in this code.                      *
*                                                                           *
*   TECHNIQUES                                                              *
*       The code is unrolled 8 times, with two LDWs read in a total of 8    *
*       bytes each iteration.  The bytes are extracted into registers,      *
*       and are then re-packed as shorts.  The packed shorts are then       *
*       written with four STWs.                                             *
*                                                                           *
*       The pack is achieved using MPYU and ADD.  First, the data is        *
*       shifted left by 15 with the MPYU by multiplying with (1 << 15).     *
*       The value is then added to itself to shift it left one more bit.    *
*       A final ADD merges the shifted quantity with a second quantity,     *
*       giving the packed result.                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

            .sect    ".data:copyright_p"

        .sect ".text:_pix_expand"
        .global _IMG_pix_expand
_IMG_pix_expand  .cproc  A_n, B_p, A_x

        .no_mdep
        .reg    B_pel_7654, A_pel_3210       ; packed pixels
        .reg    A_ff, A_8, B_15, A_ff00      ; masks and cntrls
        .reg    B_j, A_one, B_prefetch       ; masks and cntrls
        .reg    A_pel_1, A_pel_0, B_pel_3    ; 8 bit pixels
        .reg    A_pel_2, A_pel_3, B_pel_2    ; 8 bit pixels
        .reg    A_pel_4, A_pel_5, B_pel_6    ; 8 bit pixels
        .reg    B_pel_7, B_pel_5             ; 8 bit pixels
        .reg    A_in_data_0, B_in_data_1     ; in ptrs
        .reg    A_out_data_0, B_out_data_1   ; out ptrs

        LDW     .D1T2   *A_x[0],    B_prefetch
        MVK     .1      1,          A_one
        SHL     .1      A_one,      8,          A_8
        SHL     .2X     A_one,      15,         B_15
        MV      .2X     A_n,        B_j
        MV      .1X     B_p,        A_in_data_0
        ADD     .2      B_p,        4,          B_in_data_1
        MV      .1      A_x,        A_out_data_0
        ADD     .2X     A_x,        4,          B_out_data_1;
        ZERO    .1      A_ff
        SET     .1      A_ff,       8,  15,     A_ff00
        SET     .1      A_ff,       0,  7,      A_ff

        .mptr           A_in_data_0, a0+0,       8
        .mptr           B_in_data_1, a1+2,       8
        .mptr           A_out_data_0,a2+0,       8
        .mptr           B_out_data_1,a3+2,       8
LOOP_X:
        LDW     .D1T2   *A_out_data_0[8],        B_prefetch
        LDW     .D1T1   *A_in_data_0++[2],       A_pel_3210
        SHRU    .1      A_pel_3210, 24,         A_pel_3
        EXTU    .1      A_pel_3210, 8, 24,      A_pel_2
        AND     .1      A_pel_3210, A_ff00,     A_pel_1
        AND     .1      A_pel_3210, A_ff,       A_pel_0

        MPYU    .1      A_8,        A_pel_1,    A_pel_1
        ADD     .1      A_pel_1,    A_pel_0,    A_pel_0
        STW     .D1T1   A_pel_0,    *A_out_data_0++[2]

        MPYU    .2X     B_15,       A_pel_3,    B_pel_3
        ADD     .2      B_pel_3,    B_pel_3,    B_pel_3
        ADD     .2X     B_pel_3,    A_pel_2,    B_pel_2
        STW     .D2T2   B_pel_2,    *B_out_data_1++[2]

        LDW     .D2T2   *B_in_data_1++[2],       B_pel_7654
        SHRU    .2      B_pel_7654, 24,         B_pel_7
        EXTU    .2      B_pel_7654, 8,  24,     B_pel_6
        AND     .2      B_pel_7654, A_ff00,     B_pel_5
        AND     .1X     B_pel_7654, A_ff,       A_pel_4

        MPYU    .1X     A_8,        B_pel_5,    A_pel_5
        ADD     .1      A_pel_5,    A_pel_4,    A_pel_4
        STW     .D1T1   A_pel_4,    *A_out_data_0++[2]

        MPYU    .2      B_15,       B_pel_7,    B_pel_7
        ADD     .2      B_pel_7,    B_pel_7,    B_pel_7
        ADD     .2      B_pel_7,    B_pel_6,    B_pel_6
        STW     .D2T2   B_pel_6,    *B_out_data_1++[2]

 [B_j]  SUB     .2      B_j,        8,          B_j
 [B_j]  B               LOOP_X
        .return
        .endproc

* ========================================================================= *
*   End of file:  img_pix_expand.sa                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

pix_sat.sa/     1066929162  0     0     0       9570      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Mon Mar 11 19:13:05 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_pix_sat                                                         *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       12-Dec-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_pix_sat(int n, short *in_data, unsigned char *out_data);   *
*                                                                           *
*       n        : Length of input array                                    *
*       in_data  : Pointer to array of signed 16 bit numbers                *
*       out_data : Pointer to array of clipped, unsigned 8 bit numbers.     *
*                                                                           *
*   DESCRIPTION                                                             *
*       This code performs the saturation of 16 bit signed numbers to 8     *
*       bit unsigned numbers. If the data is over 255 it is saturated to    *
*       255, if it is less than 0 it is saturated to 0.                     *
*                                                                           *
*   C CODE                                                                  *
*       void IMG_pix_sat(int n, short *in_data, unsigned char * out_data)   *
*       {                                                                   *
*           int j, pixel, pel;                                              *
*           for (j = 0; j < n; j++)                                         *
*           {                                                               *
*               pixel = in_data[j];                                         *
*               pel = (unsigned char) pixel;                                *
*               if (pixel > 0xff) pel = 0xff;                               *
*               if (pixel < 0x00) pel = 0x00;                               *
*               out_data[j] = pel;                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code may have some restrictions, as     *
*       noted below.                                                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       The data is loaded in pairs of shorts, the sign bits are detected   *
*       and the test is done to see if values are over 8 bits.  Outputs     *
*       are packed back to gether to form words, i.e. if ( a & 0xff00) if   *
*       ( a & 0x8000) sat to 0 else sat to 0xff                             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input array must be aligned on an 4 bytes boundary and be a     *
*       multiple of 8 in length. n % 8 = 0. The code is interrupt tolerant  *
*       interrupts are disabled during execution.                           *
*                                                                           *
*   MEMORY NOTE                                                             *
*       It is LITTLE ENDIAN.                                                *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_pix_sat"
        .global _IMG_pix_sat
_IMG_pix_sat: .cproc A_n, B_x, A_p 
            .no_mdep
            .reg   A_pel_0, A_t0, A_t1, A_nff
            .reg   A_pel_1_, A_pel_0_, B_out_data_b, A_pixel_10
            .reg   A_out_data_a, A_pel_1, B_t3, B_t2, B_j
            .reg   B_pel_2, B_pel_3_, B_pixel_32, B_ff
            .reg   B_pel_3, B_pel_2_, B_n80, A_100
            .reg   B_pel_32, B_100, A_pel_10, A_1
            .reg   A_x_e, B_x_o

            ;.mptr a, a_bank, 0 ;bank conflicts

        MV.2X      A_n,         B_j
        MVKL.1     0x1,         A_1
        MVKL.1     0x100,       A_100
        MVKL.2     0x100,       B_100
        MVKL.1     0xff00,      A_nff
        MVKH.1     0x0000,      A_nff
        MVKL.2     0x8000,      B_n80
        MVKH.2     0x0000,      B_n80
        MVKL.2     0xff,        B_ff
        ADD.1      A_p,         0,          A_out_data_a
        ADD.2X     A_p,         2,          B_out_data_b
        MV.1X      B_x,         A_x_e
        ADD.2      B_x,         4,          B_x_o
LOOP_X:
        LDW.D1T1   *A_x_e++[2], A_pixel_10
        LDW.D2T2   *B_x_o++[2], B_pixel_32

        MPYHL.1    A_pixel_10,  A_1,        A_pel_1
        MPYHL.2    B_pixel_32,  A_1,        B_pel_3
        MPY.1      1,           A_pixel_10, A_pel_0
        MPY.2      1,           B_pixel_32, B_pel_2

        MV.1       A_pel_0,     A_pel_0_
        AND.1      A_pel_0,     A_nff,      A_t0
        AND.1X     A_pel_0,     B_n80,      A_t1
[A_t0]  MPY.1X     1,           B_ff,       A_pel_0_
[A_t1]  ZERO.1     A_pel_0_

        SHL.1      A_pel_1,     8,          A_pel_1_
        AND.1      A_pel_1,     A_nff,      A_t0
        AND.1X     A_pel_1,     B_n80,      A_t1
[A_t0]  MPY.1X     A_100,       B_ff,       A_pel_1_
[A_t1]  ZERO.1     A_pel_1_
        ADD        A_pel_0_,    A_pel_1_,   A_pel_10

        MV.2       B_pel_2,     B_pel_2_
        AND.2X     B_pel_2,     A_nff,      B_t2
        AND.2      B_pel_2,     B_n80,      B_t3
[B_t2]  MPY.2      1,           B_ff,       B_pel_2_
[B_t3]  ZERO.2     B_pel_2_

        SHL.2      B_pel_3,     8,          B_pel_3_
        AND.2X     B_pel_3,     A_nff,      B_t2
        AND.2      B_pel_3,     B_n80,      B_t3
[B_t2]  MPY.2      B_100,       B_ff,       B_pel_3_
[B_t3]  ZERO.2     B_pel_3_
        ADD        B_pel_2_,    B_pel_3_,   B_pel_32

        STH.D1T1   A_pel_10,    *A_out_data_a++[2]
        STH.D2T2   B_pel_32,    *B_out_data_b++[2]

[B_j]   SUB.2      B_j,         4,          B_j
[B_j]   B          LOOP_X

        .return
        .endproc
*==============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*==============================================================================*
quantize.sa/    1066929162  0     0     0       22486     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Mon Mar  4 02:24:15 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_quantize -- Matrix Quantization w/ Rounding, Little Endian      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Dec-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_quantize                                                   *
*       (                                                                   *
*           short       *data,      /* Data to be quantized.        */      *
*           int         num_blks,   /* Number of 64-element blocks. */      *
*           int         blk_sz,     /* Block size (multiple of 16). */      *
*           const short *recip_tbl, /* Quant. values (reciprocals). */      *
*           int         q_pt        /* Q-point of Quant values.     */      *
*       )                                                                   *
*                                                                           *
*       The number of blocks, num_blks, must be at least 1.  The block      *
*       size (number of elements in each block) must be at least 16,        *
*       and a multiple of 16.  The Q-point, q_pt, controls rounding and     *
*       final truncation; it must be in the range from 0 <= q_pt <= 31.     *
*                                                                           *
*       Both input arrays, data[] and recip_tbl[], must be word aligned.    *
*       The data[] array must be 'num_blks * blk_sz' elements, and the      *
*       recip_tbl[] array must be 'blk_sz' elements.                        *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_quantize() quantizes matrices by multiplying their *
*       contents with a second matrix that contains reciprocals of the      *
*       quantization terms.  This step corresponds to the quantization      *
*       that is performed in 2-D DCT-based compression techniques,          *
*       although IMG_quantize() may be used on any signed 16-bit data using *
*       signed 16-bit quantization terms.                                   *
*                                                                           *
*       IMG_quantize() merely multiplies the contents of the quantization   *
*       matrix with the data being quantized.  Therefore, it may be used    *
*       for inverse quantization as well, by setting the Q-point            *
*       appropriately.                                                      *
*                                                                           *
*       The following C code describes the general implementation of        *
*       IMG_quantize().                                                     *
*                                                                           *
*       void IMG_quantize                                                   *
*       (                                                                   *
*           short       *data,      /* Data to be quantized.        */      *
*           int         num_blks,   /* Number of 64-element blocks. */      *
*           int         blk_size,   /* Block size (multiple of 16). */      *
*           const short *recip_tbl, /* Quant. values (reciprocals). */      *
*           int         q_pt        /* Q-point of Quant values.     */      *
*       )                                                                   *
*       {                                                                   *
*           short recip;                                                    *
*           int i, j, k, quot, round;                                       *
*                                                                           *
*           round = q_pt ? 1 << (q_pt - 1) : 0;                             *
*                                                                           *
*           for (i = 0; i < blk_size; i++)                                  *
*           {                                                               *
*               recip   = recip_tbl[i];                                     *
*               k       = i;                                                *
*               for (j = 0; j < num_blks; j++)                              *
*               {                                                           *
*                   quot    = data[k] * recip + round;                      *
*                   data[k] = quot >> q_pt;                                 *
*                   k      += blk_size;                                     *
*               }                                                           *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code has restrictions, as noted above.  *
*                                                                           *
*   TECHNIQUES                                                              *
*       The outer loop is unrolled 16 times to allow greater amounts        *
*       of work to be performed in the inner loop.                          *
*                                                                           *
*       Reciprocals and data terms are loaded in pairs with word-wide       *
*       loads, making better use of the availably memory bandwidth.         *
*                                                                           *
*       The inner loop steps through individual blocks, while the           *
*       outer loop steps through reciprocals for quantization.  This        *
*       eliminates redundant loads for the quantization terms.              *
*                                                                           *
*       The direction of travel for the inner loop oscillates with each     *
*       iteration of the outer loop to simplify pointer updating in the     *
*       outer loop and reduce register pressure.  (eg.  in the first iter.  *
*       of the outer loop, the inner loop steps forward through memory; in  *
*       the second iter. of the outer loop, the inner loop steps backwards  *
*       through memory, etc.)                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The recip_tbl[] and data[] must be word aligned.                    *
*       The block size, blk_sz, must be a multiple of 16.                   *
*       The number of blocks, num_blks, must be at least 1.                 *
*       The Q-point, q_pt, must be in the range 0 <= q_pt <= 31.            *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts should occur, regardless of the relative          *
*       orientation of r_tbl[] and data[].                                  *
*                                                                           *
*   NOTES                                                                   *
*       Interrupts are disabled throughout most of the function.            *
*       Input arrays must be word-aligned for correct operation.            *
*       No checking is performed on the input arguments for correctness.    *
*                                                                           *
*   SOURCE                                                                  *
*       n/a                                                                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

                .sect ".data:copyright_h"

        .sect ".text:_quantize"
        .global _IMG_quantize
_IMG_quantize       .cproc  A_data, B_num_blks, A_blk_sz, B_r_tbl, A_q_pt
                   .no_mdep

; ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== ;
        .reg    A_i                             ; Outer loop counter
        .reg    B_j                             ; Inner loop counter
        .reg    A_shift                         ; q_pt - 1
        .reg    B_r_ptr, A_r_ptr                ; Reciprocal table pointers
        .reg    B_di_ptr, A_di_ptr              ; data[] pointer, input
        .reg    B_do_ptr, A_do_ptr              ; data[] pointer, output
        .reg    B_r_FE, A_r_DC, B_r_BA, A_r_98  ; Reciprocal terms 15 .. 8
        .reg    B_r_76, A_r_54, B_r_32, A_r_10  ; Reciprocal terms  7 .. 0
        .reg    B_d_FE, A_d_DC, B_d_BA, A_d_98  ; Data terms 15 .. 8
        .reg    B_d_76, A_d_54, B_d_32, A_d_10  ; Data terms  7 .. 0
        .reg    B_qp_F, B_qp_E, A_qp_D, A_qp_C  ; Quotient (product) 15 .. 12
        .reg    B_qp_B, B_qp_A, A_qp_9, A_qp_8  ; Quotient (product) 11 ..  8
        .reg    B_qp_7, B_qp_6, A_qp_5, A_qp_4  ; Quotient (product)  7 ..  4
        .reg    B_qp_3, B_qp_2, A_qp_1, A_qp_0  ; Quotient (product)  3 ..  0
        .reg    B_qr_F, B_qr_E, A_qr_D, A_qr_C  ; Quotient (rounded) 15 .. 12
        .reg    B_qr_B, B_qr_A, A_qr_9, A_qr_8  ; Quotient (rounded) 11 ..  8
        .reg    B_qr_7, B_qr_6, A_qr_5, A_qr_4  ; Quotient (rounded)  7 ..  4
        .reg    B_qr_3, B_qr_2, A_qr_1, A_qr_0  ; Quotient (rounded)  3 ..  0
        .reg    B_qt_F, B_qt_E, A_qt_D, A_qt_C  ; Quotient (trunc'd) 15 .. 12
        .reg    B_qt_B, B_qt_A, A_qt_9, A_qt_8  ; Quotient (trunc'd) 11 ..  8
        .reg    B_qt_7, B_qt_6, A_qt_5, A_qt_4  ; Quotient (trunc'd)  7 ..  4
        .reg    B_qt_3, B_qt_2, A_qt_1, A_qt_0  ; Quotient (trunc'd)  3 ..  0
        .reg    B_rnd,  A_rnd                   ; Rounding term, 1 << (q_pt-1)
        .reg    B_q_pt                          ; Q-point
        .reg    B_fix_w, A_fix_w                ; Block-to-block pointer fixup
        .reg    B_fix_h, A_fix_h                ; Block-to-block pointer fixup
; ========================================================================= ;

        ; Initialize data[] pointers
        MV      .1      A_data,     A_di_ptr
        ADD     .2X     A_data,     4,          B_di_ptr
        MV      .1      A_di_ptr,   A_do_ptr
        MV      .2      B_di_ptr,   B_do_ptr

        ; Initialize r_tbl[] pointers
        MV      .1X     B_r_tbl,    A_r_ptr
        ADD     .2      B_r_tbl,    4,          B_r_ptr

        MV      .2X     A_q_pt,     B_q_pt

        ; Initialize rounding term
        SUB     .1      A_q_pt,     1,          A_shift
        MVK     .1      1,          A_rnd
        SHL     .1      A_rnd,      A_shift,    A_rnd     ; rnd = 1<<(q_pt-1)
        MV      .2X     A_rnd,      B_rnd

        ; Initialize outer loop count
        SHR     .1      A_blk_sz,   4,          A_i       ; i = blk_sz >> 4

        .mptr           B_r_ptr,    r_tbl+4,    32
        .mptr           A_r_ptr,    r_tbl+0,    32

        ; Initialize block-to-block fixup pointers.
        MV      .1      A_blk_sz,   A_fix_h
        MV      .2X     A_blk_sz,   B_fix_h
        SHR             A_fix_h,    1,          A_fix_w
        SHR             B_fix_h,    1,          B_fix_w

i_loop:
        LDW     .D2T2   *+B_r_ptr  [6],         B_r_FE    ; Recip 15, 14
        LDW     .D1T1   *+A_r_ptr  [6],         A_r_DC    ; Recip 13, 12
        LDW     .D2T2   *+B_r_ptr  [4],         B_r_BA    ; Recip 11, 10
        LDW     .D1T1   *+A_r_ptr  [4],         A_r_98    ; Recip  9,  8
        LDW     .D2T2   *+B_r_ptr  [2],         B_r_76    ; Recip  7,  6
        LDW     .D1T1   *+A_r_ptr  [2],         A_r_54    ; Recip  5,  4
        LDW     .D2T2   * B_r_ptr++[8],         B_r_32    ; Recip  3,  2
        LDW     .D1T1   * A_r_ptr++[8],         A_r_10    ; Recip  1,  0

        MV      .2      B_num_blks, B_j                   ; j = num_blks

        .mptr           B_di_ptr,   d_tbl+4,    32
        .mptr           A_di_ptr,   d_tbl+0,    32
        .mptr           B_do_ptr,   d_tbl+4,    32
        .mptr           A_do_ptr,   d_tbl+0,    32

j_loop:
        LDW     .D2T2   *+B_di_ptr  [6],        B_d_FE    ; Data 15, 14
        LDW     .D1T1   *+A_di_ptr  [6],        A_d_DC    ; Data 13, 12
        LDW     .D2T2   *+B_di_ptr  [4],        B_d_BA    ; Data 11, 10
        LDW     .D1T1   *+A_di_ptr  [4],        A_d_98    ; Data  9,  8
        LDW     .D2T2   *+B_di_ptr  [2],        B_d_76    ; Data  7,  6
        LDW     .D1T1   *+A_di_ptr  [2],        A_d_54    ; Data  5,  4
        LDW     .D2T2   * B_di_ptr++[B_fix_w],  B_d_32    ; Data  3,  2
        LDW     .D1T1   * A_di_ptr++[A_fix_w],  A_d_10    ; Data  1,  0

        MPYH    .2      B_r_FE,     B_d_FE,     B_qp_F    ; qp_F = r_F * d_F
        MPY     .2      B_r_FE,     B_d_FE,     B_qp_E    ; qp_E = r_E * d_E
        MPYH    .1      A_r_DC,     A_d_DC,     A_qp_D    ; qp_D = r_D * d_D
        MPY     .1      A_r_DC,     A_d_DC,     A_qp_C    ; qp_C = r_C * d_C
        MPYH    .2      B_r_BA,     B_d_BA,     B_qp_B    ; qp_B = r_B * d_B
        MPY     .2      B_r_BA,     B_d_BA,     B_qp_A    ; qp_A = r_A * d_A
        MPYH    .1      A_r_98,     A_d_98,     A_qp_9    ; qp_9 = r_9 * d_9
        MPY     .1      A_r_98,     A_d_98,     A_qp_8    ; qp_8 = r_8 * d_8
        MPYH    .2      B_r_76,     B_d_76,     B_qp_7    ; qp_7 = r_7 * d_7
        MPY     .2      B_r_76,     B_d_76,     B_qp_6    ; qp_6 = r_6 * d_6
        MPYH    .1      A_r_54,     A_d_54,     A_qp_5    ; qp_5 = r_5 * d_5
        MPY     .1      A_r_54,     A_d_54,     A_qp_4    ; qp_4 = r_4 * d_4
        MPYH    .2      B_r_32,     B_d_32,     B_qp_3    ; qp_3 = r_3 * d_3
        MPY     .2      B_r_32,     B_d_32,     B_qp_2    ; qp_2 = r_2 * d_2
        MPYH    .1      A_r_10,     A_d_10,     A_qp_1    ; qp_1 = r_1 * d_1
        MPY     .1      A_r_10,     A_d_10,     A_qp_0    ; qp_0 = r_0 * d_0

        ADD     .2      B_qp_F,     B_rnd,      B_qr_F    ; qr_F = qp_F + rnd
        ADD     .2      B_qp_E,     B_rnd,      B_qr_E    ; qr_E = qp_E + rnd
        ADD     .1      A_qp_D,     A_rnd,      A_qr_D    ; qr_D = qp_D + rnd
        ADD     .1      A_qp_C,     A_rnd,      A_qr_C    ; qr_C = qp_C + rnd
        ADD     .2      B_qp_B,     B_rnd,      B_qr_B    ; qr_B = qp_B + rnd
        ADD     .2      B_qp_A,     B_rnd,      B_qr_A    ; qr_A = qp_A + rnd
        ADD     .1      A_qp_9,     A_rnd,      A_qr_9    ; qr_9 = qp_9 + rnd
        ADD     .1      A_qp_8,     A_rnd,      A_qr_8    ; qr_8 = qp_8 + rnd
        ADD     .2      B_qp_7,     B_rnd,      B_qr_7    ; qr_7 = qp_7 + rnd
        ADD     .2      B_qp_6,     B_rnd,      B_qr_6    ; qr_6 = qp_6 + rnd
        ADD     .1      A_qp_5,     A_rnd,      A_qr_5    ; qr_5 = qp_5 + rnd
        ADD     .1      A_qp_4,     A_rnd,      A_qr_4    ; qr_4 = qp_4 + rnd
        ADD     .2      B_qp_3,     B_rnd,      B_qr_3    ; qr_3 = qp_3 + rnd
        ADD     .2      B_qp_2,     B_rnd,      B_qr_2    ; qr_2 = qp_2 + rnd
        ADD     .1      A_qp_1,     A_rnd,      A_qr_1    ; qr_1 = qp_1 + rnd
        ADD     .1      A_qp_0,     A_rnd,      A_qr_0    ; qr_0 = qp_0 + rnd

        SHR     .2      B_qr_F,     B_q_pt,     B_qt_F    ; qt_F = qr_F >> q_pt
        SHR     .2      B_qr_E,     B_q_pt,     B_qt_E    ; qt_E = qr_E >> q_pt
        SHR     .1      A_qr_D,     A_q_pt,     A_qt_D    ; qt_D = qr_D >> q_pt
        SHR     .1      A_qr_C,     A_q_pt,     A_qt_C    ; qt_C = qr_C >> q_pt
        SHR     .2      B_qr_B,     B_q_pt,     B_qt_B    ; qt_B = qr_B >> q_pt
        SHR     .2      B_qr_A,     B_q_pt,     B_qt_A    ; qt_A = qr_A >> q_pt
        SHR     .1      A_qr_9,     A_q_pt,     A_qt_9    ; qt_9 = qr_9 >> q_pt
        SHR     .1      A_qr_8,     A_q_pt,     A_qt_8    ; qt_8 = qr_8 >> q_pt
        SHR     .2      B_qr_7,     B_q_pt,     B_qt_7    ; qt_7 = qr_7 >> q_pt
        SHR     .2      B_qr_6,     B_q_pt,     B_qt_6    ; qt_6 = qr_6 >> q_pt
        SHR     .1      A_qr_5,     A_q_pt,     A_qt_5    ; qt_5 = qr_5 >> q_pt
        SHR     .1      A_qr_4,     A_q_pt,     A_qt_4    ; qt_4 = qr_4 >> q_pt
        SHR     .2      B_qr_3,     B_q_pt,     B_qt_3    ; qt_3 = qr_3 >> q_pt
        SHR     .2      B_qr_2,     B_q_pt,     B_qt_2    ; qt_2 = qr_2 >> q_pt
        SHR     .1      A_qr_1,     A_q_pt,     A_qt_1    ; qt_1 = qr_1 >> q_pt
        SHR     .1      A_qr_0,     A_q_pt,     A_qt_0    ; qt_0 = qr_0 >> q_pt

        STH     .D2T2   B_qt_F,     *+B_do_ptr  [13]      ; Quotient 15
        STH     .D2T2   B_qt_E,     *+B_do_ptr  [12]      ; Quotient 14
        STH     .D1T1   A_qt_D,     *+A_do_ptr  [13]      ; Quotient 13
        STH     .D1T1   A_qt_C,     *+A_do_ptr  [12]      ; Quotient 12
        STH     .D2T2   B_qt_B,     *+B_do_ptr  [ 9]      ; Quotient 11
        STH     .D2T2   B_qt_A,     *+B_do_ptr  [ 8]      ; Quotient 10
        STH     .D1T1   A_qt_9,     *+A_do_ptr  [ 9]      ; Quotient  9
        STH     .D1T1   A_qt_8,     *+A_do_ptr  [ 8]      ; Quotient  8
        STH     .D2T2   B_qt_7,     *+B_do_ptr  [ 5]      ; Quotient  7
        STH     .D2T2   B_qt_6,     *+B_do_ptr  [ 4]      ; Quotient  6
        STH     .D1T1   A_qt_5,     *+A_do_ptr  [ 5]      ; Quotient  5
        STH     .D1T1   A_qt_4,     *+A_do_ptr  [ 4]      ; Quotient  4
        STH     .D2T2   B_qt_3,     *+B_do_ptr  [ 1]      ; Quotient  3
        STH     .D2T2   B_qt_2,     * B_do_ptr++[B_fix_h] ; Quotient  2
        STH     .D1T1   A_qt_1,     *+A_do_ptr  [ 1]      ; Quotient  1
        STH     .D1T1   A_qt_0,     * A_do_ptr++[A_fix_h] ; Quotient  0

        SUB     .2      B_j,        1,          B_j       ; j--
 [B_j]  B               j_loop                            ; while (j)

        ; Reverse inner loop's pointer direction
        NEG     .2      B_fix_h,    B_fix_h
        NEG     .1      A_fix_h,    A_fix_h
        NEG     .2      B_fix_w,    B_fix_w
        NEG     .1      A_fix_w,    A_fix_w

        ; Point to next set of inputs in data[] array.
        ADDAW   .2      B_di_ptr,   8,          B_di_ptr
        ADDAW   .1      A_di_ptr,   8,          A_di_ptr

        ADDAH   .2      B_di_ptr,   B_fix_h,    B_di_ptr
        ADDAH   .1      A_di_ptr,   A_fix_h,    A_di_ptr

        MV      .2      B_di_ptr,   B_do_ptr
        MV      .1      A_di_ptr,   A_do_ptr

        ; Iterate
        SUB     .1      A_i,        1,          A_i       ; i--
 [A_i]  B               i_loop                            ; while (i)

        .return
        .endproc

* ========================================================================= *
*   End of file:  img_quantize.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
sad_16x16.sa/   1066929162  0     0     0       7657      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Mon Mar  4 02:24:15 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_sad_16x16 -- Sum of Absolute Differences on single 16x16 block  *
*                                                                           *
*   USAGE                                                                   *
*       unsigned IMG_sad_16x16                                              *
*       (                                                                   *
*           const unsigned char *restrict srcImg,  /* 16x16 source block */ *
*           const unsigned char *restrict refImg,  /* Reference image    */ *
*           int pitch                              /* Width of ref image */ *
*       );                                                                  *
*                                                                           *
*       The code accepts a pointer to the 16x16 source block (srcImg),      *
*       and a pointer to the upper-left corner of a target position in      *
*       a reference image (refImg).  The width of the reference image       *
*       is given by the pitch argument.                                     *
*                                                                           *
*       The function returns the sum of the absolute differences            *
*       between the source block and the 16x16 region pointed to in the     *
*       reference image.                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       The algorithm takes the difference between the pixel values in      *
*       the source image block and the corresponding pixels in the          *
*       reference image.  It then takes the absolute values of these        *
*       differences, and accumulates them over the entire 16x16 region.     *
*       It returns the final accumulation.                                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       No alignment restrictions.                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_sad_16x16"
        .global _IMG_sad_16x16
_IMG_sad_16x16   .cproc A_srcImg, B_refImg, A_pitch
                .no_mdep

            .reg            B_sad, A_sad
            .reg            i,  j, j_init, B_p
            .reg            B_srcImg, A_refImg
            .reg            A_d3, B_d2, B_d1, A_d0
            .reg            A_a3, B_a2, B_a1, A_a0
            .reg            A_sp3, B_sp2, B_sp1, A_sp0
            .reg            A_rp3, B_rp2, B_rp1, A_rp0

            ZERO    .2      B_sad
            ZERO    .1      A_sad
                            ;           ;           ;
            ADD     .2X     A_srcImg,   2,          B_srcImg
            SUB     .2X     A_pitch,    16,         B_p

            MVK             64,         i
            MVK             0x2000,     j_init
            ZERO            j

            .mptr           B_srcImg,   src + 2,    4
            .mptr           A_srcImg,   src + 0,    4
            .mptr           B_refImg,   ref + 2,    4
            .mptr           A_refImg,   ref + 0,    4
loop:       .trip           64, 64, 64
            LDBU    .D2T1   *B_srcImg[1],   A_sp3
            LDBU    .D2T2   *B_srcImg++[4], B_sp2
            LDBU    .D1T2   *A_srcImg[1],   B_sp1
            LDBU    .D1T1   *A_srcImg++[4], A_sp0

            ADD     .1X     B_refImg,   2,          A_refImg
            LDBU    .D1T1   *A_refImg[1],   A_rp3
            LDBU    .D1T2   *A_refImg++[4], B_rp2
            LDBU    .D2T2   *B_refImg[1],   B_rp1
            LDBU    .D2T1   *B_refImg++[4], A_rp0

    [!j]    MPY             j_init,     1,          j
            MPY             j,          2,          j
    [!j]    ADD             B_refImg,   B_p,        B_refImg

            SUB             A_sp3,      A_rp3,      A_d3
            SUB             B_sp2,      B_rp2,      B_d2
            SUB             B_sp1,      B_rp1,      B_d1
            SUB             A_sp0,      A_rp0,      A_d0

            ABS             A_d3,       A_a3
            ABS             B_d2,       B_a2
            ABS             B_d1,       B_a1
            ABS             A_d0,       A_a0

            ADD             A_sad,      A_a3,       A_sad
            ADD             B_sad,      B_a2,       B_sad
            ADD             B_sad,      B_a1,       B_sad
            ADD             A_sad,      A_a0,       A_sad

            SUB             i,          1,          i
    [i]     B               loop

            ADD             B_sad,      A_sad,      A_sad

            .return         A_sad
            .endproc

* ========================================================================= *
*   End of file: img_sad_16x16.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

sad_8x8.sa/     1066929162  0     0     0       7559      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Mon Mar  4 02:24:15 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_sad_8x8   -- Sum of Absolute Differences on single 8x8 block    *
*                                                                           *
*   USAGE                                                                   *
*       unsigned IMG_sad_8x8                                                *
*       (                                                                   *
*           const unsigned char *restrict srcImg,  /* 8x8 source block   */ *
*           const unsigned char *restrict refImg,  /* Reference image    */ *
*           int pitch                              /* Width of ref image */ *
*       );                                                                  *
*                                                                           *
*       The code accepts a pointer to the 8x8 source block (srcImg),        *
*       and a pointer to the upper-left corner of a target position in      *
*       a reference image (refImg).  The width of the reference image       *
*       is given by the pitch argument.                                     *
*                                                                           *
*       The function returns the sum of the absolute differences            *
*       between the source block and the 8x8 region pointed to in the       *
*       reference image.                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       The algorithm takes the difference between the pixel values in      *
*       the source image block and the corresponding pixels in the          *
*       reference image.  It then takes the absolute values of these        *
*       differences, and accumulates them over the entire 8x8 region.       *
*       It returns the final accumulation.                                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       No alignment restrictions.                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_sad_8x8"
        .global _IMG_sad_8x8
_IMG_sad_8x8     .cproc A_srcImg, B_refImg, A_pitch
                .no_mdep

            .reg            B_sad, A_sad
            .reg            i,  B_p, B_q
            .reg            B_srcImg, A_refImg
            .reg            A_d3, B_d2, B_d1, A_d0
            .reg            A_a3, B_a2, B_a1, A_a0
            .reg            A_sp3, B_sp2, B_sp1, A_sp0
            .reg            A_rp3, B_rp2, B_rp1, A_rp0

            ZERO    .2      B_sad
            ZERO    .1      A_sad
                            ;           ;           ;
            ADD     .2X     A_srcImg,   2,          B_srcImg
            SUB     .2X     A_pitch,    4,          B_p

            MVK             16,         i
            XOR             B_p,        4,          B_p
            MVK             4,          B_q


            .mptr           B_srcImg,   src + 2,    4
            .mptr           A_srcImg,   src + 0,    4
            .mptr           B_refImg,   ref + 2,    4
            .mptr           A_refImg,   ref + 0,    4
loop:       .trip           16, 16, 16
            LDBU    .D2T1   *B_srcImg[1],   A_sp3
            LDBU    .D2T2   *B_srcImg++[4], B_sp2
            LDBU    .D1T2   *A_srcImg[1],   B_sp1
            LDBU    .D1T1   *A_srcImg++[4], A_sp0

            ADD     .1X     B_refImg,   2,          A_refImg
            LDBU    .D1T1   *A_refImg[1],   A_rp3
            LDBU    .D1T2   *A_refImg++[4], B_rp2
            LDBU    .D2T2   *B_refImg[1],   B_rp1
            LDBU    .D2T1   *B_refImg++[B_q], A_rp0

            XOR             B_q,        B_p,        B_q

            SUB             A_sp3,      A_rp3,      A_d3
            SUB             B_sp2,      B_rp2,      B_d2
            SUB             B_sp1,      B_rp1,      B_d1
            SUB             A_sp0,      A_rp0,      A_d0

            ABS             A_d3,       A_a3
            ABS             B_d2,       B_a2
            ABS             B_d1,       B_a1
            ABS             A_d0,       A_a0

            ADD             A_sad,      A_a3,       A_sad
            ADD             B_sad,      B_a2,       B_sad
            ADD             B_sad,      B_a1,       B_sad
            ADD             A_sad,      A_a0,       A_sad

            SUB   .1        i,          1,          i
    [i]     B     .2        loop

            ADD             B_sad,      A_sad,      A_sad

            .return         A_sad
            .endproc

* ========================================================================= *
*   End of file: img_sad_8x8.sa                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

sobel.sa/       1066929162  0     0     0       30995     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Thu Apr 18 01:36:43 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_sobel, Little Endian.                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       12-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_sobel                                                      *
*       (                                                                   *
*           const unsigned char    *in_data,      /* Input image data  */   *
*           unsigned char *restrict out_data,     /* Output image data */   *
*           short cols, short rows                /* Image dimensions  */   *
*       );                                                                  *
*                                                                           *
*       The IMG_sobel filter is applied to the input image. The input image *
*       dimensions are given by the arguments 'cols' and 'rows'.  The       *
*       output image is 'cols' pixels wide and 'rows - 2' pixels tall.      *
*                                                                           *
*   DESCRIPTION                                                             *
*       To see how the implementation is going to work on the input         *
*       buffer, lets imagine we have the following input buffer:            *
*       lets imagine we have the following input buffer:                    *
*                                                                           *
*               yyyyyyyyyyyyyyyy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yyyyyyyyyyyyyyyy                                            *
*                                                                           *
*       The output buffer would be:                                         *
*                                                                           *
*               tXXXXXXXXXXXXXXz                                            *
*               zXXXXXXXXXXXXXXz                                            *
*               zXXXXXXXXXXXXXXz                                            *
*               zXXXXXXXXXXXXXXt                                            *
*                                                                           *
*       Where:                                                              *
*                                                                           *
*           X = IMG_sobel(x)    The algorithm is applied to that pixel.     *
*                           The correct output is obtained, the data        *
*                           around the pixels we work on is used            *
*                                                                           *
*           t               Whatever was in the output buffer in that       *
*                           position is kept there.                         *
*                                                                           *
*           z = IMG_sobel(y)    The algorithm is applied to that pixel.     *
*                           The output is not meaningful, because the       *
*                           necessary data to process the pixel is not      *
*                           available.  This is because for each output     *
*                           pixel we need input pixels from the right and   *
*                           from the left of the output pixel.  But this    *
*                           data doesn't exist.                             *
*                                                                           *
*       This means that we will only process (rows-2) lines.  Then, we      *
*       will process all the pixels inside each line. Even though the       *
*       results for the first and last pixels in each line will not         *
*       be relevant, it makes the control much simpler and ends up          *
*       saving cycles.                                                      *
*                                                                           *
*       Also the fist pixel in the first processed line and the             *
*       last pixel in the last processed line will not be computed.         *
*       It is not necessary, since the results would be bogus, and          *
*       not computing them saves some time.                                 *
*                                                                           *
*       The following horizontal and vertical masks that are                *
*       applied to the input buffer to obtain one output pixel.             *
*                                                                           *
*           Horizontal:                                                     *
*               -1 -2 -1                                                    *
*                0  0  0                                                    *
*                1  2  1                                                    *
*                                                                           *
*           Vertical:                                                       *
*               -1  0  1                                                    *
*               -2  0  2                                                    *
*               -1  0  1                                                    *
*                                                                           *
*   C CODE                                                                  *
*       This is a C model of the Sobel implementation.  This C code         *
*       is functionally equivalent to the assembly code without             *
*       restrictions.   The assembly code may impose additional             *
*       restrictions.                                                       *
*                                                                           *
*           void IMG_sobel                                                  *
*           (                                                               *
*               const unsigned char *in_data,  /* Input image data  */      *
*               unsigned char       *out_data, /* Output image data */      *
*               short cols, short rows         /* Image dimensions  */      *
*           )                                                               *
*           {                                                               *
*               /* ------------------------------------------------ */      *
*               /*  Intermediate values.                            */      *
*               /* ------------------------------------------------ */      *
*               int H;    /* Horizontal mask result                 */      *
*               int V;    /* Vertical mask result                   */      *
*               int O;    /* Sum of horizontal and vertical masks   */      *
*               int i;    /* Input pixel offset                     */      *
*               int o;    /* Output pixel offset.                   */      *
*               int xy;   /* Loop counter.                          */      *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Input values.                                   */      *
*               /* ------------------------------------------------ */      *
*               int i00, i01, i02;                                          *
*               int i10,      i12;                                          *
*               int i20, i21, i22;                                          *
*               const unsigned char *in = in_data; /* shorthand */          *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Step through the entire image.  We step         */      *
*               /*  through 'rows - 2' rows in the output image,    */      *
*               /*  since those are the only rows that are fully    */      *
*               /*  defined for our filter.                         */      *
*               /* ------------------------------------------------ */      *
*               for (xy = 0, i = cols + 1, o = 1;                           *
*                    xy < cols*(rows-2) - 2;                                *
*                    xy++, i++, o++)                                        *
*               {                                                           *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Read necessary data to process an input     */      *
*                   /*  pixel.  The following instructions are      */      *
*                   /*  written to reflect the position of the      */      *
*                   /*  input pixels in reference to the pixel      */      *
*                   /*  being processed, which would correspond     */      *
*                   /*  to the blank space left in the middle.      */      *
*                   /* -------------------------------------------- */      *
*                   i00=in[i-cols-1]; i01=in[i-cols]; i02=in[i-cols+1];     *
*                   i10=in[i     -1];                 i12=in[i     +1];     *
*                   i20=in[i+cols-1]; i21=in[i+cols]; i22=in[i+cols+1];     *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Apply the horizontal mask.                  */      *
*                   /* -------------------------------------------- */      *
*                   H = -i00 - 2*i01 -   i02 +   i20 + 2*i21 + i22;         *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Apply the vertical mask.                    */      *
*                   /* -------------------------------------------- */      *
*                   V = -i00 +   i02 - 2*i10 + 2*i12 -   i20 + i22;         *
*                                                                           *
*                   O = abs(H) + abs(V);                                    *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  If the result is over 255 (largest valid    */      *
*                   /*  pixel value), saturate (clamp) to 255.      */      *
*                   /* -------------------------------------------- */      *
*                   if (O > 255) O = 255;                                   *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Store the result.                           */      *
*                   /* -------------------------------------------- */      *
*                   out_data[o] = O;                                        *
*               }                                                           *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       At least eight output pixels must be processed.                     *
*       The image arrays must be half-word aligned.                         *
*       The input image width must be even (eg. 'cols' must be even).       *
*                                                                           *
*   NOTES                                                                   *
*       This is a LITTLE ENDIAN implementation.                             *
*                                                                           *
*       The values of the left-most and right-most pixels on each line      *
*       of the output are not well-defined.                                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_sobel"
        .global _IMG_sobel
_IMG_sobel:.cproc A_ip, B_op, A_w, B_h
            .no_mdep
            .reg A_MFF            ;  Constant, 0x000000FF
            .reg A_7FFFFF00       ;  Constant, 0x7FFFFF00

            .reg A_wD2            ;  A_w/2, offset for pointers


            ; ============================================================= ;
            ;   Input values.                                               ;
            ; ============================================================= ;
            .reg        B_DC3, A_DC2, B_DC1
            .reg        A_BA3, A_BA2, A_BA1

            ; ============================================================= ;
            ;   Individual pixels.                                          ;
            ; ============================================================= ;
            .reg        A_A3, A_A2, A_A1, B_B3, B_B2, B_B1
            .reg        A_C3, A_C2, A_C1, B_D3, B_D2, B_D1


            ; ============================================================= ;
            ;    Intermediate values for the vertical masks for each column ;
            ; ============================================================= ;
            .reg A_Av_
            .reg B_Bv_
            .reg A_Cv_
            .reg B_Dv_


            ; ============================================================= ;
            ;    Values for the vertical and horizontal masks for each      ;
            ;    column (Column A, B, C and D, each one to the right of the ;
            ;    last).                                                     ;
            ; ============================================================= ;
            .reg A_Av, A_Ah, A_Cv, A_Ch
            .reg B_Bv, B_Bh, B_Dv, B_Dh, A_Bh

            ; ============================================================= ;
            ;    Intermediate values for the horizontal masks.              ;
            ; ============================================================= ;
            .reg A_hmask_, B_hmask_

            ; ============================================================= ;
            ;    Intermediate values.  They are the pixels multiplied by 2  ;
            ; ============================================================= ;
            .reg A_A2x2
            .reg B_B2x2
            .reg A_C2x2
            .reg B_D2x2
            .reg B_Chx2

            ; ============================================================= ;
            ;    Partial results for the masks.                             ;
            ; ============================================================= ;
            .reg A_vmask
            .reg A_hmask
            .reg B_vmask
            .reg B_hmask

            ; ============================================================= ;
            ;    Absolute values of the above results.                      ;
            ; ============================================================= ;
            .reg A_vABS
            .reg A_hABS
            .reg B_vABS
            .reg B_hABS

            ; ============================================================= ;
            ;    Final results as they are going to be stored.              ;
            ; ============================================================= ;
            .reg A_mask_, A_mask
            .reg B_mask_, B_mask

            ; ============================================================= ;
            ;    Conditional registers for coping with overflow.            ;
            ; ============================================================= ;
            .reg A_se, B_se

            .reg B_cnt          ;  Loop counter



            ; ============================================================= ;
            ;   Setting up shifting and masking values that will be used    ;
            ;   through out the kernel.                                     ;
            ; ============================================================= ;
            MVKL    .1  0xFF,                   A_MFF
            MVKH    .1  0xFF,                   A_MFF


            MVKL    .1  0x7FFFFF00,             A_7FFFFF00
            MVKH    .1  0x7FFFFF00,             A_7FFFFF00



            ; ============================================================= ;
            ;   A_wD2 and A_w  will be used as offsets for the input pointer;
            ;                                                               ;
            ;   With the same input pointer we have to acces a pixel in     ;
            ;   column l from row i, another in column l from row i+1       ;
            ;   (for that A_wD2 will be used) and another in column l from  ;
            ;   row i+2 (A_w).                                              ;
            ; ============================================================= ;
            SHRU    .1  A_w,        1,          A_wD2

            SUB     .2  B_h,        2,          B_h
            MPY     .2x A_w,        B_h,        B_cnt
            SUB     .2  B_cnt,      2,          B_cnt
            SHRU    .2  B_cnt,      1,          B_cnt


            ; ============================================================= ;
            ;   The two first pixels from three first lines in the input    ;
            ;   buffer are read.                                            ;
            ;                                                               ;
            ;   If we represent the input buffer using the names used in    ;
            ;   the kernel:                                                 ;
            ;                                                               ;
            ;   A_A1   B_B1   A_C1   B_D1   ...                             ;
            ;   A_A2   B_B2   A_C2   B_D2   ...                             ;
            ;   A_A3   B_B3   A_C3   B_D3   ...                             ;
            ;   .      .      .      .      ...                             ;
            ;   .      .      .      .      ...                             ;
            ;   .      .      .      .      ...                             ;
            ;                                                               ;
            ;   Here we read the pixel in half word, and then separate them ;
            ;   to have them in different registers.                        ;
            ; ============================================================= ;
            LDHU    .1   *+A_ip[A_w],            A_BA3
            LDHU    .1   *+A_ip[A_wD2],          A_BA2
            LDHU    .1   *A_ip++[1],            A_BA1

            SHRU    .2  A_BA3,      8,          B_B3
            SHRU    .2  A_BA2,      8,          B_B2
            SHRU    .2  A_BA1,      8,          B_B1

            AND     .1  A_BA3,      A_MFF,      A_A3
            AND     .1  A_BA2,      A_MFF,      A_A2
            AND     .1  A_BA1,      A_MFF,      A_A1

            ; ============================================================= ;
            ;   To all the columns we read (inside and outside the inner    ;
            ;   loop) we are going to apply the following process:          ;
            ;                                                               ;
            ;   -X1 + X3        = v  (v = Vertical procedure)               ;
            ;   X1 + 2*X2 + X3  = h  (h = Horizontal procedure)             ;
            ;                                                               ;
            ;   With A_Av we make reference to the v procedure applied to   ;
            ;   the column A, with A_Ah we refer to the h procedure applied ;
            ;   to the column A.  The same goes for column B (which is read ;
            ;   here) and also for all the other columns that will be read  ;
            ;   after words.                                                ;
            ; ============================================================= ;
            MPY     .1  A_A2,       2,          A_A2x2
            ADD     .1  A_A3,       A_A1,       A_Av_
            ADD     .1  A_Av_,      A_A2x2,     A_Av

            SUB     .1  A_A3,       A_A1,       A_Ah

            MPY     .2  B_B2,       2,          B_B2x2
            ADD     .2  B_B3,       B_B1,       B_Bv_
            ADD     .2  B_Bv_,      B_B2x2,     B_Bv

            SUB     .2  B_B3,       B_B1,       B_Bh
            MV      .1X B_Bh,       A_Bh


            .mptr       A_ip,       in + 0,     2
            .mptr       B_op,       out + 0,    2
loop:       .trip      4

            ; ============================================================= ;
            ;   We read two more columns.  We call them column C and column ;
            ;   D.                                                          ;
            ; ============================================================= ;
            LDHU  .D1T2  *+A_ip [A_w],          B_DC3
            LDHU  .D1T1  *+A_ip [A_wD2],        A_DC2
            LDHU  .D1T2  *A_ip++[1],            B_DC1

            SHRU    .2  B_DC3,      8,          B_D3
            SHRU    .2X A_DC2,      8,          B_D2
            SHRU    .2  B_DC1,      8,          B_D1

            AND     .1X B_DC3,      A_MFF,      A_C3
            AND     .1  A_DC2,      A_MFF,      A_C2
            AND     .1X B_DC1,      A_MFF,      A_C1

            ; ============================================================= ;
            ;   The same vertical and horizontal procedures are applied.    ;
            ; ============================================================= ;
            ADD     .1  A_C3,       A_C1,       A_Cv_
            ADDAH   .1  A_Cv_,      A_C2,       A_Cv

            SUB     .1  A_C3,       A_C1,       A_Ch


            ADD     .2  B_D3,       B_D1,       B_Dv_
            ADDAH   .2  B_Dv_,      B_D2,       B_Dv

            SUB     .2  B_D3,       B_D1,       B_Dh

            ; ============================================================= ;
            ;   The first input pixel to be processed is the second pixel   ;
            ;   in column B.  We need to apply the vertical mask.  Based    ;
            ;   on the partial values we already have, it can be computed   ;
            ;   by just subtracting Av from Cv.                             ;
            ; ============================================================= ;
            SUB     .1  A_Cv,       A_Av,       A_vmask

            ; ============================================================= ;
            ;   Here we are computing the horizontal mask.                  ;
            ; ============================================================= ;
            ADD     .1  A_Ah,       A_Ch,       A_hmask_
            ADDAH   .1  A_hmask_,   A_Bh,       A_hmask

            ; ============================================================= ;
            ;   The following calculations are identical to the ones above  ;
            ;   but applied to obtaining the masks needed for the second    ;
            ;   pixel in the C column.                                      ;
            ; ============================================================= ;
            SUB     .2  B_Dv,       B_Bv,       B_vmask

            MPY     .2X A_Ch,       2,          B_Chx2
            ADD     .2X A_Bh,       B_Dh,       B_hmask_
            ADD     .2  B_hmask_,   B_Chx2,     B_hmask

            ; ============================================================= ;
            ;   Once the horizontal and vertical masks are computed for a   ;
            ;   given pixel, we have to add their absolute values to find   ;
            ;   the result.                                                 ;
            ; ============================================================= ;
            ABS     .1  A_vmask,    A_vABS
            ABS     .1  A_hmask,    A_hABS
            ADD     .1  A_vABS,     A_hABS,     A_mask_

            ABS     .2  B_vmask,    B_vABS
            ABS     .2  B_hmask,    B_hABS
            ADD     .2  B_hABS,     B_vABS,     B_mask_

            ; ============================================================= ;
            ;   Due to the fact that we are adding two absolute values, the ;
            ;   result could be greater than 255, that is, not fit in one   ;
            ;   byte.  If this happens we need to truncate the value to     ;
            ;   255.                                                        ;
            ;                                                               ;
            ;   To do this, we look to the second byte in the register.  If ;
            ;   all the bits in the byte are zero, then, there is no over   ;
            ;   flow, and the value stored in A_se (or B_se) will be zero.  ;
            ;   But if the value is greater than 255, it will overflow, and ;
            ;   the value stored in A_se (or B_se) will be greater than     ;
            ;   zero.                                                       ;
            ; ============================================================= ;
            SADD    .1  A_mask_,    A_7FFFFF00, A_mask
            SADD    .2X B_mask_,    A_7FFFFF00, B_mask

            ; ============================================================= ;
            ;   The results are stored.                                     ;
            ; ============================================================= ;
            STB   .D2T1 A_mask,      *B_op[1]
            STB   .D2T2 B_mask,      *++B_op[2]

            ; ============================================================= ;
            ;   The results computed for C and D will be used for the next  ;
            ;   two output pixels, so we move them to A and B.              ;
            ; ============================================================= ;
            MPY     .1  A_Ch,       1,          A_Ah
            MPY     .1  A_Cv,       1,          A_Av
            MPY     .1X B_Dh,       1,          A_Bh
            MPY     .2  B_Dv,       1,          B_Bv

            ; ============================================================= ;
            ;   The counter is decremented by one.                          ;
            ;   This is the loop control.                                   ;
            ; ============================================================= ;
  [B_cnt]   SUB         B_cnt,      1,          B_cnt
  [B_cnt]   B           loop

            .return
            .endproc

* ========================================================================= *
*   End of file:  img_sobel.sa                                              *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

thr_gt2max.sa/  1066929162  0     0     0       28230     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.2     Thu Mar 14 08:31:20 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       threshold                                                           *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       12-Dec-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_gt2max                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     //  Input image data  //      *
*           unsigned char *restrict out_data, //  Output image data //      *
*           short cols, short rows,           //  Image dimensions  //      *
*           unsigned char       threshold     //  Threshold value   //      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are greater than the threshold      *
*       are set to 255 in the output image.                                 *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                  255_|          _________                                 *
*                      |         |                                          *
*                      |         |                                          *
*             O        |         |                                          *
*             U        |         |                                          *
*             T    th _|. . . . .|                                          *
*             P        |        /.                                          *
*             U        |      /  .                                          *
*             T        |    /    .                                          *
*                      |  /      .                                          *
*                    0_|/________.__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2thr,     *
*       and IMG_thr_le2min for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The input and output buffers must be word aligned.                  *
*                                                                           *
*       The total number of pixels rows*cols must be at least               *
*       16 and a multiple of 16.                                            *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loop is unrolled 16 times and the data is maniuplated     *
*       in packed format for speed.                                         *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_thr_gt2max"
        .global _IMG_thr_gt2max
_IMG_thr_gt2max:  .cproc  A_ip, B_op, A_w, B_h, A_th
            .no_mdep
            .reg    A_thth      ; Threshold value copied twice
            .reg    B_thth      ; Copy of the above variable, performace
            .reg    A_thS       ; Thrshold value shifted left
            .reg    A_cnt       ; Loop control variable

            .reg    B_ip        ; Input pointer
            .reg    A_op        ; Output pointer

            .reg    A_MFF00FF   ; Constante, 0xFF00FF
            .reg    B_MFF00FF   ; Copy of the above variable, performance
            .reg    A_MFF00FF00 ; Constant, 0xFF00FF00
            .reg    B_MFF00FF00 ; Copy of the above variable, performance

            .reg    A_DCBAout   ; 1st 4 output pixels for row i, in the
                                ; example buffer we show below these pixels
                                ; would be A_D, A_c, A_B and A_A in this order
            .reg    B_DCBAout   ; 2nd 4 output pixels for row i (B_D, B_C,
                                ; B_B and B_A, in this order)
            .reg    A_HGFEout   ; 3rd 4 output pixels for row i (A_H, A_G,
                                ; A_F and A_E, in this order)
            .reg    B_HGFEout   ; 4th 4 output pixels for row i (B_H, B_G,
                                ; B_F and B_E in this order)

            .reg    A_DCBA      ; 1st 4 pixels of row i read each iteration
                                ; A_D, A_C, A_B and A_A in this order
            .reg    B_DCBA      ; 2nd 4 pixels of row i read each iteration
                                ; B_D, B_C, B_B and B_A in this order
            .reg    A_HGFE      ; 3rd 4 pixels of row i read each iteration
                                ; A_H, A_G, A_F and A_E in this order
            .reg    B_HGFE      ; 4th 4 pixels of row i read each iteration
                                ; B_H, B_G, B_F and B_E in this order

            ; ============================================================= ;
            ;   Each register has 4 bytes.  Each of these bytes is          ;
            ;   represented by a letter or a 0.  If it is represented by a  ;
            ;   letter, that means the pixel to which we have assigned that ;
            ;   letter is stored there.  If it is represented by a 0, that  ;
            ;   means that byte has zeros in it.                            ;
            ; ============================================================= ;
            .reg    A_0C0A
            .reg    A_0DCB
            .reg    A_0D0B
            .reg    A_D0B0
            .reg    B_0C0A
            .reg    B_0DCB
            .reg    B_0D0B
            .reg    B_D0B0
            .reg    A_0G0E
            .reg    A_0HGF
            .reg    A_0H0F
            .reg    A_H0F0
            .reg    B_0G0E
            .reg    B_0HGF
            .reg    B_0H0F
            .reg    B_H0F0

            ; ============================================================= ;
            ;   Each register has 4 bytes.  Each of these bytes is          ;
            ;   represented by a two letters, or a zero or an X.  The X     ;
            ;   means that the result stored in that byte bears no          ;
            ;   importance.  the zero means that byte has zeros in it.      ;
            ;   The two letter (for example CM or AM) represent a byte with ;
            ;   the sign extension resulting from subtracting the           ;
            ;   corresponding pixel (for example C or A) from the th value  ;
            ; ============================================================= ;
            .reg    A_CMXAMX
            .reg    A_DMXBMX
            .reg    A_XCMXAM
            .reg    A_0CM0AM
            .reg    A_DM0BM0
            .reg    B_CMXAMX
            .reg    B_DMXBMX
            .reg    B_XCMXAM
            .reg    B_0CM0AM
            .reg    B_DM0BM0
            .reg    A_GMXEMX
            .reg    A_HMXFMX
            .reg    A_XGMXEM
            .reg    A_0GM0EM
            .reg    A_HM0FM0
            .reg    B_GMXEMX
            .reg    B_HMXFMX
            .reg    B_XGMXEM
            .reg    B_0GM0EM
            .reg    B_HM0FM0

            .reg    A_DMCMBMAM  ; Sign extensions for pixels A_D, A_C, A_B
                                ; and A_A packed
            .reg    B_DMCMBMAM  ; Sign extensions for pixels B_D, B_C, B_B
                                ; and B_A packed
            .reg    A_HMGMFMEM  ; Sign extensions for pixels A_H, A_G, A_F
                                ; and A_E packed
            .reg    B_HMGMFMEM  ; Sign extensions for pixels B_H, B_G, B_F
                                ; and B_E packed


            ; ============================================================= ;
            ;   The following lines define masks that will be used to get   ;
            ;   intermediate results.                                       ;
            ; ============================================================= ;
            MVKL    .1  0xFF00FF,               A_MFF00FF
            MVKH    .1  0xFF00FF,               A_MFF00FF

            MVKL    .2  0xFF00FF,               B_MFF00FF
            MVKH    .2  0xFF00FF,               B_MFF00FF

            MVKL    .1  0xFF00FF00,             A_MFF00FF00
            MVKH    .1  0xFF00FF00,             A_MFF00FF00

            MVKL    .2  0xFF00FF00,             B_MFF00FF00
            MVKH    .2  0xFF00FF00,             B_MFF00FF00


            ; ============================================================= ;
            ;   We are setting the counter, which is the total number of    ;
            ;   pixels, divided by 16.  This is because in each iteration,  ;
            ;   we process 16 pixels.                                       ;
            ;                                                               ;
            ;   Here, instead of dividing by 16, we divide by 4.            ;
            ; ============================================================= ;
            MPY     .1  A_w,        B_h,        A_cnt
            SHRU    .1  A_cnt,      4,          A_cnt

            ; ============================================================= ;
            ;   A_ip is the pointer to the beginning of the input buffer.   ;
            ;   In order to improve efficiency, we have two input pointer.  ;
            ;   B_op is defined based on A_ip so if the input buffer is:    ;
            ;                                                               ;
            ;   A_A A_B A_C A_D B_A B_B B_C B_D ...                         ;
            ;                                                               ;
            ;   Then A_ip would be pointing to A_A and B_ip to B_A.         ;
            ;                                                               ;
            ;   The same applies to the output buffer.                      ;
            ; ============================================================= ;
            ADD     .2  A_ip,       4,          B_ip

            ADD     .1  B_op,       4,          A_op

            ; ============================================================= ;
            ;   After the next three lines are executed, we will have the   ;
            ;   value in the replicated twice in the same variable.         ;
            ;                                                               ;
            ; |--------|--------|--------|--------|                         ;
            ; |00000000|thththth|00000000|thththth|                         ;
            ; |--------|--------|--------|--------|                         ;
            ; ============================================================= ;
            SHL     .1  A_th,       16,         A_thS
            ADD     .1  A_th,       A_thS,      A_thth
            MV      .2  A_thth,                 B_thth

            .mptr       A_ip,       in,         16
            .mptr       B_ip,       in +4,      16
            .mptr       B_op,       out,        16
            .mptr       A_op,       out+4,      16

loop:       .trip 1
            ; ============================================================= ;
            ;   In each iteration, four sets of four pixels will be read.   ;
            ;   The first set will be stored in A_DCBA, the second in       ;
            ;   B_DCBA, the third in A_HGFE and the fourth in B_HGFE.       ;
            ;                                                               ;
            ;   Meanwhile the pointers are being updated by two each time.  ;
            ;   A_ip is used to read alternating sets of four pixels.  One  ;
            ;   set is read with A_ip and the next is read with B_ip.       ;
            ;   This means that each time A_ip (B_ip) is updated, it has    ;
            ;   to skip over the data that is being read by B_ip (A_ip).    ;
            ;                                                               ;
            ; ============================================================= ;
            LDW     .1  *A_ip++[2],             A_DCBA
            LDW     .2  *B_ip++[2],             B_DCBA

            LDW     .1  *A_ip++[2],             A_HGFE
            LDW     .2  *B_ip++[2],             B_HGFE

            ; ============================================================= ;
            ;   If the input data in A_DCBA is represented as:              ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |DDDDDDDD|CCCCCCCC|BBBBBBBB|AAAAAAAA|                       ;
            ;   |--------|--------|--------|--------|                       ;
            ;                                                               ;
            ;   Then, the result will be:                                   ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |00000000|CCCCCCCC|00000000|AAAAAAAA|                       ;
            ;   |--------|--------|--------|--------|                       ;
            ; ============================================================= ;
            AND     .1  A_DCBA,     A_MFF00FF,  A_0C0A
            AND     .2  B_DCBA,     B_MFF00FF,  B_0C0A

            ; ============================================================= ;
            ;   These few lines do the same, but with the pixels D and A in ;
            ;   A_DCBA and B_DCBA.                                          ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |00000000|DDDDDDDD|00000000|BBBBBBBB|                       ;
            ;   |--------|--------|--------|--------|                       ;
            ; ============================================================= ;
            SUB    .1   A_DCBA,     A_0C0A,     A_D0B0
            SHRU   .1   A_D0B0,     8,          A_0D0B

            SUB    .2   B_DCBA,     B_0C0A,     B_D0B0
            SHRU   .2   B_D0B0,     8,          B_0D0B

            ; ============================================================= ;
            ;   Find the difference between the threshold and each of the   ;
            ;   pixel values.                                               ;
            ;                                                               ;
            ;   As a result of this computation, we will either get a       ;
            ;   positive or a negative number.  If this result is positive  ;
            ;   that means the pixel is smaller than the threshold, so we   ;
            ;   want to make it cero.  If the result is negative, we want   ;
            ;   to keep the original valued.                                ;
            ;                                                               ;
            ;   The results would look like:                                ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |11111111|yyyyyyyy|11111111|xxxxxxxx|  If the pixels        ;
            ;   |--------|--------|--------|--------|  are larger           ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |00000000|yyyyyyyy|00000000|xxxxxxxx|  If the pixels        ;
            ;   |--------|--------|--------|--------|  are smaller          ;
            ;                                                               ;
            ;    Or any combination of the two results listed above.        ;
            ;                                                               ;
            ;    The idea in this kernel is to use bits 8 to 15 of the      ;
            ;    results as masks to be applied to the ijnput pixels that   ;
            ;   occupy byte 0 in the register, and bits 23 to 31 as masks   ;
            ;   to be applied to the input pixels that occupy byte 2 in     ;
            ;   the register.                                               ;
            ; ============================================================= ;
            SUB2    .1  A_thth,     A_0C0A,     A_CMXAMX
            SUB2    .1  A_thth,     A_0D0B,     A_DMXBMX

            SUB2    .2  B_thth,     B_0C0A,     B_CMXAMX
            SUB2    .2  B_thth,     B_0D0B,     B_DMXBMX

            ; ============================================================= ;
            ;   We need to get the mask in place so we can apply them to the;
            ;   corresponding pixel.  The masks for pixels in positions A   ;
            ;   and C are out of place, they have to be shifted 8 bits to   ;
            ;   the right.                                                  ;
            ;                                                               ;
            ;   After the masks are in place, we want to leave the registers;
            ;   containing only the masks, that is why we apply X_MFF00FF   ;
            ;   to the shifted results, to set the other bits to zero.      ;
            ;                                                               ;
            ;   The result would be:                                        ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |00000000|MASK   C|00000000|MASK   A|                       ;
            ;   |--------|--------|--------|--------|                       ;
            ; ============================================================= ;
            SHRU    .1  A_CMXAMX,   8,          A_XCMXAM
            AND     .1  A_XCMXAM,   A_MFF00FF,  A_0CM0AM

            SHRU    .2  B_CMXAMX,   8,          B_XCMXAM
            AND     .2  B_XCMXAM,   B_MFF00FF,  B_0CM0AM

            ; ============================================================= ;
            ;   The masks for pixels D and B are already in place.          ;
            ;   We only need to clean the rest of the bits.                 ;
            ;                                                               ;
            ;   The result would be:                                        ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |MASK   D|00000000|MASK   B|00000000|                       ;
            ;   |--------|--------|--------|--------|                       ;
            ; ============================================================= ;
            AND     .1  A_DMXBMX,   A_MFF00FF00,A_DM0BM0

            AND     .2  B_DMXBMX,   B_MFF00FF00,B_DM0BM0

            ; ============================================================= ;
            ;   We combine the masks together, so we would get:             ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |MASK   D|MASK   C|MASK   B|MASK   A|                       ;
            ;   |--------|--------|--------|--------|                       ;
            ; ============================================================= ;
            ADD     .1  A_DM0BM0,   A_0CM0AM,   A_DMCMBMAM

            ADD     .2  B_DM0BM0,   B_0CM0AM,   B_DMCMBMAM

            ; ============================================================= ;
            ;   The mask we have been putting together are applied to the   ;
            ;   input data.  The results are stored in DCBAout.             ;
            ; ============================================================= ;
            OR          A_DMCMBMAM, A_DCBA,      A_DCBAout
            OR          B_DMCMBMAM, B_DCBA,      B_DCBAout


            ; ============================================================= ;
            ;   The loop has been unrolled once.  Which means that the exact;
            ;   set of instructions that we have gone through, are applied  ;
            ;   again to another group of input data.                       ;
            ;                                                               ;
            ;   The data we are talking about is A_HGFE and B_HGFE, that we ;
            ;   read in the beginning of the kernel, but that we haven't    ;
            ;   used yet.                                                   ;
            ; ============================================================= ;
            AND     .1  A_HGFE,     A_MFF00FF,  A_0G0E

            AND     .2  B_HGFE,     B_MFF00FF,  B_0G0E


            SUB     .1  A_HGFE,     A_0G0E,     A_H0F0
            SHRU    .1  A_H0F0,     8,          A_0H0F

            SUB     .2  B_HGFE,     B_0G0E,     B_H0F0
            SHRU    .2  B_H0F0,     8,          B_0H0F


            SUB2    .1  A_thth,     A_0G0E,     A_GMXEMX
            SUB2    .1  A_thth,     A_0H0F,     A_HMXFMX

            SUB2    .2  B_thth,     B_0G0E,     B_GMXEMX
            SUB2    .2  B_thth,     B_0H0F,     B_HMXFMX


            SHRU    .1  A_GMXEMX,   8,          A_XGMXEM
            AND     .1  A_XGMXEM,   A_MFF00FF,  A_0GM0EM

            SHRU    .2  B_GMXEMX,   8,          B_XGMXEM
            AND     .2  B_XGMXEM,   B_MFF00FF,  B_0GM0EM


            AND     .1  A_HMXFMX,   A_MFF00FF00,A_HM0FM0
            AND     .2  B_HMXFMX,   B_MFF00FF00,B_HM0FM0


            ADD     .1  A_HM0FM0,   A_0GM0EM,   A_HMGMFMEM
            ADD     .2  B_HM0FM0,   B_0GM0EM,   B_HMGMFMEM


            OR      .1  A_HMGMFMEM, A_HGFE,     A_HGFEout
            OR      .2  B_HMGMFMEM, B_HGFE,     B_HGFEout


            ; ============================================================= ;
            ;   The results are stored in the output buffer.                ;
            ;                                                               ;
            ;   And the output pointers are updated.                        ;
            ; ============================================================= ;
            STW     .2  A_DCBAout,              *B_op++[2]
            STW     .1  B_DCBAout,              *A_op++[2]

            STW     .2  A_HGFEout,              *B_op++[2]
            STW     .1  B_HGFEout,              *A_op++[2]


    [A_cnt] SUB     .1  A_cnt,      1,          A_cnt
    [A_cnt] B           loop

            .return
            .endproc

* ========================================================================= *
*   End of file:  thr_gt2max_p.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
thr_gt2thr.sa/  1066929162  0     0     0       10366     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.2     Thu Mar 14 09:21:38 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_thr_gt2thr                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       14-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_gt2thr                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     //  Input image data  //      *
*           unsigned char *restrict out_data, //  Output image data //      *
*           short cols, short rows,           //  Image dimensions  //      *
*           unsigned char       threshold     //  Threshold value   //      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are greater than the threshold      *
*       are set to the threshold value in the output image.                 *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|                                                    *
*                      |                                                    *
*                      |                                                    *
*             O        |                                                    *
*             U        |                                                    *
*             T    th _|. . . . . _________                                 *
*             P        |        /.                                          *
*             U        |      /  .                                          *
*             T        |    /    .                                          *
*                      |  /      .                                          *
*                    0_|/________.__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_le2thr, IMG_thr_le2min      *
*       and IMG_thr_gt2max for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The value rows*cols must be a multiple of 4 pixels, and at least    *
*       4 pixels long.                                                      *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       No bank conflicts are expected to occur, although this depends      *
*       on the exact schedule produced by the compiler.                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *




        .sect ".text:_thr_gt2thr"
        .global _IMG_thr_gt2thr
_IMG_thr_gt2thr  .cproc  A_i_ptr, B_o_ptr, A_cols, B_rows, A_th
            .reg        B_i,        B_th
            .reg        B_i_ptr,    A_o_ptr
            .reg        B_p3, B_p2, A_p1, A_p0
            .reg        B_c3, B_c2, A_c1, A_c0
            .reg        B_t3, B_t2, A_t1, A_t0
            .no_mdep

            ; Calculate loop trip counter (unrolled 16x)
            MPY         .2X     A_cols,     B_rows,     B_i
            SHR         .2      B_i,        2,          B_i

            ; Calculate twin pointers.
            ADD         .2X     A_i_ptr,    2,          B_i_ptr
            ADD         .1X     B_o_ptr,    2,          A_o_ptr

            ; Generate packed threshold.
            MV          .2X     A_th,       B_th

            ; The main loop!
            .mptr               B_i_ptr,    i_ptr + 2,  4
            .mptr               A_i_ptr,    i_ptr + 0,  4
            .mptr               A_o_ptr,    o_ptr + 2,  4
            .mptr               B_o_ptr,    o_ptr + 0,  4
loop:       .trip       1
            LDBU        .D2T2   *B_i_ptr[1],            B_p3
            LDBU        .D2T2   *B_i_ptr++[4],          B_p2
            LDBU        .D1T1   *A_i_ptr[1],            A_p1
            LDBU        .D1T1   *A_i_ptr++[4],          A_p0

            CMPGTU      .2      B_p3,       B_th,       B_c3
            CMPGTU      .2      B_p2,       B_th,       B_c2
            CMPGTU      .1      A_p1,       A_th,       A_c1
            CMPGTU      .1      A_p0,       A_th,       A_c0

            MPY         .2      B_th,       1,          B_t3
            MPY         .2      B_th,       1,          B_t2
            MPY         .1      A_th,       1,          A_t1
            MPY         .1      A_th,       1,          A_t0

  [!B_c3]   MV          .2      B_p3,                   B_t3
  [!B_c2]   MV          .2      B_p2,                   B_t2
  [!A_c1]   MV          .1      A_p1,                   A_t1
  [!A_c0]   MV          .1      A_p0,                   A_t0

            STB         .D1T2   B_t3,       *A_o_ptr[1]
            STB         .D1T2   B_t2,       *A_o_ptr++[4]
            STB         .D2T1   A_t1,       *B_o_ptr[1]
            STB         .D2T1   A_t0,       *B_o_ptr++[4]

            SUB                 B_i,        1,          B_i
  [ B_i]    B                   loop

            .return
            .endproc


* ========================================================================= *
*   End of file:  img_thr_gt2thr.sa                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
thr_le2min.sa/  1066929162  0     0     0       28315     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.9     Thu Mar 14 09:31:25 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       threshold                                                           *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       12-Dec-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_le2min                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     //  Input image data  //      *
*           unsigned char *restrict out_data, //  Output image data //      *
*           short cols, short rows,           //  Image dimensions  //      *
*           unsigned char       threshold     //  Threshold value   //      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are less than or equal to the       *
*       threshold are set to 0 in the output image.                         *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|                                                    *
*                      |                  /                                 *
*                      |                /                                   *
*             O        |              /                                     *
*             U        |            /                                       *
*             T    th _|. . . . . /                                         *
*             P        |         |                                          *
*             U        |         |                                          *
*             T        |         |                                          *
*                      |         |                                          *
*                    0_|_________|__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2thr,     *
*       and IMG_thr_gt2max for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The input and output buffers must be word aligned.                  *
*                                                                           *
*       The total number of pixels rows*cols must be at least               *
*       16 and a multiple of 16.                                            *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loop is unrolled 16 times and the data is maniuplated     *
*       in packed format for speed.                                         *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_thr_le2min"
        .global _IMG_thr_le2min
_IMG_thr_le2min:  .cproc  A_ip, B_op, A_w, B_h, A_th
            .no_mdep
            .reg    A_thth      ; Threshold value copied twice
            .reg    B_thth      ; Copy of the above variable, performace
            .reg    A_thS       ; Thrshold value shifted left
            .reg    A_cnt       ; Loop control variable

            .reg    B_ip        ; Input pointer
            .reg    A_op        ; Output pointer

            .reg    A_MFF00FF   ; Constante, 0xFF00FF
            .reg    B_MFF00FF   ; Copy of the above variable, performance
            .reg    A_MFF00FF00 ; Constant, 0xFF00FF00
            .reg    B_MFF00FF00 ; Copy of the above variable, performance

            .reg    A_DCBAout   ; 1st 4 output pixels for row i, in the
                                ; example buffer we show below these pixels
                                ; would be A_D, A_c, A_B and A_A in this order
            .reg    B_DCBAout   ; 2nd 4 output pixels for row i (B_D, B_C,
                                ; B_B and B_A, in this order)
            .reg    A_HGFEout   ; 3rd 4 output pixels for row i (A_H, A_G,
                                ; A_F and A_E, in this order)
            .reg    B_HGFEout   ; 4th 4 output pixels for row i (B_H, B_G,
                                ; B_F and B_E in this order)

            .reg    A_DCBA      ; 1st 4 pixels of row i read each iteration
                                ; A_D, A_C, A_B and A_A in this order
            .reg    B_DCBA      ; 2nd 4 pixels of row i read each iteration
                                ; B_D, B_C, B_B and B_A in this order
            .reg    A_HGFE      ; 3rd 4 pixels of row i read each iteration
                                ; A_H, A_G, A_F and A_E in this order
            .reg    B_HGFE      ; 4th 4 pixels of row i read each iteration
                                ; B_H, B_G, B_F and B_E in this order

            ; ============================================================= ;
            ;   Each register has 4 bytes.  Each of these bytes is          ;
            ;   represented by a letter or a 0.  If it is represented by a  ;
            ;   letter, that means the pixel to which we have assigned that ;
            ;   letter is stored there.  If it is represented by a 0, that  ;
            ;   means that byte has zeros in it.                            ;
            ; ============================================================= ;
            .reg    A_0C0A
            .reg    A_0DCB
            .reg    A_0D0B
            .reg    A_D0B0
            .reg    B_0C0A
            .reg    B_0DCB
            .reg    B_0D0B
            .reg    B_D0B0
            .reg    A_0G0E
            .reg    A_0HGF
            .reg    A_0H0F
            .reg    A_H0F0
            .reg    B_0G0E
            .reg    B_0HGF
            .reg    B_0H0F
            .reg    B_H0F0

            ; ============================================================= ;
            ;   Each register has 4 bytes.  Each of these bytes is          ;
            ;   represented by a two letters, or a zero or an X.  The X     ;
            ;   means that the result stored in that byte bears no          ;
            ;   importance.  the zero means that byte has zeros in it.      ;
            ;   The two letter (for example CM or AM) represent a byte with ;
            ;   the sign extension resulting from subtracting the           ;
            ;   corresponding pixel (for example C or A) from the th value  ;
            ; ============================================================= ;
            .reg    A_CMXAMX
            .reg    A_DMXBMX
            .reg    A_XCMXAM
            .reg    A_0CM0AM
            .reg    A_DM0BM0
            .reg    B_CMXAMX
            .reg    B_DMXBMX
            .reg    B_XCMXAM
            .reg    B_0CM0AM
            .reg    B_DM0BM0
            .reg    A_GMXEMX
            .reg    A_HMXFMX
            .reg    A_XGMXEM
            .reg    A_0GM0EM
            .reg    A_HM0FM0
            .reg    B_GMXEMX
            .reg    B_HMXFMX
            .reg    B_XGMXEM
            .reg    B_0GM0EM
            .reg    B_HM0FM0

            .reg    A_DMCMBMAM  ; Sign extensions for pixels A_D, A_C, A_B
                                ; and A_A packed
            .reg    B_DMCMBMAM  ; Sign extensions for pixels B_D, B_C, B_B
                                ; and B_A packed
            .reg    A_HMGMFMEM  ; Sign extensions for pixels A_H, A_G, A_F
                                ; and A_E packed
            .reg    B_HMGMFMEM  ; Sign extensions for pixels B_H, B_G, B_F
                                ; and B_E packed


            ; ============================================================= ;
            ;   The following lines define masks that will be used to get   ;
            ;   intermediate results.                                       ;
            ; ============================================================= ;
            MVKL    .1  0xFF00FF,               A_MFF00FF
            MVKH    .1  0xFF00FF,               A_MFF00FF

            MVKL    .2  0xFF00FF,               B_MFF00FF
            MVKH    .2  0xFF00FF,               B_MFF00FF

            MVKL    .1  0xFF00FF00,             A_MFF00FF00
            MVKH    .1  0xFF00FF00,             A_MFF00FF00

            MVKL    .2  0xFF00FF00,             B_MFF00FF00
            MVKH    .2  0xFF00FF00,             B_MFF00FF00


            ; ============================================================= ;
            ;   We are setting the counter, which is the total number of    ;
            ;   pixels, divided by 16.  This is because in each iteration,  ;
            ;   we process 16 pixels.                                       ;
            ;                                                               ;
            ;   Here, instead of dividing by 16, we divide by 4.            ;
            ; ============================================================= ;
            MPY     .1  A_w,        B_h,        A_cnt
            SHRU    .1  A_cnt,      4,          A_cnt

            ; ============================================================= ;
            ;   A_ip is the pointer to the beginning of the input buffer.   ;
            ;   In order to improve efficiency, we have two input pointer.  ;
            ;   B_op is defined based on A_ip so if the input buffer is:    ;
            ;                                                               ;
            ;   A_A A_B A_C A_D B_A B_B B_C B_D ...                         ;
            ;                                                               ;
            ;   Then A_ip would be pointing to A_A and B_ip to B_A.         ;
            ;                                                               ;
            ;   The same applies to the output buffer.                      ;
            ; ============================================================= ;
            ADD     .2  A_ip,       4,          B_ip

            ADD     .1  B_op,       4,          A_op

            ; ============================================================= ;
            ;   After the next three lines are executed, we will have the   ;
            ;   value in the replicated twice in the same variable.         ;
            ;                                                               ;
            ; |--------|--------|--------|--------|                         ;
            ; |00000000|thththth|00000000|thththth|                         ;
            ; |--------|--------|--------|--------|                         ;
            ; ============================================================= ;
            SHL     .1  A_th,       16,         A_thS
            ADD     .1  A_th,       A_thS,      A_thth
            MV      .2  A_thth,                 B_thth

            .mptr       A_ip,       in,         16
            .mptr       B_ip,       in +4,      16
            .mptr       B_op,       out,        16
            .mptr       A_op,       out+4,      16

loop:       .trip 1
            ; ============================================================= ;
            ;   In each iteration, four sets of four pixels will be read.   ;
            ;   The first set will be stored in A_DCBA, the second in       ;
            ;   B_DCBA, the third in A_HGFE and the fourth in B_HGFE.       ;
            ;                                                               ;
            ;   Meanwhile the pointers are being updated by two each time.  ;
            ;   A_ip is used to read alternating sets of four pixels.  One  ;
            ;   set is read with A_ip and the next is read with B_ip.       ;
            ;   This means that each time A_ip (B_ip) is updated, it has    ;
            ;   to skip over the data that is being read by B_ip (A_ip).    ;
            ;                                                               ;
            ; ============================================================= ;
            LDW     .1  *A_ip++[2],             A_DCBA
            LDW     .2  *B_ip++[2],             B_DCBA

            LDW     .1  *A_ip++[2],             A_HGFE
            LDW     .2  *B_ip++[2],             B_HGFE

            ; ============================================================= ;
            ;   If the input data in A_DCBA is represented as:              ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |DDDDDDDD|CCCCCCCC|BBBBBBBB|AAAAAAAA|                       ;
            ;   |--------|--------|--------|--------|                       ;
            ;                                                               ;
            ;   Then, the result will be:                                   ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |00000000|CCCCCCCC|00000000|AAAAAAAA|                       ;
            ;   |--------|--------|--------|--------|                       ;
            ; ============================================================= ;
            AND     .1  A_DCBA,     A_MFF00FF,  A_0C0A
            AND     .2  B_DCBA,     B_MFF00FF,  B_0C0A

            ; ============================================================= ;
            ;   These few lines do the same, but with the pixels D and A in ;
            ;   A_DCBA and B_DCBA.                                          ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |00000000|DDDDDDDD|00000000|BBBBBBBB|                       ;
            ;   |--------|--------|--------|--------|                       ;
            ; ============================================================= ;
            SUB    .1   A_DCBA,     A_0C0A,     A_D0B0
            SHRU   .1   A_D0B0,     8,          A_0D0B

            SUB    .2   B_DCBA,     B_0C0A,     B_D0B0
            SHRU   .2   B_D0B0,     8,          B_0D0B

            ; ============================================================= ;
            ;   Find the difference between the threshold and each of the   ;
            ;   pixel values.                                               ;
            ;                                                               ;
            ;   As a result of this computation, we will either get a       ;
            ;   positive or a negative number.  If this result is positive  ;
            ;   that means the pixel is smaller than the threshold, so we   ;
            ;   want to make it cero.  If the result is negative, we want   ;
            ;   to keep the original valued.                                ;
            ;                                                               ;
            ;   The results would look like:                                ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |11111111|yyyyyyyy|11111111|xxxxxxxx|  If the pixels        ;
            ;   |--------|--------|--------|--------|  are larger           ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |00000000|yyyyyyyy|00000000|xxxxxxxx|  If the pixels        ;
            ;   |--------|--------|--------|--------|  are smaller          ;
            ;                                                               ;
            ;    Or any combination of the two results listed above.        ;
            ;                                                               ;
            ;    The idea in this kernel is to use bits 8 to 15 of the      ;
            ;    results as masks to be applied to the ijnput pixels that   ;
            ;   occupy byte 0 in the register, and bits 23 to 31 as masks   ;
            ;   to be applied to the input pixels that occupy byte 2 in     ;
            ;   the register.                                               ;
            ; ============================================================= ;
            SUB2    .1  A_thth,     A_0C0A,     A_CMXAMX
            SUB2    .1  A_thth,     A_0D0B,     A_DMXBMX

            SUB2    .2  B_thth,     B_0C0A,     B_CMXAMX
            SUB2    .2  B_thth,     B_0D0B,     B_DMXBMX

            ; ============================================================= ;
            ;   We need to get the mask in place so we can apply them to the;
            ;   corresponding pixel.  The masks for pixels in positions A   ;
            ;   and C are out of place, they have to be shifted 8 bits to   ;
            ;   the right.                                                  ;
            ;                                                               ;
            ;   After the masks are in place, we want to leave the registers;
            ;   containing only the masks, that is why we apply X_MFF00FF   ;
            ;   to the shifted results, to set the other bits to zero.      ;
            ;                                                               ;
            ;   The result would be:                                        ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |00000000|MASK   C|00000000|MASK   A|                       ;
            ;   |--------|--------|--------|--------|                       ;
            ; ============================================================= ;
            SHRU    .1  A_CMXAMX,   8,          A_XCMXAM
            AND     .1  A_XCMXAM,   A_MFF00FF,  A_0CM0AM

            SHRU    .2  B_CMXAMX,   8,          B_XCMXAM
            AND     .2  B_XCMXAM,   B_MFF00FF,  B_0CM0AM

            ; ============================================================= ;
            ;   The masks for pixels D and B are already in place.          ;
            ;   We only need to clean the rest of the bits.                 ;
            ;                                                               ;
            ;   The result would be:                                        ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |MASK   D|00000000|MASK   B|00000000|                       ;
            ;   |--------|--------|--------|--------|                       ;
            ; ============================================================= ;
            AND     .1  A_DMXBMX,   A_MFF00FF00,A_DM0BM0

            AND     .2  B_DMXBMX,   B_MFF00FF00,B_DM0BM0

            ; ============================================================= ;
            ;   We combine the masks together, so we would get:             ;
            ;                                                               ;
            ;   |--------|--------|--------|--------|                       ;
            ;   |MASK   D|MASK   C|MASK   B|MASK   A|                       ;
            ;   |--------|--------|--------|--------|                       ;
            ; ============================================================= ;
            ADD     .1  A_DM0BM0,   A_0CM0AM,   A_DMCMBMAM

            ADD     .2  B_DM0BM0,   B_0CM0AM,   B_DMCMBMAM

            ; ============================================================= ;
            ;   The mask we have been putting together are applied to the   ;
            ;   input data.  The results are stored in DCBAout.             ;
            ; ============================================================= ;
            AND         A_DMCMBMAM, A_DCBA,      A_DCBAout
            AND         B_DMCMBMAM, B_DCBA,      B_DCBAout


            ; ============================================================= ;
            ;   The loop has been unrolled once.  Which means that the exact;
            ;   set of instructions that we have gone through, are applied  ;
            ;   again to another group of input data.                       ;
            ;                                                               ;
            ;   The data we are talking about is A_HGFE and B_HGFE, that we ;
            ;   read in the beginning of the kernel, but that we haven't    ;
            ;   used yet.                                                   ;
            ; ============================================================= ;
            AND     .1  A_HGFE,     A_MFF00FF,  A_0G0E

            AND     .2  B_HGFE,     B_MFF00FF,  B_0G0E


            SUB     .1  A_HGFE,     A_0G0E,     A_H0F0
            SHRU    .1  A_H0F0,     8,          A_0H0F

            SUB     .2  B_HGFE,     B_0G0E,     B_H0F0
            SHRU    .2  B_H0F0,     8,          B_0H0F


            SUB2    .1  A_thth,     A_0G0E,     A_GMXEMX
            SUB2    .1  A_thth,     A_0H0F,     A_HMXFMX

            SUB2    .2  B_thth,     B_0G0E,     B_GMXEMX
            SUB2    .2  B_thth,     B_0H0F,     B_HMXFMX


            SHRU    .1  A_GMXEMX,   8,          A_XGMXEM
            AND     .1  A_XGMXEM,   A_MFF00FF,  A_0GM0EM

            SHRU    .2  B_GMXEMX,   8,          B_XGMXEM
            AND     .2  B_XGMXEM,   B_MFF00FF,  B_0GM0EM


            AND     .1  A_HMXFMX,   A_MFF00FF00,A_HM0FM0

            AND     .2  B_HMXFMX,   B_MFF00FF00,B_HM0FM0


            ADD     .1  A_HM0FM0,   A_0GM0EM,   A_HMGMFMEM

            ADD     .2  B_HM0FM0,   B_0GM0EM,   B_HMGMFMEM


            AND     .1  A_HMGMFMEM, A_HGFE,     A_HGFEout

            AND     .2  B_HMGMFMEM, B_HGFE,     B_HGFEout


            ; ============================================================= ;
            ;   The results are stored in the output buffer.                ;
            ;                                                               ;
            ;   And the output pointers are updated.                        ;
            ; ============================================================= ;
            STW     .2  A_DCBAout,              *B_op++[2]
            STW     .1  B_DCBAout,              *A_op++[2]

            STW     .2  A_HGFEout,              *B_op++[2]
            STW     .1  B_HGFEout,              *A_op++[2]


    [A_cnt] SUB     .1  A_cnt,      1,          A_cnt
    [A_cnt] B           loop

            .return
            .endproc

* ========================================================================= *
*   End of file:  thr_le2min_p.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

thr_le2thr.sa/  1066929162  0     0     0       10287     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Thu Mar 14 09:21:22 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_thr_le2thr                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       14-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_le2thr                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     //  Input image data  //      *
*           unsigned char *restrict out_data, //  Output image data //      *
*           short cols, short rows,           //  Image dimensions  //      *
*           unsigned char       threshold     //  Threshold value   //      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are less than or equal to the       *
*       threshold are set to the threshold value in the output image.       *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|                                                    *
*                      |                  /                                 *
*                      |                /                                   *
*             O        |              /                                     *
*             U        |            /                                       *
*             T    th _|_________ /                                         *
*             P        |         .                                          *
*             U        |         .                                          *
*             T        |         .                                          *
*                      |         .                                          *
*                    0_|_________.__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2min      *
*       and IMG_thr_gt2max for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The value rows*cols must be a multiple of 4 pixels, and at least    *
*       4 pixels long.                                                      *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       No bank conflicts are expected to occur, although this depends      *
*       on the exact schedule produced by the compiler.                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *




        .sect ".text:_thr_le2thr"
        .global _IMG_thr_le2thr
_IMG_thr_le2thr  .cproc  A_i_ptr, B_o_ptr, A_cols, B_rows, A_th
            .reg        B_i,        B_th
            .reg        B_i_ptr,    A_o_ptr
            .reg        B_p3, B_p2, A_p1, A_p0
            .reg        B_c3, B_c2, A_c1, A_c0
            .reg        B_t3, B_t2, A_t1, A_t0
            .no_mdep

            ; Calculate loop trip counter (unrolled 16x)
            MPY         .2X     A_cols,     B_rows,     B_i
            SHR         .2      B_i,        2,          B_i

            ; Calculate twin pointers.
            ADD         .2X     A_i_ptr,    2,          B_i_ptr
            ADD         .1X     B_o_ptr,    2,          A_o_ptr

            ; Generate packed threshold.
            MV          .2X     A_th,       B_th

            ; The main loop!
            .mptr               B_i_ptr,    i_ptr + 2,  4
            .mptr               A_i_ptr,    i_ptr + 0,  4
            .mptr               A_o_ptr,    o_ptr + 2,  4
            .mptr               B_o_ptr,    o_ptr + 0,  4
loop:       .trip       1
            LDBU        .D2T2   *B_i_ptr[1],            B_p3
            LDBU        .D2T2   *B_i_ptr++[4],          B_p2
            LDBU        .D1T1   *A_i_ptr[1],            A_p1
            LDBU        .D1T1   *A_i_ptr++[4],          A_p0

            CMPGTU      .2      B_p3,       B_th,       B_c3
            CMPGTU      .2      B_p2,       B_th,       B_c2
            CMPGTU      .1      A_p1,       A_th,       A_c1
            CMPGTU      .1      A_p0,       A_th,       A_c0

            MPY         .2      B_th,       1,          B_t3
            MPY         .2      B_th,       1,          B_t2
            MPY         .1      A_th,       1,          A_t1
            MPY         .1      A_th,       1,          A_t0

  [ B_c3]   MV          .2      B_p3,                   B_t3
  [ B_c2]   MV          .2      B_p2,                   B_t2
  [ A_c1]   MV          .1      A_p1,                   A_t1
  [ A_c0]   MV          .1      A_p0,                   A_t0

            STB         .D1T2   B_t3,       *A_o_ptr[1]
            STB         .D1T2   B_t2,       *A_o_ptr++[4]
            STB         .D2T1   A_t1,       *B_o_ptr[1]
            STB         .D2T1   A_t0,       *B_o_ptr++[4]

            SUB                 B_i,        1,          B_i
  [ B_i]    B                   loop

            .return
            .endproc


* ========================================================================= *
*   End of file:  img_thr_le2thr.sa                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

wave_horz.sa/   1066929162  0     0     0       25557     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Fri Mar 15 14:58:26 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_wave_horz                                                       *
*                                                                           *
*   REVISION DATE                                                           *
*       21-Oct-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void IMG_wave_horz                                              *
*           (                                                               *
*               const short *restrict in_data,  // Row of input pixels  //  *
*               const short *restrict qmf,      // Low-pass QMF filter  //  *
*               const short *restrict mqmf,     // High-pass QMF filter //  *
*               short       *restrict out_data, // Row of output data   //  *
*               int                   cols      // Length of input.     //  *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This kernel performs a 1D Periodic Orthogonal Wavelet               *
*       decomposition.  This also performs the row decomposition in a 2D    *
*       wavelet transform.  An input signal x[n] is low pass and high pass  *
*       filtered and decimated by two.  This results in a reference signal  *
*       r1[n] which is the decimated output obtained by dropping the odd    *
*       samples of the low pass filtered output and a detail signal d[n]    *
*       obtained by dropping the odd samples of the high-pass output.  A    *
*       circular convolution algorithm is implemented and hence the         *
*       wavelet transform is periodic.  The reference signal and the        *
*       detail signal are half the size of the original signal.  The        *
*       reference signal may then be iterated again to perform another      *
*       scale of multi-resolution analysis.                                 *
*                                                                           *
* C CODE                                                                    *
*       This is the C equivalent of the assembly code without               *
*       restrictions: Note that the assembly code is hand optimized and     *
*       restrictions apply as noted under "ASSUMPTIONS".                    *
*                                                                           *
*           void IMG_wave_horz                                              *
*           (                                                               *
*               const short *restrict in_data,  // Row of input pixels      *
*               const short *restrict qmf,      // Low-pass QMF filter      *
*               const short *restrict mqmf,     // High-pass QMF filter     *
*               short       *restrict out_data, // Row of output data       *
*               int                   cols      // Length of input.         *
*           )                                                               *
*           {                                                               *
*               int         i, res, iters;                                  *
*               int         j, sum, prod;                                   *
*               const short *restrict xptr  = in_data;                      *
*               short       *restrict yptr  = out_data;                     *
*               const short *restrict x_end = &in_data[cols - 1];           *
*               short       xdata, hdata;                                   *
*               const short *restrict xstart;                               *
*               const short *restrict filt_ptr;                             *
*               int         M = 8;                                          *
*                                                                           *
*               // ------------------------------------------------- //     *
*               //  Set our loop trip count and starting x posn.     //     *
*               //  'xstart' is used in the high-pass filter loop.   //     *
*               // ------------------------------------------------- //     *
*               iters  = cols;                                              *
*               xstart = in_data + (cols - M)  + 2;                         *
*                                                                           *
*               // ------------------------------------------------- //     *
*               //  Low pass filter.  Iterate for cols/2 iterations  //     *
*               //  generating cols/2 low pass sample points with    //     *
*               //  the low-pass quadrature mirror filter.           //     *
*               // ------------------------------------------------- //     *
*               for (i = 0; i < iters; i += 2)                              *
*               {                                                           *
*                   // --------------------------------------------- //     *
*                   //  Initialize our sum to the rounding value     //     *
*                   //  and reset our pointer.                       //     *
*                   // --------------------------------------------- //     *
*                   sum  = Qr;                                              *
*                   xptr = in_data + i;                                     *
*                                                                           *
*                   // --------------------------------------------- //     *
*                   //  Iterate over the taps in our QMF.            //     *
*                   // --------------------------------------------- //     *
*                   for (j = 0; j < M; j++)                                 *
*                   {                                                       *
*                       xdata = *xptr++;                                    *
*                       hdata =  qmf[j];                                    *
*                       prod  =  xdata * hdata;                             *
*                       sum  += prod;                                       *
*                       if (xptr > x_end) xptr = in_data;                   *
*                   }                                                       *
*                                                                           *
*                   // --------------------------------------------- //     *
*                   //  Adjust the Qpt of our sum and store result.  //     *
*                   // --------------------------------------------- //     *
*                   res    = (sum >> Qpt);                                  *
*                   *out_data++ = res;                                      *
*               }                                                           *
*                                                                           *
*               // ------------------------------------------------- //     *
*               //  High pass filter.  Iterate for cols/2 iters      //     *
*               //  generating cols/2 high pass sample points with   //     *
*               //  the high-pass quadrature mirror filter.          //     *
*               // ------------------------------------------------- //     *
*               for (i = 0; i < iters ; i+=2)                               *
*               {                                                           *
*                   // --------------------------------------------- //     *
*                   //  Initialize our sum and filter pointer.       //     *
*                   // --------------------------------------------- //     *
*                   sum  = Qr;                                              *
*                   filt_ptr  = mqmf + (M - 1);                             *
*                                                                           *
*                   // --------------------------------------------- //     *
*                   //  Set up our data pointer.  This is slightly   //     *
*                   //  more complicated due to how the data wraps   //     *
*                   //  around the edge of the buffer.               //     *
*                   // --------------------------------------------- //     *
*                   xptr = xstart;                                          *
*                   xstart += 2;                                            *
*                   if (xstart > x_end) xstart = in_data;                   *
*                                                                           *
*                   // --------------------------------------------- //     *
*                   //  Iterate over the taps in our QMF.            //     *
*                   // --------------------------------------------- //     *
*                   for ( j = 0; j < M; j++)                                *
*                   {                                                       *
*                       xdata = *xptr++;                                    *
*                       hdata = *filt_ptr--;                                *
*                       prod  = xdata * hdata;                              *
*                       if (xptr > x_end) xptr = in_data;                   *
*                       sum  += prod;                                       *
*                   }                                                       *
*                                                                           *
*                   // --------------------------------------------- //     *
*                   //  Adjust the Qpt of our sum and store result.  //     *
*                   // --------------------------------------------- //     *
*                   res = (sum >> Qpt);                                     *
*                   *out_data++ =  res;                                     *
*               }                                                           *
*           }                                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*       The main idea in optimizing the code is to issue one set of reads   *
*       to the x array and to perform low-pass and high pass filtering      *
*       together to maximize the number of multiplies.  The last 6          *
*       elements of the low-pass filter and the first 6 elements of the     *
*       high pass filter use the same input. This is used to appropriately  *
*       change the output pointer to the low pass filter after 6            *
*       iterations. However for the first six iterations pointer            *
*       wrap-around can occurr and hence this creates a dependency.         *
*       Pre-reading those 6 values outside the array prevents the checks    *
*       that introduce this dependency.  In addtion the input data is read  *
*       as word wide quantities and the low-pass and high-pass filter       *
*       coefficients are stored in registers allowing for the input loop    *
*       to be completely unrolled. Thus the code has only one               *
*       loop. A predication register is used to reset the low-pass output   *
*       pointer after three iterations. The merging of the loops in this    *
*       fashion allows for the maximum number of multiplies with the        *
*       minimum number of reads.                                            *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This routine assumes that the number of filter taps for the qmf     *
*       and mqmf is 8.                                                      *
*                                                                           *
*       Both the filters are assumed to be word aligned.                    *
*                                                                           *
*       The input line is assumed to be word aligned so that LDWs may be    *
*       performed.                                                          *
*                                                                           *
*       This code assumes that filter coefficients are maintained as        *
*       shorts in Q15 format.                                               *
*                                                                           *
*       It also assumes that input data is an array of shorts (16 bit)      *
*       (The input is assumed to be an array of shorts to allow for         *
*       re-using this kernel to perform Multi Resolution Analysis as        *
*       the output of this code will feedback again as input in the         *
*       next stage.)                                                        *
*                                                                           *
*       Since the transform is a dyadic wavelet cols should be a multiple   *
*       of 2.                                                               *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN Neutral.                                        *
*                                                                           *
*   NOTES                                                                   *
*       This code can implement the Daubechies D4 filterbank for            *
*       analysis with 4 vansishing moments.  The length of the analyzing    *
*       low-pass and high pass filters is 8 in that case.                   *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

            .data
Qr          .set    16384
M           .set     8


        .sect ".text:_wave_horz"
        .global _IMG_wave_horz
_IMG_wave_horz:  .cproc   A_iptr, B_qmf, A_filter, B_optr, A_ish_x_dim

           .no_mdep

          ; Variables outside LOOP

          .reg  B_fev_ptr,    A_fod_ptr
          .reg  B_h10,        A_h32
          .reg  B_h54,        A_h76
          .reg  A_lev_ptr,    B_lod_ptr
          .reg  A_l10,        B_l32
          .reg  A_l54,        B_l76
          .reg  B_M,          A_i
          .reg  B_offset,     A_offset
          .reg  A_optr,       A_yptr_h
          .reg  B_yptr_l0,    B_yptr_l1
          .reg  B_p,          A_xiptr
          .reg  B_xiptr,      A_x10
          .reg  B_x32,        A_x54
          .reg  B_iptr,       A_qr
          .reg  B_qr

         ; Variables inside LOOP

          .reg  B_sum_l,      A_sum_h
          .reg  B_x76,        A_prod_h0
          .reg  A_prod_h1,    B_prod_h2
          .reg  B_prod_h3,    A_prod_h4
          .reg  A_prod_h5,    B_prod_h6
          .reg  B_prod_h7,    A_prod_l0
          .reg  A_prod_l1,    B_prod_l2
          .reg  B_prod_l3,    A_prod_l4
          .reg  A_prod_l5,    B_prod_l6
          .reg  B_prod_l7,    A_sumh10
          .reg  B_sumh23,     A_sumh54
          .reg  B_sumh67
          .reg  A_suml10,     B_suml23
          .reg  A_suml54,     B_suml67
          .reg  A_sumh_od,    B_sumh_ev
          .reg  A_suml_od,    B_suml_ev
          .reg  B_suml_new,   A_sumh_new
          .reg  B_acc_low,    A_acc_hi
          .reg  B_res_low,    A_res_hi

          ADD.2x     A_filter,    0,           B_fev_ptr    ; highpass even ptr
          ADD.1      A_filter,    4,           A_fod_ptr    ; high pass odd ptr

          LDW.D2T2   *B_fev_ptr++[2],          B_h10        ; highpass10
          LDW.D1T1   *A_fod_ptr++[2],          A_h32        ; highpass32
          LDW.D2T2   *B_fev_ptr++[2],          B_h54        ; highpass54
          LDW.D1T1   *A_fod_ptr++[2],          A_h76        ; highpass76

          ADD.1x      B_qmf,        0,         A_lev_ptr    ; lowpass even ptr
          ADD.2       B_qmf,        4,         B_lod_ptr    ; lowpass odd ptr

          LDW.D1T1   *A_lev_ptr++[2],          A_l10        ; lowpass10
          LDW.D2T2   *B_lod_ptr++[2],          B_l32        ; lowpass32
          LDW.D1T1   *A_lev_ptr++[2],          A_l54        ; lowpass54
          LDW.D2T2   *B_lod_ptr++[2],          B_l76        ; lowpass76

          MVK.2       M,            B_M                     ; M = 8
          SHRU.1      A_ish_x_dim,  1,         A_i          ; i = X >> 1
          SUB.2x      A_ish_x_dim,  B_M,       B_offset     ; off = x - M + 2
          ADD.2       B_offset,     2,         B_offset     ; off
          MV.1x       B_offset,     A_offset                ; Make copy

          MVK.2       3,            B_p                     ; p to switch ptrs
          ADDAH.1     A_iptr,       A_offset,  A_xiptr      ; xiptr = iptr + off
          ADD.2x      A_xiptr,      4,         B_xiptr      ; twin xiptr

          LDW.D1T1   *A_xiptr++[2],  A_x10                  ; Load x10
          LDW.D2T2   *B_xiptr++[2],  B_x32                  ; Load x32
          LDW.D1T1   *A_xiptr++[2],  A_x54                  ; Load x54

          SHRU.2      B_offset,     1,         B_offset     ; off = x - M + 2
          MV.1x       B_offset,     A_offset                ; off >>= 1

          MV.1x       B_optr,       A_optr                  ; Copy optr
          ADDAH.1     A_optr,       A_i,       A_yptr_h     ; y_h  = optr[x >>1]
          ADDAH.2     B_optr,       B_offset,  B_yptr_l0    ; y_lo = optr - off
          MV.2        B_optr,       B_yptr_l1               ; y_l1 = optr


          MV.2x       A_iptr,         B_iptr                ; B_iptr = iptr
          MVKL.1      Qr,             A_qr                  ; Qr --> A_qr
          MVKH.1      Qr,             A_qr                  ; Qr --> A_qr
          MV.2x       A_qr,           B_qr                  ; A_qr = B_qr


          .mptr       B_iptr,       A_iptr+0,  4            ; Assume worst
          .mptr       A_yptr_h,     A_iptr+0,  2            ; case banking
          .mptr       B_yptr_l0,    A_iptr+0,  2            ; scenario
          .mptr       B_yptr_l1,    A_iptr+0,  2            ; Schedule sep.

LOOP:     .trip       20

          MV.2        B_qr,           B_sum_l               ; sum_l = qr
          MV.1        A_qr,           A_sum_h               ; sum_h = qr

          LDW.D2T2   *B_iptr++,      B_x76                  ; Load x76

          MPYLH.1     A_x10,         A_h76,      A_prod_h0  ; x0 * h0
          MPYHL.1     A_x10,         A_h76,      A_prod_h1  ; x0 * h1
          MPYLH.2     B_x32,         B_h54,      B_prod_h2  ; x0 * h2
          MPYHL.2     B_x32,         B_h54,      B_prod_h3  ; x0 * h3
          MPYLH.1     A_x54,         A_h32,      A_prod_h4  ; x0 * h4
          MPYHL.1     A_x54,         A_h32,      A_prod_h5  ; x0 * h5
          MPYLH.2     B_x76,         B_h10,      B_prod_h6  ; x0 * h6
          MPYHL.2     B_x76,         B_h10,      B_prod_h7  ; x0 * h7

          MPY.1       A_x10,         A_l10,      A_prod_l0  ; x0 * l0
          MPYH.1      A_x10,         A_l10,      A_prod_l1  ; x1 * l1
          MPY.2       B_x32,         B_l32,      B_prod_l2  ; x2 * l2
          MPYH.2      B_x32,         B_l32,      B_prod_l3  ; x3 * l3
          MPY.1       A_x54,         A_l54,      A_prod_l4  ; x4 * l4
          MPYH.1      A_x54,         A_l54,      A_prod_l5  ; x5 * l5
          MPY.2       B_x76,         B_l76,      B_prod_l6  ; x6 * l6
          MPYH.2      B_x76,         B_l76,      B_prod_l7  ; x7 * l7

          ADD.1       A_prod_h0,     A_prod_h1,  A_sumh10   ; prodh0 + prodh1
          ADD.2       B_prod_h2,     B_prod_h3,  B_sumh23   ; prodh2 + prodh3
          ADD.1       A_prod_h4,     A_prod_h5,  A_sumh54   ; prodh4 + prodh5
          ADD.2       B_prod_h6,     B_prod_h7,  B_sumh67   ; prodh6 + prodh7

          ADD.1       A_prod_l0,     A_prod_l1,  A_suml10   ; prodl0 + prodl1
          ADD.2       B_prod_l2,     B_prod_l3,  B_suml23   ; prodl2 + prodl3
          ADD.1       A_prod_l4,     A_prod_l5,  A_suml54   ; prodl4 + prodl5
          ADD.2       B_prod_l6,     B_prod_l7,  B_suml67   ; prodl6 + prodl7

          ADD.1       A_sumh10,      A_sumh54,   A_sumh_od  ; sumh10 + sumh54
          ADD.2       B_sumh23,      B_sumh67,   B_sumh_ev  ; sumh23 + sumh67
          ADD.1       A_suml10,      A_suml54,   A_suml_od  ; suml10 + suml54
          ADD.2       B_suml23,      B_suml67,   B_suml_ev  ; suml23 + suml67

          ADD.2x      A_suml_od,     B_suml_ev,  B_suml_new ; suml_ev + suml_od
          ADD.1x      B_sumh_ev,     A_sumh_od,  A_sumh_new ; sumh_ev + sumh_od

          ADD.2       B_sum_l,       B_suml_new, B_acc_low  ; sum_l + suml_new
          ADD.1       A_sum_h,       A_sumh_new, A_acc_hi   ; sum_h + sumh_new

          SHR.2       B_acc_low,     15,         B_res_low  ; acc_lo >> 15
          SHR.1       A_acc_hi,      15,         A_res_hi   ; acc_hi >> 15

          MV.1x       B_x32,          A_x10                 ; x32 = x10
          MV.2x       A_x54,          B_x32                 ; x54 = x32
          MV.1x       B_x76,          A_x54                 ; x76 = x54

          STH.D1T1    A_res_hi,      *A_yptr_h++            ; Store *y_hp

[B_p]     STH.D2T2    B_res_low,     *B_yptr_l0++           ; Store *y_lp0
[!B_p]    STH.D2T2    B_res_low,     *B_yptr_l1++           ; Store *y_lp1
[B_p]     SUB.2       B_p,            1,         B_p        ; pred.for LP

[A_i]     SUB.1       A_i,            1,         A_i        ; if (i) i--
[A_i]     B.1         LOOP                                  ; if (i) B LOOP

          .return
          .endproc

* ========================================================================= *
*   End of file:  img_wave_horz.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

wave_vert.sa/   1066929162  0     0     0       31545     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Tue Mar 12 05:19:09 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_wave_vert : Vertical Pass of Wavelet Transform                  *
*                                                                           *
*   REVISION DATE                                                           *
*       09-Jan-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_wave_vert                                                  *
*       (                                                                   *
*           const short *restrict                                           *
*                       *restrict in_data,                                  *
*           const short *restrict qmf,                                      *
*           const short *restrict mqmf,                                     *
*           short       *restrict out_ldata,                                *
*           short       *restrict out_hdata,                                *
*           int cols                                                        *
*       );                                                                  *
*                                                                           *
*       in_data   : Array of row pointers. Data must be word aligned.       *
*       qmf[8]    : Low pass QMF filter. Must be 8 taps and word aligned.   *
*       mqmf[8]   : High pass QMF filter. Must be 8 taps and word aligned.  *
*       out_ldata : Low pass output data                                    *
*       out_hdata : High pass output data                                   *
*       cols      : Length of rows to process. Must be a multiple of 2.     *
*                                                                           *
*   DESCRIPTION                                                             *
*       The benchmark performs the vertical pass of 2D wavelet              *
*       transform. It performs a vertical filter on 8 rows which are        *
*       pointed to by the pointers contained in an array of pointers.       *
*       It produces two lines worth of output, one being the low-pass       *
*       and the other being the high pass result. Instead of performing     *
*       a transpose on the column and re-using the wave_horz kernel,        *
*       the vertical filter is traversed over the entire width of the       *
*       line and the low pass and high pass filtering kernels are           *
*       performed together.                                                 *
*                                                                           *
*       This implies that the low-pass and highpass filters be              *
*       overlapped in execution so that the input data array may be         *
*       loaded once and both filters can be exceuted in parallel.           *
*                                                                           *
*   C CODE                                                                  *
*       void IMG_wave_vert                                                  *
*       (                                                                   *
*           const short *restrict                                           *
*                       *restrict in_data,   // Array of row pointers //    *
*           const short *restrict qmf,       // Low pass QMF filter   //    *
*           const short *restrict mqmf,      // High pass QMF filter  //    *
*           short       *restrict out_ldata, // Low pass output data  //    *
*           short       *restrict out_hdata, // High pass output data //    *
*           int cols                     // Length of rows to process //    *
*       )                                                                   *
*       {                                                                   *
*           const int M = 8;                                                *
*           int            i, iters, j;                                     *
*           int            sum_h, sum_l;                                    *
*           int            prod_h, prod_l;                                  *
*                                                                           *
*           short          res_h, res_l;                                    *
*           short          xdata, hdata, ldata;                             *
*           short          *filt_ptr;                                       *
*                                                                           *
*           // ------------------------------------------------------ //    *
*           //  iters: variable for the # of loop iterations.         //    *
*           //                                                        //    *
*           //  Both the low pass and the high pass filters produce   //    *
*           //  'iters' points, which is also the width of the input  //    *
*           //  line.  The low-pass filter reads filter coefficients  //    *
*           //  from qmf and the high pass filter reads filter        //    *
*           //  coefficients from the conjugate mirror filter. In     //    *
*           //  addition note that the low-pass filter coefficients   //    *
*           //  are read in increasing order while the high pass the  //    *
*           //  filter coefficients are read in the opposite order.   //    *
*           // ------------------------------------------------------ //    *
*           iters = cols;                                                   *
*                                                                           *
*           // ------------------------------------------------------ //    *
*           //  Since the filters have fractional point coefficients, //    *
*           //  all math is done using Q15 fixed-point arithmetic.    //    *
*           //  Qr is the associated round value and is set as        //    *
*           //  follows:                                              //    *
*           //                                                        //    *
*           //      #define Qpt 15                                    //    *
*           //      #define Qr 16384                                  //    *
*           //                                                        //    *
*           //  Low-Pass filter: ihptr contains 8 pointers which      //    *
*           //  point to input lines. The filters are placed          //    *
*           //  vertically and input data is read from 8 seperate     //    *
*           //  lines. Hence data-reuse is not possible when          //    *
*           //  traversing horizontally. sum_l is initialized to Qr   //    *
*           //  and contains the low-pass FIR sum at the end of the   //    *
*           //  j loop. sum_h contains the accumulator result for     //    *
*           //  the high pass filter in a similar fashion.  M is      //    *
*           //  assumed to be 8 by all kernels and is # filter taps   //    *
*           //  for D4.                                               //    *
*           // ------------------------------------------------------ //    *
*                                                                           *
*           for ( i = 0; i < iters; i++)                                    *
*           {                                                               *
*               sum_l    = Qr;                                              *
*               filt_ptr = qmf;                                             *
*                                                                           *
*               for ( j = 0; j < M; j++)                                    *
*               {                                                           *
*                   xdata   =  in_data[j][i];                               *
*                   ldata   =  *filt_ptr++;                                 *
*                   prod_l  =  xdata * ldata;                               *
*                   sum_l  +=  prod_l;                                      *
*               }                                                           *
*                                                                           *
*               res_l    = (sum_l >> Qpt);                                  *
*               *out_ldata++ = res_l;                                       *
*           }                                                               *
*                                                                           *
*           // ------------------------------------------------------ //    *
*           //  High-Pass filter:  ihptr contains 8 pointers which    //    *
*           //  point to input lines.  The filters are placed         //    *
*           //  vertically and input data is read from 8 seperate     //    *
*           //  lines.  Hence data-reuse is not possible when         //    *
*           //  traversing horizontally.  sum_h is initialized to     //    *
*           //  Qr and contains the low-pass FIR sum at the end of    //    *
*           //  the j loop.  sum_h contains the accumulator result    //    *
*           //  for the high pass filter in a similar fashion.  M     //    *
*           //  is # filter taps and is assumed to be 8 by all        //    *
*           //  kernels.                                              //    *
*           // ------------------------------------------------------ //    *
*           for ( i = 0; i < iters; i++)                                    *
*           {                                                               *
*               sum_h    = Qr;                                              *
*               filt_ptr = mqmf + M - 1;                                    *
*                                                                           *
*               for ( j = 0; j < M; j++)                                    *
*               {                                                           *
*                   xdata   =  in_data[j][i];                               *
*                   hdata   =  *filt_ptr--;                                 *
*                   prod_h  =  xdata * hdata;                               *
*                   sum_h  +=  prod_h;                                      *
*               }                                                           *
*                                                                           *
*               res_h    = (sum_h >> Qpt);                                  *
*               *out_hdata++ = res_h;                                       *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loop that advances along each filter tap is totally       *
*       optimized by unrolling. Further word wide loads are performed and   *
*       split multiplies are used to perform two iterations of low-pass in  *
*       parallel. The same technique is made use of but the order of        *
*       filter traversal is reversed  By loading the filter coefficients    *
*       in a special fashion one can re-use  the low-pass kernel for doing  *
*       the high-pass thereby saving codesize                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Since the wavelet transform is dyadic, cols is assumed to be a      *
*       multiple of 2.                                                      *
*                                                                           *
*       The input filters qmf and mqmf are assumed to be word aligned       *
*       and have exactly 8 taps.                                            *
*                                                                           *
*       The input data on any line is assumed to be word aligned.           *
*                                                                           *
*       The mqmf filter is constructed from the qmf as follows:             *
*                                                                           *
*           status = -1;                                                    *
*           for (i = 0; i < 8; i++)                                         *
*           {                                                               *
*               status = status * -1;                                       *
*               hdata  = qmf[i] * status;                                   *
*               filter[i] = hdata;                                          *
*           }                                                               *
*                                                                           *
*       The kernels assume that the number of filter taps is exactly        *
*       8.  In addition data that is loaded for producing out_ldata[0]      *
*       and out_hdata[0] is not identical. The data loaded for              *
*       producing out_hdata[0] produces results at the location             *
*                                                                           *
*           out_lstart = o_im + ((rows >> 1) - 3) * cols                    *
*           out_hstart = o_im + (rows >> 1) * cols                          *
*                                                                           *
*       Where o_im is start of output image, rows is # of rows of the       *
*       input image, and cols is # of cols of the output image. Hence       *
*       after three calls to the kernel in which the following output       *
*       lines get filled the low-pass pointer should be reset to point to   *
*       the start. Since the wavelet transform is dyadic rows is assumed    *
*       to be a multiple of 2 as well, just like cols.                      *
*                                                                           *
*       The following table illustrates how ylptr and yhptr need to be      *
*       updated at the start of each call to this function:                 *
*                                                                           *
*       Call#        out_ldata                  out_hdata                   *
*         1          out_lstart                 out_hstart                  *
*         2          out_lstart + cols          out_hstart + cols           *
*         3          out_lstart + 2*cols        out_hstart + 2*cols         *
*                                                                           *
*       At this point ylptr wraps around to become o_im, while yhptr        *
*       proceeds as usual:                                                  *
*                                                                           *
*         4          o_im                       out_hstart + 3*cols         *
*                                                                           *
*       In addition the kernel accepts a pointer to an array of             *
*       pointers for each input line so that a working buffer of 10         *
*       lines can be used to effectively mix DMA's and processing as        *
*       shown below:                                                        *
*                                                                           *
*       ihptr                        LINE BUFFER                            *
*       ptr0   ---->|-------------------------------------------------|     *
*       ptr1   ---->|-------------------------------------------------|     *
*       ...                                                                 *
*       ptr7   ---->|-------------------------------------------------|     *
*                                                                           *
*       At the start of the kernel 8 input lines are filled to the          *
*       first 8 lines and processing begins.  In the background the next    *
*       two lines are fetched.  The pointers are moved up by 2 namely       *
*       ptr[i] = ptr[i+2] and the last two lines now point to lines 9       *
*       and 10 and processing starts again.  In the background the next     *
*       two lines are brought in the first two lines of the line            *
*       buffer.  Pointers move up again by 2 but now the last two           *
*       pointers to line 0 and 1.  This pattern then repeats.               *
*                                                                           *
*       The first line to begin filtering is always obtained from           *
*       ptr[0], the next from ptr[1] and so on.                             *
*                                                                           *
*   MEMORY NOTE                                                             *
*       In order to eliminate bank conflicts succesive lines in the line    *
*       buffer or the pointers to these lines are seperated by exactly one  *
*       word so that loads to any succesive lines may be parallelized       *
*       together.                                                           *
*                                                                           *
*       This code is a LITTLE ENDIAN implementation.                        *
*                                                                           *
*   BIBLIOGRAPHY                                                            *
*       Mallat, Stephane. "A Wavelet Tour of Signal Processing", pg. 309.   *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

Qr          .set      16384


        .sect ".text:_wave_vert"
        .global _IMG_wave_vert
_IMG_wave_vert:  .cproc A_ihptr, B_qmf, A_filter, B_ylptr, A_yhptr, A_x
                .no_mdep

                ; regs before loopl

                .reg B_ihptr,   A_in0ptr, B_in1ptr
                .reg A_in2ptr,  B_in3ptr, A_in4ptr
                .reg B_in5ptr,  A_in6ptr, B_in7ptr
                .reg A_qmf,     A_l10,    B_l32
                .reg A_l54,     B_l76,    A_iters
                .reg B_qr

                ; regs in loopl

                .reg B_sum_l,   A_xdataA0, B_xdataB1
                .reg A_xdataC2, B_xdataD3, A_xdataE4
                .reg B_xdataF5, A_xdataG6, B_xdataH7

                .reg A_prodl0,  B_prodl1,  A_prodl2
                .reg B_prodl3,  A_prodl4,  B_prodl5
                .reg A_prodl6,  B_prodl7,  A_sum0
                .reg B_sum1,    A_sum2,    B_sum3
                .reg A_sum_ev,  B_sum_od,  B_sum
                .reg B_res_l,   A_prodlA,  B_prodlB
                .reg A_prodlC,  B_prodlD,  A_prodlE
                .reg B_prodlF,  A_prodlG,  B_prodlH
                .reg A_sum4,    B_sum5,    A_sum6
                .reg B_sum7,    A_ylptr

                ; regs outside loop

                .reg  B_filter, A_h10,    B_h32
                .reg  A_h54,    B_h76,    A_j

                ; regs in loop2

                .reg  A_sum_h,  A_prodh0, B_prodh1
                .reg  A_prodh2, B_prodh3, A_prodh4
                .reg  B_prodh5, A_prodh6, B_prodh7
                .reg  A_res_h,  A_prodhA, B_prodhB
                .reg  A_prodhC, B_prodhD, A_prodhE
                .reg  B_prodhF, A_prodhG, B_prodhH
                .reg  A_sum,  A_l1, A_l0, B_l3, B_l2
                .reg  A_l5, A_l4, B_l7, B_l6
                .reg  A_kF, B_kF

                MV.2x   A_ihptr, B_ihptr                   ; Partitioning move

                .mptr       A_ihptr, A_ihptr+0, 8
                .mptr       B_ihptr, A_ihptr+0, 8

                LDW.D1T1  *+A_ihptr[0], A_in0ptr           ; Load in0ptr
                LDW.D2T2  *+B_ihptr[1], B_in1ptr           ; Load in1ptr
                LDW.D1T1  *+A_ihptr[2], A_in2ptr           ; Load in2ptr
                LDW.D2T2  *+B_ihptr[3], B_in3ptr           ; Load in3ptr
                LDW.D1T1  *+A_ihptr[4], A_in4ptr           ; Load in4ptr
                LDW.D2T2  *+B_ihptr[5], B_in5ptr           ; Load in5ptr
                LDW.D1T1  *+A_ihptr[6], A_in6ptr           ; Load in6ptr
                LDW.D2T2  *+B_ihptr[7], B_in7ptr           ; Load in7ptr

                MV.1x      B_qmf,  A_qmf                   ; Partitioning move

                LDW.D1T1   *+A_qmf[0],  A_l10              ; l10 =  l1 | l0
                LDW.D2T2   *+B_qmf[1],  B_l32              ; l32 =  l3 | l2
                LDW.D1T1   *+A_qmf[2],  A_l54              ; l54 =  l5 | l4
                LDW.D2T2   *+B_qmf[3],  B_l76              ; l76 =  l7 | l6

                SHRU.1      A_x,   1,  A_iters             ; iters = x >> 1

                MVKL.2      Qr,   B_qr                     ; qr = Qr
                MVKH.2      Qr,   B_qr                     ; qr = Qr
                MV.1x       B_ylptr, A_ylptr               ; Partitioning move
                MVK.1       2,     A_j                     ; repeat counter

                .mptr     A_in0ptr, A_ihptr+0, 4           ; assume succesive
                .mptr     B_in1ptr, A_ihptr+4, 4           ; lines are a word
                .mptr     A_in2ptr, A_ihptr+0, 4           ; apart so that
                .mptr     B_in3ptr, A_ihptr+4, 4           ; loads to these
                .mptr     A_in4ptr, A_ihptr+0, 4           ; line may parall
                .mptr     B_in5ptr, A_ihptr+4, 4           ; ize and stores
                .mptr     A_in6ptr, A_ihptr+0, 4           ; can schedule in
                .mptr     B_in7ptr, A_ihptr+4, 4           ; seperate cycles
                .mptr     A_ylptr,  A_ihptr+0, 2           ;

LOOPL:
                MV.2        B_qr,   B_sum_l                ; sum_l = qr

                LDW.D1T1    *A_in0ptr++, A_xdataA0         ; Load xA0
                LDW.D2T2    *B_in1ptr++, B_xdataB1         ; Load xB1
                LDW.D1T1    *A_in2ptr++, A_xdataC2         ; Load xC2
                LDW.D2T2    *B_in3ptr++, B_xdataD3         ; Load xD3
                LDW.D1T1    *A_in4ptr++, A_xdataE4         ; Load xE4
                LDW.D2T2    *B_in5ptr++, B_xdataF5         ; Load xF5
                LDW.D1T1    *A_in6ptr++, A_xdataG6         ; Load xG6
                LDW.D2T2    *B_in7ptr++, B_xdataH7         ; Load xH7

                MPY.1    A_xdataA0,  A_l10, A_prodl0       ; x0 * l0
                MPYLH.2x B_xdataB1,  A_l10, B_prodl1       ; x1 * l1
                MPY.1x   A_xdataC2,  B_l32, A_prodl2       ; x2 * l2
                MPYLH.2  B_xdataD3,  B_l32, B_prodl3       ; x3 * l3
                MPY.1    A_xdataE4,  A_l54, A_prodl4       ; x4 * l4
                MPYLH.2x B_xdataF5,  A_l54, B_prodl5       ; x5 * l5
                MPY.1x   A_xdataG6,  B_l76, A_prodl6       ; x6 * l6
                MPYLH.2  B_xdataH7,  B_l76, B_prodl7       ; x7 * l7

                ADD.1    A_prodl0,   A_prodl2, A_sum0      ; x0l0 + x2l2
                ADD.2    B_prodl1,   B_prodl3, B_sum1      ; x1l1 + x3l3
                ADD.1    A_prodl4,   A_prodl6, A_sum2      ; x4l4 + x6l6
                ADD.2    B_prodl5,   B_prodl7, B_sum3      ; x5l5 + x7l7

                ADD.1    A_sum0,     A_sum2,   A_sum_ev    ; sumof even
                ADD.2    B_sum1,     B_sum3,   B_sum_od    ; sumof odd
                ADD.2x   A_sum_ev,   B_sum_od, B_sum       ; sum

                ADD.2    B_sum,      B_sum_l,  B_sum_l     ; add round
                SHR.2    B_sum_l,    15,       B_res_l     ; shift for Q15
                STH.D1T2 B_res_l,    *A_ylptr++            ; store

                ; Perform second iteration of filter

                MV.2     B_qr,   B_sum_l                   ; Reset

                MPYHL.1   A_xdataA0,  A_l10,    A_prodlA   ; xA * l0
                MPYH.2x   B_xdataB1,  A_l10,    B_prodlB   ; XB * l1
                MPYHL.1x  A_xdataC2,  B_l32,    A_prodlC   ; XC * l2
                MPYH.2    B_xdataD3,  B_l32,    B_prodlD   ; XD * l3
                MPYHL.1   A_xdataE4,  A_l54,    A_prodlE   ; XE * l4
                MPYH.2x   B_xdataF5,  A_l54,    B_prodlF   ; xF * l5
                MPYHL.1x  A_xdataG6,  B_l76,    A_prodlG   ; xG * l6
                MPYH.2    B_xdataH7,  B_l76,    B_prodlH   ; xH * l7

                ADD.1     A_prodlA,   A_prodlC, A_sum4     ; xAl0 + xCl2
                ADD.2     B_prodlB,   B_prodlD, B_sum5     ; xBl1 + xDl3
                ADD.1     A_prodlE,   A_prodlG, A_sum6     ; xEl4 + xGl6
                ADD.2     B_prodlF,   B_prodlH, B_sum7     ; xFl5 + xHl7

                ADD.1     A_sum4,     A_sum6,   A_sum_ev   ; sum of even
                ADD.2     B_sum5,     B_sum7,   B_sum_od   ; sum of odd
                ADD.2x    A_sum_ev,   B_sum_od, B_sum      ; sum

                ADD.2     B_sum,      B_sum_l,  B_sum_l    ; add round
                SHR.2     B_sum_l,    15,       B_res_l    ; shift for Q15
                STH.D1T2  B_res_l,    *A_ylptr++           ; store

[A_iters]       SUB.1     A_iters,     1,       A_iters    ; if i i--;
[A_iters]       B.1       LOOPL                            ; if i branch

                MV.2x   A_ihptr, B_ihptr                   ; Reload pointers

                LDW.D1T1  *+A_ihptr[0], A_in0ptr           ; Load in0ptr
                LDW.D2T2  *+B_ihptr[1], B_in1ptr           ; Load in1ptr
                LDW.D1T1  *+A_ihptr[2], A_in2ptr           ; Load in2ptr
                LDW.D2T2  *+B_ihptr[3], B_in3ptr           ; Load in3ptr
                LDW.D1T1  *+A_ihptr[4], A_in4ptr           ; Load in4ptr
                LDW.D2T2  *+B_ihptr[5], B_in5ptr           ; Load in5ptr
                LDW.D1T1  *+A_ihptr[6], A_in6ptr           ; Load in6ptr
                LDW.D2T2  *+B_ihptr[7], B_in7ptr           ; Load in7ptr

                MV.2x     A_filter,   B_filter             ; Load high pass

                LDW.D1T2   *+A_filter[0],  B_l76           ; reverse load order
                LDW.D2T1   *+B_filter[1],  A_l54           ; so that low pass
                LDW.D1T2   *+A_filter[2],  B_l32           ; kernel may be used
                LDW.D2T1   *+B_filter[3],  A_l10           ;

                SHRU        B_l76,     16,    B_l7         ; Change ordering
                SHRU        A_l54,     16,    A_l5         ; within each word
                SHRU        B_l32,     16,    B_l3         ; so that paired
                SHRU        A_l10,     16,    A_l1         ; multiplies

                SHL         B_l76,     16,    B_l6         ; still work
                SHL         A_l54,     16,    A_l4         ; Change ordering
                SHL         B_l32,     16,    B_l2         ; within word
                SHL         A_l10,     16,    A_l0         ;

                ADD         B_l6,      B_l7,  B_l76        ; l67
                ADD         A_l4,      A_l5,  A_l54        ; l45
                ADD         B_l2,      B_l3,  B_l32        ; l23
                ADD         A_l0,      A_l1,  A_l10        ; l01

                SHRU.1   A_x,   1,  A_iters                ; iters = x >>>1

                MVKL      Qr,   B_qr                       ; Round factor
                MVKH      Qr,   B_qr                       ; Round factor

                MV        A_yhptr, A_ylptr                 ; Move higpass ptr
                                                           ; lowpass ptr
[A_j]           SUB      A_j,   1,   A_j                   ; if j j--
[A_j]           B        LOOPL                             ; if j B lOOPL

                .return
                .endproc

* ========================================================================= *
*   End of file:  img_wave_vert.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

yc_demux_0.sa/  1066929162  0     0     0       10562     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Sat Mar 16 02:58:58 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_yc_demux_be16 -- De-interleave a 4:2:2 BIG ENDIAN video stream  *
*                        into three separate LITTLE ENDIAN 16-bit planes    *
*                                                                           *
*   REVISION DATE                                                           *
*       02-Oct-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and is called as follows:              *
*                                                                           *
*       void IMG_yc_demux_be16                                              *
*       (                                                                   *
*           int n,                     // Number of luma pixels    //       *
*           const unsigned char * yc,  // Interleaved luma/chroma  //       *
*           short *restrict y,         // Luma plane (16-bit)      //       *
*           short *restrict cr,        // Cr chroma plane (16-bit) //       *
*           short *restrict cb         // Cb chroma plane (16-bit) //       *
*       );                                                                  *
*                                                                           *
*       The input array 'yc' is expected to be an interleaved 4:2:2         *
*       video stream.  The input is expected in BIG ENDIAN byte order       *
*       within each 4-byte word.  This is consistent with reading the       *
*       video stream from a word-oriented BIG ENDIAN device while the       *
*       C6000 device is in a LITTLE ENDIAN configuration.                   *
*                                                                           *
*       In other words, the expected pixel order is:                        *
*                                                                           *
*                   Word 0           Word 1          Word 2                 *
*              +---------------+---------------+---------------+--          *
*        Byte# | 0   1   2   3 | 4   5   6   7 | 8   9  10  11 |...         *
*              |cb0 y1  cr0 y0 |cb2 y3  cr2 y2 |cb4 y5  cr4 y4 |...         *
*              +---------------+---------------+---------------+--          *
*                                                                           *
*       The output arrays 'y', 'cr', and 'cb' are expected to not           *
*       overlap.  The de-interleaved pixels are written as half-words       *
*       in LITTLE ENDIAN order.                                             *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function reads the byte-oriented pixel data, zero-extends      *
*       it, and then writes it to the appropriate result array.  Both       *
*       the luma and chroma values are expected to be unsigned.             *
*                                                                           *
*       The data is expected to be in an order consistent with              *
*       reading byte oriented data from a word-oriented peripheral          *
*       that is operating in BIG ENDIAN mode, while the CPU is              *
*       in LITTLE ENDIAN mode.  This results in a pixel ordering            *
*       which is not immediately obvious.  This function correctly          *
*       reorders the pixel values so that further processing may            *
*       proceed in LITTLE ENDIAN mode.                                      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays are word aligned.                           *
*       The input must be a multiple of 8 luma pixels long.                 *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop has been unrolled a total of 8 times to allow for          *
*       processing 4 pixels in each datapath.                               *
*                                                                           *
*       Word-wide loads and stores maximize memory bandwidth                *
*       utilization.                                                        *
*                                                                           *
*       The 40-bit shifter is used to exchange the luma bytes within        *
*       each word, effectively giving leftward byte rotate.                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_yc_demux_be16"
        .global _IMG_yc_demux_be16
_IMG_yc_demux_be16: .cproc  A_n,  B_yc,  A_y, B_cr, A_cb 

        .no_mdep
        .reg    A_yc, B_y, A_i
        .reg    B_00FF00FF, A_00FF00FF
        .reg    B_00020001, A_00020001
        .reg    B_8000
        .reg    B_y2r2y3b2, A_y0r0y1b0
        .reg    B_r2b2,     A_r0b0
        .reg    B_r2_,      A_b2_
        .reg    B_r2, B_r0, A_b2, A_b0
        .reg    B_r2r0,     A_b2b0
        .reg    B_y2y3,     A_y0y1
        .reg    B_y3:B_y2_, A_y1:A_y0_
        .reg    B_y3y2,     A_y1y0

        SHR     .1      A_n,        2,          A_i

        ADD     .1X     B_yc,       4,          A_yc
        ADD     .2X     A_y,        4,          B_y

        MVKL    .2      0x00FF00FF, B_00FF00FF
        MVKH    .2      0x00FF00FF, B_00FF00FF
        MVK     .1      1,          A_00020001
        MVKLH   .1      2,          A_00020001
        MVK     .2      0xFFFF8000, B_8000

        MV      .2X     A_00020001, B_00020001
        MV      .1X     B_00FF00FF, A_00FF00FF

        .mptr           A_yc, yc + 4, 8
        .mptr           B_yc, yc + 0, 8
        .mptr           B_y,  y  + 4, 8
        .mptr           A_y,  y  + 0, 8
        .mptr           A_cb, c  + 4, 4
        .mptr           B_cr, c  + 0, 4
loop:
        LDW     .D1T2   *A_yc++[2], B_y2r2y3b2
        LDW     .D2T1   *B_yc++[2], A_y0r0y1b0

        ; Do the chromas
        AND     .2      B_y2r2y3b2, B_00FF00FF, B_r2b2
        AND     .1      A_y0r0y1b0, A_00FF00FF, A_r0b0

        MPYHU   .2      B_r2b2,     B_00020001, B_r2_
        MPYHLU  .2X     A_r0b0,     B_00020001, B_r0
        MPYLHU  .1      B_r2b2,     A_00020001, A_b2_
        MPYU    .1      A_r0b0,     A_00020001, A_b0

        MPYU    .2      B_r2_,      B_8000,     B_r2
        MPYU    .1X     A_b2_,      B_8000,     A_b2

        ADD             B_r2,       B_r0,       B_r2r0
        ADD             A_b2,       A_b0,       A_b2b0

        STW     .D2T2   B_r2r0,     *B_cr++[1]
        STW     .D1T1   A_b2b0,     *A_cb++[1]

        ; Do the lumas
        SUB     .2      B_y2r2y3b2, B_r2b2,     B_y2y3
        SUB     .1      A_y0r0y1b0, A_r0b0,     A_y0y1
        SHL     .2      B_y2y3,     8,          B_y3:B_y2_
        ADD     .2      B_y3,       B_y2_,      B_y3y2
        SHL     .1      A_y0y1,     8,          A_y1:A_y0_
        ADD     .1      A_y1,       A_y0_,      A_y1y0

        STW     .D2T2   B_y3y2,     *B_y++[2]
        STW     .D1T1   A_y1y0,     *A_y++[2]

 [A_i]  SUB     .1      A_i,        1,          A_i
 [A_i]  B               loop

        .return
        .endproc

* ========================================================================= *
*   End of file:  img_yc_demux_be16.sa                                      *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
yc_demux_1.sa/  1066929162  0     0     0       10032     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Sat Mar 16 03:57:27 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_yc_demux_le16 -- De-interleave a 4:2:2 LITTLE ENDIAN video stream *
*                        into three separate LITTLE ENDIAN 16-bit planes    *
*                                                                           *
*   REVISION DATE                                                           *
*       15-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and is called as follows:              *
*                                                                           *
*       void IMG_yc_demux_le16                                              *
*       (                                                                   *
*           int n,                       // Number of luma pixels    //     *
*           const unsigned char * yc,    // Interleaved luma/chroma  //     *
*           short *restrict y,           // Luma plane (16-bit)      //     *
*           short *restrict cr,          // Cr chroma plane (16-bit) //     *
*           short *restrict cb           // Cb chroma plane (16-bit) //     *
*       );                                                                  *
*                                                                           *
*       The input array 'yc' is expected to be an interleaved 4:2:2         *
*       video stream.  The input is expected in LITTLE ENDIAN byte          *
*       order within each 4-byte word.  This is consistent with reading     *
*       the video stream from a word-oriented LITTLE ENDIAN device          *
*       while the C6000 device is in a LITTLE ENDIAN configuration.         *
*                                                                           *
*       In other words, the expected pixel order is:                        *
*                                                                           *
*                   Word 0           Word 1          Word 2                 *
*              +---------------+---------------+---------------+--          *
*        Byte# | 0   1   2   3 | 4   5   6   7 | 8   9  10  11 |...         *
*              | y0 cr0 y1 cb0 | y2 cr2 y3 cb2 | y4 cr4 y5 cb4 |...         *
*              +---------------+---------------+---------------+--          *
*                                                                           *
*       The output arrays 'y', 'cr', and 'cb' are expected to not           *
*       overlap.  The de-interleaved pixels are written as half-words       *
*       in LITTLE ENDIAN order.                                             *
*                                                                           *
*       Please see the IMGLIB function IMB_yc_demux_be16 for code which     *
*       handles input coming from a BIG ENDIAN device.                      *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function reads the byte-oriented pixel data, zero-extends      *
*       it, and then writes it to the appropriate result array.  Both       *
*       the luma and chroma values are expected to be unsigned.             *
*                                                                           *
*       The data is expected to be in an order consistent with reading      *
*       byte oriented data from a word-oriented peripheral that is          *
*       operating in LITTLE ENDIAN mode, while the CPU is in LITTLE         *
*       ENDIAN mode.  This function unpacks the byte-oriented data          *
*       so that further processing may proceed in LITTLE ENDIAN mode.       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays are word aligned.                           *
*       The input must be a multiple of 8 luma pixels long.                 *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop has been unrolled a total of 8 times to allow for          *
*       processing 4 pixels in each datapath.                               *
*                                                                           *
*       Word-wide loads and stores maximize memory bandwidth                *
*       utilization.                                                        *
*                                                                           *
*       The 40-bit shifter is used to exchange the luma bytes within        *
*       each word, effectively giving leftward byte rotate.                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_yc_demux_le16"
        .global _IMG_yc_demux_le16
_IMG_yc_demux_le16: .cproc  A_n,  B_yc,  A_y, B_cr, A_cb 

        .no_mdep
        .reg    A_yc, B_y, A_i
        .reg    B_00FF00FF, A_00000100
        .reg    B_b2y3r2y2, A_b0y1r0y0
        .reg    B___y3__y2, A___y1__y0
        .reg    B_b2__r2__, A_b0__r0__
        .reg    B___b2____, A___r2____
        .reg    B_______b0, A_______r0
        .reg    B___b2__b0, A___r2__r0

        SHR     .1      A_n,        2,          A_i

        ADD     .1X     B_yc,       4,          A_yc
        ADD     .2X     A_y,        4,          B_y

        MVKL    .2      0x00FF00FF, B_00FF00FF
        MVKH    .2      0x00FF00FF, B_00FF00FF
        MVK     .1      0x00000100, A_00000100

        .mptr           A_yc, yc + 4, 8
        .mptr           B_yc, yc + 0, 8
        .mptr           B_y,  y  + 4, 8
        .mptr           A_y,  y  + 0, 8
        .mptr           A_cb, c  + 4, 4
        .mptr           B_cr, c  + 0, 4
loop:
        LDW     .D1T2   *A_yc++[2], B_b2y3r2y2
        LDW     .D2T1   *B_yc++[2], A_b0y1r0y0

        ; Do the lumas
        AND     .2      B_b2y3r2y2, B_00FF00FF, B___y3__y2
        AND     .1X     A_b0y1r0y0, B_00FF00FF, A___y1__y0

        ; Do the chromas
        SUB     .2      B_b2y3r2y2, B___y3__y2, B_b2__r2__
        SUB     .1      A_b0y1r0y0, A___y1__y0, A_b0__r0__

        SHRU    .2X     A_b0__r0__, 24,         B_______b0
        EXTU    .1      A_b0__r0__, 16, 24,     A_______r0
        MPYHLU  .2X     B_b2__r2__, A_00000100, B___b2____
        MPYU    .1X     B_b2__r2__, A_00000100, A___r2____

        ADD     .2      B___b2____, B_______b0, B___b2__b0
        ADD     .1      A___r2____, A_______r0, A___r2__r0

        STW     .D2T1   A___r2__r0, *B_cr++[1]
        STW     .D1T2   B___b2__b0, *A_cb++[1]
        STW     .D2T2   B___y3__y2, *B_y++[2]
        STW     .D1T1   A___y1__y0, *A_y++[2]

 [A_i]  SUB     .1      A_i,        1,          A_i
 [A_i]  B               loop
        .return
        .endproc

* ========================================================================= *
*   End of file:  img_yc_demux_le16.sa                                      *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

ycbcr422p_.sa/  1066929162  0     0     0       25185     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Tue Mar 26 19:07:56 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_ycbcr422p_rgb565 -- Planarized YCbCr 4:2:2 to 16-bit RGB 5:6:5  *
*                               color space conversion.                     *
*                                                                           *
*   REVISION DATE                                                           *
*       02-Sep-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and is called according to this        *
*       C prototype:                                                        *
*                                                                           *
*       void IMG_ycbcr422p_rgb565                                           *
*       (                                                                   *
*         const short         coeff[5],  /* Matrix coefficients.        */  *
*         const unsigned char *y_data,   /* Luminence data  (Y')        */  *
*         const unsigned char *cb_data,  /* Blue color-diff (B'-Y')     */  *
*         const unsigned char *cr_data,  /* Red color-diff  (R'-Y')     */  *
*         unsigned short                                                    *
*                    *restrict rgb_data, /* RGB 5:6:5 packed pixel out. */  *
*         unsigned            num_pixels /* # of luma pixels to process */  *
*       );                                                                  *
*                                                                           *
*       The 'coeff[]' array contains the color-space-conversion matrix      *
*       coefficients.  The 'y_data', 'cb_data' and 'cr_data' pointers       *
*       point to the separate input image planes.  The 'rgb_data' pointer   *
*       points to the output image buffer.  See below for alignment         *
*       constraints on these buffers.                                       *
*                                                                           *
*       The kernel is designed to process arbitrary amounts of 4:2:2        *
*       image data, although 4:2:0 image data may be processed as well.     *
*       For 4:2:2 input data, the 'y_data', 'cb_data' and 'cr_data'         *
*       arrays may hold an arbitrary amount of image data, including        *
*       multiple scan lines of image data.                                  *
*                                                                           *
*       For 4:2:0 input data, only a single scan-line (or portion           *
*       thereof) may be processed at a time.  This is achieved by           *
*       calling the function twice using the same row data for              *
*       'cr_data' and 'cb_data', and providing new row data for             *
*       'y_data'.  This is numerically equivalent to replicating the Cr     *
*       and Cb pixels vertically.                                           *
*                                                                           *
*       The coefficients in the coeff array must be in signed Q13 form.     *
*       These coefficients correspond to the following matrix equation:     *
*                                                                           *
*           [ coeff[0] 0.0000   coeff[1] ]   [ Y' -  16 ]     [ R']         *
*           [ coeff[0] coeff[2] coeff[3] ] * [ Cb - 128 ]  =  [ G']         *
*           [ coeff[0] coeff[4] 0.0000   ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*       The output from this kernel is 16-bit RGB in 5:6:5 format.          *
*       The RGB components are packed into halfwords as shown below.        *
*                                                                           *
*                      15      11 10       5 4        0                     *
*                     +----------+----------+----------+                    *
*                     |   Red    |  Green   |   Blue   |                    *
*                     +----------+----------+----------+                    *
*                                                                           *
*       This kernel can also return the red, green, and blue values in      *
*       the opposite order if a particular application requires it.         *
*       This is achieved by exchanging the 'cb_data' and 'cr_data'          *
*       arguments when calling the function, and by reversing the order     *
*       of coefficients in coeff[1] through coeff[4].  This essentially     *
*       implements the following matrix multiply:                           *
*                                                                           *
*           [ coeff[0] 0.0000   coeff[4] ]   [ Y' -  16 ]     [ B']         *
*           [ coeff[0] coeff[3] coeff[2] ] * [ Cr - 128 ]  =  [ G']         *
*           [ coeff[0] coeff[1] 0.0000   ]   [ Cb - 128 ]     [ R']         *
*                                                                           *
*       The reversed RGB ordering output by this mode is as follows:        *
*                                                                           *
*                      15      11 10       5 4        0                     *
*                     +----------+----------+----------+                    *
*                     |   Blue   |  Green   |   Red    |                    *
*                     +----------+----------+----------+                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       This kernel performs Y'CbCr to RGB conversion.  From the Color      *
*       FAQ, http://home.inforamp.net/~poynton/ColorFAQ.html :              *
*                                                                           *
*           Various scale factors are applied to (B'-Y') and (R'-Y')        *
*           for different applications.  The Y'PbPr scale factors are       *
*           optimized for component analog video.  The Y'CbCr scaling       *
*           is appropriate for component digital video, JPEG and MPEG.      *
*           Kodak's PhotoYCC(tm) uses scale factors optimized for the       *
*           gamut of film colors.  Y'UV scaling is appropriate as an        *
*           intermediate step in the formation of composite NTSC or PAL     *
*           video signals, but is not appropriate when the components       *
*           are keps separate.  Y'UV nomenclature is now used rather        *
*           loosely, and it sometimes denotes any scaling of (B'-Y')        *
*           and (R'-Y').  Y'IQ coding is obsolete.                          *
*                                                                           *
*       This code can perform various flavors of Y'CbCr to RGB              *
*       conversion as long as the offsets on Y, Cb, and Cr are -16,         *
*       -128, and -128, respectively, and the coefficients match the        *
*       pattern shown.                                                      *
*                                                                           *
*       The kernel implements the following matrix form, which involves 5   *
*       unique coefficients:                                                *
*                                                                           *
*           [ coeff[0] 0.0000   coeff[1] ]   [ Y' -  16 ]     [ R']         *
*           [ coeff[0] coeff[2] coeff[3] ] * [ Cb - 128 ]  =  [ G']         *
*           [ coeff[0] coeff[4] 0.0000   ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*                                                                           *
*       Below are some common coefficient sets, along with the matrix       *
*       equation that they correspond to.   Coefficients are in signed      *
*       Q13 notation, which gives a suitable balance between precision      *
*       and range.                                                          *
*                                                                           *
*       1.  Y'CbCr -> RGB conversion with RGB levels that correspond to     *
*           the 219-level range of Y'.  Expected ranges are [16..235] for   *
*           Y' and [16..240] for Cb and Cr.                                 *
*                                                                           *
*           coeff[] = { 0x2000, 0x2BDD, -0x0AC5, -0x1658, 0x3770 };         *
*                                                                           *
*           [ 1.0000    0.0000    1.3707 ]   [ Y' -  16 ]     [ R']         *
*           [ 1.0000   -0.3365   -0.6982 ] * [ Cb - 128 ]  =  [ G']         *
*           [ 1.0000    1.7324    0.0000 ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*       2.  Y'CbCr -> RGB conversion with the 219-level range of Y'         *
*           expanded to fill the full RGB dynamic range.  (The matrix       *
*           has been scaled by 255/219.)  Expected ranges are [16..235]     *
*           for Y' and [16..240] for Cb and Cr.                             *
*                                                                           *
*           coeff[] = { 0x2543, 0x3313, -0x0C8A, -0x1A04, 0x408D };         *
*                                                                           *
*           [ 1.1644    0.0000    1.5960 ]   [ Y' -  16 ]     [ R']         *
*           [ 1.1644   -0.3918   -0.8130 ] * [ Cb - 128 ]  =  [ G']         *
*           [ 1.1644    2.0172    0.0000 ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*       3.  Y'CbCr -> BGR conversion with RGB levels that correspond to     *
*           the 219-level range of Y'.  This is equivalent to #1 above,     *
*           except that the R, G, and B output order in the packed          *
*           pixels is reversed.  Note:  The 'cr_data' and 'cb_data'         *
*           input arguments must be exchanged for this example as           *
*           indicated under USAGE above.                                    *
*                                                                           *
*           coeff[] = { 0x2000, 0x3770, -0x1658, -0x0AC5, 0x2BDD };         *
*                                                                           *
*           [ 1.0000    0.0000    1.7324 ]   [ Y' -  16 ]     [ B']         *
*           [ 1.0000   -0.6982   -0.3365 ] * [ Cr - 128 ]  =  [ G']         *
*           [ 1.0000    1.3707    0.0000 ]   [ Cb - 128 ]     [ R']         *
*                                                                           *
*       4.  Y'CbCr -> BGR conversion with the 219-level range of Y'         *
*           expanded to fill the full RGB dynamic range.  This is           *
*           equivalent to #2 above, except that the R, G, and B output      *
*           order in the packed pixels is reversed.  Note:  The             *
*           'cr_data' and 'cb_data' input arguments must be exchanged       *
*           for this example as indicated under USAGE above.                *
*                                                                           *
*           coeff[] = { 0x2000, 0x408D, -0x1A04, -0x0C8A, 0x3313 };         *
*                                                                           *
*           [ 1.0000    0.0000    2.0172 ]   [ Y' -  16 ]     [ B']         *
*           [ 1.0000   -0.8130   -0.3918 ] * [ Cr - 128 ]  =  [ G']         *
*           [ 1.0000    1.5960    0.0000 ]   [ Cb - 128 ]     [ R']         *
*                                                                           *
*       Other scalings of the color differences (B'-Y') and (R'-Y')         *
*       (sometimes incorrectly referred to as U and V) are supported, as    *
*       long as the color differences are unsigned values centered around   *
*       128 rather than signed values centered around 0, as noted above.    *
*                                                                           *
*       In addition to performing plain color-space conversion, color       *
*       saturation can be adjusted by scaling coeff[1] through coeff[4].    *
*       Similarly, brightness can be adjusted by scaling coeff[0].          *
*       General hue adjustment can not be performed, however, due to the    *
*       two zeros hard-coded in the matrix.                                 *
*                                                                           *
*   TECHNIQUES                                                              *
*       Pixel replication is performed implicitly on chroma data to         *
*       reduce the total number of multiplies required.  The chroma         *
*       portion of the matrix is calculated once for each Cb, Cr pair,      *
*       and the result is added to both Y' samples.                         *
*                                                                           *
*       Luma is biased downwards to produce R, G, and B values that are     *
*       signed quantities centered around zero, rather than unsigned qtys.  *
*       This allows us to use SSHL to perform saturation, followed by a     *
*       quick XOR to correct the sign bits in the final packed pixels.      *
*       The required downward bias is 128 shifted left by the Q-point, 13.  *
*                                                                           *
*       To save two instructions, "(y0-16)*luma - (128<<13)" is transformed *
*       to the slightly more cryptic "y0*luma - (16*luma + (128<<13))".     *
*       This gives the non-obvious but effective y_bias value               *
*       -((128 << 13) + 16*luma).                                           *
*       Twin pointers are used for the stack and coeff[] arrays for speed.  *
*                                                                           *
*       Creatively constructed multiplies are used to avoid a bottleneck    *
*       on shifts in the loop.  In particular, the 5-bit mask 0xF8000000    *
*       doubles as a right-shift constant that happens to negate while      *
*       shifting.  This negation is reversed by merging the bits with a     *
*       SUB instead of an ADD or OR.                                        *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       An even number of luma samples needs to be processed.               *
*                                                                           *
*       The output image must be word aligned.                              *
*                                                                           *
*   SOURCE                                                                  *
*       Poynton, Charles et al.  "The Color FAQ,"  1999.                    *
*           http://home.inforamp.net/~poynton/ColorFAQ.html                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_ycbcr422pl_to_rgb565"
        .global _IMG_ycbcr422p_rgb565
_IMG_ycbcr422p_rgb565: .cproc  A_coef, B_y_data, A_cb_data, B_cr_data, A_rgb_data, B_num_pix
        .no_mdep

        .reg    A_y_ptr, B_y1, B_cb_, B_k32_k128, B_cb, B_y1t_, B_y_bias
        .reg    B_y1t, B_gcb_bcb, B_bt, B_gt_, B_r1, B_g1, B_b1
        .reg    B_r1t, B_k_mask6, B_g1t, B_b1t, B_r1s, B_g1s, B_b1s
        .reg    B_g1f, B_b1f, B_r_b1, B_rgb1, B_rgb_, B_rgb_ptr
        .reg    A_y0, B_cb_ptr, B_cr_ptr, A_cr_, A_k32_k128, A_cr
        .reg    A_one_lum, A_y0t_, A_y0t, A_gcr_rcr, A_gt_, A_gt
        .reg    A_rt, A_r0, A_g0, A_b0, A_r0t, A_g0t, A_b0t, A_r0s
        .reg    A_g0s, A_b0s, A_g0f, A_b0f, A_r_b0, A_rgb0_, A_rgb0
        .reg    A_sflip, B_rgb, A_i, A_negl, A_negl_

        .reg    A_rcr, A_gcr, A_gcr_, B_gcb, B_gcb_, B_bcb, B_coef, B_y_bias_
        .reg    B_ms5, A_ms6

        ; Move our inputs to the appropriate registers.
        MV      .1X     B_y_data,   A_y_ptr
        MV      .2X     A_cb_data,  B_cb_ptr
        MV      .2      B_cr_data,  B_cr_ptr
        MV      .2X     A_rgb_data, B_rgb_ptr

        ; Divide the loop trip count by 2.
        SHRU    .1X     B_num_pix,  1,          A_i

        ; Load our coefficients.  Use twin pointers for speed and for
        ; avoiding bank hits.

        MV      .2X     A_coef,     B_coef
        LDH     .D1T1   *A_coef[0], A_one_lum
        LDHU    .D2T1   *B_coef[1], A_rcr
        LDHU    .D1T2   *A_coef[2], B_gcb_
        LDHU    .D2T1   *B_coef[3], A_gcr_
        LDHU    .D1T2   *A_coef[4], B_bcb

        ; Finish setting up required constants.
        SHL     .2      B_gcb_,     16,         B_gcb
        SHL     .1      A_gcr_,     16,         A_gcr

        ADD     .1      A_gcr,      A_rcr,      A_gcr_rcr
        ADD     .2      B_gcb,      B_bcb,      B_gcb_bcb

        ZERO    .2      B_ms5
        MVKLH   .2      0xF800,     B_ms5
        ZERO    .1      A_ms6
        MVKLH   .1      0xFC00,     A_ms6

        MVK     .2      128,        B_k32_k128
        MVKLH   .2      32,         B_k32_k128

        MV      .1X     B_k32_k128, A_k32_k128
        MVK     .1      128,        A_k32_k128
        MVKLH   .1      32,         A_k32_k128

        CMPLT   .1      A_one_lum,  0,          A_negl_
        MVKLH   .1      1,          A_one_lum
        SHL     .2X     A_one_lum,  4,          B_y_bias_
        SHL     .1      A_negl_,    20,         A_negl
        SUB     .2X     B_y_bias_,  A_negl,     B_y_bias

        MVK     .1      0xFFFF8410, A_sflip
        MVKH    .1      0x84108410, A_sflip


        ; Do the loop.  Whee.

        .mptr           A_y_ptr,    y_data,     2
        .mptr           B_cb_ptr,   cb_data,    1
        .mptr           B_cr_ptr,   cr_data,    1
        .mptr           B_rgb_ptr,  rgb_data,   4

conv_loop:
        LDBU    .D1T1   *A_y_ptr++[2],          A_y0    ; y0 = *y_ptr++
        LDBU    .D1T2   *-A_y_ptr[1],           B_y1    ; y1 = *y_ptr++
        LDBU    .D2T2   *B_cb_ptr++,            B_cb_   ; cb = *cb_ptr++ ...
        LDBU    .D2T1   *B_cr_ptr++,            A_cr_   ; cr = *cr_ptr++ ...

        ; Remove biases from inputs.
        SUB     .2      B_cb_,      B_k32_k128, B_cb    ; cb = *cb_ptr++ - 128
        SUB     .1      A_cr_,      A_k32_k128, A_cr    ; cr = *cr_ptr++ - 128

        ; Calculate luma
        MPY     .2X     B_y1,       A_one_lum,  B_y1t_  ; y1t = y1*luma ...
        MPY     .1      A_y0,       A_one_lum,  A_y0t_  ; y0t = y0*luma ...

        SUB     .2      B_y1t_,     B_y_bias,   B_y1t   ; y1t = y1*luma - bias
        SUB     .1X     A_y0t_,     B_y_bias,   A_y0t   ; y0t = y0*luma - bias


        ; Calculate chroma
        MPY     .2      B_cb,       B_gcb_bcb,  B_bt    ; bt = cb * bcb
        MPYLH   .2      B_cb,       B_gcb_bcb,  B_gt_   ; gt = cb * gcb ...
        MPYLH   .1      A_cr,       A_gcr_rcr,  A_gt_   ; gt = ... cr * gcr
        ADD     .1X     B_gt_,      A_gt_,      A_gt    ; gt = cb*gcb + cr*gcr
        MPY     .1      A_cr,       A_gcr_rcr,  A_rt    ; rt = cr * rcr

        ; Mix luma and chroma
        ADD     .2X     B_y1t,      A_rt,       B_r1    ; r1 = y1t + rt
        ADD     .2X     B_y1t,      A_gt,       B_g1    ; g1 = y1t + gt
        ADD     .2      B_y1t,      B_bt,       B_b1    ; b1 = y1t + bt

        ADD     .1      A_y0t,      A_rt,       A_r0    ; r0 = y0t + rt
        ADD     .1      A_y0t,      A_gt,       A_g0    ; g0 = y0t + gt
        ADD     .1X     A_y0t,      B_bt,       A_b0    ; b0 = y0t + bt

        ; Saturate
        SSHL    .2      B_r1,       11,         B_r1s   ; r1s = SAT(r1)
        SSHL    .2      B_g1,       11,         B_g1s   ; g1s = SAT(g1)
        SSHL    .2      B_b1,       11,         B_b1s   ; b1s = SAT(b1)

        SSHL    .1      A_r0,       11,         A_r0s   ; r0s = SAT(r0)
        SSHL    .1      A_g0,       11,         A_g0s   ; g0s = SAT(g0)
        SSHL    .1      A_b0,       11,         A_b0s   ; b0s = SAT(b0)

        ; Truncate
        AND     .2      B_r1s,      B_ms5,      B_r1t   ; r1t = 5 msbs of r1s
        AND     .2X     B_g1s,      A_ms6,      B_g1t   ; g1t = 6 msbs of g1s
        AND     .2      B_b1s,      B_ms5,      B_b1t   ; b1t = 5 msbs of b1s

        AND     .1X     A_r0s,      B_ms5,      A_r0t   ; r0t = 5 msbs of r0s
        AND     .1      A_g0s,      A_ms6,      A_g0t   ; g0t = 6 msbs of g0s
        AND     .1X     A_b0s,      B_ms5,      A_b0t   ; b0t = 5 msbs of b0s

        ; Merge
        MPYHUS  .2      B_g1t,      B_ms5,      B_g1f   ; >> 5 and negate
        MPYHU   .2      B_b1t,      B_k32_k128, B_b1f   ; >> 11
        ADD     .2      B_r1t,      B_b1f,      B_r_b1  ; Merge red, blu
        SUB     .2      B_r_b1,     B_g1f,      B_rgb1  ; Merge red, grn, blu


        MPYHUS  .1X     A_g0t,      B_ms5,      A_g0f   ; >> 5 and negate
        MPYHU   .1      A_b0t,      A_k32_k128, A_b0f   ; >> 11
        ADD     .1      A_r0t,      A_b0f,      A_r_b0  ; Merge red, blu
        SUB     .1      A_r_b0,     A_g0f,      A_rgb0_ ; Merge red, grn, blu

        MPYHU   .1      A_rgb0_,    A_one_lum,  A_rgb0  ; >> 16

        ADD     .2X     B_rgb1,     A_rgb0,     B_rgb_  ; Merge pix 0, pix 1

        XOR     .2X     B_rgb_,     A_sflip,    B_rgb   ; Fix sign bits

        STW     .D2T2   B_rgb,      *B_rgb_ptr++        ; *rgb_ptr++ = rgb

        SUB     .1      A_i,        1,          A_i     ; while (i--)
[A_i]   B               conv_loop


        .return
        .endproc

* ========================================================================= *
*   End of file:  img_ycbcr422p_rgb565.sa                                   *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

