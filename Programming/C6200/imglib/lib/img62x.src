!<arch>
boundary.asm/   1066929161  0     0     0       14750     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.9     Sun Sep 29 03:31:21 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   NAME                                                                    *
*       IMG_boundary -- Returns coordinates of IMG_boundary pixels.         *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and is called as follows:               *
*                                                                           *
*           void IMG_boundary                                               *
*           (                                                               *
*               const unsigned char *restrict i_data,                       *
*               int rows, int cols,                                         *
*               int *restrict o_coord,                                      *
*               int *restrict o_grey                                        *
*           );                                                              *
*                                                                           *
*       The arguments are defined as follows:                               *
*                                                                           *
*           i_data   Input images that is cols-by-rows in size.             *
*           rows     Height of the input image                              *
*           cols     Width of the input image                               *
*           o_coord  Array to write output coordinates to                   *
*           o_grey   Array to write output grey levels to                   *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine scans an image looking for non-zero pixels.            *
*       The locations of those pixels are stored out to the o_coord         *
*       as packed Y/X pairs, with Y in the upper half, and X in             *
*       the lower half.  The grey levels encountered are stored             *
*       in the o_grey array in parallel.                                    *
*                                                                           *
*       The following is a C code description of the kernel without         *
*       restrictions.  This implementation has restrictions as noted        *
*       in the assumptions below.                                           *
*                                                                           *
*         void IMG_boundary                                                 *
*         (                                                                 *
*             const unsigned char *restrict i_data,                         *
*             int rows, int cols,                                           *
*             int *restrict o_coord,                                        *
*             int *restrict o_grey                                          *
*         )                                                                 *
*         {                                                                 *
*             int x, y, p;                                                  *
*                                                                           *
*             for (y = 0; y < rows; y++)                                    *
*                 for (x = 0; x < cols; x++)                                *
*                     if ((p = i_data[x + y*cols] != 0)                     *
*                     {                                                     *
*                         *o_coord++ = ((y & 0xFFFF) << 16) |               *
*                                       (x & 0xFFFF);                       *
*                         *o_grey++  = p;                                   *
*                     }                                                     *
*         }                                                                 *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       At least one row is being processed.                                *
*                                                                           *
*       Input is word aligned.                                              *
*                                                                           *
*       Input is a multiple of 4 pixels wide.                               *
*                                                                           *
*       Output buffers o_coord and o_grey start in different banks          *
*       and are word-aligned.                                               *
*                                                                           *
*       No more than 32764 rows or 32764 columns are being processed.       *
*                                                                           *
*   TECHNIQUES                                                              *
*       Outer and inner loops are collapsed together.                       *
*       Inner loop is unrolled to process four pixels per iteration.        *
*       Packed coordinate value is updated directly, rather than            *
*       by repacking x, y every time it's needed.                           *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur as long as o_coord and o_grey start         *
*       in different banks.  If they start in the same bank, every          *
*       access to each array will cause a bank conflict.                    *
*                                                                           *
*   NOTES                                                                   *
*       This code blocks interrupts for nearly its entire duration.         *
*       It is interrupt tolerant, but not interruptible.                    *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = (5 * rows * cols) / 4 + 12.                                *
*                                                                           *
*   CODESIZE                                                                *
*       160 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_boundary"
        .global _IMG_boundary
_IMG_boundary: 
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_i_data
        .asg            B4,         B_rows
        .asg            A6,         A_cols
        .asg            B6,         B_o_coord
        .asg            A8,         A_o_grey
        .asg            A7,         A_c0
        .asg            A9,         A_c1
        .asg            A9,         A_c2
        .asg            A9,         A_c3
        .asg            B5,         B_p3210
        .asg            B0,         B_p3
        .asg            B0,         B_p2
        .asg            B0,         B_p1
        .asg            B0,         B_p0
        .asg            A1,         A_x
        .asg            A5,         A_r_step
        .asg            A3,         A_cols4
        .asg            A2,         A_i
        .asg            B1,         B_l
        .asg            B3,         B_ret_addr
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        LDW     .D1T2   *A_i_data++,            B_p3210         ;[ 1,1]

        NEG     .L1     A_cols,     A_r_step
||      SHR     .S1     A_cols,     2,          A_cols4

        MVKLH   .S1     0,          A_r_step    ; r_step = 0x10000-cols
||      MPYU    .M1X    B_rows,     A_cols4,    A_i

        ZERO    .L1     A_c0

        MV      .L1     A_cols4,    A_x
||      SUB             A_i,        1,          A_i
;-
  [ A_i]B       .S1     loop                                    ;[ 6,1]
||      EXTU    .S2     B_p3210,    24, 24,     B_p0            ;[ 6,1]
||      LDW     .D1T2   *A_i_data++,            B_p3210         ;[ 1,2]

* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [ B_p0]STW    .D2T1   A_c0,       *B_o_coord++                ;[ 7,1]
||[ B_p0]STW    .D1T2   B_p0,       *A_o_grey++                 ;[ 7,1]
||      EXTU    .S2     B_p3210,    16, 24,     B_p1            ;[ 7,1]
||      ADD     .S1     A_c0,       1,          A_c1            ;[ 7,1]
||      SUB     .L1     A_i,        1,          A_i
;-
        SUB     .S1     A_x,        1,          A_x             ;[ 8,1]
||[ B_p1]STW    .D2T1   A_c1,       *B_o_coord++                ;[ 8,1]
||[ B_p1]STW    .D1T2   B_p1,       *A_o_grey++                 ;[ 8,1]
||      EXTU    .S2     B_p3210,    8,  24,     B_p2            ;[ 8,1]
||      ADD     .L1     A_c0,       2,          A_c2            ;[ 8,1]
;-
        ADD     .S1     A_c0,       4,          A_c0            ;[ 9,1]
||[ B_p2]STW    .D2T1   A_c2,       *B_o_coord++                ;[ 9,1]
||[ B_p2]STW    .D1T2   B_p2,       *A_o_grey++                 ;[ 9,1]
||      SHRU    .S2     B_p3210,    24,         B_p3            ;[ 9,1]
||      ADD     .L1     A_c0,       3,          A_c3            ;[ 9,1]
||      CMPGT   .L2     A_i,        0,          B_l
;-
  [!A_x]MV      .S1     A_cols4,    A_x                         ;[10,1]
||[!A_x]ADD     .L1     A_c0,       A_r_step,   A_c0            ;[10,1]
||[ B_p3]STW    .D2T1   A_c3,       *B_o_coord++                ;[10,1]
||[ B_p3]STW    .D1T2   B_p3,       *A_o_grey++                 ;[10,1]
||[!A_i]RET     .S2     B_ret_addr                              ; return

  [ B_l]B       .S1     loop                                    ;[ 6,2]
||      EXTU    .S2     B_p3210,    24, 24,     B_p0            ;[ 6,2]
||[ B_l]LDW     .D1T2   *A_i_data++,            B_p3210         ;[ 1,3]
* ========================================================================= *

* ========================================================================= *
*   End of file:  img_boundary.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
conv_3x3.asm/   1066929161  0     0     0       33898     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Sun Sep 29 03:31:22 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*  TEXAS INSTRUMENTS, INC.                                                  *
*                                                                           *
*   NAME                                                                    *
*       IMG_conv_3x3 -- 3x3 convolution  hand assembly                      *
*                                                                           *
*   REVISION DATE                                                           *
*       24-Jan-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_conv_3x3( const unsigned char *restrict inptr,             *
*                                unsigned char *restrict outptr,            *
*                                         int            x_dim,             *
*                          const          char *restrict mask,              *
*                                         int            shift)             *
*                                                                           *
*                                                                           *
*      The convolution routine accepts three rows of 'x_dim' input points   *
*      and performs some operation on each.  A total of 'x_dim' outputs     *
*      are written to the output array. The 'mask' array has the 3 by 3     *
*      array of coefficients.                                               *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      The convolution kernel accepts three rows of 'x_dim' input points    *
*      and produces one output row of 'x_dim' points using the input mask   *
*      of 3 by 3. The user defined shift value is used to shift the convo-  *
*      lution value, down to the byte range. The convolution sum is also    *
*      range limited to 0..255. The shift amount is non-zero for low pass   *
*      filters, and zero for high pass and sharpening filters.              *
*                                                                           *
*      The following is the C code model for the algorithm:                 *
*                                                                           *
*                                                                           *
*      void IMG_conv_3x3(   const unsigned char *restrict inptr,            *
*                                unsigned char *restrict outptr,            *
*                                         int            x_dim,             *
*                          const          char *restrict mask,              *
*                                         int            shift)             *
*      {                                                                    *
*           const   unsigned char   *IN1,*IN2,*IN3;                         *
*           unsigned char           *OUT;                                   *
*                                                                           *
*           short    pix10,  pix20,  pix30;                                 *
*           short    mask10, mask20, mask30;                                *
*                                                                           *
*           int      sum,      sum00,  sum11;                               *
*           int      i;                                                     *
*           int      sum22,    j;                                           *
*                                                                           *
*           IN1      =   inptr;                                             *
*           IN2      =   IN1 + x_dim;                                       *
*           IN3      =   IN2 + x_dim;                                       *
*           OUT      =   outptr;                                            *
*                                                                           *
*           for (j = 0; j < x_dim ; j++)                                    *
*           {                                                               *
*               sum = 0;                                                    *
*                                                                           *
*               for (i = 0; i < 3; i++)                                     *
*               {                                                           *
*                   pix10  =   IN1[i];                                      *
*                   pix20  =   IN2[i];                                      *
*                   pix30  =   IN3[i];                                      *
*                                                                           *
*                   mask10 =   mask[i];                                     *
*                   mask20 =   mask[i + 3];                                 *
*                   mask30 =   mask[i + 6];                                 *
*                                                                           *
*                   sum00  =   pix10 * mask10;                              *
*                   sum11  =   pix20 * mask20;                              *
*                   sum22  =   pix30 * mask30;                              *
*                                                                           *
*                   sum   +=   sum00 + sum11+ sum22;                        *
*               }                                                           *
*                                                                           *
*               IN1++;                                                      *
*               IN2++;                                                      *
*               IN3++;                                                      *
*                                                                           *
*               sum = (sum >> shift);                                       *
*               if ( sum <  0  )       sum = 0;                             *
*               if ( sum > 255 )       sum = 255;                           *
*               *OUT++   =       sum;                                       *
*           }                                                               *
*      }                                                                    *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*      The inner loop that computes the correlation sum is completely       *
*      unrolled and two output pixels are computed together. The mask       *
*      values are loaded and packed as words to minimize register pre-      *
*      ssure. Input data is re-used between the computations of the         *
*      two output pixels, to minimize the number of loads.                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*      An even number of output pixels needs to be computed. The image      *
*      x dimension is even.                                                 *
*                                                                           *
*   NOTES                                                                   *
*      Code is Little Endian. Code is interrup tolerant but not interru-    *
*      ptible.                                                              *
*                                                                           *
*   CYCLES                                                                  *
*      44 + x_dim/2 * 9                                                     *
*                                                                           *
*   CODESIZE                                                                *
*      768 bytes                                                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_conv_3x3"
        .global _IMG_conv_3x3
_IMG_conv_3x3:

; ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
; ========================================================================= ;
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T1   A15,        *B_SP--[14]             ; Get stk, Save A15
||      MV              B_SP,       A_SP                    ; Twin Stack Ptr

        STW     .D1T1   A14,        *-A_SP[ 2]              ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]              ; Save B14
||      MVC     .S2     CSR,        B_csr                   ; Get CSR's state

        STW     .D1T1   A13,        *-A_SP[ 4]              ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]              ; Save B13
||      AND             B_csr,      -2,         B_no_gie    ; Clear GIE
;-
        STW     .D1T1   A12,        *-A_SP[ 6]              ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]              ; Save B12

        STW     .D1T1   A11,        *-A_SP[ 8]              ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]              ; Save B11
||      MV              B_csr,      A_csr                   ; Partitioning MV

        STW     .D1T1   A10,        *-A_SP[10]              ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]              ; Save B10
||      MVC     .S2     B_no_gie,   CSR                     ; Disable ints.

; ===== Interrupts masked here =====
;-

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
;       Variables Passed to the Next Section
;-----------------------------------------------------------------------------
        .asg            A4,         A_in                   ; Input  pointer
        .asg            B4,         B_out                  ; Output pointer
        .asg            A6,         A_x_dim                ; X dimension
        .asg            B6,         B_mask                 ; mask value
        .asg            A8,         A_shift                ; shift value
        .asg            A13,        A_mask10               ; mask10 packed
        .asg            B11,        B_mask32               ; mask32 packed
        .asg            B12,        B_mask54               ; mask54 packed
        .asg            B13,        B_mask76               ; mask76 packed
        .asg            A14,        A_mask98               ; mask98 packed
        .asg            A5,         A_pix02                ; pix02
        .asg            A6,         A_pix03                ; pix03
        .asg            B4,         B_pix22                ; pix22
        .asg            B8,         B_pix23                ; pix23
        .asg            A7,         A_pix32                ; pix32
        .asg            B7,         B_pix33                ; pix33
        .asg            A4,         A_IN1                  ; pointer to line1
        .asg            A10,        A_IN2                  ; pointer to line2
        .asg            A11,        A_IN3                  ; pointer to line3
        .asg            B14,        B_shift                ; shift value
        .asg            B15,        B_255                  ; 255
        .asg            A12,        A_outp                 ; Output pointer
        .asg            A2,         A_count                ; Count for loop
        .asg            B2,         B_pd                   ; Predication
        .asg            A0,         A_mask32               ; mask32 copy
        .asg            B1,         B_out_c                ; Copy of pointer
;-----------------------------------------------------------------------------
;       Variables Consumed in this Section
;-----------------------------------------------------------------------------
        .asg            A9,         A_mask                 ; Input Mask
        .asg            A3,         A_mask0                ; Mask0 value
        .asg            A1,         A_mask1                ; Mask1 value
        .asg            B5,         B_mask2                ; Mask2 value
        .asg            B7,         B_mask3                ; Mask3 value
        .asg            A0,         A_mask4                ; Mask4 value
        .asg            A5,         A_mask5                ; Mask5 value
        .asg            B5,         B_mask6                ; Mask6 value
        .asg            B9,         B_mask7                ; Mask7 value
        .asg            A9,         A_mask8                ; Mask8 value
        .asg            A9,         A_MASK                 ; MASK copy
        .asg            A6,         A_mask1_s              ; Mask1 shifted
        .asg            A3,         A_mask0_s              ; Mask0 shifted
        .asg            B5,         B_mask3_s              ; Mask3 shifted
        .asg            B9,         B_mask2_s              ; Mask2 shifted
        .asg            A12,        A_mask5_s              ; Mask5 shifted
        .asg            A0,         A_mask4_s              ; Mask4 shifted
        .asg            A8,         A_mask54               ; Mask54 copy
        .asg            B9,         B_mask7_s              ; Mask7 shifted
        .asg            B8,         B_mask6_s              ; Mask6 shifted
        .asg            A1,         A_mask76               ; Packed mask76
        .asg            B5,         B_x_dim                ; x_dim
; ============================================================================
        MV      .S1X    B_mask,      A_mask                ; Mask Copy
||      MV      .L2     B_out,       B_out_c               ; Out  Copy
||      STW     .D1T1   A_csr,       *-A_SP[12]            ; Save CSR
||      STW     .D2T2   B_ret,       *+B_SP[ 1]            ; Save return addr.

        LDB     .D1T1   *+A_mask[5], A_mask5               ; maskk22 = mask[5]

        ADD     .L1     A_in,       0,          A_IN1      ; INPTR+offset
||      LDB     .D1T1   *+A_mask[4],            A_mask4    ; mask21 = mask[4]
||      ADD     .S1     A_IN1,      A_x_dim,    A_IN2      ; IN1 + inputcols

;--
        LDB     .D2T2   *+B_mask[7],            B_mask7    ; mask31 = mask[7]
||      LDB     .D1T1   *+A_mask[0],            A_mask0    ; mask00 = mask[0]

        ADD     .S1     A_IN2,      A_x_dim,    A_IN3      ; IN2 + inputcols
||      LDB     .D2T2   *+B_mask[6],            B_mask6    ; mask30 = mask[6]
||      LDB     .D1T1   *+A_mask[1],            A_mask1    ; mask01 = mask[1]

        LDB     .D2T2   *+B_mask[3],            B_mask3    ; mask20 = mask[3]
||      LDBU    .D1T1   *A_IN3++,   A_pix32                ; a31    = pix30

        LDBU    .D1T2   *A_IN2++,   B_pix22                ; a21    = pix20

;--
        LDB     .D2T2   *+B_mask[2],            B_mask2    ; mask02 = mask[2]
||      LDBU    .D1T1   *A_IN1++,   A_pix02                ; a01    = pix00

        LDB     .D1T1   *+A_mask[8],            A_mask8    ; mask32 = mask[8]

        MVKL    .S1     0FFFFh,     A_MASK                 ; MASK
||      LDBU    .D1T2   *A_IN3++,   B_pix33                ; a32 = pix31

        MVKH    .S1     0FFFFh,     A_MASK                 ; MASK
||      LDBU    .D1T2   *A_IN2++,   B_pix23                ; a22  = pix21
||      MV              B_SP,       A_SP                   ; Copy Stack

;--
        AND     .L2X    B_mask6,    A_MASK,     B_mask6_s  ; mask6(16)
||      SHL     .S2     B_mask7,    16,         B_mask7_s  ; mask7(16)
||      AND     .L1     A_mask4,    A_MASK,     A_mask4_s  ; mask4(16)
||      SHL     .S1     A_mask5,    16,         A_mask5_s  ; mask5(16)
||      LDBU    .D1T1   *A_IN1++,   A_pix03                ; a02 = pix01

        AND     .L2X    B_mask2,    A_MASK,     B_mask2_s  ; mask2(16)
||      SHL     .S2     B_mask3,    16,         B_mask3_s  ; mask3(16)
||      ADD     .D2     B_mask7_s,  B_mask6_s,  B_mask76   ; mask76
||      SHRU    .S1     A_x_dim,    1,          A_count    ; count for loop
||      AND     .L1     A_mask0,    A_MASK,     A_mask0_s  ; mask0(16)

        ADD     .D2     B_mask3_s,  B_mask2_s,  B_mask32   ; mask32
||      SHL     .S1     A_mask1,    16,         A_mask1_s  ; mask1(16)
||      MVKL    .S2     0FFh,       B_255                  ; 255
||      MV      .L2X    A_x_dim,    B_x_dim                ; Copy x_dim
||      MV      .L1X    B_mask76,   A_mask76               ; mask76

        ADD     .L1     A_mask5_s,  A_mask4_s,  A_mask54   ; mask54
||      MV      .S1X    B_mask32,   A_mask32               ; mask32
||      MVK     .S2     3,          B_pd                   ; predicate
||      ADD     .D1     A_count,    1,          A_count    ; count - ii
||      MV      .L2X    A_shift,    B_shift                ; shift copy

        ADD     .L1X    0,          B_out_c,    A_outp     ; out pointer
||      MVKH    .S2     0FFh,       B_255                  ; 255
||      MV      .S1     A_mask8,    A_mask98               ; mask98
||      MV      .L2X    A_mask54,   B_mask54               ; mask54
||      ADD     .D1     A_mask1_s,  A_mask0_s,  A_mask10   ; mask10

        ;==== Branch occurs

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
;       Variables passed to this section from previous section
;=============================================================================
        .asg            A13,        A_mask10      ;  Mask10 register
        .asg            B11,        B_mask32      ;  Mask32 register
        .asg            B12,        B_mask54      ;  Mask54 register
        .asg            B13,        B_mask76      ;  Mask76 register
        .asg            A14,        A_mask98      ;  Mask98 register
        .asg            A5,         A_pix02       ;  pix02
        .asg            A6,         A_pix03       ;  pix03
        .asg            B4,         B_pix22       ;  pix22
        .asg            B8,         B_pix23       ;  pix23
        .asg            A7,         A_pix32       ;  pix32
        .asg            B7,         B_pix33       ;  pix33
        .asg            A4,         A_IN1         ;  Pointer to row 1
        .asg            A10,        A_IN2         ;  Pointer to row 2
        .asg            A11,        A_IN3         ;  Pointer to row 3
        .asg            B14,        B_shift       ;  Shift value
        .asg            B15,        B_255         ;  255
        .asg            A12,        A_outp        ;  outp pointer
        .asg            A2,         A_count       ;  loop trip count
        .asg            B2,         B_pd          ; Predication register
        .asg            A0,         A_mask32      ; Mask32 copy
;-----------------------------------------------------------------------------
;       Variables created and destroyed in this section
;-----------------------------------------------------------------------------
        .asg            A3,         A_sum00       ; sum00 for row0 pixel0
        .asg            A5,         A_sum01       ; sum01 for row1 pixel0
        .asg            B3,         B_sum10       ; sum02 for row2 pixel0
        .asg            B9,         B_sum11       ; sum11 for row0 pixel0
        .asg            A6,         A_sum20       ; sum20 for row0 pixel0
        .asg            B9,         B_sum21       ; sum21 for row1 pixel0
        .asg            A9,         A_sum30       ; sum30 for row0 pixel1
        .asg            B1,         B_sum40       ; Temporary variables
        .asg            B4,         B_sum51       ; to hold partial
        .asg            A8,         A_sum02       ; convolution sums
        .asg            A3,         A_sum0        ; when the inner loop
        .asg            B9,         B_sum12       ; is unrolled once
        .asg            B3,         B_sum1        ; for 18 multiplies
        .asg            B0,         B_sum         ; to be executed in
        .asg            A5,         A_sum22       ; parallel.
        .asg            B6,         B_sum2        ; sum2 temporary sum
        .asg            B10,        B_pix         ; pix to store
        .asg            B1,         B_pos         ; pos flag
        .asg            A1,         A_neg         ; neg flag
        .asg            A8,         A_sum31       ; sum31 temporary sum
        .asg            A3,         A_sum32       ; sum32 temporary sum
        .asg            A8,         A_sum3        ; sum3  temporary sum
        .asg            B5,         B_sum41       ;
        .asg            B4,         B_sum42       ;
        .asg            B5,         B_sum4        ;
        .asg            B5,         B_add         ;
        .asg            A9,         A_sum50       ;
        .asg            B1,         B_sum52       ;
        .asg            B6,         B_sum5        ; sum5 is temporary
        .asg            B9,         B_pix_1       ; pix_1 to store
        .asg            B6,         B_255_new     ; Copy 255 to B6
; ============================ PIPE LOOP KERNEL ==============================

LOOP:
        CMPGT   .L1X    0,          B_pix,      A_neg    ; neg = (pix1 < 0)
||      CMPGT   .L2     B_pix,      B_255,      B_pos    ; pos = (pix1 > 255)
||      ADD     .S2X    B_sum4,     A_sum3,     B_add    ; sum1= sum1+ sum0
||      MPYLH   .M1     A_pix02,    A_mask10,   A_sum31  ; c01 = (a01*mask01)
||      ADD     .D2     B_sum10,    B_sum11,    B_sum1   ; sum1= (c00+c01)
||      MPYLH   .M2     B_pix22,    B_mask54,   B_sum12  ; c02 = (a22*mask22)
||      LDBU    .D1T2   *-A_IN3[1], B_pix33              ; a33 = pix32

  [ B_pos]MV    .L2     B_255,      B_pix                ; pix = 255
||      ADD     .D2     B_add,      B_sum5,     B_add    ; sum2   = sum2 + sum1
||[ A_count]SUB .S1     A_count,    1,          A_count  ; count--
||      ADD     .S2X    A_sum20,    B_sum21,    B_sum2   ; sum2 = c00+c01
||      ADD     .L1     A_sum0,     A_sum02,    A_sum0   ; sum0 = (c00+c01+c02)
||      MPYLH   .M1X    A_pix32,    B_mask76,   A_sum50  ; c01  = (a31*mask31)
||      MPY     .M2     B_pix22,    B_mask54,   B_sum41  ; c01  = (a21*mask21)
||      LDBU    .D1T2   *-A_IN2[1], B_pix23              ; a23  = pix22

  [ A_neg]ZERO  .L2     B_pix                            ; pix = 0
||      SHR     .S2     B_add,      B_shift,    B_pix_1  ; sum2 = sum2>>shiftval
||      ADD     .D1     A_sum30,    A_sum31,    A_sum3   ; sum0 = (c00+c01)
||      MPY     .M2     B_pix33,    B_mask76,   B_sum51  ; c00  = (a30*mask30)
||      ADD     .D2     B_sum1,     B_sum12,    B_sum1   ; sum1 = (c00+c01+c02)
||      MPY     .M1     A_pix03,    A_mask32,   A_sum32  ; c02  = (a02*mask02)

        CMPGT   .L2     B_pix_1,    B_255,      B_pos    ; pos = pix1 > 255
||[ A_count]B   .S1     LOOP                             ; if(count) B LOOP
||      ADD     .S2X    B_sum1,     A_sum0,     B_sum    ; sum1 = sum1+ sum0
||      MPYLH   .M2     B_pix22,    B_mask32,   B_sum10  ; c00  = (a20*mask20)
||      MPY     .M1     A_pix02,    A_mask10,   A_sum00  ; c00  = (a00*mask00)
||      LDBU    .D1T1   *A_IN1++[2],            A_pix02  ; a02  = pix02

        CMPGT   .L1X    0,          B_pix_1,    A_neg    ; neg = ( pix1 < 0)
||[ B_pos]MV    .L2     B_255,      B_pix_1              ; pix1 = 255
||      ADD     .S1     A_sum3,     A_sum32,    A_sum3   ; sum0 = (c00+c01+c02)
||      MPYLH   .M2     B_pix23,    B_mask32,   B_sum40  ; c00  = (a20*mask20)
||      MPY     .M1     A_pix32,    A_mask98,   A_sum22  ; c02  = (a32*mask32)
||      LDBU    .D1T2   *A_IN2++[2],            B_pix22  ; a22  = pix22

  [ A_neg]ZERO  .L2     B_pix_1                          ; pix1 = 0
||[ B_pd]SUB    .D2     B_pd,       1,          B_pd     ; pd--
||      MPY     .M2X    B_pix33,    A_mask98,   B_sum52  ; c02 = (a32*mask32)
||      MPYLH   .M1     A_pix03,    A_mask10,   A_sum01  ; c01 = (a01*mask01)
||      LDBU    .D1T1   *A_IN3++[2],            A_pix32  ; a32 = pix32

        ADD     .D2     B_sum40,    B_sum41,    B_sum4   ; sum1= (c00+c01)
||      ADD     .S2X    B_sum2,     A_sum22,    B_sum2   ; sum2= c00+c01+c02
||      MPYLH   .M2     B_pix23,    B_mask54,   B_sum42  ; c02 = (a22*mask22)
||      MPY     .M1X    A_pix32,    B_mask76,   A_sum20  ; c00 = (a30*mask30)
||      LDBU    .D1T1   *-A_IN1[1], A_pix03              ; a03 = pix02

  [!B_pd]STB    .D1T2   B_pix,      *A_outp++            ; *outp++= sum2
||      ADD     .L2     B_sum,      B_sum2,     B_sum    ; sum2   = sum2+sum1
||      ADD     .D2     B_sum52,    B_sum51,    B_sum5   ; sum2   = c00+c01
||      MPY     .M1     A_pix03,    A_mask10,   A_sum30  ; c00    = (a00*mask00)
||      ADD     .S1     A_sum00,    A_sum01,    A_sum0   ; sum0   = (c00+c01)
||      MPY     .M2     B_pix23,    B_mask54,   B_sum11  ; c01    = (a21*mask21)

  [!B_pd]STB    .D1T2   B_pix_1,    *A_outp++            ; *outp++= sum2
||      SHR     .S2     B_sum,      B_shift,    B_pix    ; sum2 = sum2>>shiftval
||      ADD     .L2X    B_sum5,     A_sum50,    B_sum5   ; sum2 = c00+c01+c02
||      ADD     .D2     B_sum4,     B_sum42,    B_sum4   ; sum1 = (c00+c01+c02)
||      MPYLH   .M2     B_pix33,    B_mask76,   B_sum21  ; c01  = (a31*mask31)
||      MPY     .M1     A_pix02,    A_mask32,   A_sum02  ; c02  = (a02*mask02)

; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:

        CMPGT   .L1X    0,          B_pix,      A_neg    ; neg = (pix1 < 0)
||      CMPGT   .L2     B_pix,      B_255,      B_pos    ; pos = (pix > 255)
||      ADD     .S2X    B_sum4,     A_sum3,     B_add    ; sum1= sum1+ sum0

  [ B_pos]MV    .L2     B_255,      B_pix                ; pix = 255
||      ADD     .D2     B_add,      B_sum5,     B_add    ; sum2= sum2+sum1
||[ A_count]SUB .S1     A_count,    1,          A_count  ; count--
||      MPY     .M2     B_255,      1,          B_255_new; Copy 255 to B6
||      MV      .S2x    A_SP,       B_SP                 ; Twin Stack Pointer

  [ A_neg]ZERO  .L2     B_pix                            ; pix = 0
||      SHR     .S2     B_add,      B_shift,    B_pix_1  ; sum2 = sum2>>shiftval
||      LDW     .D1T2   *+A_SP[ 1], B_ret                ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr                ; Get CSR's value


; ================ SYMBOLIC REGISTER ASSIGNMENTS: CLEANUP ================= ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            A0,         A_csr       ; CSR value to restore
        .asg            B3,         B_ret       ; Return address
        .asg            B6,         B_255_new   ;
        .asg            B4,         B_pix_c     ;
; ========================================================================= ;

        CMPGT   .L2     B_pix_1,    B_255_new,   B_pos  ; pos = (pix1 > 255)
||      LDW     .D1T2   *+A_SP[ 5], B11                 ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11                 ; Restore A11
||      MV      .S2     B_pix,      B_pix_c             ; Copy last B_pix

        CMPGT   .L1X    0,          B_pix_1,    A_neg   ; neg = (pix1 < 0)
||[ B_pos]MV    .L2     B_255_new,  B_pix_1             ; pix1 = 255
||      LDW     .D1T2   *+A_SP[ 3], B10                 ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10                 ; Restore A10

  [ A_neg]ZERO  .L2     B_pix_1                         ; pix1 = 0
||[ B_pd]SUB    .S2     B_pd,       1,          B_pd    ; pd--
||      LDW     .D1T2   *+A_SP[11], B14                 ; Restore B12
||      LDW     .D2T1   *+B_SP[12], A14                 ; Restore A12

;--
        LDW     .D1T2   *+A_SP[ 9], B13                 ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13                 ; Restore A13

        LDW     .D1T2   *+A_SP[ 7], B12                 ; Restore B14
||      LDW     .D2T1   *+B_SP[ 8], A12                 ; Restore A14
||      RET     .S2     B_ret                           ; Return to caller

        MVC     .S2X    A_csr,      CSR                 ; Restore CSR
||      LDW     .D2T1   *++B_SP[14],A15                 ; Restore A15
; ===== Interruptibility state restored here =====

 [!B_pd]STB    .D1T2   B_pix_c,    *A_outp++            ; *outp++= sum2

 [!B_pd]STB    .D1T2   B_pix_1,    *A_outp++            ; *outp++= sum2

        NOP             2                               ; 2 NOPS
; ===== Branch Occurs =====

* ========================================================================= *
*   End of file:  convolution_h.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
corr_3x3.asm/   1066929161  0     0     0       20805     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Fri Oct 11 16:11:42 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       corr_3x3: 3x3 correlation with rounding for 8 bit data              *
*                                                                           *
*   REVISION DATE                                                           *
*       11-Oct-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void IMG_corr_3x3                                               *
*           (                                                               *
*               const unsigned char *i_data,       // input image       //  *
*               int        *restrict o_data,       // output image      //  *
*               const unsigned char  mask[3][3],   // convolution mask  //  *
*               int                  x_dim,        // width of image    //  *
*               int                  n_out         // number of outputs //  *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       The correlation performs a point by point multiplication of the     *
*       3 by 3 mask with the input image.  The result of the nine           *
*       multiplications are then summed up together to produce a            *
*       convolution sum.  This sum is then stored to the output array.      *
*                                                                           *
*       The image mask to be correlated is typically part of the input      *
*       image and indicates the area of the best match between the          *
*       input image and mask.  The mask is moved one column at a time,      *
*       advancing the mask over the portion of the row specified by         *
*       'n_out'.  When 'n_out' is larger than 'x_dim', multiple rows        *
*       will be processed.                                                  *
*                                                                           *
*       An application may call this kernel once per row to calculate       *
*       the correlation for an entire image:                                *
*                                                                           *
*           for (i = 0; i < rows; i++)                                      *
*           {                                                               *
*               IMG_corr_3x3(&i_data[i * x_dim], &o_data[i * n_out],        *
*                           mask, x_dim, n_out);                            *
*           }                                                               *
*                                                                           *
*       Alternately, the kernel may be invoked for multiple rows at         *
*       a time, although the two outputs at the end of each row will        *
*       have meaningless values.  For example:                              *
*                                                                           *
*           IMG_corr_3x3(i_data, o_data, mask, x_dim, 2 * x_dim);           *
*                                                                           *
*       This will produce two rows of outputs into 'o_data'.  The           *
*       outputs at locations o_data[x_dim - 2], o_data[x_dim - 1],          *
*       o_data[2*x_dim - 2] and o_data[2*x_dim - 1] will have               *
*       meaningless values.  This is harmless, although the application     *
*       will have to account for this when interpreting the results.        *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The array pointed to by o_data does not alias with the array        *
*       pointed to by i_data or mask.                                       *
*                                                                           *
*       The number of outputs 'n_out' must be a multiple of 2.  In cases    *
*       where 'n_out' is not a multiple of 2, most applications can safely  *
*       round 'n_out' up to the next multiple of 2 and ignore the extra     *
*       outputs.  This kernel does not round 'n_out' up for the user.       *
*                                                                           *
*   NOTE                                                                    *
*       This kernel is interrupt tolerant, but not interruptible.           *
*       Interrupts are masked for the entire duration of the kernel         *
*       by clearing GIE.                                                    *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The mask[] array must be word aligned.  No other restrictions       *
*       are placed on the alignments of the inputs.                         *
*                                                                           *
*       Up to 6 bank conflicts occur during the setup code.  No bank        *
*                                                                           *
*       This code assumes a LITTLE ENDIAN configuration.                    *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loops are unrolled completely.  The outer loop is         *
*       unrolled 2 times.                                                   *
*                                                                           *
*       To save register pressure, we store our mask values packed in       *
*       registers.  This allows us to store our 9 element mask in 5         *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 4.5 * n_out + 35 + bc, where bc is between 0 and 5.        *
*                                                                           *
*       For n_out = 248, cycles = 1151.                                     *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*       Up to 5 bank conflicts will occur in the setup code.  This is       *
*       captured in the term 'bc' above.  Note that bank conflicts will     *
*       not occur on C6211/C6711 devices.                                   *
*                                                                           *
*   CODESIZE                                                                *
*       416 bytes.                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .sect ".text:_corr_3x3_32"
        .global _IMG_corr_3x3
_IMG_corr_3x3
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_i0
        .asg            B4,         B_o
        .asg            A6,         A_mask
        .asg            B6,         B_x_dim
        .asg            A8,         A_n_out

        .asg            A0,         A_mask3210
        .asg            A0,         A_m01m10
        .asg            A1,         A_p
        .asg            A2,         A_k0F0F
        .asg            A2,         A_m02m11
        .asg            A3,         A_p11
        .asg            A3,         A_p12
        .asg            A3,         A_s0c
        .asg            A3,         A_s1c
        .asg            A3,         A_s2
        .asg            A5,         A_p10
        .asg            A5,         A_s1a
        .asg            A5,         A_s1b
        .asg            A5,         A_s2a
        .asg            A5,         A_s2b
        .asg            A6,         A_p00
        .asg            A6,         A_p02
        .asg            A6,         A_p20
        .asg            A6,         A_p21
        .asg            A6,         A_p22
        .asg            A6,         A_SP
        .asg            A7,         A_p01
        .asg            A7,         A_s0b
        .asg            A7,         A_x1
        .asg            A8,         A_x0
        .asg            A9,         A_m20m00
        .asg            A10,        A_i1
        .asg            A11,        A_i2
        .asg            A12,        A_x2
        .asg            B0,         B_mask7654
        .asg            B0,         B_m12m21
        .asg            B1,         B_i
        .asg            B2,         B____m22
        .asg            B5,         B_p02
        .asg            B5,         B_p20
        .asg            B5,         B_s1b
        .asg            B5,         B_s2b
        .asg            B6,         B_p01
        .asg            B6,         B_p10
        .asg            B6,         B_s1a
        .asg            B6,         B_s2
        .asg            B6,         B_x1
        .asg            B7,         B_p00
        .asg            B7,         B_p12
        .asg            B7,         B_s0b
        .asg            B7,         B_s0c
        .asg            B8,         B_p11
        .asg            B8,         B_s1c
        .asg            B8,         B_no_gie
        .asg            B9,         B_p22
        .asg            B9,         B_x2
        .asg            B9,         B_old_csr
        .asg            B10,        B_p21
        .asg            B11,        B_x0
        .asg            B12,        B_s2a
        .asg            B15,        B_SP
* ========================================================================= *
        LDW     .D1T1   *A_mask(0), A_mask3210
||      MVC     .S2     CSR,        B_old_csr

        LDW     .D1T2   *A_mask(4), B_mask7654
||      STW     .D2T1   A10,        *B_SP--[8]
||      AND     .S2     B_old_csr,  -2,         B_no_gie

        LDBU    .D1T2   *A_mask(8), B____m22
||      STW     .D2T1   A11,        *B_SP[2]
||      MVC     .S2     B_no_gie,   CSR
;-
* =========================== PIPE LOOP PROLOG ============================ *
        LDBU    .D1T1   *A_i0++,    A_x0                        ;[ 1,1]
||      STW     .D2T2   B10,        *B_SP[1]
||      MVKL    .S1     0x00FF00FF, A_k0F0F
||      ADD     .L1X    A_i0,       B_x_dim,    A_i1

        LDBU    .D1T2   *A_i0++,    B_x0                        ;[ 2,1]
||      MVKH    .S1     0x00FF00FF, A_k0F0F
||      ADD     .L1X    A_i1,       B_x_dim,    A_i2
;-
        LDBU    .D1T1   *A_i1++,    A_x1                        ;[ 3,1]
||      STW     .D2T2   B11,        *B_SP[3]
||      AND     .S1     A_mask3210, A_k0F0F,    A_m20m00
||      SHR     .S2X    A_n_out,    1,          B_i

        LDBU    .D1T1   *A_i2++,    A_x2                        ;[ 4,1]
||      STW     .D2T2   B_old_csr,  *B_SP[7]
||      XOR     .S1     A_mask3210, A_m20m00,   A_m01m10
||      AND     .L1X    B_mask7654, A_k0F0F,    A_m02m11
;-
        LDBU    .D1T2   *A_i1++,    B_x1                        ;[ 5,1]
||      STW     .D2T1   A12,        *B_SP[6]
||      XOR     .L2X    B_mask7654, A_m02m11,   B_m12m21
||      SHRU    .S1     A_m01m10,   8,          A_m01m10

        MPYU    .M1     A_x0,       A_m01m10,   A_p10           ;[ 6,1]
||      STW     .D2T2   B12,        *B_SP[5]

        LDBU    .D1T2   *A_i2++,    B_x2                        ;[ 7,1]
||      MPYLHU  .M1     A_x0,       A_m20m00,   A_p20           ;[ 7,1]
;-
        MPYU    .M2X    B_x0,       A_m20m00,   B_p00           ;[ 8,1]
||      ADD     .S1X    A_p10,      B_s0c,      A_s1a           ;[ 8,1]
||      MPYU    .M1     A_x1,       A_m02m11,   A_p11           ;[ 8,1]
||      SHRU    .S2     B_m12m21,   8,          B_m12m21

        MPYLHU  .M2X    B_x0,       A_m20m00,   B_p20           ;[ 9,1]
||      MPYLHU  .M1X    A_x2,       B_m12m21,   A_p12           ;[ 9,1]
||      MVK     .S1     1,          A_p
;-
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        MPYU    .M2     B_x1,       B_m12m21,   B_p21           ;[10,1]
||      ADD     .S1     A_p11,      A_s1a,      A_s1b           ;[10,1]
||      MPYU    .M1X    A_x1,       B_m12m21,   A_p21           ;[10,1]
||[ B_i]LDBU    .D1T1   *A_i0++,    A_x0                        ;[ 1,2]
;-
        MPYLHU  .M2X    B_x1,       A_m01m10,   B_p01           ;[11,1]
||      ADD     .L1     A_p12,      A_s1b,      A_s1c           ;[11,1]
||      ADD     .S1X    A_p20,      B_s1c,      A_s2a           ;[11,1]
||      MPYLHU  .M1     A_x1,       A_m01m10,   A_p01           ;[11,1]
||[ B_i]LDBU    .D1T2   *A_i0++,    B_x0                        ;[ 2,2]

        MPYU    .M2X    B_x1,       A_m02m11,   B_p11           ;[12,1]
||      MPYU    .M1     A_x0,       A_m20m00,   A_p00           ;[12,1]
||[ B_i]LDBU    .D1T1   *A_i1++,    A_x1                        ;[ 3,2]
;-
  [ B_i]B       .S1     loop                                    ;[13,1]
||      ADD     .L1     A_p21,      A_s2a,      A_s2b           ;[12,1]
||      ADD     .S2     B_p01,      B_p00,      B_s0b           ;[13,1]
||      MPYU    .M2X    B_x0,       A_m01m10,   B_p10           ;[13,1]
||      MPYLHU  .M1     A_x2,       A_m02m11,   A_p02           ;[13,1]
||[ B_i]LDBU    .D1T1   *A_i2++,    A_x2                        ;[ 4,2]
;-
        MPYLHU  .M2X    B_x2,       A_m02m11,   B_p02           ;[14,1]
||      ADD     .S1     A_p01,      A_p00,      A_s0b           ;[14,1]
||      MPYU    .M1X    A_x2,       B____m22,   A_p22           ;[14,1]
||[ B_i]LDBU    .D1T2   *A_i1++,    B_x1                        ;[ 5,2]

        ADD     .S2X    B_p20,      A_s1c,      B_s2a           ;[15,1]
||      MPYU    .M2     B_x2,       B____m22,   B_p22           ;[15,1]
||      ADD     .S1     A_p02,      A_s0b,      A_s0c           ;[15,1]
||[ B_i]MPYU    .M1     A_x0,       A_m01m10,   A_p10           ;[ 6,2]
;-
        ADD     .D2     B_p02,      B_s0b,      B_s0c           ;[16,1]
||      ADD     .S2X    B_p10,      A_s0c,      B_s1a           ;[16,1]
||      ADD     .L2     B_p21,      B_s2a,      B_s2b           ;[16,1]
||      MPYLHU  .M2     B_x2,       B_m12m21,   B_p12           ;[16,1]
||      ADD     .L1     A_p22,      A_s2b,      A_s2            ;[16,1]
||[ B_i]LDBU    .D1T2   *A_i2++,    B_x2                        ;[ 7,2]
||[ B_i]MPYLHU  .M1     A_x0,       A_m20m00,   A_p20           ;[ 7,2]
||[!B_i]MV      .S1X    B_SP,       A_SP
;-
        ADD     .L2     B_p11,      B_s1a,      B_s1b           ;[17,1]
||      ADD     .S2     B_p22,      B_s2b,      B_s2            ;[17,1]
||[!A_p]STW     .D2T1   A_s2,       *B_o++                      ;[17,1]
||[ B_i]MPYU    .M2X    B_x0,       A_m20m00,   B_p00           ;[ 8,2]
||[ B_i]ADD     .S1X    A_p10,      B_s0c,      A_s1a           ;[ 8,2]
||[ B_i]MPYU    .M1     A_x1,       A_m02m11,   A_p11           ;[ 8,2]
;-
  [!A_p]STW     .D2T2   B_s2,       *B_o++                      ;[18,1]
||[ A_p]SUB     .S1     A_p,        1,          A_p             ;[18,1]
||[ B_i]ADD     .S2     B_p12,      B_s1b,      B_s1c           ;[18,1]
||[ B_i]SUB     .L2     B_i,        1,          B_i             ;[ 9,2]
||[ B_i]MPYLHU  .M2X    B_x0,       A_m20m00,   B_p20           ;[ 9,2]
||[ B_i]MPYLHU  .M1X    A_x2,       B_m12m21,   A_p12           ;[ 9,2]
* =========================== PIPE LOOP EPILOG ============================ *
; ===== Epilog completely removed.
        LDW     .D1T2   *A_SP[7],   B_old_csr
||      LDW     .D2T1   *B_SP[6],   A12
;-
        LDW     .D1T2   *A_SP[5],   B12

        RET     .S2     B3
||      LDW     .D1T2   *A_SP[3],   B11
||      LDW     .D2T1   *B_SP[2],   A11

        LDW     .D1T2   *A_SP[1],   B10
||      LDW     .D2T1   *++B_SP[8], A10

        NOP             3

        MVC             B_old_csr,  CSR
;-
* ========================================================================= *
*   End of file:  img_corr_3x3.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

corr_gen.asm/   1066929161  0     0     0       35519     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.13    Sun Sep 29 03:31:22 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_corr_gen : Generalized Correlatoion                             *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Jan-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_corr_gen                                                   *
*       (                                                                   *
*           short *in_data,      //  Input: pixel array           //        *
*           short *h,            //  Input: 1-by-M mask           //        *
*           short *out_data,     //  Output: correlation sum      //        *
*           int M,               //  Input: # of filter taps      //        *
*           int cols             //  Input: Width of input image  //        *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine performs a generalized correlation with a 1 by M       *
*       tap filter. It can be called repetitively to form an arbitrary      *
*       M by n 2D generalized correlation kernel.  The correlation sum      *
*       is currently stored as half words.  The input pixel, and mask       *
*       data is assumed to come in as shorts.  No restrictions are          *
*       placed cols and M.                                                  *
*                                                                           *
*   C CODE                                                                  *
*       The C code is a general implementation without restrictions.        *
*       The assembly code may have some restrictions, as noted below.       *
*                                                                           *
*       void IMG_corr_gen(short *in_data, short *h, short *out_data,int M,  *
*       int cols)                                                           *
*       {                                                                   *
*                                                                           *
*          //--------------------------------------------------------//     *
*          // For all columns compute a M tap fir                    //     *
*          // Add correlation sum to existing value to allow for a   //     *
*          // generalized 2D correlation to be built using several   //     *
*          // 1D correlations                                        //     *
*          //--------------------------------------------------------//     *
*                                                                           *
*          for (j = 0; j < cols - M; j++)                                   *
*          {                                                                *
*             sum =  out_data[j];                                           *
*             for (i = 0; i < M; i++)                                       *
*             {                                                             *
*                sum += in_data[i + j] * h[i];                              *
*             }                                                             *
*             out_data[j] = sum;                                            *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Since this kernel is a generalized correlation kernel the # of      *
*       filter taps can be as small as 1.  Hence it is not beneficial       *
*       to pipeline this loop.  In addition collapsing both the loops       *
*       causes data dependencies and degrades the performance.  However     *
*       this is one of the few cases where loop order interchange can       *
*       be used effectively.  In this case the outer loop of the            *
*       natural C code is exchanged to be the inner loop that is to be      *
*       software pipe- lined.  it is beneficial to pieline this loop        *
*       because typical image dimensions are larger than the # of           *
*       filter taps.  Notice however that the # of loads and stores do      *
*       go up within this loop as compared to the natural C code.           *
*                                                                           *
*       The hand assembly version of the code tries to balance the          *
*       computing with the loads/stores that have to be performed           *
*       because of the loop order interchange.  In order to do this         *
*       word-wide loads are used.  In addition the outer loop that          *
*       computes one filter-tap at a time is unrolled and computes two      *
*       filter taps at a time.  This has certain ramifications that are     *
*       discussed later.  In order to decrease the # of loads the first     *
*       word is pre-loaded outside the j loop and data is re-used           *
*       within the j loop.  The updating of the present correl- ation       *
*       sum with the previous correlation sum is done using the add2        *
*       instruction.  In addition to get better multiplier utilization      *
*       the inner loop is unrolled four times and four outputs are          *
*       computed together.  The inner loop unrolling also has certain       *
*       ramifications that are explained below.                             *
*                                                                           *
*       Special Cases                                                       *
*                                                                           *
*       Unrolling the outer loop assumes that there are an even number      *
*       of filter taps.  Two cases arise:                                   *
*                                                                           *
*       a) M = 1.  In this case a seperate version that does just 1 tap     *
*       needs to be used and the code should directly start from this       *
*       loop without executing the even version.                            *
*                                                                           *
*       b) M is odd.  In this case the evn version of the loop is used      *
*       for as many even taps as possible and then the last tap is          *
*       computed using the odd tap special version created for M = 1.       *
*                                                                           *
*       In this way problems associated with unrolling the outer loop       *
*       are overcome.                                                       *
*                                                                           *
*       Unrolling the inner loop four times assumes that the loop           *
*       iteration cols - M is a multiple of four.  In most typical          *
*       images cols is a multiple of 8 but since M is totally general       *
*       cols - M is definitely not a multiple of 4.  In addition if cols    *
*       - M is not a multiple of 4 then the inner loop iterates fewer       *
*       times than required and certain output pixels will not be           *
*       computed.  This problem is overcome as foll                         *
*                                                                           *
*       a) Increment (cols - M) by 4 so that the next higher multiple of    *
*       4 is computed.  This implies that in certain cases up to 4          *
*       extra pixels may be computed if cols - M is an exact multiple of    *
*       4.  In other cases 1,2 or 3 extra pixels may be computed.  In       *
*       order to annull this extra computation 4 locations starting at      *
*       x[cols-M] are zeroed out before returning to ensure identical       *
*       behaviour with the natural C code.                                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       a) input image, output array must be word-alligned                  *
*                                                                           *
*       b) output array must have at-least a dimension of cols -            *
*       M + 4                                                               *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts should occurr in this kernel.                     *
*       This code is ENDIAN NEUTRAL                                         *
*                                                                           *
*   NOTE                                                                    *
*       This code masks interrupts for nearly its entire duration.          *
*       The code is interrupt-tolerant, but not interruptible               *
*                                                                           *
*   CYCLES                                                                  *
*       cols = width of the image                                           *
*       M    = # filter taps                                                *
*                                                                           *
*       when M is even:                                                     *
*           (cols - M + 24) * M/2 + 36                                      *
*       when M is odd:                                                      *
*           (cols - M + 23) * (M-1)/2 + (cols - M + 3) * 3/4 + 50           *
*                                                                           *
*       For M = 8, cols = 720: 2980 cycles                                  *
*       For M = 9, cols = 720: 3520 cycles                                  *
*                                                                           *
*   CODESIZE                                                                *
*       768 bytes                                                           *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_corr_gen"
        .global _IMG_corr_gen
_IMG_corr_gen: 

*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            A2,         A_j
        .asg            A2,         A_jump
        .asg            A4,         A_x
        .asg            A6,         A_y
        .asg            A7,         A_xptr
        .asg            A8,         A_iters
        .asg            A8,         A_x_dim
        .asg            A9,         A_yiptr
        .asg            A10,        A_ziptr
        .asg            A11,        A_x1x0
        .asg            A12,        A_x5x4
        .asg            A13,        A_h0
        .asg            A14,        A_k
        .asg            A14,        A_tmp0
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            A15,        A_hptr
        .asg            B0,         B_csr       ; CSR's value
        .asg            B0,         B_tmp1
        .asg            B1,         B_i
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            B2,         B_p
        .asg            B3,         B_ret       ; Return address
        .asg            B3,         B_x3x2
        .asg            B4,         B_h
        .asg            B5,         B_h1
        .asg            B6,         B_m
        .asg            B11,        B_xptr
        .asg            B12,        B_yiptr
        .asg            B13,        B_ziptr
        .asg            B14,        B_hptr
        .asg            B15,        B_SP        ; Stack pointer, B datapath
*==============================================================================*
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, B_table
;-
        STW     .D2T1   A15,        *B_SP--[14] ; Reserve stack, Save A15

        MV              B_SP,       A_SP        ; Twin Stack Pointer

        STW     .D1T1   A14,        *+A_SP[12]  ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]  ; Save B14
||      MVC     .S2     CSR,        B_csr       ; Capture CSR's state

        STW     .D1T1   A13,        *+A_SP[10]  ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]  ; Save B13
||      AND             B_csr,      -2,         B_no_gie    ; Clear GIE
;-
        STW     .D1T1   A12,        *+A_SP[ 8]  ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]  ; Save B12

        STW     .D1T1   A11,        *+A_SP[ 6]  ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]  ; Save B11
||      MV              B_csr,      A_csr       ; Partitioning MV

        STW     .D1T1   A10,        *+A_SP[ 4]  ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]  ; Save B10
||      MVC     .S2     B_no_gie,   CSR         ; Disable interrupts

        STW     .D1T1   A_csr,      *+A_SP[ 2]  ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]  ; return address
||      SUB     .S1X    B_m,        1,          A_jump


; ===== Interrupts masked here =====
;-

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================

; ============================================================================
        SUB     .L1X    A_x_dim,    B_m,        A_tmp0       ; tmp0 = x - M
||      STW     .D2T1   A_x_dim,    *+B_SP[13]

        AND     .S2X    A_tmp0,     1,          B_tmp1       ; odd/even
||[!A_jump] B   .S1     SKIP

        SUB     .D2     B_m,        B_tmp1,     B_i          ; deduct 1 if odd
||      ADD     .L1X    B_h,        2,          A_hptr       ; Even filter ptr

        SHRU    .S2     B_i,        1,          B_i          ; Process 2  taps
||      ZERO    .L1     A_k                                  ; k = 0
||      MV      .D2     B_h,        B_hptr                   ; Odd filter ptr
||      SUB     .S1X    A_tmp0,     B_tmp1,     A_iters      ; deduct 1 if odd

        ADD     .L1     A_x,        A_k,        A_xptr       ; Word-wide loads

        LDW     .D1T1   *A_xptr++,  A_x1x0                   ; x1x0 load

LOOPNI:

        LDH     .D1T2   *A_hptr++[2],           B_h1         ; h1 odd  tap
||      LDH     .D2T1   *B_hptr++[2],           A_h0         ; h0 even tap
||      MV      .L2X    A_xptr,     B_xptr                   ; Bxptr-->x[0],x[1]
||      ADD     .L1     A_xptr,     4,          A_xptr       ; Axptr-->x[2],x[4]

        LDW     .D1T1   *A_xptr++[2],           A_x5x4       ; x5x4 load
||      LDW     .D2T2   *B_xptr++[2],           B_x3x2       ; x3x2 load
||      ADD     .L1     A_iters,    4,          A_j          ; j += iters

        SHRU    .S1     A_j,        2,          A_j          ; j >> 2
||      ADD     .S2X    A_y,        4,          B_ziptr      ; B_ziptr= &y[1]

        ADD     .L1     A_k,        4,          A_k          ; k inc. by 1 word
||      SUB     .D1     A_j,        0,          A_j          ;
||      ADD     .L2X    A_y,        4,          B_yiptr      ; B_yiptr= &y[1]

        MVK     .S2     2,          B_p                      ;
||      MV      .L1     A_y,        A_ziptr                  ; A_ziptr= &y[0]
||      MV      .S1     A_y,        A_yiptr                  ; A_yiptr= &y[0]

        ;==== Branch occurs

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B11,        B_xptr
        .asg            A7,         A_xptr
        .asg            A13,        A_h0
        .asg            B5,         B_h1
        .asg            A9,         A_yiptr
        .asg            B12,        B_yiptr
        .asg            A10,        A_ziptr
        .asg            B13,        B_ziptr
        .asg            A2,         A_j
        .asg            B2,         B_p
        .asg            A11,        A_x1x0
        .asg            B3,         B_x3x2
        .asg            A12,        A_x5x4
        .asg            A3,         A_h0x0
        .asg            A0,         A_h0x1
        .asg            B7,         B_h0x2
        .asg            B8,         B_h0x3
        .asg            A0,         A_h1x1
        .asg            B8,         B_h1x2
        .asg            B8,         B_h1x3
        .asg            A5,         A_h1x4
        .asg            A5,         A_sum0
        .asg            A1,         A_sum1
        .asg            B10,        B_sum2
        .asg            B7,         B_sum3
        .asg            A1,         A_sum1_s
        .asg            B7,         B_sum3_s
        .asg            A0,         A_sum_zero
        .asg            B10,        B_sum_one
        .asg            A3,         A_y1y0
        .asg            B9,         B_y3y2
        .asg            A0,         A_z1z0
        .asg            B7,         B_z3z2
; ============================================================================
; START:
; ============================ PIPE LOOP PROLOG ==============================
; PROLOG:

        LDW     .D1T1   *A_xptr++[2],           A_x5x4       ; x5x4 load
||      LDW     .D2T2   *B_xptr++[2],           B_x3x2       ; x3x2 load

        MPY     .M2     B_h1,       B_x3x2,     B_h1x2       ; h1x2 = h1 * x2
||      MPYLH   .M1     A_h0,       A_x1x0,     A_h0x1       ; h0x1 = h0 * x1

        LDW     .D1T1   *A_yiptr++[2],          A_y1y0       ; prev0
||      MPY     .M1X    B_h1,       A_x5x4,     A_h1x4       ; h1x4 = h1 * x4
||      MPYLH   .M2     B_h1,       B_x3x2,     B_h1x3       ; h1x3 = h1 * x3
||      B       .S2     LOOPJ

        LDW     .D2T2   *B_yiptr++[2],          B_y3y2       ; prev1
||      ADD     .L1X    A_h0x1,     B_h1x2,     A_sum1       ; h0x1 + h1x2
||      MPY     .M2X    A_h0,       B_x3x2,     B_h0x2       ; h0x2 = h0 * x2
||      MPY     .M1     A_h0,       A_x1x0,     A_h0x0       ; h0x0 = h0 * x0


; ============================ PIPE LOOP KERNEL ==============================
LOOPJ:

  [ B_p]SUB     .L2     B_p,        1,          B_p          ; predication
||      ADD2    .S1     A_y1y0,     A_sum_zero, A_z1z0       ; (prev0,sum_zero)
||      ADD     .S2     B_sum3_s,   B_sum2,     B_sum_one    ; sum3_s + sum2
||      MV      .L1     A_x5x4,     A_x1x0                   ; x1x0 = x5x4
||      MPYLH   .M1X    B_h1,       A_x1x0,     A_h1x1       ; h1x1 = h1 * x1
||      MPYLH   .M2X    A_h0,       B_x3x2,     B_h0x3       ; h0x3 = h0 * x3
||      LDW     .D1T1   *A_xptr++[2],           A_x5x4       ; x5x4 load
||      LDW     .D2T2   *B_xptr++[2],           B_x3x2       ; x3x2 load

  [!B_p]STW     .D1T1   A_z1z0,     *A_ziptr++[2]            ; Store pres0
||      ADD2    .S2     B_y3y2,     B_sum_one,  B_z3z2       ; (prev1,sum_one)
||[ A_j]SUB     .L1     A_j,        1,          A_j          ; if (j) j--
||      SHL     .S1     A_sum1,     16,         A_sum1_s     ; sum1_s = sum1 >> 16
||      ADD     .D2     B_h0x2,     B_h1x3,     B_sum2       ; h0x2 + h1x3
||      MPY     .M2     B_h1,       B_x3x2,     B_h1x2       ; h1x2 = h1 * x2
||      MPYLH   .M1     A_h0,       A_x1x0,     A_h0x1       ; h0x1 = h0 * x1

  [!B_p]STW     .D2T2   B_z3z2,     *B_ziptr++[2]            ; Store pres1
||[ A_j]B       .S1     LOOPJ                                ; if (j) B LOOPJ
||      ADD     .S2X    B_h0x3,     A_h1x4,     B_sum3       ; h0x3 + h1x4
||      ADD     .L1     A_h0x0,     A_h1x1,     A_sum0       ; h0x0 + h1x1
||      LDW     .D1T1   *A_yiptr++[2],          A_y1y0       ; prev0
||      MPY     .M1X    B_h1,       A_x5x4,     A_h1x4       ; h1 * x4
||      MPYLH   .M2     B_h1,       B_x3x2,     B_h1x3       ; h1 * x3

        ADD     .D1     A_sum1_s,   A_sum0,     A_sum_zero   ; sum1_s + sum0
||      SHL     .S2     B_sum3,     16,         B_sum3_s     ; sum3 >> 16
||      LDW     .D2T2   *B_yiptr++[2],          B_y3y2       ; prev1
||      ADD     .L1X    A_h0x1,     B_h1x2,     A_sum1       ; h0x1 + h1x2
||      MPY     .M2X    A_h0,       B_x3x2,     B_h0x2       ; h0x2 = h0 * x2
||      MPY     .M1     A_h0,       A_x1x0,     A_h0x0       ; h0x0 = h0 * x0

; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:


; ============================================================================
; END:

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B1,         B_i                         ;
        .asg            B0,         B_tmp1                      ;
        .asg            B6,         B_m                         ;
        .asg            A4,         A_x                         ;
        .asg            B4,         B_h                         ;
        .asg            A6,         A_y                         ;
        .asg            A8,         A_iters                     ;
        .asg            A7,         A_xptr                      ;
        .asg            B14,        B_hptr                      ;
        .asg            B10,        B_h0                        ;
        .asg            A12,        A_h0                        ;
        .asg            B11,        B_xptr                      ;
        .asg            A9,         A_yiptr                     ;
        .asg            B13,        B_ziptr                     ;
        .asg            A2,         A_od                        ;
        .asg            B12,        B_yiptr                     ;
        .asg            A10,        A_ziptr                     ;
        .asg            B2,         B_p                         ;
        .asg            A3,         A_tmp
        .asg            B7,         B_xword0
        .asg            A5,         A_xword1
        .asg            A4,         A_x_dim
; ============================================================================

  [ B_i]SUB     .D2     B_i,        1,          B_i          ; if (i) i--

  [ B_i]B       .S2     LOOPNI                               ; if (i) B LOOPI

        NOP             3

L_1:    ADD     .L1     A_x,        A_k,        A_xptr       ; Word-wide loads

L_2:    LDW     .D1T1   *A_xptr++,  A_x1x0                   ; x1x0 load



        ;==== Branch occurs                                  ;


SKIP:

 [!B_tmp1]LDW    .D2T1    *+B_SP[13],  A_x_dim
||        SUB    .L1X    B_m,        1,          A_tmp        ; tmp = M - 1
||[!B_tmp1]B     .S1     END                                  ; if (even) end

        MPY     .M1     A_tmp,      2,          A_tmp        ; Scale for HWORD

        NOP             1

        ADD     .L2X    B_h,        A_tmp,      B_hptr       ; hptr = &h[M-1]
||      ADD     .S1     A_x,        A_tmp,      A_xptr       ; xptr = &x[M-1]

        LDH     .D2T2   *B_hptr,    B_h0                     ; h0 = h[M-1]

        NOP             1

        ;=======Branch Occurrs

        ADD     .D1     A_iters,    4,          A_od         ; Iterate 4M times
||      MV      .S2X    A_xptr,     B_xptr                   ; Make xptr copy
||      ADD     .L1     A_xptr,     4,          A_xptr       ; A_xptr = &x[2]

        SHRU    .S1     A_od,       2,          A_od         ; od >> 2
||      LDW     .D2T2   *B_xptr++[2],           B_xword0     ; x1x0 load
||      LDW     .D1T1   *A_xptr++[2],           A_xword1     ; x3x2 load

        MV      .S1     A_y,        A_ziptr                  ; A_ziptr = &y[0]
||      ADD     .S2X    A_y,        4,          B_yiptr      ; B_yiptr = &y[2]
||      SUB     .L1     A_od,       0,          A_od         ;


        MVK     .S2     2,          B_p                      ;
||      ADD     .L2X    A_y,        4,          B_ziptr      ; B_ziptr = &y[2]
||      MV      .S1     A_y,        A_yiptr                  ; A_yiptr = &y[0]
||      MV      .L1X    B_h0,       A_h0                     ; Make h0 copy
||      LDW    .D2T1    *+B_SP[13],  A_x_dim


        ;==== Branch occurs

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B11,        B_xptr                      ;
        .asg            A7,         A_xptr                      ;
        .asg            A12,        A_h0                        ;
        .asg            B10,        B_h0                        ;
        .asg            A9,         A_yiptr                     ;
        .asg            B12,        B_yiptr                     ;
        .asg            A10,        A_ziptr                     ;
        .asg            B13,        B_ziptr                     ;
        .asg            A2,         A_od                        ;
        .asg            B2,         B_p                         ;
        .asg            B7,         B_xword0
        .asg            A5,         A_xword1
        .asg            A3,         A_h0x0
        .asg            A11,        A_h0x1
        .asg            B9,         B_h0x2
        .asg            B5,         B_h0x3
        .asg            A11,        A_sum1_s
        .asg            A3,         A_sum_zero
        .asg            B5,         B_sum3_s
        .asg            B3,         B_sum_one
        .asg            A14,        A_y1y0
        .asg            B14,        B_y3y2
        .asg            A8,         A_z1z0
        .asg            B14,        B_z3z2
; ============================================================================
; START:
; ============================ PIPE LOOP PROLOG ==============================
; PROLOG:

        LDW     .D2T2   *B_xptr++[2],           B_xword0     ; x1x0 load
||      LDW     .D1T1   *A_xptr++[2],           A_xword1     ; x3x2 load

         B      .S2      LOOPOD                              ; 1 Delay Slot

        LDW     .D1T1   *A_yiptr++[2],          A_y1y0       ; prev0
||      MPY     .M2X    B_h0,       A_xword1,   B_h0x2       ; h0x2 = h0 * x2

        MPYLH   .M1X    A_h0,       B_xword0,   A_h0x1       ; h0x1 = h0 * x1
||      MPYLH   .M2X    B_h0,       A_xword1,   B_h0x3       ; h0x3 = h0 * x3
||      LDW     .D2T2   *B_xptr++[2],           B_xword0     ; x1x0 load
||      LDW     .D1T1   *A_xptr++[2],           A_xword1     ; x3x2 load

; ============================ PIPE LOOP KERNEL ==============================
LOOPOD:
  [!B_p]STW     .D1T1   A_z1z0,     *A_ziptr++[2]            ; pres0 store
||[ A_od]B      .S1     LOOPOD                               ; if (od) B LOOPOD
||      ADD     .L1     A_sum1_s,   A_h0x0,     A_sum_zero   ; h0x1 | h0x0
||      MPY     .M1X    A_h0,       B_xword0,   A_h0x0       ; h0x0 = h0 * x0
||      LDW     .D2T2   *B_yiptr++[2],          B_y3y2       ; prev1

  [!B_p]STW     .D2T2   B_z3z2,     *B_ziptr++[2]            ; pres1 store
||      ADD2    .S1     A_y1y0,     A_sum_zero, A_z1z0       ; add2 to prev0
||[ B_p]SUB     .L2     B_p,        1,          B_p          ;
||      SHL     .S2     B_h0x3,     16,         B_sum3_s     ; h0x3 << 16
||      LDW     .D1T1   *A_yiptr++[2],          A_y1y0       ; prev0
||      MPY     .M2X    B_h0,       A_xword1,   B_h0x2       ; h0x2 = h0 * x2

        ADD2    .S2     B_y3y2,     B_sum_one,  B_z3z2       ; add2 to prev1
||[ A_od]SUB    .L1     A_od,       1,          A_od         ; if (od) od--
||      SHL     .S1     A_h0x1,     16,         A_sum1_s     ; h0x1 << 16
||      ADD     .L2     B_sum3_s,   B_h0x2,     B_sum_one    ; h0x3 | h0x2
||      MPYLH   .M1X    A_h0,       B_xword0,   A_h0x1       ; h0x1 = h0 * x1
||      MPYLH   .M2X    B_h0,       A_xword1,   B_h0x3       ; h0x3 = h0 * x3
||      LDW     .D2T2   *B_xptr++[2],           B_xword0     ; x1x0 load
||      LDW     .D1T1   *A_xptr++[2],           A_xword1     ; x3x2 load

; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:

END:

        SUB    .L1x      A_x_dim,    B_m,    A_h0
||      SUB    .D1       A_z1z0,     A_z1z0, A_z1z0
||      SUB    .S2       B_z3z2,     B_z3z2, B_z3z2

        ADDAH  .D1       A_y,    A_h0,     A_xptr

        STH    .D1T1     A_z1z0, *A_xptr++[2]
||      ADD    .L2x      A_xptr,  2,       B_xptr

        STH    .D1T1     A_z1z0, *A_xptr++[2]
||      STH    .D2T2     B_z3z2, *B_xptr++[2]


*================= SYMBOLIC REGISTER ASSIGNMENTS: CLEANUP =====================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            A0,         A_csr       ; CSR value to restore
        .asg            B3,         B_ret       ; Return address
*==============================================================================*

        MV              B_SP,       A_SP        ; Twin Stack Pointer
||      STH    .D1T1     A_z1z0, *A_xptr++[2]
||      STH    .D2T2     B_z3z2, *B_xptr++[2]

        LDW     .D1T2   *+A_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr       ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10         ; Restore A10

        LDW     .D1T2   *+A_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11         ; Restore A11

        LDW     .D1T2   *+A_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12         ; Restore A12

        LDW     .D1T2   *+A_SP[ 9], B13         ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13         ; Restore A13

        LDW     .D1T2   *+A_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14         ; Restore A14
||      RET     .S2     B_ret                   ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
||      LDW     .D2T1   *++B_SP[14],A15         ; Restore A15

*====== Interruptibility state restored here ==================================*

        NOP             4
;====== Branch Occurs =====

* ========================================================================= *
*   End of file:  img_corr_gen.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

dilate_bin.asm/ 1066929161  0     0     0       21984     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.11    Sun Sep 29 03:31:22 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_dilate_bin-- This code performs 3x3 binary dilation             *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Nov-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_dilate_bin                                                 *
*       (                                                                   *
*           const unsigned char *restrict in_data,   /* Incoming image  */  *
*           unsigned char       *restrict out_data,  /* Filtered output */  *
*           const char          *restrict mask,      /* Filter mask     */  *
*           int cols  /* Number of columns to process, in bytes.        */  *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_dilate_bin() implements binary dilation using an   *
*       arbitrary 3x3 mask.  The dilation operator generates output pixels  *
*       by ORing the pixels under the input mask together to generate       *
*       the output pixel.  The input mask specifies whether one or more     *
*       pixels from the input are to be ignored.                            *
*                                                                           *
*       In pseudo-code, the filtering operation for a pixel at (x, y)       *
*       works like so:                                                      *
*                                                                           *
*           result = 0;                                                     *
*           if (mask[0][0] != DONT_CARE) result |= input[y + 0][x + 0];     *
*           if (mask[0][1] != DONT_CARE) result |= input[y + 1][x + 1];     *
*           if (mask[0][2] != DONT_CARE) result |= input[y + 2][x + 2];     *
*           if (mask[1][0] != DONT_CARE) result |= input[y + 0][x + 0];     *
*           if (mask[1][1] != DONT_CARE) result |= input[y + 1][x + 1];     *
*           if (mask[1][2] != DONT_CARE) result |= input[y + 2][x + 2];     *
*           if (mask[2][0] != DONT_CARE) result |= input[y + 0][x + 0];     *
*           if (mask[2][1] != DONT_CARE) result |= input[y + 1][x + 1];     *
*           if (mask[2][2] != DONT_CARE) result |= input[y + 2][x + 2];     *
*           output[y][x] = result;                                          *
*                                                                           *
*       For this code, "DONT_CARE" is specified by a negative value         *
*       in the input mask.  Non-negative values in the mask cause the       *
*       corresponding pixel to be included in the dilation operation.       *
*                                                                           *
*       Note that this code operates on a bitmap where each pixel is        *
*       represented as a single bit within a byte or word.  Although        *
*       the pseudo-code above operates only on one pixel at a time,         *
*       with a single pixel in each array element, this implementation      *
*       operates on a bitmap which contains 8 pixels in each byte.          *
*                                                                           *
*       Pixels are organized within each byte such that the pixel with      *
*       the smallest index is in the LSB position, and the pixel with       *
*       the largest index is in the MSB position.  (That is, the code       *
*       assumes a LITTLE ENDIAN bit ordering.)                              *
*                                                                           *
*       Note that the "cols" argument actually specifies the number of      *
*       BYTES in the output, not the number of columns.  The number of      *
*       columns is 8 times this argument.                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The 3x3 dilation mask is applied to 32 output pixels                *
*       simultaneously.  This is done with 32-bit-wide bitwise              *
*       operators in the register file.  In order to do this, the code      *
*       reads in a 34-bit-wide input window, and 40-bit operations          *
*       are used to manipulate the pixels initially.                        *
*                                                                           *
*       Because the code reads a 34-bit context for each 32-bits of         *
*       output, the input needs to be one byte longer than the output       *
*       in order to make the rightmost two pixels well-defined.             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1.  Negative values in the mask specify "DONT_CARE", and non-       *
*           negative values specify that pixels are included in the         *
*           dilation operation.                                             *
*                                                                           *
*       2.  The input image needs to have a multiple of 32 pixels(bits)     *
*           per row.  Therefore, "cols" must be a multiple of 4.            *
*                                                                           *
*       3.  The input and output buffers must be word-aligned.              *
*                                                                           *
*   NOTES                                                                   *
*       Little Endian                                                       *
*                                                                           *
*       This code is interrupt tolerant, but not interruptible.  The code   *
*       locks out interrupts for nearly its entire duration.                *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = (cols / 4) * 5 + 39.  (Note:  # of pixels = 8 * cols.)     *
*       For cols = 80 (pixels = 320), cycles = 139.                         *
*                                                                           *
*   CODESIZE                                                                *
*       480 bytes.                                                          *
*                                                                           *
*   SOURCE                                                                  *
*       "Digital Image Processing: Principles and Applications"             *
*       by Gregory A. Baxes, Chapter 5                                      *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

                .sect ".data:copyright_h"

        .sect ".text:_dilate_bin"
        .global _IMG_dilate_bin
_IMG_dilate_bin:
; ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== ;
           .asg           B15,        B_SP       ; Stack pointer, B datapath
           .asg           A15,        A_SP       ; Stack pointer, A datapath
           .asg           B0,         B_csr      ; CSR's value
           .asg           B1,         B_no_gie   ; CSR w/ GIE bit cleared
           .asg           A0,         A_csr      ; Copy of CSR's value
           .asg           B3,         B_ret      ; Return address
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
           .asg           A0,         A_out_data
           .asg           A1,         A_m4
           .asg           A2,         A_m1
           .asg           A3,         A_m8
           .asg           A4,         A_ir0
           .asg           A4,         A_p2
           .asg           A5,         A_q2
           .asg           A5,         A_rslt
           .asg           A5,         A_k1
           .asg           A6,         A_mask
           .asg           A6,         A_p0
           .asg           A7,         A_p0h
           .asg           A7,         A_rD
           .asg           A8,         A_p0_
           .asg           A8,         A_p1
           .asg           A9,         A_q1
           .asg           A9,         A_rB
           .asg           A9,         A_t4
           .asg           A10,        A_m6
           .asg           A11,        A_m3
           .asg           A12,        A_m0
           .asg           A13,        A_m2
           .asg           A14,        A_rC
           .asg           B0,         B_i
           .asg           B1,         B_m7
           .asg           B2,         B_m5
           .asg           B4,         B_ir1
           .asg           B4,         B_out_data
           .asg           B5,         B_rA
           .asg           B6,         B_cols
           .asg           B6,         B_c4
           .asg           B7,         B_p3_
           .asg           B8,         B_p4
           .asg           B8,         B_t8
           .asg           B9,         B_q4
           .asg           B9,         B_rA_
           .asg           B9,         B_rB
           .asg           B10,        B_p6
           .asg           B10,        B_p7
           .asg           B11,        B_p6_
           .asg           B11,        B_p6h
           .asg           B11,        B_q7
           .asg           B12,        B_p3
           .asg           B12,        B_p5
           .asg           B12,        B_p8
           .asg           B13,        B_p3h
           .asg           B13,        B_q5
           .asg           B13,        B_q8
* ========================================================================= *
; ========================================================================= ;
        ; Stack frame.  12 words:  A10..A15, B10..B13, CSR, pad
;-
           STW   .D2T1    A15,        *B_SP--[12]          ; Get stk, Save A15
||         MV             B_SP,       A_SP                 ; Twin Stack Ptr

           STW   .D1T1    A14,        *-A_SP[ 2]           ; Save A14
||         STW   .D2T2    B13,        *+B_SP[ 9]           ; Save B13
||         MVC   .S2      CSR,        B_csr                ; Get CSR's state

           STW   .D1T1    A13,        *-A_SP[ 4]           ; Save A13
||         STW   .D2T2    B12,        *+B_SP[ 7]           ; Save B12
||         AND            B_csr,      -2,         B_no_gie ; Clear GIE
;-
           STW   .D1T1    A12,        *-A_SP[ 6]           ; Save A12
||         STW   .D2T2    B11,        *+B_SP[ 5]           ; Save B11

           STW   .D1T1    A11,        *-A_SP[ 8]           ; Save A10
||         STW   .D2T2    B10,        *+B_SP[ 3]           ; Save B11
||         MVK   .S1      1,          A_k1

           STW   .D1T1    A10,        *-A_SP[10]           ; Save A10
||         STW   .D2T2    B_csr,      *+B_SP[ 1]           ; Save CSR
||         MVC   .S2      B_no_gie,   CSR                  ; Disable ints.
; ===== Interrupts masked here =====
;-
           LDB   .D1T1    *A_mask[8], A_m8
||         ADD   .L2      B_out_data, B_cols,     B_out_data

           LDB   .D1T2    *A_mask[7], B_m7
||         MV    .L1X     B_out_data, A_out_data

           LDB   .D1T1    *A_mask[6], A_m6
||         MV    .L2X     A_ir0,      B_ir1

           LDB   .D1T2    *A_mask[5], B_m5
||         ADDAH .D2      B_ir1,      B_cols,     B_ir1       ; Row 1 ptr
;-
           LDB   .D1T1    *A_mask[4], A_m4

           LDB   .D1T1    *A_mask[3], A_m3

           LDB   .D1T1    *A_mask[2], A_m2

           LDB   .D1T1    *A_mask[1], A_m1

           LDB   .D1T1    *A_mask[0], A_m0

           LDBU  .D2T2    *+B_ir1[B_cols],        B_p6h
||         MPYHL .M1      A_m8,       A_k1,       A_m8
||         MPYHL .M2X     B_m5,       A_k1,       B_m5
;-
           LDBU  .D2T1    *-B_ir1[B_cols],        A_p0h
||         MPYHL .M1      A_m6,       A_k1,       A_m6
||         SHR   .2       B_cols,     2,          B_c4

           LDBU  .D2T2    * B_ir1--(4),           B_p3_
||         MPYHL .M1      A_m4,       A_k1,       A_m4
||         SUB   .2       B_c4,       1,          B_i

           LDW   .D2T1    *-B_ir1[B_c4],          A_p0          ;[ 1,1]
||         MPYHL .M1      A_m3,       A_k1,       A_m3
;-
           LDW   .D2T2    *+B_ir1[B_c4],          B_p6          ;[ 2,1]
||         MPYHL .M1      A_m2,       A_k1,       A_m2
||         NOT   .L1      A_m0,       A_m0
||         NOT   .S1      A_m8,       A_m8

           MPYHL .M1      A_m1,       A_k1,       A_m1
||         NOT   .L1      A_m3,       A_m3
||         NOT   .S1      A_m6,       A_m6
;-
           B     .S1      loop_5 + 4
||         LDW   .D2T2    *B_ir1--(4),            B_p3          ;[ 4,1]
||         MPYHL .M1      A_m0,       A_k1,       A_m0
||         MPYHL .M2X     B_m7,       A_k1,       B_m7
||         NOT   .L1      A_m2,       A_m2

   [ B_i]  B     .S2      loop_1                                ;[ 5,1]
|| [ B_i]  SUB   .D2      B_i,        1,          B_i           ;[ 5,1]

* ============================= PIPE LOOP KERNEL ========================== *
loop_1:
   [!A_m4] OR    .L1X     B_p4,       A_rC,       A_rC          ;[11,1]
|| [!B_m5] OR    .S2      B_p5,       B_rB,       B_rB          ;[11,1]
|| [!B_m7] OR    .L2      B_p7,       B_rA,       B_rA          ;[11,1]
||         SHR   .S1      A_p0h:A_p0, 2,          A_q2:A_p2     ;[ 6,2]
||         LDW   .D2T1    *-B_ir1[B_c4],          A_p0          ;[ 1,3]
||         MPY   .M1      A_p0,       1,          A_p0_         ;[ 1,3]
loop_2:
   [!A_m1] OR    .L1      A_p1,       A_rC,       A_rC          ;[12,1]
||         OR    .S1X     A_t4,       B_rB,       A_rB          ;[12,1]
||         AND   .L2X     B_p6,       A_m6,       B_rA_         ;[ 7,2]
||         SHR   .S2      B_p6h:B_p6, 2,          B_q8:B_p8     ;[ 7,2]
||         MPY   .M2      B_p3_,      1,          B_p3h         ;[ 7,2]
||         LDW   .D2T2    *+B_ir1[B_c4],          B_p6          ;[ 2,3]
loop_3:
           OR    .L1X     B_rA,       A_rB,       A_rD          ;[13,1]
||         AND   .L2X     B_p8,       A_m8,       B_t8          ;[ 8,2]
||         SHR   .S1      A_p0h:A_p0, 1,          A_q1:A_p1     ;[ 8,2]
||         SHR   .S2      B_p6h:B_p6, 1,          B_q7:B_p7     ;[ 8,2]
||         MPY   .M1      A_p0_,      1,          A_p0h         ;[ 3,3]
||         MPY   .M2      B_p6,       1,          B_p6_         ;[ 3,3]
loop_4:
           OR    .L1      A_rC,       A_rD,       A_rslt        ;[14,1]
||         OR    .L2      B_t8,       B_rA_,      B_rA          ;[ 9,2]
||         AND   .S1      A_p2,       A_m2,       A_t4          ;[ 9,2]
||         SHR   .S2      B_p3h:B_p3, 1,          B_q4:B_p4     ;[ 9,2]
||         LDW   .D2T2    *B_ir1--(4),            B_p3          ;[ 4,3]
||         MPY   .M2      B_p3,       1,          B_p3_         ;[ 4,3]
loop_5:
           STW   .D1T1    A_rslt,     *--A_out_data(4)          ;[15,1]
|| [ B_i]  B     .S1      loop_1                                ;[10,2]
||         AND   .L1      A_p0,       A_m0,       A_rC          ;[10,2]
||         AND   .L2X     B_p3,       A_m3,       B_rB          ;[10,2]
||         SHR   .S2      B_p3h:B_p3, 2,          B_q5:B_p5     ;[10,2]
|| [ B_i]  SUB   .D2      B_i,        1,          B_i           ;[ 5,3]
||         MPY   .M2      B_p6_,      1,          B_p6h         ;[ 5,3]

* ============================= PIPE LOOP EPILOG ========================== *
;-
           LDW   .D1T2    *-A_SP[11], B_csr       ; Get CSR's value
||         LDW   .D2T1    *+B_SP[ 2], A10         ; Get CSR's value
|| [!A_m4] OR    .L1X     B_p4,       A_rC,       A_rC          ;[11,3]
|| [!B_m7] OR    .L2      B_p7,       B_rA,       B_rA          ;[11,3]
|| [!B_m5] OR    .S2      B_p5,       B_rB,       B_rB          ;[11,3]

           LDW   .D1T2    *-A_SP[ 9], B10         ; Restore B10
||         LDW   .D2T1    *+B_SP[ 4], A11         ; Restore A11
|| [!A_m1] OR    .L1      A_p1,       A_rC,       A_rC          ;[12,3]
;-
           LDW   .D1T2    *-A_SP[ 7], B11         ; Restore B11
||         LDW   .D2T1    *+B_SP[ 6], A12         ; Restore A12

           LDW   .D1T2    *-A_SP[ 5], B12         ; Restore B12
||         LDW   .D2T1    *+B_SP[ 8], A13         ; Restore A13

           LDW   .D1T2    *-A_SP[ 3], B13         ; Restore B13
||         LDW   .D2T1    *+B_SP[10], A14         ; Restore A14
||         RET   .S2      B_ret                   ; Return to caller

           LDW   .D2T1    *++B_SP[12],A15         ; Restore A15
;-
           MVC   .S2      B_csr,      CSR                       ; Restore CSR
||         OR    .S1X     A_t4,       B_rB,       A_rB          ;[12,3]

           OR    .L1X     B_rA,       A_rB,       A_rD          ;[13,3]

           OR    .L1      A_rC,       A_rD,       A_rslt        ;[14,3]

           STW   .D1T1    A_rslt,     *-A_out_data(4)           ;[15,3]
;-
; ===== Branch Occurs =====

* ========================================================================= *
*   End of file:  img_dilate_bin.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
erode_bin.asm/  1066929161  0     0     0       21762     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.10    Sun Sep 29 03:31:23 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_erode_bin-- This code performs 3x3 binary dilation              *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Nov-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_erode_bin                                                  *
*       (                                                                   *
*           const unsigned char *restrict in_data,   /* Incoming image  */  *
*           unsigned char       *restrict out_data,  /* Filtered output */  *
*           const char          *restrict mask,      /* Filter mask     */  *
*           int cols  /* Number of columns to process, in bytes.        */  *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_erode_bin() implements binary erosion using an     *
*       arbitrary 3x3 mask.  The erosion operator generates output pixels   *
*       by ANDing the pixels under the input mask together to generate      *
*       the output pixel.  The input mask specifies whether one or more     *
*       pixels from the input are to be ignored.                            *
*                                                                           *
*       In pseudo-code, the filtering operation for a pixel at (x, y)       *
*       works like so:                                                      *
*                                                                           *
*           result = 1;                                                     *
*           if (mask[0][0] != DONT_CARE) result &= input[y + 0][x + 0];     *
*           if (mask[0][1] != DONT_CARE) result &= input[y + 1][x + 1];     *
*           if (mask[0][2] != DONT_CARE) result &= input[y + 2][x + 2];     *
*           if (mask[1][0] != DONT_CARE) result &= input[y + 0][x + 0];     *
*           if (mask[1][1] != DONT_CARE) result &= input[y + 1][x + 1];     *
*           if (mask[1][2] != DONT_CARE) result &= input[y + 2][x + 2];     *
*           if (mask[2][0] != DONT_CARE) result &= input[y + 0][x + 0];     *
*           if (mask[2][1] != DONT_CARE) result &= input[y + 1][x + 1];     *
*           if (mask[2][2] != DONT_CARE) result &= input[y + 2][x + 2];     *
*           output[y][x] = result;                                          *
*                                                                           *
*       For this code, "DONT_CARE" is specified by a negative value         *
*       in the input mask.  Non-negative values in the mask cause the       *
*       corresponding pixel to be included in the erosion operation.        *
*                                                                           *
*       Note that this code operates on a bitmap where each pixel is        *
*       represented as a single bit within a byte or word.  Although        *
*       the pseudo-code above operates only on one pixel at a time,         *
*       with a single pixel in each array element, this implementation      *
*       operates on a bitmap which contains 8 pixels in each byte.          *
*                                                                           *
*       Pixels are organized within each byte such that the pixel with      *
*       the smallest index is in the LSB position, and the pixel with       *
*       the largest index is in the MSB position.  (That is, the code       *
*       assumes a LITTLE ENDIAN bit ordering.)                              *
*                                                                           *
*       Note that the "cols" argument actually specifies the number of      *
*       BYTES in the output, not the number of columns.  The number of      *
*       columns is 8 times this argument.                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The 3x3 erosion mask is applied to 32 output pixels                 *
*       simultaneously.  This is done with 32-bit-wide bitwise              *
*       operators in the register file.  In order to do this, the code      *
*       reads in a 34-bit-wide input window, and 40-bit operations          *
*       are used to manipulate the pixels initially.                        *
*                                                                           *
*       Because the code reads a 34-bit context for each 32-bits of         *
*       output, the input needs to be one byte longer than the output       *
*       in order to make the rightmost two pixels well-defined.             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1.  Negative values in the mask specify "DONT_CARE", and non-       *
*           negative values specify that pixels are included in the         *
*           erosion operation.                                              *
*                                                                           *
*       2.  The input image needs to have a multiple of 32 pixels(bits)     *
*           per row.  Therefore, "cols" must be a multiple of 4.            *
*                                                                           *
*       3.  The input and output buffers must be word-aligned.              *
*                                                                           *
*   NOTES                                                                   *
*       Little Endian                                                       *
*                                                                           *
*       This code is interrupt tolerant, but not interruptible.  The code   *
*       locks out interrupts for nearly its entire duration.                *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = (cols / 4) * 5 + 39.  (Note:  # of pixels = 8 * cols.)     *
*       For cols = 80 (pixels = 320), cycles = 139.                         *
*                                                                           *
*   CODESIZE                                                                *
*       448 bytes.                                                          *
*                                                                           *
*   SOURCE                                                                  *
*       "Digital Image Processing: Principles and Applications"             *
*       by Gregory A. Baxes, Chapter 5                                      *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

                .sect ".data:copyright_h"

        .sect ".text:_erode_bin"
        .global _IMG_erode_bin
_IMG_erode_bin: 
; ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== ;
           .asg           B15,        B_SP       ; Stack pointer, B datapath
           .asg           A15,        A_SP       ; Stack pointer, A datapath
           .asg           B0,         B_csr      ; CSR's value
           .asg           B1,         B_no_gie   ; CSR w/ GIE bit cleared
           .asg           A0,         A_csr      ; Copy of CSR's value
           .asg           B3,         B_ret      ; Return address
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
           .asg           A0,         A_out_data
           .asg           A1,         A_m4
           .asg           A2,         A_m1
           .asg           A3,         A_m8
           .asg           A4,         A_ir0
           .asg           A4,         A_p2
           .asg           A5,         A_q2
           .asg           A5,         A_rslt
           .asg           A5,         A_k1
           .asg           A6,         A_mask
           .asg           A6,         A_p0
           .asg           A7,         A_p0h
           .asg           A7,         A_rD
           .asg           A8,         A_p0_
           .asg           A8,         A_p1
           .asg           A9,         A_q1
           .asg           A9,         A_rB
           .asg           A9,         A_t4
           .asg           A10,        A_m6
           .asg           A11,        A_m3
           .asg           A12,        A_m0
           .asg           A13,        A_m2
           .asg           A14,        A_rC
           .asg           B0,         B_i
           .asg           B1,         B_m7
           .asg           B2,         B_m5
           .asg           B4,         B_ir1
           .asg           B4,         B_out_data
           .asg           B5,         B_rA
           .asg           B6,         B_cols
           .asg           B6,         B_c4
           .asg           B7,         B_p3_
           .asg           B8,         B_p4
           .asg           B8,         B_t8
           .asg           B9,         B_q4
           .asg           B9,         B_rA_
           .asg           B9,         B_rB
           .asg           B10,        B_p6
           .asg           B10,        B_p7
           .asg           B11,        B_p6_
           .asg           B11,        B_p6h
           .asg           B11,        B_q7
           .asg           B12,        B_p3
           .asg           B12,        B_p5
           .asg           B12,        B_p8
           .asg           B13,        B_p3h
           .asg           B13,        B_q5
           .asg           B13,        B_q8
* ========================================================================= *
; ========================================================================= ;
        ; Stack frame.  12 words:  A10..A15, B10..B13, CSR, pad
;-
           STW   .D2T1    A15,        *B_SP--[12]          ; Get stk, Save A15
||         MV             B_SP,       A_SP                 ; Twin Stack Ptr

           STW   .D1T1    A14,        *-A_SP[ 2]           ; Save A14
||         STW   .D2T2    B13,        *+B_SP[ 9]           ; Save B13
||         MVC   .S2      CSR,        B_csr                ; Get CSR's state

           STW   .D1T1    A13,        *-A_SP[ 4]           ; Save A13
||         STW   .D2T2    B12,        *+B_SP[ 7]           ; Save B12
||         AND            B_csr,      -2,         B_no_gie ; Clear GIE
;-
           STW   .D1T1    A12,        *-A_SP[ 6]           ; Save A12
||         STW   .D2T2    B11,        *+B_SP[ 5]           ; Save B11

           STW   .D1T1    A11,        *-A_SP[ 8]           ; Save A11
||         STW   .D2T2    B10,        *+B_SP[ 3]           ; Save B10
||         MVK   .S1      1,          A_k1

           STW   .D1T1    A10,        *-A_SP[10]           ; Save A10
||         STW   .D2T2    B_csr,      *+B_SP[ 1]           ; Save CSR
||         MVC   .S2      B_no_gie,   CSR                  ; Disable ints.
; ===== Interrupts masked here =====
;-
           LDB   .D1T1    *A_mask[8], A_m8
||         ADD   .L2      B_out_data, B_cols,     B_out_data

           LDB   .D1T2    *A_mask[7], B_m7
||         MV    .L1X     B_out_data, A_out_data

           LDB   .D1T1    *A_mask[6], A_m6
||         MV    .L2X     A_ir0,      B_ir1

           LDB   .D1T2    *A_mask[5], B_m5
||         ADDAH .D2      B_ir1,      B_cols,     B_ir1       ; Row 1 ptr
;-
           LDB   .D1T1    *A_mask[4], A_m4

           LDB   .D1T1    *A_mask[3], A_m3

           LDB   .D1T1    *A_mask[2], A_m2

           LDB   .D1T1    *A_mask[1], A_m1

           LDB   .D1T1    *A_mask[0], A_m0

           LDBU  .D2T2    *+B_ir1[B_cols],        B_p6h
||         MPYHL .M1      A_m8,       A_k1,       A_m8
||         MPYHL .M2X     B_m5,       A_k1,       B_m5
;-
           LDBU  .D2T1    *-B_ir1[B_cols],        A_p0h
||         MPYHL .M1      A_m6,       A_k1,       A_m6
||         SHR   .2       B_cols,     2,          B_c4

           LDBU  .D2T2    * B_ir1--(4),           B_p3_
||         MPYHL .M1      A_m4,       A_k1,       A_m4
||         SUB   .2       B_c4,       1,          B_i

           LDW   .D2T1    *-B_ir1[B_c4],          A_p0          ;[ 1,1]
||         MPYHL .M1      A_m3,       A_k1,       A_m3
;-
           LDW   .D2T2    *+B_ir1[B_c4],          B_p6          ;[ 2,1]
||         MPYHL .M1      A_m2,       A_k1,       A_m2

           MPYHL .M1      A_m1,       A_k1,       A_m1

           B     .S1      loop_5 + 4
||         LDW   .D2T2    *B_ir1--(4),            B_p3          ;[ 4,1]
||         MPYHL .M1      A_m0,       A_k1,       A_m0
||         MPYHL .M2X     B_m7,       A_k1,       B_m7
;-
   [ B_i]  B     .S1      loop_1                                ;[ 5,1]
|| [ B_i]  SUB   .D2      B_i,        1,          B_i           ;[ 5,1]

* ============================= PIPE LOOP KERNEL ========================== *
loop_1:
   [!A_m4] AND   .L1X     B_p4,       A_rC,       A_rC          ;[11,1]
|| [!B_m5] AND   .S2      B_p5,       B_rB,       B_rB          ;[11,1]
|| [!B_m7] AND   .L2      B_p7,       B_rA,       B_rA          ;[11,1]
||         SHR   .S1      A_p0h:A_p0, 2,          A_q2:A_p2     ;[ 6,2]
||         LDW   .D2T1    *-B_ir1[B_c4],          A_p0          ;[ 1,3]
||         MPY   .M1      A_p0,       1,          A_p0_         ;[ 1,3]
loop_2:
   [!A_m1] AND   .L1      A_p1,       A_rC,       A_rC          ;[12,1]
||         AND   .S1X     A_t4,       B_rB,       A_rB          ;[12,1]
||         OR    .L2X     B_p6,       A_m6,       B_rA_         ;[ 7,2]
||         SHR   .S2      B_p6h:B_p6, 2,          B_q8:B_p8     ;[ 7,2]
||         MPY   .M2      B_p3_,      1,          B_p3h         ;[ 7,2]
||         LDW   .D2T2    *+B_ir1[B_c4],          B_p6          ;[ 2,3]
loop_3:
           AND   .L1X     B_rA,       A_rB,       A_rD          ;[13,1]
||         OR    .L2X     B_p8,       A_m8,       B_t8          ;[ 8,2]
||         SHR   .S1      A_p0h:A_p0, 1,          A_q1:A_p1     ;[ 8,2]
||         SHR   .S2      B_p6h:B_p6, 1,          B_q7:B_p7     ;[ 8,2]
||         MPY   .M1      A_p0_,      1,          A_p0h         ;[ 3,3]
||         MPY   .M2      B_p6,       1,          B_p6_         ;[ 3,3]
loop_4:
           AND   .L1      A_rC,       A_rD,       A_rslt        ;[14,1]
||         AND   .L2      B_t8,       B_rA_,      B_rA          ;[ 9,2]
||         OR    .S1      A_p2,       A_m2,       A_t4          ;[ 9,2]
||         SHR   .S2      B_p3h:B_p3, 1,          B_q4:B_p4     ;[ 9,2]
||         LDW   .D2T2    *B_ir1--(4),            B_p3          ;[ 4,3]
||         MPY   .M2      B_p3,       1,          B_p3_         ;[ 4,3]
loop_5:
           STW   .D1T1    A_rslt,     *--A_out_data(4)          ;[15,1]
|| [ B_i]  B     .S1      loop_1                                ;[10,2]
||         OR    .L1      A_p0,       A_m0,       A_rC          ;[10,2]
||         OR    .L2X     B_p3,       A_m3,       B_rB          ;[10,2]
||         SHR   .S2      B_p3h:B_p3, 2,          B_q5:B_p5     ;[10,2]
|| [ B_i]  SUB   .D2      B_i,        1,          B_i           ;[ 5,3]
||         MPY   .M2      B_p6_,      1,          B_p6h         ;[ 5,3]

* ============================= PIPE LOOP EPILOG ========================== *
;-
           LDW   .D1T2    *-A_SP[11], B_csr       ; Get CSR's value
||         LDW   .D2T1    *+B_SP[ 2], A10         ; Get CSR's value
|| [!A_m4] AND   .L1X     B_p4,       A_rC,       A_rC          ;[11,3]
|| [!B_m7] AND   .L2      B_p7,       B_rA,       B_rA          ;[11,3]
|| [!B_m5] AND   .S2      B_p5,       B_rB,       B_rB          ;[11,3]

           LDW   .D1T2    *-A_SP[ 9], B10         ; Restore B10
||         LDW   .D2T1    *+B_SP[ 4], A11         ; Restore A11
|| [!A_m1] AND   .L1      A_p1,       A_rC,       A_rC          ;[12,3]
;-
           LDW   .D1T2    *-A_SP[ 7], B11         ; Restore B11
||         LDW   .D2T1    *+B_SP[ 6], A12         ; Restore A12

           LDW   .D1T2    *-A_SP[ 5], B12         ; Restore B12
||         LDW   .D2T1    *+B_SP[ 8], A13         ; Restore A13

           LDW   .D1T2    *-A_SP[ 3], B13         ; Restore B13
||         LDW   .D2T1    *+B_SP[10], A14         ; Restore A14
||         RET   .S2      B_ret                   ; Return to caller

           LDW   .D2T1    *++B_SP[12],A15         ; Restore A15
;-
           MVC   .S2      B_csr,      CSR                       ; Restore CSR
||         AND   .S1X     A_t4,       B_rB,       A_rB          ;[12,3]

           AND   .L1X     B_rA,       A_rB,       A_rD          ;[13,3]

           AND   .L1      A_rC,       A_rD,       A_rslt        ;[14,3]

           STW   .D1T1    A_rslt,     *-A_out_data(4)           ;[15,3]
;-
; ===== Branch Occurs =====

* ========================================================================= *
*   End of file:  img_erode_bin.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
errdif_bin.asm/ 1066929161  0     0     0       30397     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.25    Sun Sep 29 03:31:23 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_errdif_bin -- Binary Floyd-Steinberg Error Diffusion. Endian Neutra *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Jul-2001                                                         *
*                                                                           *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*               void IMG_errdif_bin                                         *
*               (                                                           *
*                   unsigned char *restrict errdif_data,                    *
*                   int           cols,                                     *
*                   int           rows,                                     *
*                   short         *restrict err_buf,                        *
*                   unsigned char thresh                                    *
*               )                                                           *
*                                                                           *
*       errdif_data:     Input/Output image ptr                             *
*       cols:            Number of columns (Width)                          *
*       rows:            Number of rows    (Height)                         *
*       err_buf:         Buffer where one row of errors is to be saved      *
*       thresh:          Threshold in the range [0x00, 0xFF]                *
*                                                                           *
*       errdif_data[] is used for both input and output and the number      *
*       of colums, cols, must be at least 4.  No restriction on number      *
*       of rows.                                                            *
*                                                                           *
*       err_buf[], additional buffer, should be provided with               *
*       initialized to all-zero's for the first call with an image.         *
*       The subsequent call with the same image should provide this         *
*       kernel the returned err_buf The size of err_buf should be           *
*       (cols+1)*Half-Word.                                                 *
*                                                                           *
*   DESCRIPTION                                                             *
*       The code implements the Binary Floyd-Steinberg error diffusion      *
*       filter.  The filter kernel used is this one:                        *
*                                                                           *
*                                   +---+                                   *
*                                 P | 7 |                                   *
*                           +---+---+---+                                   *
*                           | 3 | 5 | 1 |                                   *
*                           +---+---+---+                                   *
*                                                                           *
*                                                                           *
*       Pixels are processed from left-to-right, top-to-bottom.  Each       *
*       pixel is compared against a user-defined threshold.  Pixels         *
*       that are larger than the threshold are set to 255, and pixels       *
*       that are smaller or equal to the threshold are set to 0.  The       *
*       error value for the pixel (eg. the difference between the           *
*       thresholded pixel and its original grey level) is propagated to     *
*       the neighboring pixels according to the filter above.  This         *
*       error propagation diffuses the error over a larger area, hence      *
*       the term "error diffusion."                                         *
*                                                                           *
*       The following C code illustrates the algorithm.  The C code is      *
*       a general implementation without restrictions.  This version        *
*       may have restriction as noted in the ASSUMPTIONS below.             *
*                                                                           *
*       void IMG_errdif_bin                                                 *
*       (                                                                   *
*          unsigned char *restrict                                          *
*                        errdif_data,    /* Input/Output image ptr      */  *
*          int           cols,           /* Number of columns (Width)   */  *
*          int           rows,           /* Number of rows    (Height)  */  *
*          short         *restrict                                          *
*                        err_buf,        /* row-to-row error buffer.    */  *
*          unsigned char thresh          /* Threshold from [0x00, 0xFF] */  *
*       )                                                                   *
*       {                                                                   *
*          int   x, i, y;        /* Loop counters                       */  *
*          int   F;              /* Current pixel value at [x,y]        */  *
*          int   errA;           /* Error value at [x-1, y-1]           */  *
*          int   errB;           /* Error value at [  x, y-1]           */  *
*          int   errC;           /* Error value at [x+1, y-1]           */  *
*          int   errE;           /* Error value at [x-1,   y]           */  *
*          int   errF;           /* Error value at [  x,   y]           */  *
*                                                                           *
*          /* --------------------------------------------------------- */  *
*          /*  Step through rows of pixels.                             */  *
*          /* --------------------------------------------------------- */  *
*          for (y = 0, i = 0; y < rows; y++)                                *
*          {                                                                *
*             /* ------------------------------------------------------ */  *
*             /*  Start off with our initial errors set to zero at      */  *
*             /*  the start of the line since we do not have any        */  *
*             /*  pixels to the left of the row.  These error terms     */  *
*             /*  are maintained within the inner loop.                 */  *
*             /* ------------------------------------------------------ */  *
*             errA = 0; errE = 0;                                           *
*             errB = err_buf[0];                                            *
*                                                                           *
*             /* ------------------------------------------------------ */  *
*             /*  Step through pixels in each row.                      */  *
*             /* ------------------------------------------------------ */  *
*             for (x = 0; x < cols; x++, i++)                               *
*             {                                                             *
*                /* --------------------------------------------------- */  *
*                /*  Load the error being propagated from pixel 'C'     */  *
*                /*  from our error buffer.  This was calculated        */  *
*                /*  during the previous line.                          */  *
*                /* --------------------------------------------------- */  *
*                errC = err_buf[x+1];                                       *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Load our pixel value to quantize.                  */  *
*                /* --------------------------------------------------- */  *
*                F = errdif_data[i];                                        *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Calculate our resulting pixel.  If we assume       */  *
*                /*  that this pixel will be set to zero, this also     */  *
*                /*  doubles as our error term.                         */  *
*                /* --------------------------------------------------- */  *
*                errF = F + ((errE*7 + errA + errB*5 + errC*3) >> 4);       *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Set pixels that are larger than the threshold to   */  *
*                /*  255, and pixels that are smaller than the          */  *
*                /*  threshold to 0.                                    */  *
*                /* --------------------------------------------------- */  *
*                if (errF > thresh)  errdif_data[i] = 0xFF;                 *
*                else                errdif_data[i] = 0;                    *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  If the pixel was larger than the threshold, then   */  *
*                /*  we need subtract 255 from our error.  In any       */  *
*                /*  case, store the error to the error buffer.         */  *
*                /* --------------------------------------------------- */  *
*                if (errF > thresh)  err_buf[x] = errF = errF - 0xFF;       *
*                else                err_buf[x] = errF;                     *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Propagate error terms for the next pixel.          */  *
*                /* --------------------------------------------------- */  *
*                errE = errF;                                               *
*                errA = errB;                                               *
*                errB = errC;                                               *
*             }                                                             *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Constants, 7, 5, 3, 1 for multiplication are shifted left 12 to     *
*       avoid 'SHR 4' operation in the critical path.                       *
*                                                                           *
*       The processing of the filter itself is inverted so that the         *
*       errors from previous pixels "propagate into" a given pixel at       *
*       the time the pixel is processed, rather than "accumulate into"      *
*       a pixel as its neighbors are processed.  This allows us to          *
*       keep our image as an 8-bit image, and reduces the number of         *
*       accesses to the image array.  The inverted filter kernel            *
*       performs identically to the kernel's original form.  In this        *
*       form, the weights specify the weighting assigned to the errors      *
*       coming from the neighboring pixels.                                 *
*                                                                           *
*                           +---+---+---+                                   *
*                           | 1 | 5 | 3 |                                   *
*                           +---+---+---+                                   *
*                           | 7 | P                                         *
*                           +---+                                           *
*                                                                           *
*       The inner loop is software-pipelined.                               *
*                                                                           *
*       Twin stack pointers have been used to speed up stack accesses.      *
*                                                                           *
*       The outer loop has been interleaved with the prolog and epilog      *
*       of the inner loop.                                                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The number of columns must be at least 4.                           *
*                                                                           *
*       err_buf[] must be initialized to zeros for the first call and       *
*       the returned err_buf should be provided for the next call.          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur, regardless of the relative orientation     *
*       of errdif_data[] and err_buf[].                                     *
*                                                                           *
*       A total of 8 words of stack frame are used for saving the           *
*       Save-On-Entry registers.                                            *
*                                                                           *
*   NOTES                                                                   *
*       Interrupts are disabled throughout most of the function.            *
*       No checking is performed on the input arguments for correctness.    *
*       No special alignment of data arrays is expected.                    *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = (cols * 4 + 14) * rows + 21.  [4 cycles / pixel]           *
*                                                                           *
*       For an image of cols = 720, rows = 480, cycles = 1389141            *
*                                                                           *
*   CODESIZE                                                                *
*       480 Bytes                                                           *
*                                                                           *
*   SOURCE                                                                  *
*       Floyd-Steinberg Error Diffusion.                                    *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_errdif_bin"
        .global _IMG_errdif_bin
_IMG_errdif_bin:

*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            A0,         A_k3k5
        .asg            A1,         A_y
        .asg            A2,         A_x
        .asg            A3,         A_SP        ; Stack pointer, A datapath
        .asg            A3,         A_k7
        .asg            A4,         A_errA
        .asg            A4,         A_errEAC
        .asg            A4,         A_rgb0
        .asg            A5,         A_w
        .asg            A6,         A_h
        .asg            A6,         A_neg
        .asg            A7,         A_rgb_r
        .asg            A8,         A_eE7
        .asg            A8,         A_errAll
        .asg            A8,         A_thrsh
        .asg            A9,         A_rgb_w
        .asg            A10,        A_out
        .asg            A11,        A_errEA
        .asg            A12,        A_eB5
        .asg            B0,         B_big
        .asg            B0,         B_csr       ; CSR's value
        .asg            B0,         B_errSft
        .asg            B0,         B_outX
        .asg            B1,         B_eC3
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            B2,         B_pr
        .asg            B3,         B_ret       ; Return address
        .asg            B4,         B_errbuf_w
        .asg            B4,         B_w
        .asg            B5,         B_errbuf_r
        .asg            B6,         B_errbuf0
        .asg            B7,         B_errB
        .asg            B8,         B_thrsh
        .asg            B9,         B_F7
        .asg            B9,         B_eC3F7
        .asg            B10,        B_F
        .asg            B11,        B_errC
        .asg            B12,        B_errE_
        .asg            B13,        B_errE
        .asg            B15,        B_SP        ; Stack pointer, B datapath
*==============================================================================*
        ; Setup code is merged with prologue
;-
        STW     .D2T2   B12,        *B_SP--[8]                  ; Reserve stack, Save A15
||      MVC     .S2     CSR,        B_csr                       ; Capture CSR's state

        MV      .L1X    B_SP,       A_SP                        ; Twin Stack Pointer
||      STW     .D2T1   A12,        *+B_SP[ 7]                  ; Save A12
||      AND     .L2     B_csr,      -2,         B_no_gie        ; Clear GIE

        STW     .D1T1   A11,        *+A_SP[ 6]                  ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]                  ; Save B11
||      MV      .L1X    B_csr,      A_csr                       ; Partitioning MV
;-

        STW     .D1T1   A10,        *+A_SP[ 4]                  ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]                  ; Save B10
||      MVC     .S2     B_no_gie,   CSR                         ; Disable interrupts
* ===== Interrupts masked here =====

        STW     .D1T1   A_csr,      *+A_SP[ 2]  ; Save CSR
||      LDH     .D2T2   *B_errbuf0, B_errB                      ;[ 7,0]
||      MVK     .S1     07000h,     A_k7                        ;[ 1,0] 7 << 12
||      MV      .L1X    B_w,        A_w                         ;[ 4,0]
;-

        MV      .D1     A_h,        A_y                         ;[ 4,0]
||      MVK     .S1     -1785,      A_neg                       ;[ 4,0]
||      LDH     .D2T2   *B_errbuf0[1],          B_errC          ;[ 1,1]

        MV      .L1     A_rgb0,     A_rgb_w                     ;[ 5,0]
||      STW     .D2T2   B13,        *+B_SP[ 1]                  ; Save B10
||      ADD     .D1     A_rgb0,     1,          A_rgb_r                     ;[ 5,0]
||      MV      .S2X    A_thrsh,    B_thrsh                     ;[ 5,0]
||      MVK     .S1     05000h,     A_k3k5                      ;[ 2,0] (Low Half)  5 << 12

        SHL     .S1     A_neg,      12,         A_neg           ;[ 5,0]
;-
        MVKLH   .S1     03000h,     A_k3k5                      ;[ 3,0] (High Half) 3 << 12

y_start:
; ============================ PIPE LOOP PROLOG ==============================
; PROLOG:

        LDH     .D2T2   *B_errbuf0[2],          B_errC          ;[ 1,2]
||      MV      .L2     B_errbuf0,  B_errbuf_w                  ;[11,0]
||      ADD     .S2     B_errbuf0,  6,          B_errbuf_r      ;[11,0]

        MPY     .M1X    B_errB,     A_k3k5,     A_errEA         ;[ 6,1]

        MPYLH   .M2X    B_errC,     A_k3k5,     B_eC3           ;[ 6,1]

        LDBU    .D1T2   *A_rgb_r[-1], B_F                       ;[ 8,1]
||      MVK     .S2     2,          B_pr
;-

        MV      .S2     B_errC,     B_errB                      ;[ 9,1]
||      SHL     .S1X    B_errB,     12,         A_errA          ;[ 9,1]
||      LDH     .D2T2   *B_errbuf_r++,          B_errC          ;[ 1,3]
||      SUB     .L1     A_w,        3,          A_x             ;[11,0]

        MPY     .M1X    B_errB,     A_k3k5,     A_eB5           ;[ 6,2]
||      MPYLH   .M2X    B_errC,     A_k3k5,     B_eC3           ;[ 6,2]

        ADD     .L2     B_eC3,      0,          B_eC3F7         ;[11,1]
;-

        ADD     .S1X    A_errEA,    B_eC3F7,    A_errAll        ;[12,1]
||      ADD     .L1     A_eB5,      A_errA,     A_errEA         ;[ 8,2]
||      LDBU    .D1T2   *A_rgb_r++, B_F                         ;[ 8,2]

        MPY     .M2X    B_F,        A_k7,       B_F7            ;[13,1]
||      MV      .S2     B_errC,     B_errB                      ;[ 9,2]
||      SHL     .S1X    B_errB,     12,         A_errA          ;[ 9,2]
||      LDH     .D2T2   *B_errbuf_r++,          B_errC          ;[ 1,4]
;-

        MPYLH   .M2X    B_errC,     A_k3k5,     B_eC3           ;[ 6,3]
||      MPY     .M1X    B_errB,     A_k3k5,     A_eB5           ;[ 6,3]
||[ A_x]B       .S2     x_start                                 ;[18,1]

        SHR     .S2X    A_errAll,   16,         B_errSft        ;[15,1]
||      ADD     .L2     B_eC3,      B_F7,       B_eC3F7         ;[11,2]
||      MPYHL   .M1     A_errAll,   A_k7,       A_eE7           ;[11,2]
;-

; ============================ PIPE LOOP KERNEL ==============================
x_start:
        SUB     .L2X    B_errE,     A_out,      B_errE_         ;[20,1]
||      ADD     .S2     B_errSft,   B_F,        B_errE          ;[16,2]
||      ADD     .S1X    A_errEA,    B_eC3F7,    A_errEAC        ;[12,3]
||      ADD     .L1     A_eB5,      A_errA,     A_errEA         ;[ 8,4]
||      LDBU    .D1T2   *A_rgb_r++, B_F                         ;[ 8,4]
;-

        CMPGT   .L2     B_errE,     B_thrsh,    B_big           ;[17,2]
||      ADD     .D1     A_errEAC,   A_eE7,      A_errAll        ;[13,3]
||      MPY     .M2X    B_F,        A_k7,       B_F7            ;[13,3]
||      MV      .S2     B_errC,     B_errB                      ;[ 9,4]
||      SHL     .S1X    B_errB,     12,         A_errA          ;[ 9,4]
||      LDH     .D2T2   *B_errbuf_r++,          B_errC          ;[ 1,6]
;-

  [!B_pr]STB     .D1T1   A_out,      *A_rgb_w++                  ;[22,1]
||[ A_x]B       .S2     x_start                                 ;[18,2]
||      SUB     .D2     B_thrsh,    B_errE,     B_outX          ;[18,2]
||[ B_big]ADD   .S1     A_neg,      A_errAll,   A_errAll        ;[14,3]
||[ A_x]SUB     .L1     A_x,        1,          A_x             ;[14,3]
||      MPY     .M1X    B_errB,     A_k3k5,     A_eB5           ;[ 6,5]
||      MPYLH   .M2X    B_errC,     A_k3k5,     B_eC3           ;[ 6,5]
;-

  [!B_pr]STH     .D2T2   B_errE_,    *B_errbuf_w++               ;[23,1]
||      SHRU    .S1X    B_outX,     24,         A_out           ;[19,2]
||      SHR     .S2X    A_errAll,   16,         B_errSft        ;[15,3]
||      ADD     .L2     B_eC3,      B_F7,       B_eC3F7         ;[11,4]
||      MPYHL   .M1     A_errAll,   A_k7,       A_eE7           ;[11,4]
||[ B_pr]MPY    .M2     B_pr,       0,          B_pr
;-

; ============================ PIPE LOOP EPILOG ==============================
; EPILOG: Collapsed and merged with prologue
; ============================================================================
; END:

  [ A_y]SUB     .S1     A_y,        1,          A_y             ;[ 4,0]
||      SUB     .L2X    B_errE,     A_out,      B_errE_         ;[20,5]
||      ADD     .S2     B_errSft,   B_F,        B_errE          ;[16,6]
||      STB     .D1T1   A_out,      *A_rgb_w++                  ;[22,5]
;-

  [ A_y]B       .S2     y_start                                 ;[ 5,0]
||      LDH     .D2T2   *B_errbuf0, B_errB                      ;[ 7,0]
||[!A_y]MV      .L1X    B_SP,       A_SP                        ; Twin Stack Pointer

        SUB     .L2     B_thrsh,    B_errE,     B_outX          ;[18,6]
||      LDH     .D2T2   *B_errbuf0[1],          B_errC          ;[ 1,1]
||[!A_y]LDW     .D1T1   *+A_SP[ 6], A11                         ; Restore A11
;-

        STH     .D2T2   B_errE_,    *B_errbuf_w++               ;[23,5]
||      SHRU    .S1X    B_outX,     24,         A_out           ;[19,6]
||[!A_y]LDW     .D1T1   *+A_SP[ 2], A_csr                       ; Get CSR's value

        SUB     .L2X    B_errE,     A_out,      B_errE_         ;[20,6]
||      STB     .D1T1   A_out,      *A_rgb_w++                  ;[22,6]
||[!A_y]LDW     .D2T2   *+B_SP[ 3], B10                         ; Restore B10

        STH     .D2T2   B_errE_,    *B_errbuf_w++               ;[23,6]

  [!A_y]LDW     .D2T1   *+B_SP[ 4], A10                         ; Restore A10
||[!A_y]LDW     .D1T2   *+A_SP[ 5], B11                         ; Restore B11
;-          ;==== Branch occurs ( to y_start)                       ;[11,0]

  [!A_y]LDW     .D2T2   *+B_SP[ 1], B13                         ; Restore B10
||[!A_y]RET     .S2     B_ret                                   ; Return to caller

  [!A_y]LDW     .D2T2   *++B_SP[ 8], B12                        ; Restore B12
||[!A_y]LDW     .D1T1   *+A_SP[ 7], A12                         ; Restore A12
||      MVC     .S2X    A_csr,      CSR                         ; Restore CSR

        NOP             4
;-
*====== Interruptibility state restored here ==================================*
;====== Branch Occurs (if returning) =====

* ========================================================================= *
*   End of file:  errdiff_bin_h.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

fdct_8x8.asm/   1066929161  0     0     0       70117     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Thu Nov 14 21:39:22 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_fdct_8x8 -- 8x8 Block FDCT With Rounding, Endian Neutral        *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       28-Oct-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           void IMG_fdct_8x8(short fdct_data[], unsigned num_fdcts)        *
*                                                                           *
*       The fdct routine accepts a list of 8x8 pixel blocks and performs    *
*       FDCTs on each.  The array should be laid out identically to         *
*       "fdct_data[num_fdcts][8][8]".  All operations in this array are     *
*       performed entirely in-place.                                        *
*                                                                           *
*       Input values are stored in shorts, and may be in the range          *
*       [-512,511].  Larger input values may result in overflow.            *
*                                                                           *
*       This code requires '48 + 160 * num_fdcts' cycles to process         *
*       'num_fdcts' blocks, including function call overhead.  When         *
*       'num_fdcts' is zero, an early exit is taken and the function        *
*       runs for only 13 cycles (again, including call overhead).           *
*                                                                           *
*   DESCRIPTION                                                             *
*       The IMG_fdct_8x8 function implements a Chen FDCT. Output values are *
*       rounded, providing improved accuracy.  Input terms are expected     *
*       to be signed 11Q0 values, producing signed 15Q0 results.  (A        *
*       smaller dynamic range may be used on the input, producing a         *
*       correspondingly smaller output range.  Typical applications         *
*       include processing signed 9Q0 and unsigned 8Q0 pixel data,          *
*       producing signed 13Q0 or 12Q0 outputs, respectively.)  No           *
*       saturation is performed.                                            *
*                                                                           *
*       void IMG_fdct_8x8(short *dct_data, unsigned num_fdcts)              *
*       {                                                                   *
*         /* -------------------------------------------------------- */    *
*         /*  Set up the cosine coefficients c0..c7.                  */    *
*         /* -------------------------------------------------------- */    *
*         const unsigned short c1 = 0x2C62, c3 = 0x25A0;                    *
*         const unsigned short c5 = 0x1924, c7 = 0x08D4;                    *
*         const unsigned short c0 = 0xB505, c2 = 0x29CF;                    *
*         const unsigned short c6 = 0x1151;                                 *
*                                                                           *
*         /* -------------------------------------------------------- */    *
*         /*  Intermediate calculations.                              */    *
*         /* -------------------------------------------------------- */    *
*         short f0, f1, f2, f3,                                             *
*               f4, f5, f6, f7;       /* Spatial domain samples.      */    *
*         int   g0, g1, h0, h1,                                             *
*               p0, p1;               /* Even-half intermediate.      */    *
*         short r0, r1;               /* Even-half intermediate.      */    *
*         int   P0, P1, R0, R1;       /* Even-half intermediate.      */    *
*         short g2, g3, h2, h3;       /* Odd-half intermediate.       */    *
*         short q0a,s0a,q0, q1,                                             *
*               s0, s1;               /* Odd-half intermediate.       */    *
*         short Q0, Q1, S0, S1;       /* Odd-half intermediate.       */    *
*         int   F0, F1, F2, F3,                                             *
*               F4, F5, F6, F7;       /* Freq. domain results.        */    *
*         int   F0r,F1r,F2r,F3r,                                            *
*               F4r,F5r,F6r,F7r;      /* Rounded, truncated results.  */    *
*                                                                           *
*         /* -------------------------------------------------------- */    *
*         /*  Input and output pointers, loop control.                */    *
*         /* -------------------------------------------------------- */    *
*         unsigned i, j;                                                    *
*         short    *dct_io_ptr;                                             *
*                                                                           *
*         /* -------------------------------------------------------- */    *
*         /*  Outer vertical loop -- Process each 8x8 block.          */    *
*         /* -------------------------------------------------------- */    *
*         dct_io_ptr = dct_data;                                            *
*         for (i = 0; i < num_fdcts; i++)                                   *
*         {                                                                 *
*             /* ---------------------------------------------------- */    *
*             /*  Perform Vert 1-D FDCT on columns within each block. */    *
*             /* ---------------------------------------------------- */    *
*             for (j = 0; j < 8; j++)                                       *
*             {                                                             *
*                 /* ------------------------------------------------ */    *
*                 /*  Load the spatial-domain samples.                */    *
*                 /* ------------------------------------------------ */    *
*                 f0 = dct_io_ptr[ 0];                                      *
*                 f1 = dct_io_ptr[ 8];                                      *
*                 f2 = dct_io_ptr[16];                                      *
*                 f3 = dct_io_ptr[24];                                      *
*                 f4 = dct_io_ptr[32];                                      *
*                 f5 = dct_io_ptr[40];                                      *
*                 f6 = dct_io_ptr[48];                                      *
*                 f7 = dct_io_ptr[56];                                      *
*                                                                           *
*                 /* ------------------------------------------------ */    *
*                 /*  Stage 1:  Separate into even and odd halves.    */    *
*                 /* ------------------------------------------------ */    *
*                 g0 = f0 + f7;               h2 = f0 - f7;                 *
*                 g1 = f1 + f6;               h3 = f1 - f6;                 *
*                 h1 = f2 + f5;               g3 = f2 - f5;                 *
*                 h0 = f3 + f4;               g2 = f3 - f4;                 *
*                                                                           *
*                 /* ------------------------------------------------ */    *
*                 /*  Stage 2                                         */    *
*                 /* ------------------------------------------------ */    *
*                 p0 = g0 + h0;               r0 = g0 - h0;                 *
*                 p1 = g1 + h1;               r1 = g1 - h1;                 *
*                 q1 = g2;                    s1 = h2;                      *
*                                                                           *
*                 s0a= h3 + g3;               q0a= h3 - g3;                 *
*                 s0 = (s0a * c0 + 0x7FFF) >> 16;                           *
*                 q0 = (q0a * c0 + 0x7FFF) >> 16;                           *
*                                                                           *
*                 /* ------------------------------------------------ */    *
*                 /*  Stage 3                                         */    *
*                 /* ------------------------------------------------ */    *
*                 P0 = p0 + p1;               P1 = p0 - p1;                 *
*                 R1 = c6 * r1 + c2 * r0;     R0 = c6 * r0 - c2 * r1;       *
*                                                                           *
*                 Q1 = q1 + q0;               Q0 = q1 - q0;                 *
*                 S1 = s1 + s0;               S0 = s1 - s0;                 *
*                                                                           *
*                 /* ------------------------------------------------ */    *
*                 /*  Stage 4                                         */    *
*                 /* ------------------------------------------------ */    *
*                 F0 = P0;                    F4 = P1;                      *
*                 F2 = R1;                    F6 = R0;                      *
*                                                                           *
*                 F1 = c7 * Q1 + c1 * S1;     F7 = c7 * S1 - c1 * Q1;       *
*                 F5 = c3 * Q0 + c5 * S0;     F3 = c3 * S0 - c5 * Q0;       *
*                                                                           *
*                 /* ------------------------------------------------ */    *
*                 /*  Store the frequency domain results.             */    *
*                 /* ------------------------------------------------ */    *
*                 dct_io_ptr[ 0] = F0;                                      *
*                 dct_io_ptr[ 8] = F1 >> 13;                                *
*                 dct_io_ptr[16] = F2 >> 13;                                *
*                 dct_io_ptr[24] = F3 >> 13;                                *
*                 dct_io_ptr[32] = F4;                                      *
*                 dct_io_ptr[40] = F5 >> 13;                                *
*                 dct_io_ptr[48] = F6 >> 13;                                *
*                 dct_io_ptr[56] = F7 >> 13;                                *
*                                                                           *
*                 dct_io_ptr++;                                             *
*             }                                                             *
*             /* ---------------------------------------------------- */    *
*             /*  Update pointer to next 8x8 FDCT block.              */    *
*             /* ---------------------------------------------------- */    *
*             dct_io_ptr += 56;                                             *
*         }                                                                 *
*                                                                           *
*         /* -------------------------------------------------------- */    *
*         /*  Perform Horizontal 1-D FDCT on each 8x8 block.          */    *
*         /* -------------------------------------------------------- */    *
*         dct_io_ptr = dct_data;                                            *
*         for (i = 0; i < 8 * num_fdcts; i++)                               *
*         {                                                                 *
*             /* ---------------------------------------------------- */    *
*             /*  Load the spatial-domain samples.                    */    *
*             /* ---------------------------------------------------- */    *
*             f0 = dct_io_ptr[0];                                           *
*             f1 = dct_io_ptr[1];                                           *
*             f2 = dct_io_ptr[2];                                           *
*             f3 = dct_io_ptr[3];                                           *
*             f4 = dct_io_ptr[4];                                           *
*             f5 = dct_io_ptr[5];                                           *
*             f6 = dct_io_ptr[6];                                           *
*             f7 = dct_io_ptr[7];                                           *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Stage 1:  Separate into even and odd halves.        */    *
*             /* ---------------------------------------------------- */    *
*             g0 = f0 + f7;               h2 = f0 - f7;                     *
*             g1 = f1 + f6;               h3 = f1 - f6;                     *
*             h1 = f2 + f5;               g3 = f2 - f5;                     *
*             h0 = f3 + f4;               g2 = f3 - f4;                     *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Stage 2                                             */    *
*             /* ---------------------------------------------------- */    *
*             p0 = g0 + h0;               r0 = g0 - h0;                     *
*             p1 = g1 + h1;               r1 = g1 - h1;                     *
*             q1 = g2;                    s1 = h2;                          *
*                                                                           *
*             s0a= h3 + g3;               q0a= h3 - g3;                     *
*             q0 = (q0a * c0 + 0x7FFF) >> 16;                               *
*             s0 = (s0a * c0 + 0x7FFF) >> 16;                               *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Stage 3                                             */    *
*             /* ---------------------------------------------------- */    *
*             P0 = p0 + p1;               P1 = p0 - p1;                     *
*             R1 = c6 * r1 + c2 * r0;     R0 = c6 * r0 - c2 * r1;           *
*                                                                           *
*             Q1 = q1 + q0;               Q0 = q1 - q0;                     *
*             S1 = s1 + s0;               S0 = s1 - s0;                     *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Stage 4                                             */    *
*             /* ---------------------------------------------------- */    *
*             F0 = P0;                    F4 = P1;                          *
*             F2 = R1;                    F6 = R0;                          *
*                                                                           *
*             F1 = c7 * Q1 + c1 * S1;     F7 = c7 * S1 - c1 * Q1;           *
*             F5 = c3 * Q0 + c5 * S0;     F3 = c3 * S0 - c5 * Q0;           *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Round and truncate values.                          */    *
*             /*                                                      */    *
*             /*  Note: F0 and F4 have different rounding since no    */    *
*             /*  MPYs have been applied to either term.  Also, F0's  */    *
*             /*  rounding is slightly different to offset the        */    *
*             /*  truncation effects from the horizontal pass (which  */    *
*             /*  does not round).                                    */    *
*             /* ---------------------------------------------------- */    *
*             F0r = (F0 + 0x0006) >>  3;                                    *
*             F1r = (F1 + 0x7FFF) >> 16;                                    *
*             F2r = (F2 + 0x7FFF) >> 16;                                    *
*             F3r = (F3 + 0x7FFF) >> 16;                                    *
*             F4r = (F4 + 0x0004) >>  3;                                    *
*             F5r = (F5 + 0x7FFF) >> 16;                                    *
*             F6r = (F6 + 0x7FFF) >> 16;                                    *
*             F7r = (F7 + 0x7FFF) >> 16;                                    *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Store the results                                   */    *
*             /* ---------------------------------------------------- */    *
*             dct_io_ptr[0] = F0r;                                          *
*             dct_io_ptr[1] = F1r;                                          *
*             dct_io_ptr[2] = F2r;                                          *
*             dct_io_ptr[3] = F3r;                                          *
*             dct_io_ptr[4] = F4r;                                          *
*             dct_io_ptr[5] = F5r;                                          *
*             dct_io_ptr[6] = F6r;                                          *
*             dct_io_ptr[7] = F7r;                                          *
*                                                                           *
*             /* ---------------------------------------------------- */    *
*             /*  Update pointer to next FDCT row.                    */    *
*             /* ---------------------------------------------------- */    *
*             dct_io_ptr += 8;                                              *
*         }                                                                 *
*                                                                           *
*         return;                                                           *
*       }                                                                   *
*                                                                           *
*                                                                           *
*       Note:  This code guarantees correct operation, even in the case     *
*       that 'num_fdcts == 0'.  In this case, the function runs for only    *
*       13 cycles (counting 6 cycles of function-call overhead), due to     *
*       early-exit code.  The early-exit case performs no accesses to the   *
*       fdct_data[] array and minimal access to the stack.                  *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop nest in the vertical pass has been collapsed into a        *
*       single-level loop.  Both vertical and horizontal loops have         *
*       been software pipelined.                                            *
*                                                                           *
*       For performance, portions of the code outside the loops have been   *
*       inter-scheduled with the prolog and epilog code of the loops.       *
*       Also, twin stack-pointers are used to accelerate stack accesses.    *
*       Finally, pointer values and cosine term registers are reused        *
*       between the horizontal and vertical loops to reduce the impact of   *
*       pointer and constant reinitialization.                              *
*                                                                           *
*       To save codesize, prolog and epilog collapsing have been performed  *
*       to the extent that it does not impact performance.  Also, code      *
*       outside the loops has been scheduled to pack as tightly into        *
*       fetch packets as possible to avoid alignment padding NOPs.          *
*                                                                           *
*       To reduce register pressure and save some code, the horizontal      *
*       loop uses the same pair of pointer register for both reading and    *
*       writing.  The pointer increments are on the LDs to permit prolog    *
*       and epilog collapsing, since LDs can be speculated.                 *
*                                                                           *
*       Additional section-specific optimization notes are provided below.  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Stack is aligned to a word boundary.                                *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur, regardless of fdct_data[]'s alignment.     *
*                                                                           *
*       The code requires 16 words of stack space to save Save-On-Entry     *
*       (SOE) registers, CSR, IRP, and a spill value.                       *
*                                                                           *
*       Bank usage on C6201:  1 of 4 banks for 40% of loop cycles           *
*                             2 of 4 banks for 60% of loop cycles           *
*                                                                           *
*       Nearly every cycle of this function performs at least one           *
*       memory access.                                                      *
*                                                                           *
*       This code issues speculative loads beyond both ends of the          *
*       input array.  Speculative loads may read up to 16 bytes before      *
*       and 128 bytes after the input buffer.  The caller must ensure       *
*       that the input is placed in memory so that these speculative        *
*       accesses do not cause incorrect program behavior.                   *
*                                                                           *
*   NOTES                                                                   *
*       This code masks interrupts for nearly its entire duration.          *
*       Interrupts are locked out for '40 + 160 * num_fdcts' cycles.  As    *
*       a result, the code is interrupt-tolerant, but not interruptible.    *
*                                                                           *
*       The cosine terms have all been scaled by sqrt(2), so that the       *
*       "c4" term is basically an even power of 2.                          *
*                                                                           *
*       The code is completely ENDIAN NEUTRAL.                              *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 48 + 160 * num_fdcts                                       *
*                                                                           *
*       For num_fdcts =  6, cycles = 1008.                                  *
*       For num_fdcts = 24, cycles = 3888.                                  *
*                                                                           *
*   CODESIZE                                                                *
*       1216 bytes.                                                         *
*                                                                           *
*   SOURCE                                                                  *
*       Chen FDCT.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

                .sect ".data:copyright_h"

        .sect ".text:_fdct_8x8"
        .global _IMG_fdct_8x8
_IMG_fdct_8x8:
; ========================== SYMBOLIC CONSTANTS =========================== ;
        .asg            0xB505,     cst_c0  ; Cosine term c0
        .asg            0x2C62,     cst_c1  ; Cosine term c1
        .asg            0x29CF,     cst_c2  ; Cosine term c2
        .asg            0x25A0,     cst_c3  ; Cosine term c3
        .asg            0x1924,     cst_c5  ; Cosine term c5
        .asg            0x1151,     cst_c6  ; Cosine term c6
        .asg            0x08D4,     cst_c7  ; Cosine term c7

; =============== SYMBOLIC REGISTER ASSIGNMENTS: VERT LOOP ================ ;
        .asg            A11,        A_k1c0  ; 1, Cosine term c0     (packed)
        .asg            A12,        A_c1c7  ; Cosine terms c1, c7   (packed)
        .asg            A13,        A_c2c6  ; Cosine terms c2, c6   (packed)
        .asg            B11,        B_k1c0  ; 1, Cosine term c0     (packed)
        .asg            B12,        B_c1c7  ; Cosine terms c1, c7   (packed)
        .asg            B13,        B_c2c6  ; Cosine terms c2, c6   (packed)
        .asg            B14,        B_c3c5  ; Cosine terms c3, c5   (packed)
        .asg            A4,         A_i_ptr ; Input pointer
        .asg            B10,        B_o_ptr ; Output pointer
        .asg            A9,         A_f0    ; Spatial domain sample f0
        .asg            B8,         B_f1    ; Spatial domain sample f1
        .asg            B6,         B_f2    ; Spatial domain sample f2
        .asg            A5,         A_f3    ; Spatial domain sample f3
        .asg            A7,         A_f4    ; Spatial domain sample f4
        .asg            B7,         B_f5    ; Spatial domain sample f5
        .asg            B15,        B_f6    ; Spatial domain sample f6
        .asg            A6,         A_f7    ; Spatial domain sample f7
        .asg            A6,         A_g0    ; Node g0 in flow graph
        .asg            B8,         B_g1    ; Node g1 in flow graph
        .asg            B6,         B_h1    ; Node h1 in flow graph
        .asg            A7,         A_h0    ; Node h0 in flow graph
        .asg            A0,         A_s1    ; Node s1 (h2) in flow graph
        .asg            B4,         B_h3    ; Node h3 in flow graph
        .asg            B15,        B_g3    ; Node g3 in flow graph
        .asg            A15,        A_q1    ; Node q1 (g2) in flow graph
        .asg            A6,         A_p0    ; Node p0 in flow graph
        .asg            B6,         B_p1    ; Node p1 in flow graph
        .asg            B15,        B_s0a   ; Node s0 intermediate result
        .asg            B5,         B_s0b   ; Node s0 intermediate result
        .asg            B15,        B_s0    ; Node s0 in flow graph
        .asg            A3,         A_r0    ; Node r0 in flow graph
        .asg            B15,        B_r1    ; Node r1 in flow graph
        .asg            B4,         B_q0a   ; Node q0 intermediate result
        .asg            A14,        A_q0b   ; Node q0 intermediate result
        .asg            A3,         A_q0    ; Node q0 in flow graph
        .asg            A10,        A_Q1    ; Node Q1 in flow graph
        .asg            B5,         B_S1    ; Node S1 in flow graph
        .asg            A3,         A_Q0    ; Node Q0 in flow graph
        .asg            B4,         B_S0    ; Node S0 in flow graph
        .asg            A14,        A_c1Q1  ; Intermediate value c1 * Q1
        .asg            A6,         A_c2r0  ; Intermediate value c2 * r0
        .asg            A7,         A_c3Q0  ; Intermediate value c3 * Q0
        .asg            A3,         A_c5Q0  ; Intermediate value c5 * Q0
        .asg            A14,        A_c6r0  ; Intermediate value c6 * r0
        .asg            A8,         A_c7Q1  ; Intermediate value c7 * Q1
        .asg            B5,         B_c1S1  ; Intermediate value c1 * S1
        .asg            B0,         B_c2r1  ; Intermediate value c2 * r1
        .asg            B0,         B_c3S0  ; Intermediate value c3 * S0
        .asg            B3,         B_c5S0  ; Intermediate value c5 * S0
        .asg            B6,         B_c6r1  ; Intermediate value c6 * r1
        .asg            B5,         B_c7S1  ; Intermediate value c7 * S1
        .asg            B9,         B_F0    ; Frequency domain term F0
        .asg            A8,         A_F1    ; Frequency domain term F1
        .asg            A5,         A_F2    ; Frequency domain term F2
        .asg            B4,         B_F3    ; Frequency domain term F3
        .asg            B3,         B_F4    ; Frequency domain term F4
        .asg            A9,         A_F5    ; Frequency domain term F5
        .asg            A10,        A_F6    ; Frequency domain term F6
        .asg            B4,         B_F7    ; Frequency domain term F7
        .asg            A8,         A_F1t   ; Truncated result for F1
        .asg            A5,         A_F2t   ; Truncated result for F2
        .asg            B7,         B_F3t   ; Truncated result for F3
        .asg            A10,        A_F5t   ; Truncated result for F5
        .asg            A10,        A_F6t   ; Truncated result for F6
        .asg            B5,         B_F7t   ; Truncated result for F7
        .asg            B2,         B_i     ; Inner loop counter #1
        .asg            A1,         A_i     ; Inner loop counter #2
        .asg            B1,         B_o     ; Outer loop counter
        .asg            A2,         A_c     ; Prolog collapse counter
; ========================================================================= ;


* ========================================================================= *
*   Initialization code / Stack Management                                  *
*                                                                           *
*   This code is responsible for saving registers to the stack, disabling   *
*   interrupts, and setting up for the vertical loop.                       *
*                                                                           *
*   This function requires 16 words of stack.  A10...A15, B10...B14, CSR,   *
*   IRP, and 'num_fdcts' are all pushed on the stack.  For speed, this      *
*   code uses twin stack pointers to offload registers onto the stack as    *
*   quickly as possible.                                                    *
*                                                                           *
*   The majority of the code in this function is not interruptible.         *
*   Therefore, interrupts are disabled almost immediately after entry       *
*   into the function, and the previous interruptibility state is restored  *
*   on exit.  The previous value of CSR is pushed on the stack and          *
*   restored on exit.                                                       *
*                                                                           *
*   Since all 32 registers are used by the vertical loop, the stack         *
*   pointer is saved in the IRP register.  The previous contents of IRP     *
*   are also pushed on the stack.                                           *
*                                                                           *
*   Initialization for constants (cosine terms, etc.) is overlapped with    *
*   the prolog of the vertical loop to save time.  Pointer setup for the    *
*   output pointer is also hidden in the prolog.                            *
*                                                                           *
*   Early exit code suppresses most of the function's activity (including   *
*   most of the stack accesses) if num_fdcts (in B4) is zero.  It is not    *
*   possible to exit the function faster.                                   *
* ========================================================================= *

;-
        STW     .D2T1   A15,        * B15--[16]     ; Save A15, get stk frame
||      MV      .L1X    B15,        A15             ; Twin Stack Pointer
||      SHL     .S2     B4,         3,          B_o ; iters == num_fdcts * 8

  [ B_o]STW     .D1T2   B14,        *-A15  [ 2]     ; Save B14 (SP[14])
||[ B_o]ADD     .L2     B_o,        -1,         B_o ; Adj. for parallel iters
||[ B_o]ADDK    .S1     48,         A_i_ptr         ; Point to row 3, col 0
||[!B_o]RET     .S2     B3                          ; Abort if num_fdcts == 0
||[!B_o]LDW     .D2T1   *++B15[16], A15             ; Restore A15 on abort
; ===== Interrupts masked by branch delay slots =====
;-
  [ B_o]STW     .D1T1   A13,        *-A15  [ 3]     ; Save A13 (SP[13])
||[ B_o]STW     .D2T2   B11,        *+B15  [ 8]     ; Save B11
||[ B_o]MVC     .S2     CSR,        B0              ; Snapshot CSR

  [ B_o]STW     .D1T1   A12,        *-A15  [ 5]     ; Save A12 (SP[11])
||[ B_o]STW     .D2T2   B12,        *+B15  [10]     ; Save B12

  [ B_o]STW     .D1T2   B13,        *-A15  [ 7]     ; Save B13 (SP[ 9])
||[ B_o]STW     .D2T1   A11,        *+B15  [12]     ; Save A11
||[ B_o]MVC     .S2     IRP,        B5              ; Snapshot IRP
;-
  [ B_o]STW     .D1T1   A10,        *-A15  [ 9]     ; Save A10 (SP[ 7])
||[ B_o]STW     .D2T2   B10,        *+B15  [ 6]     ; Save B10
||[ B_o]AND     .L2     B0,         -2,         B2  ; Clear GIE bit in CSR
||[ B_o]MV      .L1X    B5,         A1              ; Partitioning MV

  [ B_o]STW     .D2T2   B3,         *+B15  [ 5]     ; Save return address
||[ B_o]STW     .D1T1   A1,         *-A15  [12]     ; Save IRP (SP[ 4])
||[ B_o]MV      .L1X    B0,         A0              ; Partitioning MV
||[ B_o]MVC     .S2     B2,         CSR             ; Mask interrupts
; ===== Branch Occurs =====
;-
; =========================== PIPE LOOP PROLOG ============================ ;
        LDH     .D1T1   *+A_i_ptr  [ 8],        A_f4            ;[ 1,1]
||      MVC     .S2     B15,        IRP             ; Save Stack Pointer

        LDH     .D1T2   *-A_i_ptr  [16],        B_f1            ;[ 2,1]
||      MVK     .S1     4,          A_i             ; Inner loop counter #1

        LDH     .D1T1   * A_i_ptr++[ 1],        A_f3            ;[ 3,1]
||      MVKL    .S1     cst_c7,     A_c1c7          ; Cosine term C7

        LDH     .D1T1   *-A_i_ptr  [25],        A_f0            ;[ 4,1]
||      MVKL    .S1     cst_c0,     A_k1c0          ; Cosine term C0
;-
        LDH     .D1T2   *+A_i_ptr  [15],        B_f5            ;[ 5,1]
||      MVKL    .S1     cst_c6,     A_c2c6          ; Cosine term C6
||      MVKL    .S2     cst_c6,     B_c2c6          ; Cosine term C6
||      MV      .L2X    A_c1c7,     B_c1c7          ; Twin constant register

        LDH     .D1T2   *-A_i_ptr  [ 9],        B_f2            ;[ 6,1]
||      MVKLH   .S1     cst_c2,     A_c2c6          ; Cosine term C2
||      SUB     .L1     A_i,        2,          A_c ; Prolog collapse cnt = 2
||      ADD     .L2X    A_i_ptr,    -2,         B_o_ptr
;-
        LDH     .D1T2   *+A_i_ptr  [23],        B_f6            ;[ 7,1]
||      MVKLH   .S2     cst_c1,     B_c1c7          ; Cosine term C1

        LDH     .D1T1   *+A_i_ptr  [31],        A_f7            ;[ 8,1]
||      MVKLH   .S1     cst_c1,     A_c1c7          ; Cosine term C1
||      MVKLH   .S2     cst_c2,     B_c2c6          ; Cosine term C2

        MVKL    .S2     cst_c5,     B_c3c5          ; Cosine term C5
||      MVKLH   .S1     1,          A_k1c0          ; Constant: 0x0001
||      STW     .D2T1   A14,        *+B15  [15]     ; Save A14
;-
        SUB     .L1     A_f3,       A_f4,       A_q1            ;[ 9,1] q1=g2
||      ADD     .S1     A_f3,       A_f4,       A_h0            ;[10,1]
||      MVKLH   .S2     cst_c3,     B_c3c5          ; Cosine term C3
||      STW     .D2T2   B_o,        *+B15  [ 3]     ; Spill horiz loop count
||      STW     .D1T1   A0,         *-A15  [14]     ; Save CSR (SP[ 2])

        LDH     .D1T1   *+A_i_ptr  [ 8],        A_f4            ;[ 1,2]
||      MV      .L2X    A_k1c0,     B_k1c0          ; Twin constant register
||      MVK     .S2     16,         B_i             ; Inner loop counter #2
;-
; =========================== PIPE LOOP KERNEL ============================ ;
v_loop:
        SHR     .S1     A_F6,       13,         A_F6t           ;[22,1]
||      MPY     .M2     B_S0,       B_c3c5,     B_c5S0          ;[22,1]
||      MPY     .M1X    A_Q0,       B_c3c5,     A_c5Q0          ;[22,1]
||      ADD     .D2     B_f1,       B_f6,       B_g1            ;[12,2]
||      SUB     .S2     B_f2,       B_f5,       B_g3            ;[12,2]
||      SUB     .L2     B_f1,       B_f6,       B_h3            ;[12,2]
||      LDH     .D1T2   *-A_i_ptr  [16],        B_f1            ;[ 2,3]
||[ A_c]ADD     .L1     A_c,        -1,         A_c             ;pro. collapse
;-
v_loop_1:
  [!A_c]STH     .D2T2   B_F4,       *+B_o_ptr  [ 8]             ;[23,1]
||      MPY     .M2     B_S1,       B_c1c7,     B_c7S1          ;[23,1]
||      MPYLH   .M1X    A_Q0,       B_c3c5,     A_c3Q0          ;[23,1]
||      ADD     .L2     B_h3,       B_g3,       B_s0a           ;[13,2]
||      SUB     .S2     B_h3,       B_g3,       B_q0a           ;[13,2]
||      SUB     .S1     A_f0,       A_f7,       A_s1            ;[13,2] s1=h2
||      ADD     .L1     A_f0,       A_f7,       A_g0            ;[13,2]
||      LDH     .D1T1   * A_i_ptr++[ 1],        A_f3            ;[ 3,3]
;-
v_loop_2:
  [!A_c]STH     .D2T2   B_F0,       *-B_o_ptr  [24]             ;[24,1]
||      SUB     .S2X    B_c3S0,     A_c5Q0,     B_F3            ;[24,1]
||      MPYLH   .M2     B_S1,       B_c1c7,     B_c1S1          ;[24,1]
||      ADD     .L2     B_f2,       B_f5,       B_h1            ;[14,2]
||      SUB     .S1     A_g0,       A_h0,       A_r0            ;[14,2]
||      ADD     .L1     A_g0,       A_h0,       A_p0            ;[14,2]
||      MPYSU   .M1X    B_q0a,      A_k1c0,     A_q0b           ;[14,2]
||      LDH     .D1T1   *-A_i_ptr  [25],        A_f0            ;[ 4,3]
;-
v_loop_3:
  [!A_c]SHR     .S1     A_F2,       13,         A_F2t           ;[25,1]
||[!A_c]MPY     .M1     A_i,        4,          A_i             ;[25,1]
||      SHR     .S2     B_F3,       13,         B_F3t           ;[25,1]
||      SUB     .L2X    B_c7S1,     A_c1Q1,     B_F7            ;[25,1]
||      ADD     .L1X    A_c3Q0,     B_c5S0,     A_F5            ;[25,1]
||      SUB     .D2     B_g1,       B_h1,       B_r1            ;[15,2]
||      MPYSU   .M2     B_s0a,      B_k1c0,     B_s0b           ;[15,2]
||      LDH     .D1T2   *+A_i_ptr  [15],        B_f5            ;[ 5,3]
;-
v_loop_4:
        ADD     .L1X    A_c7Q1,     B_c1S1,     A_F1            ;[26,1]
||[ B_o]B       .S2     v_loop                                  ;[26,1]
||[!A_c]STH     .D2T1   A_F6t,      *+B_o_ptr  [24]             ;[26,1]
||      ADD     .L2     B_g1,       B_h1,       B_p1            ;[16,2]
||      ADDK    .S1     07FFFh,     A_q0b                       ;[16,2]
||      MPY     .M1     A_r0,       A_c2c6,     A_c6r0          ;[16,2]
||      MPY     .M2     B_i,        4,          B_i             ;[ 6,3]
||      LDH     .D1T2   *-A_i_ptr  [ 9],        B_f2            ;[ 6,3]
;-
v_loop_5:
  [!A_c]STH     .D2T1   A_F2t,      *-B_o_ptr  [ 8]             ;[27,1]
||      SHR     .S1     A_F5,       13,         A_F5t           ;[27,1]
||      MPY     .M2     B_r1,       B_c2c6,     B_c6r1          ;[17,2]
||      SUB     .L2X    A_p0,       B_p1,       B_F4            ;[17,2]
||      ADDK    .S2     07FFFh,     B_s0b                       ;[17,2]
||      MPYH    .M1     A_q0b,      A_k1c0,     A_q0            ;[17,2]
||      LDH     .D1T2   *+A_i_ptr  [23],        B_f6            ;[ 7,3]
;-
v_loop_6:
  [!A_c]STH     .D2T2   B_F3t,      * B_o_ptr++[ 1]             ;[28,1]
||      SHR     .S1     A_F1,       13,         A_F1t           ;[28,1]
||      ADD     .L2X    A_p0,       B_p1,       B_F0            ;[18,2]
||      MPYLH   .M1     A_r0,       A_c2c6,     A_c2r0          ;[18,2]
||      MPYH    .M2     B_s0b,      B_k1c0,     B_s0            ;[18,2]
||[ B_o]SUB     .S2     B_o,        1,          B_o             ;[18,2]
||      LDH     .D1T1   *+A_i_ptr  [31],        A_f7            ;[ 8,3]
v_loop_7:
;-
        SHR     .S2     B_F7,       13,         B_F7t           ;[29,1]
||[!A_c]STH     .D2T1   A_F5t,      *+B_o_ptr  [15]             ;[29,1]
||      MPYLH   .M2     B_r1,       B_c2c6,     B_c2r1          ;[19,2]
||      SUB     .L1     A_q1,       A_q0,       A_Q0            ;[19,2]
||      ADD     .D1     A_q1,       A_q0,       A_Q1            ;[19,2]
||      SUB     .S1     A_f3,       A_f4,       A_q1            ;[ 9,3] q1=g2
;-
v_loop_8:
  [!A_c]STH     .D2T1   A_F1t,      *-B_o_ptr  [17]             ;[30,1]
||      ADD     .L1X    B_c6r1,     A_c2r0,     A_F2            ;[20,2]
||      SUB     .L2X    A_s1,       B_s0,       B_S0            ;[20,2]
||      MPYLH   .M1     A_Q1,       A_c1c7,     A_c1Q1          ;[20,2]
||      ADD     .D1     A_f3,       A_f4,       A_h0            ;[10,3]
||[!B_i]ADD     .S2     B_i,        4,          B_i             ;[10,3]
||[!B_i]ADDK    .S1     112,        A_i_ptr                     ;[10,3]
;-
v_loop_9:
  [!A_c]STH     .D2T2   B_F7t,      *+B_o_ptr  [31]             ;[31,1]
||[!A_i]ADDK    .S2     112,        B_o_ptr                     ;[31,1]
||[!A_i]ADD     .S1     A_i,        4,          A_i             ;[31,1]
||      SUB     .L1X    A_c6r0,     B_c2r1,     A_F6            ;[21,2]
||      MPYLH   .M2     B_S0,       B_c3c5,     B_c3S0          ;[21,2]
||      ADD     .L2X    A_s1,       B_s0,       B_S1            ;[21,2]
||      MPY     .M1     A_Q1,       A_c1c7,     A_c7Q1          ;[21,2]
||      LDH     .D1T1   *+A_i_ptr  [ 8],        A_f4            ;[ 1,4]
; =========================== PIPE LOOP EPILOG ============================ ;

* ========================================================================= *
*   Epilog / Inter-loop / Prolog Code                                       *
*                                                                           *
*   The code from the vertical loop's epilog has been interscheduled        *
*   with inter-loop code and prolog code for the horizontal loop.           *
*   This allows hiding some of the overhead as we pipe-down one loop and    *
*   pipe-up the next.                                                       *
*                                                                           *
*   Notably, we restore B15 and IRP here (rather than after the loop)       *
*   and unspill our loop trip count from the stack, all in parallel with    *
*   the prolog and epilog code.  Also, the epilog of the first loop has     *
*   been heavily overlapped with the prolog of the second loop.  Since      *
*   a handful of symbolic names have been assigned to different registers,  *
*   and others have conflicting names between the two loops, we use a set   *
*   of intermediate symbolic names that bridge the transition.              *
*                                                                           *
*   To save a STH/LDH pair, the value of "F7t" from the first loop is       *
*   forwarded directly to the input "f7" of the second loop.  (The last     *
*   FDCT performed by the vertical loop overlaps the first FDCT performed   *
*   by the second loop.)  This is done through a "sign extension", to       *
*   exactly mimic the overflow behavior of the original C code.             *
*                                                                           *
*   For speed, we twin the stack pointer in a spare slot here so that the   *
*   stack restore after the loop can proceed as quickly as possible.        *
* ========================================================================= *

        .asg            A4,         Ah_io_ptr   ; Horiz Input/output pointer
        .asg            A14,        Av_c1Q1     ; Vert: Intermediate c1 * Q1
        .asg            A6,         Av_c3Q0     ; Vert: Intermediate c3 * Q0
        .asg            A8,         Av_c7Q1     ; Vert: Intermediate c7 * Q1
        .asg            B6,         Bv_c1S1     ; Vert: Intermediate c1 * S1
        .asg            B3,         Bv_c5S0     ; Vert: Intermediate c5 * S0
        .asg            B5,         Bv_c7S1     ; Vert: Intermediate c7 * S1
        .asg            A8,         Av_F1       ; Vert: Freq. domain term F1
        .asg            A5,         Av_F2       ; Vert: Freq. domain term F2
        .asg            B4,         Bv_F3       ; Vert: Freq. domain term F3
        .asg            A9,         Av_F5       ; Vert: Freq. domain term F5
        .asg            B4,         Bv_F7       ; Vert: Freq. domain term F7
        .asg            A8,         Av_F1t      ; Vert: Trunc. result for F1
        .asg            A5,         Av_F2t      ; Vert: Trunc. result for F2
        .asg            B7,         Bv_F3t      ; Vert: Trunc. result for F3
        .asg            A9,         Av_F5t      ; Vert: Trunc. result for F5
        .asg            B5,         Bv_F7t      ; Vert: Trunc. result for F7
;-
        SHR     .S1     A_F6,       13,         A_F6t           ;[22,4]
||      MPYLH   .M2     B_S1,       B_c1c7,     Bv_c1S1         ;[24,4]
||      MPY     .M1X    A_Q0,       B_c3c5,     A_c5Q0          ;[22,4]
||      STH     .D2T2   B_F4,       *+B_o_ptr  [ 8]             ;[23,4]

        MPY     .M2     B_S0,       B_c3c5,     Bv_c5S0         ;[22,4]
||      MPYLH   .M1X    A_Q0,       B_c3c5,     Av_c3Q0         ;[23,4]
||      STH     .D2T1   A_F6t,      *+B_o_ptr  [24]             ;[26,4]
||      MVC     .S2     IRP,        B15
;-
        STH     .D2T2   B_F0,       *-B_o_ptr  [24]             ;[24,4]
||      MPY     .M2     B_S1,       B_c1c7,     B_c7S1          ;[23,4]
||      SUB     .S2X    B_c3S0,     A_c5Q0,     B_F3            ;[24,4]
||      ADD     .L1X    A_c7Q1,     Bv_c1S1,    A_F1            ;[26,4]
||      ADDK    .S1     -54,        Ah_io_ptr   ; Adjust pointer

        SHR     .S2     B_F3,       13,         B_F3t           ;[25,4]
||      LDW     .D2T1   *B15[4],    A2          ; Load IRP's value
||      SHR     .S1     A_F1,       13,         Av_F1t          ;[28,4]
;-
; ========================================================================= ;

; =============== SYMBOLIC REGISTER ASSIGNMENTS: HORIZ LOOP =============== ;
        .asg            A14,        A_c3c5  ; Cosine terms c3, c5   (packed)
        .asg            B1,         B_k_rnd ; Rounding constant 0x7FFF
        .asg            A12,        A_k_rnd ; Rounding constant 0x7FFF
        .asg            B2,         B_io_ptr; Input/output pointer
        .asg            A4,         A_io_ptr; Input/output pointer
        .asg            A7,         A_f0    ; Spatial domain sample f0
        .asg            B13,        B_f1    ; Spatial domain sample f1
        .asg            B3,         B_f2    ; Spatial domain sample f2
        .asg            A10,        A_f3    ; Spatial domain sample f3
        .asg            A0,         A_f4    ; Spatial domain sample f4
        .asg            B7,         B_f5    ; Spatial domain sample f5
        .asg            B9,         B_f6t   ; Spatial domain sample f6 (tmp)
        .asg            B10,        B_f6    ; Spatial domain sample f6
        .asg            A8,         A_f7    ; Spatial domain sample f7
        .asg            A0,         A_g0    ; Node g0 in flow graph
        .asg            B3,         B_g1    ; Node g1 in flow graph
        .asg            B8,         B_h1    ; Node h1 in flow graph
        .asg            A9,         A_h0    ; Node h0 in flow graph
        .asg            A1,         A_s1    ; Node s1 in flow graph
        .asg            B13,        B_h3    ; Node h3 in flow graph
        .asg            B10,        B_g3    ; Node g3 in flow graph
        .asg            A10,        A_q1    ; Node q1 in flow graph
        .asg            A5,         A_p0    ; Node p0 in flow graph
        .asg            B4,         B_p1    ; Node p1 in flow graph
        .asg            B4,         B_s0a   ; Node s0 intermediate value
        .asg            B5,         B_s0b   ; Node s0 intermediate value
        .asg            B5,         B_s0c   ; Node s0 intermediate value
        .asg            B9,         B_s0    ; Node s0 in flow graph
        .asg            A0,         A_r0    ; Node r0 in flow graph
        .asg            B7,         B_r1    ; Node r1 in flow graph
        .asg            B5,         B_q0a   ; Node q0 intermediate value
        .asg            A3,         A_q0b   ; Node q0 intermediate value
        .asg            A0,         A_q0c   ; Node q0 intermediate value
        .asg            A6,         A_q0    ; Node q0 in flow graph
        .asg            A9,         A_Q1    ; Node Q1 in flow graph
        .asg            B8,         B_S1    ; Node S1 in flow graph
        .asg            A6,         A_Q0    ; Node Q0 in flow graph
        .asg            B5,         B_S0    ; Node S0 in flow graph
        .asg            A0,         A_c1Q1  ; Intermediate value c1 * Q1
        .asg            A5,         A_c2r0  ; Intermediate value c2 * r0
        .asg            A3,         A_c3Q0  ; Intermediate value c3 * Q0
        .asg            A9,         A_c5Q0  ; Intermediate value c5 * Q0
        .asg            A3,         A_c6r0  ; Intermediate value c6 * r0
        .asg            A3,         A_c7Q1  ; Intermediate value c7 * Q1
        .asg            B7,         B_c1S1  ; Intermediate value c1 * S1
        .asg            B3,         B_c2r1  ; Intermediate value c2 * r1
        .asg            B4,         B_c3S0  ; Intermediate value c3 * S0
        .asg            B10,        B_c5S0  ; Intermediate value c5 * S0
        .asg            B4,         B_c6r1  ; Intermediate value c6 * r1
        .asg            B4,         B_c7S1  ; Intermediate value c7 * S1
        .asg            B5,         B_F0    ; Frequency domain term F0
        .asg            A6,         A_F1    ; Frequency domain term F1
        .asg            B9,         B_F2    ; Frequency domain term F2
        .asg            B3,         B_F3    ; Frequency domain term F3
        .asg            A1,         A_F4    ; Frequency domain term F4
        .asg            A9,         A_F5    ; Frequency domain term F5
        .asg            A3,         A_F6    ; Frequency domain term F6
        .asg            B7,         B_F7    ; Frequency domain term F7
        .asg            B5,         B_F0r   ; Rounded value for F0
        .asg            A6,         A_F1r   ; Rounded value for F1
        .asg            B3,         B_F2r   ; Rounded value for F2
        .asg            B3,         B_F3r   ; Rounded value for F3
        .asg            A7,         A_F4r   ; Rounded value for F4
        .asg            A9,         A_F5r   ; Rounded value for F5
        .asg            A3,         A_F6r   ; Rounded value for F6
        .asg            B5,         B_F7r   ; Rounded value for F7
        .asg            B6,         B_F0t   ; Truncated result for F0
        .asg            A8,         A_F1t   ; Truncated result for F1
        .asg            B6,         B_F2t   ; Truncated result for F2
        .asg            B4,         B_F3t   ; Truncated result for F3
        .asg            A7,         A_F4t   ; Truncated result for F4
        .asg            A0,         A_F5t   ; Truncated result for F5
        .asg            A5,         A_F6t   ; Truncated result for F6
        .asg            B13,        B_F7t   ; Truncated result for F7
        .asg            A2,         A_o     ; Outer loop counter
        .asg            B0,         B_c     ; Prolog collapse counter
        .asg            A1,         A_c     ; Prolog collapse counter copy
; ========================================================================= ;

* ========================================================================= *
*   (Instructions marked "(v)" in the prolog below are from the vertical    *
*   loop's epilog.)                                                         *
* ========================================================================= *

; =========================== PIPE LOOP PROLOG ============================ ;
        LDH     .D1T2   *-A_io_ptr  [ 4],       B_f2            ;[ 1,1]
||      SUB             A_io_ptr,   12,         B_io_ptr
||      STH     .D2T1   Av_F1t,     *-B_o_ptr  [16]             ;[30,4] (v)
||      SHR     .S1     Av_F2,      13,         Av_F2t          ;[25,4] (v)

        LDH     .D1T1   *-A_io_ptr  [ 3],       A_f3            ;[ 2,1]
||      LDH     .D2T2   *+B_io_ptr  [ 5],       B_f5            ;[ 2,1]
||      SUB     .L2X    Bv_c7S1,    Av_c1Q1,    Bv_F7           ;[25,4] (v)
||      ADD     .L1X    Av_c3Q0,    Bv_c5S0,    Av_F5           ;[25,4] (v)
;-
        LDH     .D2T1   *+B_io_ptr  [ 4],       A_f4            ;[ 3,1]
||      LDH     .D1T2   * A_io_ptr--[ 7],       B_f6t           ;[ 3,1]
||      MVK     .S1     0x7FFF,     A_k_rnd         ; Rounding value
||      MVK     .S2     0x7FFF,     B_k_rnd         ; Rounding value

        LDH     .D2T1   * B_io_ptr--[ 8],       A_f0            ;[ 5,1]
||      LDH     .D1T2   *+A_io_ptr  [ 2],       B_f1            ;[ 4,1]
||      SHR     .S1     Av_F5,      13,         Av_F5t          ;[27,4] (v)

;-
        SHL     .S1X    Bv_F7,      3,          A_f7            ;[29,4] (v)
||      STH     .D2T2   Bv_F3t,     * B_o_ptr  [ 0]             ;[28,4] (v)

        CLR     .S2     B_k1c0,     0,15,       B_c ; Prolog collapse: 0x10000
||      MV      .L1X    B_c3c5,     A_c3c5          ; Twin constant register
||      STH     .D2T1   Av_F5t,     *+B_o_ptr  [16]             ;[29,4] (v)

        MV      .L1X    B15,        A15             ; Twin stack pointer
||      MVC     .S2X    A2,         IRP             ; Restore IRP
||      STH     .D2T1   Av_F2t,     *-B_o_ptr  [ 8]             ;[27,4] (v)
;-

        ADD     .L1     A_f3,       A_f4,       A_h0            ;[ 8,1]
||      ADD     .S2     B_f2,       B_f5,       B_h1            ;[ 8,1]
||      SUB     .L2     B_f2,       B_f5,       B_g3            ;[ 9,1]
||      LDW     .D2T1   *B15[3],    A_o

        SUB     .L1     A_f3,       A_f4,       A_q1            ;[ 9,1] q1=g2
||      ADD     .L2     B_f1,       B_f6t,      B_g1            ;[ 9,1]
||      SUB     .S2     B_f1,       B_f6t,      B_h3            ;[ 9,1]
||      SHR     .S1     A_f7,       16,         A_f7
;-
; =========================== PIPE LOOP KERNEL ============================ ;
h_loop:
  [!B_c]STH     .D1T2   B_F0t,      *+A_io_ptr[ 9]              ;[20,1]
||      MPY     .M1     A_Q0,       A_c3c5,     A_c5Q0          ;[20,1]
||      MPYLH   .M2     B_S0,       B_c3c5,     B_c3S0          ;[20,1]
||      ADD     .S1X    A_c7Q1,     B_c1S1,     A_F1            ;[20,1]
||      SUB     .S2X    B_c7S1,     A_c1Q1,     B_F7            ;[20,1]
||      ADD     .L1     A_f0,       A_f7,       A_g0            ;[10,2]
||      ADD     .D2     B_h3,       B_g3,       B_s0a           ;[10,2]
||      SUB     .L2     B_h3,       B_g3,       B_q0a           ;[10,2]
;-
h_loop_1:
        ADD     .L2     B_F7,       B_k_rnd,    B_F7r           ;[21,1]
||[!B_c]STH     .D2T1   A_F6t,      *+B_io_ptr[22]              ;[21,1]
||      SUB     .S2     B_g1,       B_h1,       B_r1            ;[11,2]
||      MPYSU   .M2     B_s0a,      B_k1c0,     B_s0b           ;[11,2]
||      MPYSU   .M1X    B_q0a,      A_k1c0,     A_q0b           ;[11,2]
||      ADD     .S1     A_g0,       A_h0,       A_p0            ;[11,2]
||      SUB     .L1     A_g0,       A_h0,       A_r0            ;[11,2]
||      LDH     .D1T2   *-A_io_ptr  [ 2],       B_f5            ;[ 1,3]
;-
h_loop_2:
        SUB     .S2X    B_c3S0,     A_c5Q0,     B_F3            ;[22,1]
||      ADD     .S1X    A_c3Q0,     B_c5S0,     A_F5            ;[22,1]
||      ADD     .L1     A_F1,       A_k_rnd,    A_F1r           ;[22,1]
||      MPYH    .M2     B_F7r,      B_k1c0,     B_F7t           ;[22,1]
||      ADD     .L2     B_g1,       B_h1,       B_p1            ;[12,2]
||      MPY     .M1     A_r0,       A_c2c6,     A_c6r0          ;[12,2]
||      LDH     .D1T1   *-A_io_ptr  [ 4],       A_f3            ;[ 2,3]
||      LDH     .D2T2   *+B_io_ptr  [ 2],       B_f2            ;[ 2,3]
;-
h_loop_3:
        ADD     .S2     B_F3,       B_k_rnd,    B_F3r           ;[23,1]
||      SUB     .S1X    A_p0,       B_p1,       A_F4            ;[13,2]
||      ADD     .L1     A_q0b,      A_k_rnd,    A_q0c           ;[13,2]
||      ADD     .L2     B_s0b,      B_k_rnd,    B_s0c           ;[13,2]
||      MPYLH   .M2X    B_r1,       A_c2c6,     B_c2r1          ;[13,2]
||      MPYLH   .M1     A_r0,       A_c2c6,     A_c2r0          ;[13,2]
||      LDH     .D2T1   *+B_io_ptr  [ 4],       A_f4            ;[ 3,3]
||      LDH     .D1T2   *-A_io_ptr  [ 1],       B_f6            ;[ 3,3]
;-
h_loop_4:
        ADD     .L1     A_F5,       A_k_rnd,    A_F5r           ;[24,1]
||      SHR     .S2     B_F3r,      16,         B_F3t           ;[24,1]
||[ A_o]B       .S1     h_loop                                  ;[24,1]
||      ADD     .L2X    A_p0,       B_p1,       B_F0            ;[14,2]
||      MPYH    .M2     B_s0c,      B_k1c0,     B_s0            ;[14,2]
||      MPYH    .M1     A_q0c,      A_k1c0,     A_q0            ;[14,2]
||      LDH     .D1T1   * A_io_ptr--[ 8],       A_f7            ;[ 4,3]
||      LDH     .D2T2   *+B_io_ptr  [ 1],       B_f1            ;[ 4,3]
;-
h_loop_5:
        ADD     .S2     B_F2,       B_k_rnd,    B_F2r           ;[25,1]
||      MPYH    .M1     A_F1r,      A_k1c0,     A_F1t           ;[25,1]
||      ADD     .D1     A_F4,       4,          A_F4r           ;[15,2]
||      SUB     .S1X    A_c6r0,     B_c2r1,     A_F6            ;[15,2]
||      SUB     .L1     A_f0,       A_f7,       A_s1            ;[15,2] s1=h2
||      ADD     .L2     B_F0,       6,          B_F0r           ;[15,2]
||      MPY     .M2X    B_r1,       A_c2c6,     B_c6r1          ;[15,2]
||      LDH     .D2T1   * B_io_ptr--[ 8],       A_f0            ;[ 5,3]
;-
h_loop_6:
        SHR     .S1     A_F5r,      16,         A_F5t           ;[26,1]
||      SHR     .S2     B_F2r,      16,         B_F2t           ;[26,1]
||[!B_c]STH     .D2T2   B_F3t,      *+B_io_ptr[27]              ;[26,1]
||      SUB     .L1     A_q1,       A_q0,       A_Q0            ;[16,2]
||      ADD     .L2X    A_s1,       B_s0,       B_S1            ;[16,2]
||      ADD     .D1     A_q1,       A_q0,       A_Q1            ;[16,2]
||      MPYUS   .M2     B_c,        2,          B_c             ;pro. collapse
||      MPYHL   .M1X    B_c,        A_c2c6,     A_c             ;pro. collapse
;-
h_loop_7:
  [!B_c]STH     .D1T1   A_F5t,      *+A_io_ptr[22]              ;[27,1]
||[!B_c]STH     .D2T2   B_F2t,      *+B_io_ptr[26]              ;[27,1]
||      ADD     .L1     A_F6,       A_k_rnd,    A_F6r           ;[17,2]
||      SHR     .S2     B_F0r,      3,          B_F0t           ;[17,2]
||      SHR     .S1     A_F4r,      3,          A_F4t           ;[17,2]
||      SUB     .L2X    A_s1,       B_s0,       B_S0            ;[17,2]
||      MPY     .M2     B_S1,       B_c1c7,     B_c7S1          ;[17,2]
||      MPY     .M1X    A_Q1,       B_c1c7,     A_c7Q1          ;[17,2]
;-
h_loop_8:
  [!A_c]STH     .D1T1   A_F1t,      *+A_io_ptr[18]              ;[28,1]
||[!A_c]STH     .D2T2   B_F7t,      *+B_io_ptr[31]              ;[28,1]
||      SHR     .S1     A_F6r,      16,         A_F6t           ;[18,2]
||      ADD     .L2X    B_c6r1,     A_c2r0,     B_F2            ;[18,2]
||      MPYLH   .M2     B_S1,       B_c1c7,     B_c1S1          ;[18,2]
||      MPYLH   .M1X    A_Q1,       B_c1c7,     A_c1Q1          ;[18,2]
||      ADD     .L1     A_f3,       A_f4,       A_h0            ;[ 8,3]
||      ADD     .S2     B_f2,       B_f5,       B_h1            ;[ 8,3]
;-
h_loop_9:
  [ A_o]SUB     .S1     A_o,        1,          A_o             ;[19,2]
||[!B_c]STH     .D1T1   A_F4t,      *+A_io_ptr[13]              ;[19,2]
||      MPYLH   .M1     A_Q0,       A_c3c5,     A_c3Q0          ;[19,2]
||      MPY     .M2     B_S0,       B_c3c5,     B_c5S0          ;[19,2]
||      SUB     .L1     A_f3,       A_f4,       A_q1            ;[ 9,3] q1=g2
||      ADD     .L2     B_f1,       B_f6,       B_g1            ;[ 9,3]
||      SUB     .D2     B_f1,       B_f6,       B_h3            ;[ 9,3]
||      SUB     .S2     B_f2,       B_f5,       B_g3            ;[ 9,3]
; =========================== PIPE LOOP EPILOG ============================ ;
; EPILOG:
;-
* ========================================================================= *
*   Epilog / Final Cleanup Code.                                            *
*                                                                           *
*   This code performs the final stores from the epilog while retoring      *
*   Save-On-Entry values from the stack.  The two processes are heavily     *
*   interwoven in the interest of speed.  For instance, the return addr.    *
*   is loaded immediately and branched to as soon as it lands in the        *
*   register file.  Meanwhile, the final epilog stores complete as the      *
*   return-branch is taken.                                                 *
*                                                                           *
*   Note that a handful of symbolic names have been reassigned in the       *
*   epilog to avoid interfering with the values being loaded from the       *
*   stack.                                                                  *
* ========================================================================= *
        .asg            B5,         B_F7t
        .asg            B9,         B_F2r
        .asg            B8,         B_F3
        .asg            B8,         B_F3r
        .asg            A9,         A_F5t

        MPY     .M1     A_Q0,       A_c3c5,     A_c5Q0
||      MPYLH   .M2     B_S0,       B_c3c5,     B_c3S0
||      ADD     .S1X    A_c7Q1,     B_c1S1,     A_F1
||      SUB     .S2X    B_c7S1,     A_c1Q1,     B_F7
||      ADD     .L2     B_F2,       B_k_rnd,    B_F2r
||      LDW     .D2T1   *+ B15[ 2], A0              ; Load CSR's value
||      LDW     .D1T2   *+ A15[ 5], B3              ; Load return address
;-
        ADD     .L2     B_F7,       B_k_rnd,    B_F7r
||      ADD     .L1     A_F1,       A_k_rnd,    A_F1r
||      LDW     .D2T2   *+ B15[ 8], B11             ; Restore B11
||      LDW     .D1T1   *+ A15[13], A13             ; Restore A13

        MPYH    .M2     B_F7r,      B_k1c0,     B_F7t
||      MPYH    .M1     A_F1r,      A_k1c0,     A_F1t
||      LDW     .D1T2   *+ A15[ 6], B10             ; Restore B10
||      LDW     .D2T1   *+ B15[ 7], A10             ; Restore A10
;-
        ADD     .S1X    A_c3Q0,     B_c5S0,     A_F5
||      SUB     .S2X    B_c3S0,     A_c5Q0,     B_F3
||      LDW     .D1T2   *+ A15[14], B14             ; Restore B14
||      LDW     .D2T1   *+ B15[15], A14             ; Restore A14

        ADD     .L2     B_F3,       B_k_rnd,    B_F3r
||      ADD     .L1     A_F5,       A_k_rnd,    A_F5r
||      LDW     .D1T2   *+ A15[10], B12             ; Restore B12
||      LDW     .D2T1   *+ B15[11], A12             ; Restore A12
;-
        RET     .S2     B3                          ; Return to caller
||      LDW     .D2T1   *+ B15[12], A11             ; Restore A11

        SHR     .S2     B_F3r,      16,         B_F3t
||      LDW     .D2T1   *++B15[16], A15             ; Rst. A15, release stack
||      LDW     .D1T2   *+ A15[ 9], B13             ; Restore B13

        STH     .D1T1   A_F1t,      *+A_io_ptr[10]
||      STH     .D2T2   B_F7t,      *+B_io_ptr[23]
||      SHR     .S1     A_F5r,      16,         A_F5t
;-
        STH     .D2T1   A_F6t,      *+B_io_ptr[22]
||      STH     .D1T2   B_F0t,      *+A_io_ptr[ 9]

        SHR     .S2     B_F2r,      16,         B_F2t
||      STH     .D2T2   B_F3t,      *+B_io_ptr[19]

        STH     .D1T1   A_F5t,      *+A_io_ptr[14]
||      STH     .D2T2   B_F2t,      *+B_io_ptr[18]
||      MVC     .S2X    A0,         CSR             ; Restore CSR
;-
; ===== Interruptibility state restored here =====
; ===== Branch Occurs =====

* ========================================================================= *
*   End of file:  img_fdct_8x8.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

histogram.asm/  1066929161  0     0     0       34731     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.11    Sun Sep 29 03:31:25 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_histogram                                                       *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       01-May-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_histogram                                                  *
*       (                                                                   *
*           unsigned char * in_data,  // input data to IMG_histogram   //   *
*           int n,                    // number of points              //   *
*           int accumulate,           // sign of accumulation (+1/-1)  //   *
*           unsigned short * t_hist,  // temporary IMG_histogram buffer //  *
*           unsigned short * hist     // final IMG_histogram output    //   *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This code takes a IMG_histogram of an array of n, 8 bit inputs.  It *
*       returns the IMG_histogram of 256 bins at 16 bit precision.  It can  *
*       either add or subtract to an existing IMG_histogram, using the      *
*       'accumulate' control.                                               *
*                                                                           *
*       It requires some temporary storage for 4 temporary histograms,      *
*       which are later summed together.                                    *
*                                                                           *
*     C CODE                                                                *
*         void IMG_histogram                                                *
*         (                                                                 *
*             unsigned char * in_data,  // input data to IMG_histogram   // *
*             int n,                    // number of points              // *
*             int accumulate,           // sign of accumulation (+1/-1)  // *
*             unsigned short * t_hist,  // temporary IMG_histogram buffer // *
*             unsigned short * hist     // final IMG_histogram output    // *
*         )                                                                 *
*         {                                                                 *
*            int pixel, j;                                                  *
*            for (j = 0; j < n; j++)                                        *
*            {                                                              *
*               pixel = (int) in_data[j];                                   *
*               hist[data] += accumulate;                                   *
*            }                                                              *
*         }                                                                 *
*                                                                           *
*         The above C code is a general implementation without              *
*         restrictions.  The assembly code may have some restrictions, as   *
*         noted below.                                                      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       It is assumed that the temporary array of data, t_hist is           *
*       initialised to zero.                                                *
*                                                                           *
*       The input array of in_data data must be aligned to a 4 byte         *
*       boundary and n must be a multiple of 8.                             *
*                                                                           *
*       The maximum number of pixels that can be profiled in each bin       *
*       is 65535 in the main IMG_histogram and the maximum n is 262143.     *
*                                                                           *
*   TECHNIQUES                                                              *
*       This code operates on four interleaved IMG_histogram bins.  The     *
*       loop is divided into two halves.  The even half operates on         *
*       even words full of pixels and the odd half operates on odd          *
*       words.  Both halves operate on the same 4 IMG_histogram bins.  This *
*       introduces a memory dependency which ordinarily would degrade       *
*       performance.  To break the memory depenencies, the two halves       *
*       forward their results to each other.  Exact memory access           *
*       ordering obviates the need to predicate stores The algorithm is     *
*       ordered as follows:                                                 *
*                                                                           *
*       1.  Load from IMG_histogram for even half                           *
*                                                                           *
*       2.  Store odd_bin to IMG_histogram for odd half (previous itn.)     *
*                                                                           *
*       3.  if data_even == previous data_odd increment even_bin by 2       *
*           else increment even_bin by 1, forward to odd                    *
*                                                                           *
*       4.  Load from IMG_histogram for odd half (current itn.)             *
*                                                                           *
*       5.  Store even_bin to IMG_histogram for even half                   *
*                                                                           *
*       6.  if data_odd == previous data_even increment odd_bin by 2        *
*       else increment odd_bin by 1, forward to even                        *
*                                                                           *
*       7.  goto 1.                                                         *
*                                                                           *
*       With this particular ordering, forwarding is necessary between      *
*       even/odd halves when pixels in adjacent halves need to be           *
*       placed in the same bin.  The store is never predicated and          *
*       occurs speculatively as it will be overwritten by the next          *
*       value containing the extra forwarded value.                         *
*                                                                           *
*       The four histograms are interleaved with each bin spaced four       *
*       half-words apart and each IMG_histogram starting in a different     *
*       memory bank.  This allows the four IMG_histogram accesses to        *
*       proceed in any order without worrying about bank conflicts.         *
*       The diagram below illustrates this: (addresses are halfword         *
*       offsets)                                                            *
*                                                                           *
*              0       1       2       3       4       5       6   ...      *
*          | hst 0 | hst 1 | hst 2 | hst 3 | hst 0 | hst 1 | ...   ...      *
*          | bin 0 | bin 0 | bin 0 | bin 0 | bin 1 | bin 1 | ...   ...      *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts should occur in this code in the optimized        *
*       forms of hand assembly and serial assembly.                         *
*                                                                           *
*   NOTE                                                                    *
*       The code is LITTLE_ENDIAN and is Interrupt tolerant.                *
*       Interrupts are disabled during execution.                           *
*                                                                           *
*       With small modification this code can be used without the           *
*       summing stage.  The sparse IMG_histogram can be accumulated into    *
*       and the final summing loop left until the end of a series of        *
*       histograms.                                                         *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 9/8 * n + 560                                              *
*                                                                           *
*       e.g.  n = 1024, cycles = 1712                                       *
*       e.g.  n = 512,  cycles = 1136                                       *
*                                                                           *
*   CODESIZE                                                                *
*       832 bytes                                                           *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
                .sect ".data:copyright_h"
        .sect ".text:_histogram"
        .global _IMG_histogram
_IMG_histogram: 
*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A12,        A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A6,         A_accumulate; add or sub main IMG_histogram
        .asg            A8,         A_hist      ; main IMG_histogram 256 bins
        .asg            B4,         B_n         ; number of inputs
        .asg            B6,         B_t_hist    ; sparse IMG_histogram 1024 bins
        .asg            A4,         A_img       ; even image pixels
        .asg            B12,        B_img       ; odd image pixels
        .asg            A2,         A_i         ; loop count
        .asg            A14,        A_hst0      ; sub IMG_histogram 0
        .asg            A0,         A_hst1      ; sub IMG_histogram 1
        .asg            B14,        B_hst2      ; sub IMG_histogram 2
        .asg            B11,        B_hst3      ; sub IMG_histogram 3
        .asg            A5,         A_bc0o      ; odd bin copy 0
        .asg            A1,         A_bc1o      ; odd bin copy 1
        .asg            B8,         B_bc2o      ; odd bin copy 2
        .asg            B2,         B_bc3o      ; odd bin copy 3
        .asg            A3,         A_ha0o      ; hist after accumulation
        .asg            A8,         A_ha1o      ; hist after accumulation
        .asg            B0,         B_ha2o      ; hist after accumulation
        .asg            B1,         B_ha3o      ; hist after accumulation
        .asg            A11,        A_pix       ; even 4 pixels
        .asg            A11,        A_px0e      ; even pixel 0
        .asg            A11,        A_bn0e      ; index into hst 0
        .asg            A13,        A_px1e      ; even pixel 1
        .asg            A13,        A_bn1e      ; index into hst 1
        .asg            A6,         A_px2e      ; even pixel 2
        .asg            B2,         B_bn2e      ; index into hst 2
        .asg            B3,         B_px3e      ; even pixel 3
        .asg            B5,         B_bn3e      ; index into hst 3
        .asg            A7,         A_eq0e      ; forward bin 0
        .asg            A6,         A_eq1e      ; forward bin 1
        .asg            B7,         B_eq2e      ; forward bin 2
        .asg            B3,         B_eq3e      ; forward bin 3
        .asg            A13,        A_hs0e      ; bin data 0
        .asg            A1,         A_hs1e      ; bin data 1
        .asg            B6,         B_hs2e      ; bin data 2
        .asg            B9,         B_hs3e      ; bin data 3
        .asg            A5,         A_hf0e      ; fordwarded bin 0
        .asg            A3,         A_hf1e      ; fordwarded bin 1
        .asg            B7,         B_hf2e      ; fordwarded bin 2
        .asg            B3,         B_hf3e      ; fordwarded bin 3
        .asg            A11,        A_ha0e      ; hist after accumulation
        .asg            A3,         A_ha1e      ; hist after accumulation
        .asg            B0,         B_ha2e      ; hist after accumulation
        .asg            B5,         B_ha3e      ; hist after accumulation
        .asg            A12,        A_bc0e      ; copy of even bin 0
        .asg            A9,         A_bc1e      ; copy of even bin 1
        .asg            B13,        B_bc2e      ; copy of even bin 2
        .asg            B15,        B_bc3e      ; copy of even bin 3
        .asg            B10,        B_pix       ; odd 4 pixels
        .asg            B4,         B_px0o      ; extracted 0 pixel
        .asg            A5,         A_bn0o      ; index into hst0
        .asg            B4,         B_px1o      ; extracted 1 pixel
        .asg            A8,         A_bn1o      ; index into hst1
        .asg            B6,         B_px2o      ; extracted 2 pixel
        .asg            B1,         B_bn2o      ; index into hst2
        .asg            B3,         B_px3o      ; extracted 3 pixel
        .asg            B5,         B_bn3o      ; index into hst3
        .asg            A3,         A_eq0o      ; forward bin 0
        .asg            A10,        A_eq1o      ; forward bin 1
        .asg            B9,         B_eq2o      ; forward bin 2
        .asg            B6,         B_eq3o      ; forward bin 3
        .asg            A13,        A_hs0o      ; bin data 0
        .asg            A6,         A_hs1o      ; bin data 1
        .asg            B7,         B_hs2o      ; bin data 2
        .asg            B4,         B_hs3o      ; bin data 3
        .asg            A3,         A_hf0o      ; forwarded bin value 0
        .asg            A6,         A_hf1o      ; forwarded bin value 1
        .asg            B9,         B_hf2o      ; forwarded bin value 2
        .asg            B3,         B_hf3o      ; forwarded bin value 3
*==============================================================================*
        STW     .D2T1   A15,        *B_SP--[16]    ; Reserve stack, Save A15

        MV      .S1X    B_SP,       A_SP           ; Twin Stack Pointer

        STW     .D1T1   A14,        *+A_SP[12]     ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]     ; Save B14
||      MVC     .S2     CSR,        B_csr          ; Capture CSR's state

        STW     .D1T1   A13,        *+A_SP[10]     ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]     ; Save B13
||      AND     .L2     B_csr,  -2, B_no_gie       ; Clear GIE
;-
        STW     .D1T1   A12,        *+A_SP[ 8]     ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]     ; Save B12

        STW     .D1T1   A11,        *+A_SP[ 6]     ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]     ; Save B11
||      MV      .L1X    B_csr,      A_csr          ; Partitioning MV

        STW     .D1T1   A10,        *+A_SP[ 4]     ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]     ; Save B10
||      ADD     .S2X    A_img,      4,      B_img  ;
;-

; ============================ PIPE LOOP PROLOG ==============================
        LDW     .D2T2   *B_img++[2],        B_pix  ;
||      LDW     .D1T1   *A_img++[2],        A_pix  ;
||      ADD     .L2     B_t_hist,   6,      B_hst3 ;
||      ADD     .S1X    B_t_hist,   2,      A_hst1 ;
||      MVC     .S2     B_no_gie,   CSR            ; Disable interrupts

; ===== Interrupts masked here =====
        STW     .D1T1   A_csr,      *+A_SP[ 2]     ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]     ; Remember return address
||      MV      .S1X    B_t_hist,   A_hst0         ;
;-
        LDH     .D1T1   *A_hst0[1],         A_ha0o ;Store odd hist0
||      ADD     .L2     B_t_hist,   4,      B_hst2 ;

        MVK     .S1     1,          A_bc0o
||      STW     .D1T1   A_accumulate, *+A_SP[13]

        MV      .L1X    B_n,        A_i            ;
||      STW     .D1T1   A_hist,       *+A_SP[14]

        EXTU    .S1     A_pix,      16, 24, A_px1e ;] Extract pixel 1
||      SHRU    .S2X    A_pix,      24,     B_px3e ;] Extract pixel 3
;-
        EXTU    .S1     A_pix,      8,  24, A_px2e ;] Extract pixel 2
||      SHRU    .S2     B_pix,      24,     B_px3o ;] Extract pixel 3
||      MPY     .M2     4,          B_px3e, B_bn3e ;] Set offset into hist3

        EXTU    .S2     B_pix,      16, 24, B_px1o ;] Extract pixel 1
||      MPY     .M2     4,          B_px3o, B_bn3o ;] Set offset into hist3
||      B       .S1     LOOP7 + 4
||      ZERO    .L2     B_eq3e                     ;] Odd->Even fwd comp 3
||      MPY     .M1     4,          A_px1e, A_bn1e ;] Set offset into hist1
;-
        EXTU    .S1     A_pix,      24, 24, A_px0e ;] Extract pixel 0
||      MPY     .M2     1,          B_bn3e, B_bc3e ;] copy of bin 3 (l2l)
||      LDH     .D2T2   *B_hst3[B_bn3e],    B_hs3e ;]
||      B       .S2     LOOP8 + 4
;-
        MPY     .M2X    4,          A_px2e, B_bn2e ;] Set offset into hist2
||      LDW     .D2T2   *B_img++[2],        B_pix  ;]
||      LDW     .D1T1   *A_img++[2],        A_pix  ;]
||      EXTU    .S2     B_pix,      8,  24, B_px2o ;] Extract pixel 2
||      B       .S1     LOOP_H
;-
        MPY     .M1     4,          A_px0e, A_bn0e ;] Set offset into hist0
||      MPY     .M2     4,          B_px2o, B_bn2o ;] Set offset into hist2
||      LDH     .D1T1   *A_hst1[A_bn1e],    A_hs1e ;]

        MPY     .M1     1,          A_bn1e, A_bc1e ;] copy of bin 1 (l2l)
||      CMPEQ   .L2     B_bn3o,     B_bc3e, B_eq3o ;] Even->Odd fwd comp 3
||      MPY     .M2     1,          B_bn2e, B_bc2e ;] copy of bin 2 (l2l)
||      LDH     .D2T2   *B_hst3[B_bn3o],    B_hs3o ;]
||      ZERO    .L1     A_eq0e:A_eq1e              ;] Odd->Even fwd comp 1
;-
        EXTU    .S2     B_pix,      24, 24, B_px0o ;] Extract pixel 0
||      ZERO    .L2     B_eq2e                     ;] Odd->Even fwd comp 2
||      MPY     .M1X    4,          B_px1o, A_bn1o ;] Set offset into hist1
; ============================ PIPE LOOP KERNEL ==============================
LOOP_H:
        ADD     .L1     A_hs1e,     A_eq1e, A_hf1e ;] forwarding for hist1
||      STH     .D1T1   A_ha0o,     *A_hst0[A_bc0o];]
||      LDH     .D2T2   *B_hst2[B_bn2o],    B_hs2o ;]
||      MPY     .M1     1,          A_bn1o, A_bc1o ;] copy of bin 1 (l2l)
||      EXTU    .S1     A_pix,      8,  24, A_px2e ;] Extract pixel 2
||      SHRU    .S2     B_pix,      24,     B_px3o ;] Extract pixel 3
||      MPY     .M2     4,          B_px3e, B_bn3e ;] Set offset into hist3

        ADD     .L1     A_hf1e,     1,      A_ha1e ;] Accumulate for hist1
||      LDH     .D1T1   *A_hst0[A_bn0o],    A_hs0o ;]
||      ADD     .L2     B_hs3o,     B_eq3o, B_hf3o ;] forwarding for hist3
||[ A_i]SUB     .S1     A_i,        8,      A_i    ;] Loop control.
||      STH     .D2T2   B_ha3e,     *B_hst3[B_bc3e];]
||      EXTU    .S2     B_pix,      16, 24, B_px1o ;] Extract pixel 1
||      MPY     .M2     4,          B_px3o, B_bn3o ;] Set offset into hist3

        CMPEQ   .L1     A_bn0o,     A_bc0e, A_eq0o ;] Even->Odd fwd comp 0
||      STH     .D1T1   A_ha1e,     *A_hst1[A_bc1e];]
||      ADD     .S2     B_hf3o,     1,      B_ha3o ;] Accumulate for hist3
||[A_i] EXTU    .S1     A_pix,      24, 24, A_px0e ;] Extract pixel 0
||[A_i] MPY     .M2     1,          B_bn3e, B_bc3e ;] copy of bin 3 (l2l)
||[A_i] CMPEQ   .L2     B_bn3e,     B_bc3o, B_eq3e ;] Odd->Even fwd comp 3
||[A_i] MPY     .M1     4,          A_px1e, A_bn1e ;] Set offset into hist1
||[A_i] LDH     .D2T2   *B_hst3[B_bn3e],    B_hs3e ;]

  [ A_i]B       .S1     LOOP_H                     ;]
||      MPY     .M1     1,          A_bn0o, A_bc0o ;] copy of bin 0 (l2l)
||      ADD     .L1     A_hs0e,     A_eq0e, A_hf0e ;] forwarding for hist0
||      ADD     .L2     B_hs2e,     B_eq2e, B_hf2e ;] forwarding for hist2
||[A_i] MPY     .M2X    4,          A_px2e, B_bn2e ;] Set offset into hist2
||[A_i] EXTU    .S2     B_pix,      8,  24, B_px2o ;] Extract pixel 2
||[A_i] LDW     .D2T2   *B_img++[2],        B_pix  ;]
||[A_i] LDW     .D1T1   *A_img++[2],        A_pix  ;]

        ADD     .L1     A_hf0e,     1,      A_ha0e ;] Accumulate for hist0
||      ADD     .S1     A_hs1o,     A_eq1o, A_hf1o ;] forwarding for hist1
||      ADD     .S2     B_hf2e,     1,      B_ha2e ;] Accumulate for hist2
||[A_i] MPY     .M1     4,          A_px0e, A_bn0e ;] Set offset into hist0
||[A_i] MPY     .M2     4,          B_px2o, B_bn2o ;] Set offset into hist2
||[A_i] CMPEQ   .L2     B_bn3o,     B_bc3e, B_eq3o ;] Even->Odd fwd comp 3
||[A_i] LDH     .D1T1   *A_hst1[A_bn1e],    A_hs1e ;]
||[A_i] STH     .D2T2   B_ha3o,     *B_hst3[B_bc3o];]

        STH     .D1T1   A_ha0e,     *A_hst0[A_bc0e];]
||      ADD     .S1     A_hf1o,     1,      A_ha1o ;] Accumulate for hist1
||      ADD     .S2     B_hs2o,     B_eq2o, B_hf2o ;] forwarding for hist2
||[A_i] MPY     .M1     1,          A_bn1e, A_bc1e ;] copy of bin 1 (l2l)
||[A_i] CMPEQ   .L1     A_bn1e,     A_bc1o, A_eq1e ;] Odd->Even fwd comp 1
||[A_i] CMPEQ   .L2     B_bn2e,     B_bc2o, B_eq2e ;] Odd->Even fwd comp 2
||[A_i] MPY     .M2     1,          B_bn2e, B_bc2e ;] copy of bin 2 (l2l)
||[A_i] LDH     .D2T2   *B_hst3[B_bn3o],    B_hs3o ;]

        ADD     .S1     A_hs0o,     A_eq0o, A_hf0o ;] forwarding for hist0
||      ADD     .L2     B_hf2o,     1,      B_ha2o ;] Accumulate for hist2
||      STH     .D2T2   B_ha2e,     *B_hst2[B_bc2e];]
||[A_i] CMPEQ   .L1     A_bn0e,     A_bc0o, A_eq0e ;] Odd->Even fwd comp 0
||[A_i] EXTU    .S2     B_pix,      24, 24, B_px0o ;] Extract pixel 0
||[A_i] MPY     .M1X    4,          B_px1o, A_bn1o ;] Set offset into hist1
||[A_i] STH     .D1T1   A_ha1o,     *A_hst1[A_bc1o];]
LOOP7:
        ADD     .S1     A_hf0o,     1,      A_ha0o ;] Accumulate for hist0
||[A_i] MPY     .M1     1,          A_bn0e, A_bc0e ;] copy of bin 0 (l2l)
||[A_i] LDH     .D1T1   *A_hst0[A_bn0e],    A_hs0e ;]
||[A_i] CMPEQ   .L2     B_bn2o,     B_bc2e, B_eq2o ;] Even->Odd fwd comp 2
||[A_i] ADD     .S2     B_hs3e,     B_eq3e, B_hf3e ;] forwarding for hist3
||[A_i] LDH     .D2T2   *B_hst2[B_bn2e],    B_hs2e ;]
||[A_i] MPY     .M2     1,          B_bn3o, B_bc3o ;] copy of bin 3 (l2l)
LOOP8:
  [A_i] STH     .D2T2   B_ha2o,     *B_hst2[B_bc2o];]
||[A_i] MPY     .M2     1,          B_bn2o, B_bc2o ;] copy of bin 2 (l2l)
||[A_i] CMPEQ   .L1     A_bn1o,     A_bc1e, A_eq1o ;] Even->Odd fwd comp 1
||[A_i] MPY     .M1X    4,          B_px0o, A_bn0o ;]Set offset into hist0
||[A_i] LDH     .D1T1   *A_hst1[A_bn1o],    A_hs1o ;]
||[A_i] ADD     .L2     B_hf3e,     1,      B_ha3e ;] Accumulate for hist3
||[A_i] EXTU    .S1     A_pix,      16, 24, A_px1e ;] Extract pixel 1
||[A_i] SHRU    .S2X    A_pix,      24,     B_px3e ;] Extract pixel 3
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A0,         A_bin54        ; data 4,5
        .asg            A1,         A_i            ; loop count
        .asg            A3,         A_bin          ; sum of bins
        .asg            A3,         A_bin10        ; data 0,1
        .asg            A3,         A_bin_ba       ; sum of 0,2 & 1,3
        .asg            A4,         A_hist_in_e    ; even 2 bins
        .asg            A5,         A_hist_e_r     ; main even read bins
        .asg            A6,         A_hist_e_w     ; main even write bins
        .asg            A7,         A_main_bin     ; main hist bin
        .asg            A7,         A_new_bin      ; updated main bin
        .asg            A8,         A_bin_b        ; sum or 0 to 3
        .asg            A8,         A_s_bin        ; scaled sub bin * 1,-1
        .asg            A9,         A_accumulate   ; add or subtract
        .asg            A15,        A_SP           ; Stack pointer, A datapath
        .asg            B0,         B_new_bin      ; new odd main bin
        .asg            B1,         B_csr          ; CSR value to restore
        .asg            B2,         B_r            ; prolog collapse
        .asg            B3,         B_ret          ; Return address
        .asg            B4,         B_bin          ; sum of bins
        .asg            B4,         B_bin76        ; data 6,7
        .asg            B4,         B_bin_ba       ; partial sum of bins
        .asg            B5,         B_hist_in_o    ; odd 2 bins
        .asg            B6,         B_bin_b        ; partial sum of bins
        .asg            B6,         B_main_bin     ; odd main bin
        .asg            B7,         B_bin32        ; data 2,3
        .asg            B7,         B_s_bin        ; scaled bin delta
        .asg            B8,         B_hist_o_r     ; mian odd read bins
        .asg            B9,         B_hist_o_w     ; mian odd write bins
        .asg            B15,        B_SP           ; Stack pointer, B datapath
; ============================ PIPE LOOP PROLOG ==============================
        LDW     .D1T1   *+A_SP[14], A_hist_e_r
||      MV      .S2X    A_SP,       B_SP           ; Twin Stack Pointer

        MVK     .S1     127,         A_i
||      STH     .D2T2   B_ha3o,     *B_hst3[B_bc3o]; Store odd hist3
||      STH     .D1T1   A_ha1o,     *A_hst1[A_bc1o]; Store odd hist1

        MV      .L1     A_hst0,     A_hist_in_e
||      STH     .D2T2   B_ha2o,     *B_hst2[B_bc2o]; Store odd hist2
||      STH     .D1T1   A_ha0o,     *A_hst0[A_bc0o]; Store odd hist0
;-
        LDW     .D1T2   *+A_SP[ 2], B_csr          ; Get CSR's value
||      LDW     .D2T1   *+B_SP[13], A_accumulate

        LDW     .D1T2   *+A_SP[ 3], B10            ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10            ; Restore A10
||      ADD     .L2X    A_hst0,     4, B_hist_in_o

        LDW     .D1T2   *+A_SP[ 5], B11            ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11            ; Restore A11
||      ADD     .S2X    A_hist_e_r, 2, B_hist_o_r
;-
        B       .S1     LOOP_S1 + 16               ;]
||      LDW     .D1T2   *+A_SP[11], B14            ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14            ; Restore A14

        LDW     .D1T2   *+A_SP[ 7], B12            ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12            ; Restore A12
||      B       .S2     LOOP_S2 + 8                ;]

        LDW     .D1T1   *A_hist_in_e++[2], A_bin10 ;] load 4 bins for bin 2*i
||      LDW     .D2T2   *B_hist_in_o++[2], B_bin32 ;]
;-

        LDW     .D1T2   *+A_SP[ 9], B13            ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13            ; Restore A13
||      B       .S1     LOOP_S  + 4                ;]

        LDW     .D1T1   *A_hist_in_e++[2], A_bin54 ;load 4 bins for bin 2*i+1
||      LDW     .D2T2   *B_hist_in_o++[2], B_bin76 ;]

        LDW     .D1T2   *+A_SP[ 1], B_ret          ; Get return address
||      LDW     .D2T1   *++B_SP[16],A15            ; Restore A15
||      B       .S2     LOOP_S2 + 4                ;]
;-
; ============================ PIPE LOOP KERNEL ==============================
LOOP_S:
        STH     .D1T1   A_new_bin, *-A_hist_e_r[4] ;]add to sub bins,storeback
||      LDH     .D2T2  *B_hist_o_r++[2], B_main_bin;] load even main bin 2*i+1
||      ADD     .L1     A_bin_ba,   A_bin_b, A_bin ;]
||      ADD2    .S2X    B_bin76, A_bin54, B_bin_ba ;] add 4 sub-bins together
LOOP_S1:
        ADD     .L2     B_main_bin, B_s_bin, B_new_bin  ;]
||[ A_i]SUB     .S1     A_i,        1,       A_i   ;]
||      MPY     .M1     A_accumulate, A_bin, A_s_bin;] scale sub bins with 1,-1
||      SHRU    .S2     B_bin_ba,   16,      B_bin_b;]
||[ A_i]LDW     .D1T1   *A_hist_in_e++[2],   A_bin10;] load 4 bins for bin 2*i
||[ A_i]LDW     .D2T2   *B_hist_in_o++[2],   B_bin32;]
||      MPY     .M2X    A_i,        1,       B_r
LOOP_S2:
        STH     .D2T2   B_new_bin,  *-B_hist_o_r[4] ;]addto sub bins,store back
||      ADD     .L2     B_bin_ba,   B_bin_b, B_bin  ;]
||      LDH     .D1T1   *A_hist_e_r++[2],  A_main_bin;ld even mainhist bin 2*i
||[ A_i]B       .S2     LOOP_S                      ;]
||      ADD2    .S1X    A_bin10,  B_bin32, A_bin_ba ;] add 4 sub-bins together
LOOP_S3:
        ADD     .L1     A_main_bin, A_s_bin, A_new_bin;]
||      MPY     .M2X    A_accumulate, B_bin, B_s_bin;]
||[ A_i]LDW     .D1T1   *A_hist_in_e++[2],   A_bin54;load 4 bins for bin 2*i+1
||[ A_i]LDW     .D2T2   *B_hist_in_o++[2],   B_bin76;]
||      SHRU    .S1     A_bin_ba,   16,      A_bin_b;]
||[!B_r]RET     .S2     B_ret
*==============================================================================*
        STH     .D1T1   A_new_bin,  *-A_hist_e_r[4]
        ADD     .L2     B_main_bin, B_s_bin, B_new_bin  ;]
        STH     .D2T2   B_new_bin,  *-B_hist_o_r[2]
        NOP
        MVC     .S2     B_csr,      CSR         ; Restore CSR

* ========================================================================= *
*   End of file:  img_histogram.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

idct_8x8.asm/   1066929161  0     0     0       76113     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.13    Thu Nov 14 21:39:50 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_idct_8x8 -- IEEE-1180 Compliant IDCT, Little Endian.            *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       27-Jul-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           void IMG_idct_8x8(short idct_data[], unsigned num_idcts)        *
*                                                                           *
*       The IMG_idct_8x8 routine accepts a list of 8x8 DCT coeffient blocks *
*       and performs IDCTs on each.  The array should be aligned to a       *
*       32-bit boundary, and be laid out equivalently to the C array        *
*       idct_data[num_idcts+1][8][8].                                       *
*                                                                           *
*       The routine requires one 8x8-block's worth of extra storage at      *
*       the end of the list of DCT blocks.  The caller must provide room    *
*       for 'num_idcts + 1' blocks of data in the idct_data[] array.        *
*       The contents of the extra block are ignored and overwritten         *
*       with intermediate results by IMG_idct_8x8().                        *
*                                                                           *
*       This code requires '62 + 168 * num_idcts' cycles to process         *
*       'num_idcts' blocks, including 6 cycles of function call overhead.   *
*       When 'num_idcts' is zero, the function takes an early exit and      *
*       runs for only 35 cycles (again, including overhead).                *
*                                                                           *
*   DESCRIPTION                                                             *
*       The IMG_idct_8x8() algorithm performs an IEEE-1180 compliant IDCT,  *
*       complete with rounding and saturation to signed 9-bit quantities.   *
*       The input coefficients are assumed to be signed 12-bit cosine       *
*       terms.                                                              *
*                                                                           *
*       void IMG_idct_8x8(short *idct_data, unsigned num_dcts)              *
*       {                                                                   *
*         const short c1 = 0x0B19, c2 = 0x0A74, c3 = 0x0968;                *
*         const short c5 = 0x0649, c6 = 0x0454, c7 = 0x0235;                *
*         const int   c4_shift = 11;                                        *
*         const int   round1 = 256, round2 = 32768;                         *
*         const int   trunc1 = 9, trunc2 = 16;                              *
*         const short *i_ptr;                                               *
*         short       *o_ptr;                                               *
*         unsigned    i, j;                                                 *
*         short X0, X1, X2, X3, X4, X5, X6, X7;   /* Freq domain terms  */  *
*         int   P0, P1, p0, p1, r0, r1;           /* Even-half temp     */  *
*         int   g0, g1, h1, h0;                   /* Even-half result   */  *
*         int   g2, g3, h3, h2;                   /* Odd-half result    */  *
*         int   x0, x1, x2, x3, x4, x5, x6, x7;   /* Resulting samples  */  *
*         int   x0t,x1t,x2t,x3t,x4t,x5t,x6t,x7t;  /* Truncated result   */  *
*         int   x0s,x1s,x2s,x3s,x4s,x5s,x6s,x7s;  /* Saturated result   */  *
*                                                                           *
*         /* ---------------------------------------------------------- */  *
*         /*  Avoid running the code if we don't have any IDCTs to do.  */  *
*         /* ---------------------------------------------------------- */  *
*         if (!num_dcts) return;                                            *
*                                                                           *
*         /* ---------------------------------------------------------- */  *
*         /*  Set up pointers.                                          */  *
*         /* ---------------------------------------------------------- */  *
*         i_ptr = idct_data + num_dcts * 64 - 8;                            *
*         o_ptr = idct_data + num_dcts * 64 + 7;                            *
*                                                                           *
*         for (j = 0; j < num_dcts; j++)                                    *
*         {                                                                 *
*           /* -------------------------------------------------------- */  *
*           /*  Perform Horizontal 1-D IDCT on each 8x8 block.  Store   */  *
*           /*  out the results transposed.                             */  *
*           /* -------------------------------------------------------- */  *
*           for (i = 0; i < 8; i++)                                         *
*           {                                                               *
*               /* ---------------------------------------------------- */  *
*               /*  Load the freq-domain coefficients.                  */  *
*               /* ---------------------------------------------------- */  *
*               X0 = i_ptr[0];                                              *
*               X1 = i_ptr[1];                                              *
*               X2 = i_ptr[2];                                              *
*               X3 = i_ptr[3];                                              *
*               X4 = i_ptr[4];                                              *
*               X5 = i_ptr[5];                                              *
*               X6 = i_ptr[6];                                              *
*               X7 = i_ptr[7];                                              *
*                                                                           *
*               i_ptr -= 8;             /* decr pointer to next row     */  *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Even part of decomp.  Add rounding to DC term.      */  *
*               /* ---------------------------------------------------- */  *
*               P0 = (((int)X0) << c4_shift) + round1;                      *
*               P1 = (((int)X4) << c4_shift);                               *
*                                                                           *
*               p0 = P0 + P1;                                               *
*               p1 = P0 - P1;                                               *
*                                                                           *
*               r1 = X2*c6 - X6*c2;                                         *
*               r0 = X2*c2 + X6*c6;                                         *
*                                                                           *
*               g0 = p0 + r0;                                               *
*               g1 = p1 + r1;                                               *
*               h1 = p1 - r1;                                               *
*               h0 = p0 - r0;                                               *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Odd part of decomp.                                 */  *
*               /* ---------------------------------------------------- */  *
*               g2 = (X1*c7 - X3*c5) + (X5*c3 - X7*c1);                     *
*               g3 = (X1*c5 - X3*c1) + (X5*c7 + X7*c3);                     *
*               h3 = (X1*c3 - X3*c7) - (X5*c1 + X7*c5);                     *
*               h2 = (X1*c1 + X3*c3) + (X5*c5 + X7*c7);                     *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Final butterfly.                                    */  *
*               /* ---------------------------------------------------- */  *
*               x0 = g0 + h2;                                               *
*               x1 = g1 + h3;                                               *
*               x2 = h1 + g3;                                               *
*               x3 = h0 + g2;                                               *
*               x4 = h0 - g2;                                               *
*               x5 = h1 - g3;                                               *
*               x6 = g1 - h3;                                               *
*               x7 = g0 - h2;                                               *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Truncate to fit back into 16 bits.                  */  *
*               /* ---------------------------------------------------- */  *
*               x0t = x0 >> trunc1;                                         *
*               x1t = x1 >> trunc1;                                         *
*               x2t = x2 >> trunc1;                                         *
*               x3t = x3 >> trunc1;                                         *
*               x4t = x4 >> trunc1;                                         *
*               x5t = x5 >> trunc1;                                         *
*               x6t = x6 >> trunc1;                                         *
*               x7t = x7 >> trunc1;                                         *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Store the results transposed.                       */  *
*               /* ---------------------------------------------------- */  *
*               o_ptr[ 0] = x0t;                                            *
*               o_ptr[ 8] = x1t;                                            *
*               o_ptr[16] = x2t;                                            *
*               o_ptr[24] = x3t;                                            *
*               o_ptr[32] = x4t;                                            *
*               o_ptr[40] = x5t;                                            *
*               o_ptr[48] = x6t;                                            *
*               o_ptr[56] = x7t;                                            *
*                                                                           *
*               o_ptr--;                /* decrement ptr to next column */  *
*           }                                                               *
*                                                                           *
*           /* -------------------------------------------------------- */  *
*           /*  Update output pointer to point to next block.           */  *
*           /* -------------------------------------------------------- */  *
*                                                                           *
*           o_ptr = o_ptr + 8 - 64;                                         *
*         }                                                                 *
*                                                                           *
*         /* ---------------------------------------------------------- */  *
*         /*  Reset our pointers for the vertical pass.                 */  *
*         /* ---------------------------------------------------------- */  *
*         i_ptr = idct_data + 64;                                           *
*         o_ptr = idct_data;                                                *
*                                                                           *
*         for (j = 0; j < num_dcts; j++)                                    *
*         {                                                                 *
*           /* -------------------------------------------------------- */  *
*           /*  Perform Vertical 1-D IDCT on each 8x8 block.  Store     */  *
*           /*  out the results transposed.                             */  *
*           /* -------------------------------------------------------- */  *
*           for (i = 0; i < 8; i++)                                         *
*           {                                                               *
*               /* ---------------------------------------------------- */  *
*               /*  Load the freq-domain coefficients.                  */  *
*               /* ---------------------------------------------------- */  *
*               X0 = i_ptr[0];                                              *
*               X1 = i_ptr[1];                                              *
*               X2 = i_ptr[2];                                              *
*               X3 = i_ptr[3];                                              *
*               X4 = i_ptr[4];                                              *
*               X5 = i_ptr[5];                                              *
*               X6 = i_ptr[6];                                              *
*               X7 = i_ptr[7];                                              *
*               i_ptr += 8;             /* increment ptr to next row    */  *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Even part of decomp.  Add rounding term to DC.      */  *
*               /* ---------------------------------------------------- */  *
*               P0 = (((int)X0) << c4_shift) + round2; /* c4 is a shift */  *
*               P1 = (((int)X4) << c4_shift);          /* c4 is a shift */  *
*                                                                           *
*               p0 = P0 + P1;                                               *
*               p1 = P0 - P1;                                               *
*                                                                           *
*               r1 = X2*c6 - X6*c2;                                         *
*               r0 = X2*c2 + X6*c6;                                         *
*                                                                           *
*               g0 = p0 + r0;                                               *
*               g1 = p1 + r1;                                               *
*               h1 = p1 - r1;                                               *
*               h0 = p0 - r0;                                               *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Odd part of decomp.                                 */  *
*               /* ---------------------------------------------------- */  *
*               g2 = (X1*c7 - X3*c5) + (X5*c3 - X7*c1);                     *
*               g3 = (X1*c5 - X3*c1) + (X5*c7 + X7*c3);                     *
*               h3 = (X1*c3 - X3*c7) - (X5*c1 + X7*c5);                     *
*               h2 = (X1*c1 + X3*c3) + (X5*c5 + X7*c7);                     *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Final butterfly.                                    */  *
*               /* ---------------------------------------------------- */  *
*               x0 = g0 + h2;                                               *
*               x1 = g1 + h3;                                               *
*               x2 = h1 + g3;                                               *
*               x3 = h0 + g2;                                               *
*               x4 = h0 - g2;                                               *
*               x5 = h1 - g3;                                               *
*               x6 = g1 - h3;                                               *
*               x7 = g0 - h2;                                               *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Truncate and saturate final results.                */  *
*               /* ---------------------------------------------------- */  *
*               x0t = x0 >> trunc2;                                         *
*               x1t = x1 >> trunc2;                                         *
*               x2t = x2 >> trunc2;                                         *
*               x3t = x3 >> trunc2;                                         *
*               x4t = x4 >> trunc2;                                         *
*               x5t = x5 >> trunc2;                                         *
*               x6t = x6 >> trunc2;                                         *
*               x7t = x7 >> trunc2;                                         *
*                                                                           *
*               x0s = x0t < -256 ? -256 : x0t > 255 ? 255 : x0t;            *
*               x1s = x1t < -256 ? -256 : x1t > 255 ? 255 : x1t;            *
*               x2s = x2t < -256 ? -256 : x2t > 255 ? 255 : x2t;            *
*               x3s = x3t < -256 ? -256 : x3t > 255 ? 255 : x3t;            *
*               x4s = x4t < -256 ? -256 : x4t > 255 ? 255 : x4t;            *
*               x5s = x5t < -256 ? -256 : x5t > 255 ? 255 : x5t;            *
*               x6s = x6t < -256 ? -256 : x6t > 255 ? 255 : x6t;            *
*               x7s = x7t < -256 ? -256 : x7t > 255 ? 255 : x7t;            *
*                                                                           *
*               /* ---------------------------------------------------- */  *
*               /*  Store the results transposed in the result area.    */  *
*               /* ---------------------------------------------------- */  *
*               o_ptr[ 0] = x0s;                                            *
*               o_ptr[ 8] = x1s;                                            *
*               o_ptr[16] = x2s;                                            *
*               o_ptr[24] = x3s;                                            *
*               o_ptr[32] = x4s;                                            *
*               o_ptr[40] = x5s;                                            *
*               o_ptr[48] = x6s;                                            *
*               o_ptr[56] = x7s;                                            *
*                                                                           *
*               o_ptr++;                /* increment ptr to next column */  *
*           }                                                               *
*           /* -------------------------------------------------------- */  *
*           /*  Update output pointer to point to next block.           */  *
*           /* -------------------------------------------------------- */  *
*           o_ptr = o_ptr - 8 + 64;                                         *
*         }                                                                 *
*       }                                                                   *
*                                                                           *
*                                                                           *
*       Note:  This code guarantees correct operation, even in the case     *
*       that 'num_idcts == 0'.  In that case, the function runs for only    *
*       35 cycles (counting 6 cycles of function-call overhead), due to     *
*       early-exit code.  The early-exit case performs no accesses to the   *
*       idct_data[] array.                                                  *
*                                                                           *
*   TECHNIQUES                                                              *
*       All levels of looping are collapsed into single loops which are     *
*       pipelined.  The outer loop focuses on 8-pt IDCTs, whereas the       *
*       inner loop controls the column-pointer to handle jumps between      *
*       IDCT blocks.                                                        *
*                                                                           *
*       For performance, portions of the code outside the loops have been   *
*       inter-scheduled with the prolog and epilog code of the loops.       *
*       Also, twin stack-pointers are used to accelerate stack accesses.    *
*       Finally, pointer values and cosine term registers are reused        *
*       between the horizontal and vertical loops to save the need for      *
*       messy pointer and constant reinitialization.                        *
*                                                                           *
*       To save codesize, prolog and epilog collapsing have been performed  *
*       to the extent that it does not impact performance.  Also, code      *
*       outside the loops has been scheduled to pack as tightly into        *
*       fetch packets as possible to avoid alignment padding NOPs.          *
*                                                                           *
*       The IDCTs cannot be performed completely in-place due to the        *
*       transpose that each pass performs.  In order to save data memory,   *
*       the horizontal pass works from the end of the array towards the     *
*       begining, writing its result one IDCT block later in memory,        *
*       thus performing the IDCT nearly-in-place.  The vertical pass        *
*       performs its IDCTs in the opposite direction, working from the      *
*       start of the array towards the end, writing the results in-place.   *
*       A nice side effect of this is that the pointer values at the        *
*       end of the horizontal loop are a fixed offset relative to their     *
*       required values for the vertical loop, regardless of the number     *
*       of IDCTs performed.  This makes the pointer reinitialization        *
*       exceptionally cheap.                                                *
*                                                                           *
*       Additional section-specific optimization notes are provided below.  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input array must be aligned on a word boundary, and one         *
*       extra block's worth of storage must be present after the list       *
*       of IDCT input blocks.                                               *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.  The code requires 16 words of stack       *
*       space to save Save-On-Entry (SOE) registers, CSR, IRP, and a        *
*       spill value.  For correct operation, the input array must be        *
*       aligned to a word boundary.                                         *
*                                                                           *
*       Bank usage on C6201:                                                *
*                                                                           *
*           Horiz loop accesses: 1 of 4 banks for 80% of cycles             *
*                                4 of 4 banks for 20% of cycles             *
*                                                                           *
*           Vert loop accesses:  1 of 4 banks for 73% of cycles             *
*                                4 of 4 banks for 18% of cycles             *
*                                0 of 4 banks for  9% of cycles             *
*                                                                           *
*       This code issues speculative loads beyond both ends of the          *
*       input array.  This is in addition to the 1 block of scratch         *
*       storage that the code requires.  Speculative loads may read         *
*       up to 32 bytes before and 48 bytes after the input buffer.          *
*       The caller must ensure that the input is placed in memory so        *
*       that these speculative accesses do not cause incorrect program      *
*       behavior.                                                           *
*                                                                           *
*   NOTES                                                                   *
*       This is a LITTLE ENDIAN implementation.                             *
*                                                                           *
*       This code masks interrupts for nearly its entire duration.          *
*       Interrupts are locked out for '53 + 168 * num_idcts' cycles.  As    *
*       a result, the code is interrupt-tolerant, but not interruptible.    *
*                                                                           *
*       The cosine terms have all been scaled by sqrt(2), so that the       *
*       "c4" term is basically an even power of 2.                          *
*                                                                           *
*       The precision of the final results can be changed by modifying      *
*       the constants at the top of the code and reassembling.  Usually,    *
*       modifying the final-shift constants in the "Symbolic Constants"     *
*       section is sufficient.                                              *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 62 + 168 * num_idcts  (or 35 cycles if num_idcts == 0)     *
*                                                                           *
*       For num_idcts == 6,   cycles = 1070.                                *
*       For num_idcts == 24,  cycles = 4094.                                *
*                                                                           *
*   CODESIZE                                                                *
*       1344 bytes                                                          *
*                                                                           *
*   SOURCE                                                                  *
*       Even-Odd Decomposition IDCT.                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_idct_8x8"
        .global _IMG_idct_8x8
_IMG_idct_8x8:
; ============================ SYMBOLIC CONSTANTS ============================
        .asg            0x0B19,     cst_c1  ; Cosine term c1
        .asg            0x0A74,     cst_c2  ; Cosine term c2
        .asg            0x0968,     cst_c3  ; Cosine term c3
        .asg            0x0800,     cst_c4  ; Cosine term c4
        .asg            0x0649,     cst_c5  ; Cosine term c5
        .asg            0x0454,     cst_c6  ; Cosine term c6
        .asg            0x0235,     cst_c7  ; Cosine term c7
        .asg            11,         q_pt    ; Q-point for calculations
        .asg            16,         kq_a    ; Extract const for c4 "mpy"
        .asg            16-q_pt,    kq_b    ; Extract const for c4 "mpy"
        .asg            9,          trunc1  ; Truncation after horizontal pass
        .asg            9,          results ; Final precision of results
        .asg            32-results, trunc2  ; Final truncation right-shift
        .asg            16-results, satl    ; Final saturation left-shift
; =============== SYMBOLIC REGISTER ASSIGNMENTS FOR HORIZ LOOP ===============
        .asg            B13,        B_c7c5  ; Cosine terms c7, c5   (packed)
        .asg            A13,        A_c7c5  ; Cosine terms c7, c5   (packed)
        .asg            B12,        B_c3c1  ; Cosine terms c3, c1   (packed)
        .asg            A12,        A_c3c1  ; Cosine terms c3, c1   (packed)
        .asg            B14,        B_c6c2  ; Cosine terms c6, c2   (packed)
        .asg            A14,        A_i_ptr ; Input pointer #1
        .asg            B15,        B_i_ptr ; Input pointer #2
        .asg            A11,        A_o_ptr ; Output pointer #1
        .asg            B11,        B_o_ptr ; Output pointer #2
        .asg            B2,         B_o     ; Outer loop counter
        .asg            A5,         A_X1X0  ; Incoming coefs X1, X0 (packed)
        .asg            A10,        A_X3X2  ; Incoming coefs X3, X2 (packed)
        .asg            B7,         B_X5X4  ; Incoming coefs X5, X4 (packed)
        .asg            B10,        B_X7X6  ; Incoming coefs X7, X6 (packed)
        .asg            A7,         A_X2c6  ; X2 * c6
        .asg            B0,         B_X6c2  ; X6 * c2
        .asg            A0,         A_X2c2  ; X2 * c2
        .asg            B1,         B_X6c6  ; X6 * c6
        .asg            A6,         A_P0    ; Node P0 in signal flow graph
        .asg            B8,         B_P1    ; Node P1 in signal flow graph
        .asg            A8,         A_p0    ; Node p0 in signal flow graph
        .asg            A0,         A_p1    ; Node p1 in signal flow graph
        .asg            B0,         B_r1    ; Node r1 in signal flow graph
        .asg            B4,         B_r0    ; Node r0 in signal flow graph
        .asg            B7,         B_g0    ; Node g0 in signal flow graph
        .asg            B3,         B_g1    ; Node g1 in signal flow graph
        .asg            A15,        A_h1    ; Node h1 in signal flow graph
        .asg            A15,        A_h0    ; Node h0 in signal flow graph
        .asg            A3,         A_X1c1  ; X1 * c1
        .asg            A0,         A_X1c3  ; X1 * c3
        .asg            A3,         A_X1c5  ; X1 * c5
        .asg            A9,         A_X1c7  ; X1 * c7
        .asg            A9,         A_X3c1  ; X3 * c1
        .asg            A0,         A_X3c3  ; X3 * c3
        .asg            A5,         A_X3c5  ; X3 * c5
        .asg            A5,         A_X3c7  ; X3 * c7
        .asg            B0,         B_X5c1  ; X5 * c1
        .asg            B4,         B_X5c3  ; X5 * c3
        .asg            B3,         B_X5c5  ; X5 * c5
        .asg            B6,         B_X5c7  ; X5 * c7
        .asg            B0,         B_X7c1  ; X7 * c1
        .asg            B3,         B_X7c3  ; X7 * c3
        .asg            B9,         B_X7c5  ; X7 * c5
        .asg            B1,         B_X7c7  ; X7 * c7
        .asg            A7,         A_g2a   ; X1 * c7 - X3 * c5
        .asg            B8,         B_g2b   ; X5 * c3 - X7 * c1
        .asg            A6,         A_g2    ; Node g2 in signal flow graph
        .asg            A3,         A_g3a   ; X1 * c5 - X3 * c1
        .asg            B6,         B_g3b   ; X5 * c7 + X7 * c3
        .asg            A4,         A_g3    ; Node g3 in signal flow graph
        .asg            A6,         A_h3a   ; X1 * c3 - X2 * c7
        .asg            B7,         B_h3b   ; X5 * c1 + X7 * c5
        .asg            B5,         B_h3n   ; Node h3, negated.
        .asg            A0,         A_h2a   ; X1 * c1 + X3 * c3
        .asg            B3,         B_h2b   ; X5 * c5 + X7 * c7
        .asg            B1,         B_h2    ; Node h2 in signal flow graph
        .asg            B4,         B_x0    ; Output x0, pre-truncation
        .asg            B0,         B_x1    ; Output x1, pre-truncation
        .asg            A4,         A_x2    ; Output x2, pre-truncation
        .asg            A4,         A_x3    ; Output x3, pre-truncation
        .asg            A7,         A_x4    ; Output x4, pre-truncation
        .asg            A15,        A_x5    ; Output x5, pre-truncation
        .asg            B6,         B_x6    ; Output x6, pre-truncation
        .asg            B3,         B_x7    ; Output x7, pre-truncation
        .asg            B4,         B_x0t   ; Output x0, truncated to 16 bits
        .asg            B5,         B_x1t   ; Output x1, truncated to 16 bits
        .asg            A4,         A_x2t   ; Output x2, truncated to 16 bits
        .asg            A8,         A_x3t   ; Output x3, truncated to 16 bits
        .asg            A7,         A_x4t   ; Output x4, truncated to 16 bits
        .asg            A5,         A_x5t   ; Output x5, truncated to 16 bits
        .asg            B3,         B_x6t   ; Output x6, truncated to 16 bits
        .asg            B9,         B_x7t   ; Output x7, truncated to 16 bits
        .asg            A2,         A_i     ; Inner-loop counter.
; ============================================================================

* ========================================================================= *
*   Initialization code for horizontal loop:  Saves registers to            *
*   the stack, sets up cosine terms, pointers and loop control.             *
*                                                                           *
*   The stack frame for this code is 16 words large.  It holds the Save     *
*   on Entry (SOE) registers A10..A15, B10..B14, as well as the return      *
*   address (B3), CSR, IRP, and a single spill value.  (The loop counter    *
*   initializer is shared between both loops and so I spill it to the       *
*   stack.)  I twin the stack pointer to speed up stack accesses.  The      *
*   stack frame layout is slightly funky to avoid bank conflicts while      *
*   allowing me to get to everything when I need it most.                   *
*                                                                           *
*   The horizontal loop starts at the end of the IDCT array and works back  *
*   towards the beginning.  As a result, the input and output pointers are  *
*   initialized like so:                                                    *
*                                                                           *
*    -- A_i_ptr is set to point to the coefficients "X0" and "X1" in the    *
*       last row of the last valid IDCT block in the input.  B_i_ptr is     *
*       set to point to the coefficients "X4" and "X5" in that same row.    *
*                                                                           *
*    -- A_o_ptr is set to point to the coefficient "x4" in the rightmost    *
*       column of the scratch block I require at the end of the array.      *
*       B_o_ptr is set to point to "x3" in that same column.                *
*                                                                           *
*   The loop count is simply the number of IDCTs times 8, minus 1 to        *
*   handle the parallel iterations in the kernel.  (It would've been more,  *
*   except that I've performed some limited prolog and epilog collapsing,   *
*   so I need to iterate the kernel more times.)  A happy coincidence       *
*   gives both horizontal and vertical loops the exact same trip count,     *
*   so I spill this value to the stack and simply restore it unchanged      *
*   for the second loop, rather than recalculating it.                      *
*                                                                           *
*   Since I was able to free up a single predication register in the first  *
*   loop, I prolog-collapsed one stage of the prolog.  I use A1 as my       *
*   prolog-collapse counter.  To save a MVK (since this code bottlenecks    *
*   heavily on S units), I initialize it to -1 with an OR, rather than a    *
*   more traditional 1.                                                     *
*                                                                           *
*   Both loops use all 32 registers, so I have saved the stack pointer in   *
*   IRP.  This is safe since interrupts are explicitly disabled for the     *
*   entire function.                                                        *
*                                                                           *
*   Note:  This setup code could possibly be a cycle or two faster.  For    *
*   instance, I could copy B15 to A15 before the decrement and use          *
*   negative indexes for the STWs through A15, saving a whole cycle on      *
*   the stack saves.  The resulting code doesn't pack as nicely, though.    *
* ========================================================================= *

;-
        STW     .D2T1   A15,        *B15--[16]      ; Save A15, get stack frame
||      MVC     .S2     CSR,        B0              ; Grab the current CSR

        AND     .L2     B0,         -2,         B1  ; Clear GIE bit in CSR
||      MV      .L1X    B15,        A15             ; Twin the stack pointer

        STW     .D1T1   A14,        *+A15 [13]      ; Save SOE reg A14
||      STW     .D2T2   B14,        *+B15 [12]      ; Save SOE reg B14
||      MV      .L1X    B0,         A0              ; Partitioning MV.
||      MVC     .S2     B1,         CSR             ; Interrupts disabled here

;-
        STW     .D1T1   A13,        *+A15 [10]      ; Save SOE reg A13
||      STW     .D2T2   B13,        *+B15 [11]      ; Save SOE reg B13

        STW     .D1T1   A12,        *+A15 [ 9]      ; Save SOE reg A12
||      STW     .D2T2   B12,        *+B15 [ 8]      ; Save SOE reg B12

        STW     .D1T1   A11,        *+A15 [ 7]      ; Save SOE reg A11
||      STW     .D2T2   B11,        *+B15 [ 6]      ; Save SOE reg B11
||      SHL     .S2     B4,         3,      B_o     ; Set up outer loop counter
||      OR      .L1     A1,         -1,     A1      ; Prolog collapse counter

;-
        STW     .D1T1   A10,        *+A15 [ 5]      ; Save SOE reg A10
||      STW     .D2T2   B10,        *+B15 [ 4]      ; Save SOE reg B10
||      SHL     .S2     B4,         7,      B4      ; Set up end-of-array ptr
||[B_o] SUB     .L2     B_o,        1,      B_o     ; Loop count = IDCTs*8 - 1

        STW     .D2T2   B3,         *+B15 [ 2]      ; Remember the return addr
||      STW     .D1T1   A0,         *+A15 [ 3]      ; Remember the CSR state
||      ADD     .L2X    A4,         B4,     B4      ; Point to scratch area
||      MVC     .S2     IRP,        B0

;-
        STW     .D2T2   B_o,        *+B15 [ 1]      ; Spill our loop count init
||      MVC     .S2     B15,        IRP             ; Save stack ptr in IRP
||      SUB     .L2     B4,         8,      B_i_ptr ; Point to X5X4, row 7
||      MV      .L1X    B4,         A_o_ptr
||      MVK     .S1     7,          A_i             ; Set up inner loop counter

        SUB     .L1X    B_i_ptr,    8,      A_i_ptr ; Point to X1X0, row 7
||      ADDAH   .D2     B4,         31,     B_o_ptr ; Point to x3, col 7
||      ADDK    .S1     78,         A_o_ptr         ; Point to x4, col 7
;-
; ============================ PIPE LOOP PROLOG ==============================
h_prolog:
  [ B_o]LDW     .D1T1   * A_i_ptr--[4],         A_X1X0  ;[ 1,1]
||[ B_o]LDW     .D2T2   *+B_i_ptr[1],           B_X7X6  ;[ 1,1]
||      MVK     .S1     cst_c1,     A_c3c1              ; c1
||[!B_o]B       .S2     idct_8x8_abort                  ; num_idcts==0? Abort.

  [ B_o]LDW     .D1T1   *+A_i_ptr[5],           A_X3X2  ;[ 2,1]
||[ B_o]LDW     .D2T2   * B_i_ptr--[4],         B_X5X4  ;[ 2,1]
||      MVK     .S1     cst_c5,     A_c7c5              ; c5
||      MVK     .S2     cst_c2,     B_c6c2              ; c2
;-
        STW     .D1T2   B0,         *A15[14]            ; save IRP

        MVKLH   .S1     cst_c7,     A_c7c5              ; c7
||      MVKLH   .S2     cst_c6,     B_c6c2              ; c6

        MVKLH   .S1     cst_c3,     A_c3c1              ; c3
||      MVK     .S2     cst_c5,     B_c7c5              ; c5

        MPYH    .M1     A_X1X0,     A_c7c5,     A_X1c7  ;[ 6,1]
||      MPYLH   .M2     B_X7X6,     B_c6c2,     B_X6c6  ;[ 6,1]
||      MVKLH   .S2     cst_c7,     B_c7c5              ; c7

; ===== Branch Occurs =====
;-
        EXT     .S1     A_X1X0,     kq_a, kq_b, A_P0    ;[ 7,1]
||      MPY     .M1X    A_X3X2,     B_c6c2,     A_X2c2  ;[ 7,1]
||      MPYHL   .M2     B_X7X6,     B_c7c5,     B_X7c5  ;[ 7,1]
||      MV      .L2X    A_c3c1,     B_c3c1

        ADDK    .S1     256,        A_P0                ;[ 8,1]
||      EXT     .S2     B_X5X4,     kq_a, kq_b, B_P1    ;[ 8,1]
||      MPYHL   .M1     A_X1X0,     A_c3c1,     A_X1c1  ;[ 8,1]
||      MPYH    .M2     B_X7X6,     B_c7c5,     B_X7c7  ;[ 8,1]
;-
; ============================ PIPE LOOP KERNEL ==============================
h_loop:
h_loop_0:
        SUB     .L2     B_g1,       B_h3n,      B_x1    ;[19,1]
||      STH     .D2T2   B_x0t,      *-B_o_ptr[24]       ;[19,1]
||      ADD     .D1     A_i,        1,          A_i     ;[19,1]
||      SHR     .S1     A_x3,       trunc1,     A_x3t   ;[19,1]
||      ADD     .L1X    A_g3a,      B_g3b,      A_g3    ;[19,1]
||      ADD     .S2X    A_X2c2,     B_X6c6,     B_r0    ;[ 9,2]
||      MPYH    .M1     A_X3X2,     A_c3c1,     A_X3c3  ;[ 9,2]
||      MPYHL   .M2     B_X5X4,     B_c7c5,     B_X5c5  ;[ 9,2]

h_loop_1:
        ADD     .L2     B_g1,       B_h3n,      B_x6    ;[20,1]
||[!A1] STH     .D2T1   A_x3t,      * B_o_ptr--[1]      ;[20,1]
||      ADD     .S1     A_h1,       A_g3,       A_x2    ;[20,1]
||      SUB     .D1     A_h1,       A_g3,       A_x5    ;[20,1]
||      ADD     .L1X    A_P0,       B_P1,       A_p0    ;[10,2]
||      MPYHL   .M1     A_X1X0,     A_c7c5,     A_X1c5  ;[10,2]
||      MPYHL   .M2     B_X7X6,     B_c3c1,     B_X7c1  ;[10,2]

h_loop_2:
        SHR     .S1     A_x5,       trunc1,     A_x5t   ;[21,1]
||      SHR     .S2     B_x1,       trunc1,     B_x1t   ;[21,1]
||      ADD     .L1     A_X1c1,     A_X3c3,     A_h2a   ;[11,2]
||      ADD     .L2     B_X5c5,     B_X7c7,     B_h2b   ;[11,2]
||      MPYH    .M1     A_X1X0,     A_c3c1,     A_X1c3  ;[11,2]
||      MPYH    .M2     B_X5X4,     B_c7c5,     B_X5c7  ;[11,2]
||      LDW     .D1T1   * A_i_ptr--[4],         A_X1X0  ;[ 1,3]
||      LDW     .D2T2   *+B_i_ptr[1],           B_X7X6  ;[ 1,3]

h_loop_3:
        SHR     .S2     B_x6,       trunc1,     B_x6t   ;[22,1]
||      SHR     .S1     A_x2,       trunc1,     A_x2t   ;[22,1]
||      SUB     .L1X    A_p0,       B_r0,       A_h0    ;[12,2]
||      ADD     .L2X    A_h2a,      B_h2b,      B_h2    ;[12,2]
||      MPYH    .M1     A_X3X2,     A_c7c5,     A_X3c7  ;[12,2]
||      MPYH    .M2     B_X5X4,     B_c3c1,     B_X5c3  ;[12,2]
||      LDW     .D1T1   *+A_i_ptr[5],           A_X3X2  ;[ 2,3]
||      LDW     .D2T2   * B_i_ptr--[4],         B_X5X4  ;[ 2,3]

h_loop_4:
  [ B_o]B       .S2     h_loop                          ;[23,1]
||      STH     .D1T1   A_x5t,      *+A_o_ptr[8]        ;[23,1]
||      SHR     .S1     A_x4,       trunc1,     A_x4t   ;[23,1]
||      ADD     .L2X    A_p0,       B_r0,       B_g0    ;[13,2]
||[ B_o]SUB     .D2     B_o,        1,          B_o     ;[13,2]
||[!A1] AND     .L1     A_i,        7,          A_i     ;[13,2]
||      MPYHL   .M1     A_X3X2,     A_c7c5,     A_X3c5  ;[13,2]
||      MPYHL   .M2     B_X5X4,     B_c3c1,     B_X5c1  ;[13,2]

h_loop_5:
  [!A1] STH     .D1T1   A_x4t,      * A_o_ptr--[1]      ;[24,1]
||      SUB     .S1     A_X1c3,     A_X3c7,     A_h3a   ;[14,2]
||      SUB     .L1X    A_P0,       B_P1,       A_p1    ;[14,2]
||      ADD     .S2     B_g0,       B_h2,       B_x0    ;[14,2]
||      SUB     .L2     B_X5c3,     B_X7c1,     B_g2b   ;[14,2]
||      MPYHL   .M1     A_X3X2,     A_c3c1,     A_X3c1  ;[14,2]
||      MPY     .M2     B_X7X6,     B_c6c2,     B_X6c2  ;[14,2]

h_loop_6:
        STH     .D1T2   B_x6t,      *+A_o_ptr[17]       ;[25,1]
||      SUB     .D2     B_g0,       B_h2,       B_x7    ;[15,2]
||      SHR     .S2     B_x0,       trunc1,     B_x0t   ;[15,2]
||      SUB     .S1     A_X1c7,     A_X3c5,     A_g2a   ;[15,2]
||      ADD     .L2     B_X5c1,     B_X7c5,     B_h3b   ;[15,2]
||      MPYLH   .M1X    A_X3X2,     B_c6c2,     A_X2c6  ;[15,2]
||      MPYH    .M2     B_X7X6,     B_c3c1,     B_X7c3  ;[15,2]
||[ A1] ADD     .L1     A1,         1,          A1

h_loop_7:
  [!A_i]SUBAW   .D1     A_o_ptr,    28,         A_o_ptr ;[26,1]
||      STH     .D2T2   B_x1t,      *-B_o_ptr[15]       ;[26,1]
||      SHR     .S2     B_x7,       trunc1,     B_x7t   ;[16,2]
||      SUB     .L1     A_X1c5,     A_X3c1,     A_g3a   ;[16,2]
||      SUB     .L2X    B_h3b,      A_h3a,      B_h3n   ;[16,2]
||      ADD     .S1X    A_g2a,      B_g2b,      A_g2    ;[16,2]
||      MPYH    .M1     A_X1X0,     A_c7c5,     A_X1c7  ;[ 6,3]
||      MPYLH   .M2     B_X7X6,     B_c6c2,     B_X6c6  ;[ 6,3]

h_loop_8:
        STH     .D2T1   A_x2t,      *-B_o_ptr[7]        ;[27,1]
||      ADD     .L1     A_h0,       A_g2,       A_x3    ;[17,2]
||      SUB     .D1     A_h0,       A_g2,       A_x4    ;[17,2]
||      SUB     .L2X    A_X2c6,     B_X6c2,     B_r1    ;[17,2]
||      EXT     .S1     A_X1X0,     kq_a, kq_b, A_P0    ;[ 7,3]
||      EXT     .S2     B_X5X4,     kq_a, kq_b, B_P1    ;[ 7,3]
||      MPY     .M1X    A_X3X2,     B_c6c2,     A_X2c2  ;[ 7,3]
||      MPYHL   .M2     B_X7X6,     B_c7c5,     B_X7c5  ;[ 7,3]

h_loop_9:
  [!A_i]SUBAW   .D2     B_o_ptr,    28,         B_o_ptr ;[28,1]
||      STH     .D1T2   B_x7t,      *+A_o_ptr[24]       ;[18,2]
||      ADD     .S2X    A_p1,       B_r1,       B_g1    ;[18,2]
||      SUB     .L1X    A_p1,       B_r1,       A_h1    ;[18,2]
||      ADD     .L2     B_X5c7,     B_X7c3,     B_g3b   ;[18,2]
||      ADDK    .S1     256,        A_P0                ;[ 8,3]
||      MPYHL   .M1     A_X1X0,     A_c3c1,     A_X1c1  ;[ 8,3]
||      MPYH    .M2     B_X7X6,     B_c7c5,     B_X7c7  ;[ 8,3]

; ============================ PIPE LOOP EPILOG ==============================
h_epilog:
        SUB     .L2     B_g1,       B_h3n,      B_x1    ;[19,3]
||      STH     .D2T2   B_x0t,      *-B_o_ptr[24]       ;[19,3]
||      SHR     .S1     A_x3,       trunc1,     A_x3t   ;[19,3]
||      ADD     .L1X    A_g3a,      B_g3b,      A_g3    ;[19,3]

        ADD     .L2     B_g1,       B_h3n,      B_x6    ;[20,3]
||      STH     .D2T1   A_x3t,      *+B_o_ptr[0]        ;[20,3]
||      ADD     .S1     A_h1,       A_g3,       A_x2    ;[20,3]
||      SUB     .D1     A_h1,       A_g3,       A_x5    ;[20,3]
;-
        SHR     .S1     A_x5,       trunc1,     A_x5t   ;[21,3]
||      SHR     .S2     B_x1,       trunc1,     B_x1t   ;[21,3]

        SHR     .S2     B_x6,       trunc1,     B_x6t   ;[22,3]
||      SHR     .S1     A_x2,       trunc1,     A_x2t   ;[22,3]
||      STH     .D2T2   B_x1t,      *-B_o_ptr[16]       ;[26,3]

        STH     .D1T1   A_x5t,      *+A_o_ptr[8]        ;[23,3]
||      SHR     .S1     A_x4,       trunc1,     A_x4t   ;[23,3]

* ========================================================================= *
*   Interloop code:  Performs remaining epilog from horizontal pass, and    *
*   begins setup of the vertical pass.                                      *
*                                                                           *
*   In order to save some time between loops, I start performing pointer    *
*   fixups and constant initializations in the epilog of the horizontal     *
*   pass loop.  The horizontal pass works from the bottom of the            *
*   IDCT list and ends at the top, whereas the vertical pass works from     *
*   the top of the list and ends up at the bottom.  As a result, the        *
*   displacement between the required pointer settings between the two      *
*   loops is fixed, regardless of the number of IDCTs processed, since      *
*   the two loops pointers always meet at the top of the list.              *
*                                                                           *
*   The vertical loop needs a new repacking of the cosine terms: c6c3 and   *
*   c2c1.  By playing around w/ how the cosine terms are packed,            *
*   I was able to save two whole registers in the vertical loop and thus    *
*   fit into the register file.  I do this repacking partly here, and       *
*   partly in the vertical loop's prolog.                                   *
* ========================================================================= *

        STH     .D1T1   A_x4t,      *+A_o_ptr[0]        ;[24,3]
;-
        STH     .D1T2   B_x6t,      *+A_o_ptr[16]       ;[25,3]
||      ADDK    .S1     168,        A_i_ptr             ; Fixup for vert loop
||      ADDK    .S2     156,        B_i_ptr             ; Fixup for vert loop

        .asg            A15,        A_c6c3              ; Symbolic name from
                                                        ;    vertical loop.

        STH     .D2T1   A_x2t,      *-B_o_ptr[8]        ;[27,3]
||      SHR     .S1     A_c3c1,     16, A_c6c3          ; Set up new cos cst
||      MVC     .S2     IRP,        B0                  ; Get SP so we can
                                                        ;    unspill A_o.

; ============================================================================

; =============== SYMBOLIC REGISTER ASSIGNMENTS FOR VERT LOOP ================
        .asg            A14,        A_i_ptr ; Input pointer #1
        .asg            B15,        B_i_ptr ; Input pointer #2
        .asg            A11,        A_o_ptr ; Output pointer #1
        .asg            B11,        B_o_ptr ; Output pointer #2
        .asg            B13,        B_c7c5  ; Cosine terms c7, c5   (packed)
        .asg            A13,        A_c7c5  ; Cosine terms c7, c5   (packed)
        .asg            A15,        A_c6c3  ; Cosine terms c6, c3   (packed)
        .asg            B12,        B_c2c1  ; Cosine terms c2, c1   (packed)
        .asg            A4,         A_c1c4  ; Cosine term  c1, c4 (alternates)
        .asg            A2,         A_o     ; Outer loop counter
        .asg            B2,         B_i     ; Inner loop counter
        .asg            A12,        A_X7X6  ; Incoming coefs X7, X6 (packed)
        .asg            A8,         A_X5X4  ; Incoming coefs X5, X4 (packed)
        .asg            B10,        B_X3X2  ; Incoming coefs X3, X2 (packed)
        .asg            B14,        B_X1X0  ; Incoming coefs X1, X0 (packed)
        .asg            B9,         B_rnd   ; Rounding value applied to P0
        .asg            B1,         B_P0_t  ; Node P0, temporary pre-rounding
        .asg            B5,         B_P0    ; Rounded value of Node P0
        .asg            A7,         A_P1    ; Node P1 in signal flow graph
        .asg            B0,         B_X2c2  ; X2 * c2
        .asg            B4,         B_X2c6  ; X2 * c6
        .asg            A4,         A_X6c2  ; X6 * c2
        .asg            A3,         A_X6c6  ; X6 * c6
        .asg            A5,         A_p0    ; Node p0 in signal flow graph
        .asg            A8,         A_p1    ; Node p1 in signal flow graph
        .asg            B4,         B_r1    ; Node r1 in signal flow graph
        .asg            B3,         B_r0    ; Node r0 in signal flow graph
        .asg            B0,         B_g0    ; Node g0 in signal flow graph
        .asg            A1,         A_g1    ; Node g1 in signal flow graph
        .asg            B3,         B_h1    ; Node h1 in signal flow graph
        .asg            A3,         A_h0    ; Node h0 in signal flow graph
        .asg            B5,         B_X1c1  ; X1 * c1
        .asg            B1,         B_X1c3  ; X1 * c3
        .asg            B3,         B_X1c5  ; X1 * c5
        .asg            B8,         B_X1c7  ; X1 * c7
        .asg            B0,         B_X3c1  ; X3 * c1
        .asg            B0,         B_X3c3  ; X3 * c3
        .asg            B0,         B_X3c5  ; X3 * c5
        .asg            B9,         B_X3c7  ; X3 * c7
        .asg            A3,         A_X5c1  ; X5 * c1
        .asg            A1,         A_X5c3  ; X5 * c3
        .asg            A5,         A_X5c5  ; X5 * c5
        .asg            A0,         A_X5c7  ; X5 * c7
        .asg            A6,         A_X7c1  ; X7 * c1
        .asg            A7,         A_X7c3  ; X7 * c3
        .asg            A4,         A_X7c5  ; X7 * c5
        .asg            A6,         A_X7c7  ; X7 * c7
        .asg            A3,         A_h2a   ; X5 * c5 + X7 * c7
        .asg            B3,         B_h2b   ; X1 * c1 + X3 * c3
        .asg            B6,         B_h2    ; Node h2 in signal flow graph
        .asg            A4,         A_h3a   ; X5 * c1 + X7 * c5
        .asg            B1,         B_h3b   ; X1 * c3 + X3 * c7
        .asg            A3,         A_h3    ; Node h3 in signal flow graph
        .asg            A9,         A_g3a   ; X5 * c7 + X7 * c3
        .asg            B1,         B_g3b   ; X1 * c5 + X3 * c1
        .asg            B7,         B_g3    ; Node g3 in signal flow graph
        .asg            A9,         A_g2a   ; X5 * c3 + X7 * c1
        .asg            B1,         B_g2b   ; X1 * c7 + X3 * c5
        .asg            A0,         A_g2    ; Node g2 in signal flow graph
        .asg            B8,         B_x0    ; Output x0, pre-saturate/truncate
        .asg            A1,         A_x1    ; Output x1, pre-saturate/truncate
        .asg            B7,         B_x2    ; Output x2, pre-saturate/truncate
        .asg            A4,         A_x3    ; Output x3, pre-saturate/truncate
        .asg            A0,         A_x4    ; Output x4, pre-saturate/truncate
        .asg            B4,         B_x5    ; Output x5, pre-saturate/truncate
        .asg            A5,         A_x6    ; Output x6, pre-saturate/truncate
        .asg            B6,         B_x7    ; Output x7, pre-saturate/truncate
        .asg            B5,         B_x0s   ; Output x0, saturated to 9 bits
        .asg            A10,        A_x1s   ; Output x1, saturated to 9 bits
        .asg            B3,         B_x2s   ; Output x2, saturated to 9 bits
        .asg            A6,         A_x3s   ; Output x3, saturated to 9 bits
        .asg            A7,         A_x4s   ; Output x4, saturated to 9 bits
        .asg            B4,         B_x5s   ; Output x5, saturated to 9 bits
        .asg            A3,         A_x6s   ; Output x6, saturated to 9 bits
        .asg            B6,         B_x7s   ; Output x7, saturated to 9 bits
        .asg            B8,         B_x0t   ; Output x0, truncated to 9 bits
        .asg            A0,         A_x1t   ; Output x1, truncated to 9 bits
        .asg            B0,         B_x2t   ; Output x2, truncated to 9 bits
        .asg            A6,         A_x3t   ; Output x3, truncated to 9 bits
        .asg            A7,         A_x4t   ; Output x4, truncated to 9 bits
        .asg            B4,         B_x5t   ; Output x5, truncated to 9 bits
        .asg            A5,         A_x6t   ; Output x6, truncated to 9 bits
        .asg            B3,         B_x7t   ; Output x7, truncated to 9 bits
; ============================================================================

; ============================ PIPE LOOP PROLOG ==============================
v_prolog:
        LDW     .D2T1   *B0[1],     A_o                 ; Unspill loop counter
||      ADDK    .S2     -128,       B_o_ptr             ; Fixup for vert loop
;-
        LDW     .D1T1   *+A_i_ptr[1],           A_X7X6  ;[ 1,1]
||      LDW     .D2T2   *-B_i_ptr[1],           B_X1X0  ;[ 1,1]

        ADDK    .S1     -128,       A_o_ptr             ; Fixup for vert loop

        ; Set up modified constants for second loop
        ; Note: A_c7c5, B_c7c5 are in same regs both loops.
        ; Also, B_c2c1 reuses h_loop's B_c3c1.

        LDW     .D2T2   * B_i_ptr++[4],         B_X3X2  ;[ 3,1]
||      LDW     .D1T1   * A_i_ptr++[4],         A_X5X4  ;[ 3,1]

        MVKLH   .S2     cst_c2,     B_c2c1              ; c2 (B_c2c1 == B_c3c1)
||      MVKLH   .S1     cst_c6,     A_c6c3              ; c6

        MVK     .S2     8,          B_i                 ; Inner loop counter.
;-
        MPYHL   .M1     A_X7X6,     A_c6c3,     A_X7c3  ;[ 6,1]

        MPYH    .M1     A_X7X6,     A_c7c5,     A_X7c7  ;[ 7,1]
||      MPYHL   .M2     B_X1X0,     B_c2c1,     B_X1c1  ;[ 7,1]

        MVK     .S1     cst_c4,     A_c1c4              ;[ 8,1]
||      MPYH    .M1     A_X5X4,     A_c7c5,     A_X5c7  ;[ 8,1]
||      MPYHL   .M2     B_X1X0,     B_c7c5,     B_X1c5  ;[ 8,1]

        MPY     .M1     A_X5X4,     A_c1c4,     A_P1    ;[ 9,1]
||      MPYHL   .M2     B_X3X2,     B_c2c1,     B_X3c1  ;[ 9,1]
;-
        ADD     .D1     A_X5c7,     A_X7c3,     A_g3a   ;[10,1]
||      MPYHL   .M1     A_X5X4,     A_c6c3,     A_X5c3  ;[10,1]
||      MPYHL   .M2X    B_X3X2,     A_c6c3,     B_X3c3  ;[10,1]

        SUB     .L2     B_X1c5,     B_X3c1,     B_g3b   ;[11,1]
||      MPYHL   .M1     A_X5X4,     A_c7c5,     A_X5c5  ;[11,1]
||      MPY     .M2X    B_X1X0,     A_c1c4,     B_P0_t  ;[11,1]
||      MVK     .S2     -32768,     B_rnd               ;[ 6,1]
||      B       .S1     v_loop_0 + 8                    ; skip 2
;-
        ADD     .L2X    B_g3b,      A_g3a,      B_g3    ;[12,1]
||      MPYHL   .M1X    A_X7X6,     B_c2c1,     A_X7c1  ;[12,1]
||      MPYH    .M2     B_X3X2,     B_c7c5,     B_X3c7  ;[12,1]
||      LDW     .D1T1   *+A_i_ptr[1],           A_X7X6  ;[ 1,2]
||      LDW     .D2T2   *-B_i_ptr[1],           B_X1X0  ;[ 1,2]
||      B       .S2     v_loop_1 + 8                    ; skip 2
;-
        SUB     .D2     B_P0_t,     B_rnd,      B_P0    ;[13,1]
||      ADD     .L2     B_X1c1,     B_X3c3,     B_h2b   ;[13,1]
||      ADD     .L1     A_X5c5,     A_X7c7,     A_h2a   ;[13,1]
||      MPYLH   .M1X    A_X7X6,     B_c2c1,     A_X6c2  ;[13,1]
||      MPYLH   .M2X    B_X3X2,     A_c6c3,     B_X2c6  ;[13,1]
||      B       .S2     v_loop_2 + 12                   ; skip 3
||      MVKL    .S1     cst_c1,     A_c1c4              ;
;-
        SUB     .L1     A_X5c3,     A_X7c1,     A_g2a   ;[14,1]
||      MPYHL   .M1     A_X5X4,     A_c1c4,     A_X5c1  ;[14,1]
||      MPYHL   .M2X    B_X1X0,     A_c6c3,     B_X1c3  ;[14,1]
||      LDW     .D2T2   * B_i_ptr++[4],         B_X3X2  ;[ 3,2]
||      LDW     .D1T1   * A_i_ptr++[4],         A_X5X4  ;[ 3,2]
||      B       .S2     v_loop_3 + 4                    ; skip 1
||      ADD     .S1X    B_P0,       A_P1,       A_p0    ;[16,1]
;-
        ADD     .L2X    B_h2b,      A_h2a,      B_h2    ;[15,1]
||      SUB     .L1X    B_P0,       A_P1,       A_p1    ;[15,1]
||      MPYHL   .M1     A_X7X6,     A_c7c5,     A_X7c5  ;[15,1]
||      MPYLH   .M2     B_X3X2,     B_c2c1,     B_X2c2  ;[15,1]
||      B       .S2     v_loop_4 + 4                    ; skip 1

        SUB     .L2X    B_X2c6,     A_X6c2,     B_r1    ;[16,1]
||      MPYLH   .M1     A_X7X6,     A_c6c3,     A_X6c6  ;[16,1]
||      MPYH    .M2     B_X1X0,     B_c7c5,     B_X1c7  ;[16,1]
;-
; ===== Branch Occurs =====
; ============================ PIPE LOOP KERNEL ==============================
v_loop:
v_loop_0:
        STH     .D1T2   B_x7t,      *+A_o_ptr[24]       ;[28,1]
||      SHR     .S1     A_x4s,      trunc2,     A_x4t   ;[28,1]
||      ADD     .L1     A_X5c1,     A_X7c5,     A_h3a   ;[17,2]
||      SUB     .D2     B_X1c3,     B_X3c7,     B_h3b   ;[17,2]
||      SUB     .L2X    A_p1,       B_r1,       B_h1    ;[17,2]
||      MPYHL   .M2     B_X3X2,     B_c7c5,     B_X3c5  ;[17,2]
||      MVK     .S2     -32768,     B_rnd               ;[ 6,3]
||      MPYHL   .M1     A_X7X6,     A_c6c3,     A_X7c3  ;[ 6,3]

v_loop_1:
        STH     .D1T1   A_x4t,      * A_o_ptr++[1]      ;[29,1]
||      SHR     .S1     A_x1s,      trunc2,     A_x1t   ;[29,1]
||      ADD     .S2     B_h1,       B_g3,       B_x2    ;[18,2]
||      SUB     .D2     B_h1,       B_g3,       B_x5    ;[18,2]
||      ADD     .L1X    A_p1,       B_r1,       A_g1    ;[18,2]
||      ADD     .L2X    B_X2c2,     A_X6c6,     B_r0    ;[18,2]
||      MPYH    .M1     A_X7X6,     A_c7c5,     A_X7c7  ;[ 7,3]
||      MPYHL   .M2     B_X1X0,     B_c2c1,     B_X1c1  ;[ 7,3]

v_loop_2:
  [!B_i]ADDAW   .D1     A_o_ptr,    28,         A_o_ptr ;[30,1]
||      STH     .D2T1   A_x3t,      * B_o_ptr++[1]      ;[30,1]
||      SHR     .S2     B_x0s,      trunc2,     B_x0t   ;[30,1]
||      SUB     .L2     B_X1c7,     B_X3c5,     B_g2b   ;[19,2]
||      SUB     .L1X    B_h3b,      A_h3a,      A_h3    ;[19,2]
||      MVK     .S1     cst_c4,     A_c1c4              ;[ 8,3]
||      MPYH    .M1     A_X5X4,     A_c7c5,     A_X5c7  ;[ 8,3]
||      MPYHL   .M2     B_X1X0,     B_c7c5,     B_X1c5  ;[ 8,3]

v_loop_3:
        STH     .D2T1   A_x1t,      *-B_o_ptr[17]       ;[31,1]
||      ADD     .L2X    A_p0,       B_r0,       B_g0    ;[20,2]
||      SSHL    .S2     B_x5,       satl,       B_x5s   ;[20,2]
||      SUB     .S1X    A_p0,       B_r0,       A_h0    ;[20,2]
||      SUB     .L1     A_g1,       A_h3,       A_x6    ;[20,2]
||      ADD     .D1     A_g1,       A_h3,       A_x1    ;[20,2]
||      MPY     .M1     A_X5X4,     A_c1c4,     A_P1    ;[ 9,3]
||      MPYHL   .M2     B_X3X2,     B_c2c1,     B_X3c1  ;[ 9,3]

v_loop_4:
        STH     .D2T2   B_x0t,      *-B_o_ptr[25]       ;[32,1]
||      SUB     .S2     B_g0,       B_h2,       B_x7    ;[21,2]
||      ADD     .L2     B_g0,       B_h2,       B_x0    ;[21,2]
||      ADD     .L1X    B_g2b,      A_g2a,      A_g2    ;[21,2]
||      SSHL    .S1     A_x1,       satl,       A_x1s   ;[21,2]
||      ADD     .D1     A_X5c7,     A_X7c3,     A_g3a   ;[10,3]
||      MPYHL   .M1     A_X5X4,     A_c6c3,     A_X5c3  ;[10,3]
||      MPYHL   .M2X    B_X3X2,     A_c6c3,     B_X3c3  ;[10,3]

v_loop_5:
  [ A_o]B       .S1     v_loop                          ;[33,1]
||[!B_i]ADDAW   .D2     B_o_ptr,    28,         B_o_ptr ;[33,1]
||      SSHL    .S2     B_x2,       satl,       B_x2s   ;[22,2]
||      ADD     .D1     A_h0,       A_g2,       A_x3    ;[22,2]
||[ A_o]SUB     .L1     A_o,        1,          A_o     ;[22,2]
||      SUB     .L2     B_X1c5,     B_X3c1,     B_g3b   ;[11,3]
||      MPYHL   .M1     A_X5X4,     A_c7c5,     A_X5c5  ;[11,3]
||      MPY     .M2X    B_X1X0,     A_c1c4,     B_P0_t  ;[11,3]

v_loop_6:
        SHR     .S2     B_x5s,      trunc2,     B_x5t   ;[23,2]
||      SUB     .L1     A_h0,       A_g2,       A_x4    ;[23,2]
||      SSHL    .S1     A_x6,       satl,       A_x6s   ;[23,2]
||      ADD     .L2X    B_g3b,      A_g3a,      B_g3    ;[12,3]
||      MPYHL   .M1X    A_X7X6,     B_c2c1,     A_X7c1  ;[12,3]
||      MPYH    .M2     B_X3X2,     B_c7c5,     B_X3c7  ;[12,3]
||      LDW     .D1T1   *+A_i_ptr[1],           A_X7X6  ;[ 1,4]
||      LDW     .D2T2   *-B_i_ptr[1],           B_X1X0  ;[ 1,4]

v_loop_7:
        SHR     .S2     B_x2s,      trunc2,     B_x2t   ;[24,2]
||      STH     .D1T2   B_x5t,      *+A_o_ptr[8]        ;[24,2]
||      SHR     .S1     A_x6s,      trunc2,     A_x6t   ;[24,2]
||      SUB     .D2     B_P0_t,     B_rnd,      B_P0    ;[13,3]
||      ADD     .L2     B_X1c1,     B_X3c3,     B_h2b   ;[13,3]
||      ADD     .L1     A_X5c5,     A_X7c7,     A_h2a   ;[13,3]
||      MPYLH   .M1X    A_X7X6,     B_c2c1,     A_X6c2  ;[13,3]
||      MPYLH   .M2X    B_X3X2,     A_c6c3,     B_X2c6  ;[13,3]

v_loop_8:
        AND     .L2     B_i,        7,          B_i     ;[36,1]
||      SSHL    .S2     B_x7,       satl,       B_x7s   ;[25,2]
||      SSHL    .S1     A_x3,       satl,       A_x3s   ;[25,2]
||      SUB     .L1     A_X5c3,     A_X7c1,     A_g2a   ;[14,3]
||      MPYHL   .M1X    A_X5X4,     B_c2c1,     A_X5c1  ;[14,3]
||      MPYHL   .M2X    B_X1X0,     A_c6c3,     B_X1c3  ;[14,3]
||      LDW     .D2T2   * B_i_ptr++[4],         B_X3X2  ;[ 3,4]
||      LDW     .D1T1   * A_i_ptr++[4],         A_X5X4  ;[ 3,4]

v_loop_9:
        STH     .D2T2   B_x2t,      *-B_o_ptr[8]        ;[26,2]
||      SHR     .S1     A_x3s,      trunc2,     A_x3t   ;[26,2]
||      SHR     .S2     B_x7s,      trunc2,     B_x7t   ;[26,2]
||      ADD     .L2X    B_h2b,      A_h2a,      B_h2    ;[15,3]
||      SUB     .L1X    B_P0,       A_P1,       A_p1    ;[15,3]
||      MPYHL   .M1     A_X7X6,     A_c7c5,     A_X7c5  ;[15,3]
||      MPYLH   .M2     B_X3X2,     B_c2c1,     B_X2c2  ;[15,3]

v_loop_a:
  [ A_o]SUB     .D2     B_i,        1,          B_i     ;[27,2]
||      STH     .D1T1   A_x6t,      *+A_o_ptr[16]       ;[27,2]
||      SSHL    .S2     B_x0,       satl,       B_x0s   ;[27,2]
||      SSHL    .S1     A_x4,       satl,       A_x4s   ;[27,2]
||      SUB     .L2X    B_X2c6,     A_X6c2,     B_r1    ;[16,3]
||      ADD     .L1X    B_P0,       A_P1,       A_p0    ;[16,3]
||      MPYLH   .M1     A_X7X6,     A_c6c3,     A_X6c6  ;[16,3]
||      MPYH    .M2     B_X1X0,     B_c7c5,     B_X1c7  ;[16,3]

; ============================ PIPE LOOP EPILOG ==============================
v_epilog:
* ========================================================================= *
*   Post-vertical loop code:  Performs remaining vertical-loop epilog,      *
*   pulls registers from the stack, restores the interrupt-enable state,    *
*   and returns to the caller.                                              *
*                                                                           *
*   For speed, I start pulling items from the stack as quickly as           *
*   possible. I pop the return address earliest, followed by the CSR        *
*   restore value and the rest of the stack frame (basically, the SOE       *
*   registers).                                                             *
*                                                                           *
*   I throw the return branch in flight nearly as soon as the return addr   *
*   arrives from the stack in order to return to the caller as soon as      *
*   possible.  I don't think it's possible to save any more time in this    *
*   epilog code.  :-)                                                       *
*                                                                           *
*   Once the stack-frame restore is complete, I allow the remainder of      *
*   the epilog (mostly shifts and stores) to complete, in the remaining     *
*   delay slots of the return branch.  Since the stack-restore loads        *
*   need to complete before this time anyway, I couldn't of used those      *
*   cycles for much else anyway.                                            *
*                                                                           *
*   The interrupt-enable state is not restored until the return branch      *
*   is in flight.  This implies that any pending interrupt will be taken    *
*   on arrival in the calling function, assuming it called the IDCT with    *
*   interrupts enabled.                                                     *
*                                                                           *
*   Again, this code uses twin stack-pointers for speed.                    *
*                                                                           *
*   To highlight how intertwined the epilog is with the stack frame code    *
*   I've added comments highlighting what is what.                          *
*                                                                           *
*   I've played a trick in order to allow an early abort from the code:     *
*   If the loop trip count is calculated to be zero by the main setup code  *
*   at the beginning, an emergency branch is made to the abort label        *
*   below.  (The abort is triggered only if we're asked to do zero IDCTs.)  *
*   The outer loop trip count for the first loop (B_o) is stored in B2.     *
*   The second loop uses B2 for its inner loop trip count (B_i).  Under     *
*   normal operation, B2 (aka. B_o) is non-zero upon entry to this code.    *
*   However, in the case of an abort, it will be zero, since we did not     *
*   execute either loop.  Therefore we can use B_o to shut off the epilog   *
*   stores in the case of an early abort.                                   *
* ========================================================================= *
idct_8x8_abort:
  [ B_o]STH     .D1T2   B_x7t,      *+A_o_ptr[24]       ; epilog code
||      SHR     .S1     A_x4s,      trunc2,     A_x4t   ; epilog code
||      MVC     .S2     IRP,        B15                 ; Get stack pointer

        LDW     .D2T2   *+ B15[ 2], B3                  ; Get return address
||      MV      .L2     B_o_ptr,    B0                  ; We need this later.
||      SHR     .S1     A_x1s,      trunc2,     A_x1t   ; epilog code
||      MV      .L1X    B15,        A1

        LDW     .D2T1   *+ B15[14], A2
;-
        LDW     .D2T2   *+ B15[10], B1                  ; A13 value's
||      LDW     .D1T1   *+ A1 [13], A14                 ; Restore A14

        LDW     .D2T2   *+ B15[12], B14                 ; Restore B14
||      LDW     .D1T1   *+ A1 [ 3], A3                  ; CSR value's

        LDW     .D1T2   *+ A1 [ 4], B10                 ; Restore A10
||      LDW     .D2T1   *+ B15[ 5], A10                 ; Restore A10

        LDW     .D1T2   *+ A1 [ 6], B11                 ; Restore A11
||      LDW     .D2T1   *+ B15[ 7], A11                 ; Restore A11
;-
        LDW     .D1T2   *+ A1 [ 8], B12                 ; Restore A12
||      LDW     .D2T1   *+ B15[ 9], A12                 ; Restore A12
||      RET     .S2     B3                              ; Go home!

        LDW     .D1T2   *+ A1 [11], B13                 ; Restore B13
||      LDW     .D2T1   *++B15[16], A15                 ; Restore A15, B15
||      MV      .L1X    B1,         A13                 ; Restore A13

  [ B_o]STH     .D2T1   A_x3t,      * B0                ; epilog code
||      SHR     .S2     B_x0s,      trunc2,     B_x0t   ; epilog code
;-

  [ B_o]STH     .D2T1   A_x1t,      *-B0[16]            ; epilog code

  [ B_o]STH     .D2T2   B_x0t,      *-B0[24]            ; epilog code
||      MVC     .S2X    A2,         IRP                 ; Restore IRP

  [ B_o]STH     .D2T1   A_x4t,      *+B0[8]             ; epilog code
||      MVC     .S2X    A3,         CSR                 ; Restore CSR
;-
v_end:

* ========================================================================= *
*   End of file:  img_idct_8x8.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mad_16x16.asm/  1066929161  0     0     0       30796     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.19    Sun Sep 29 03:31:26 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mad_16x16    Minimum Absolute Difference                        *
*                                                                           *
*   REVISION DATE                                                           *
*       21-May-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_mad_16x16                                                  *
*       (                                                                   *
*           const unsigned char *refImg,// reference image                  *
*           const unsigned char *srcImg,// 16x16 block image to look for    *
*           int pitch,                  // Width of reference image         *
*           int                 h,      // horiz. size of search area       *
*           int                 v,      // vert.  size of search area       *
*           unsigned            *match  // Result                           *
*       )                               //     match[0] is packed x, y.     *
*                                       //     match[1] is MAD value.       *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine returns the location of the minimum absolute           *
*       difference between a 16x16 search block and some block in a         *
*       (h + 16) x (v + 16) search area. h and v are the sizes of the       *
*       search space for the top left coordinate of the search block.       *
*       refImg points to the top left pixel of the search area.             *
*                                                                           *
*            (0,0)          (h,0)      (h+16,0)                             *
*              ;--------------+--------;                                    *
*              ;    search    |        ;                                    *
*              ;    space     |        ;                                    *
*              ;              |        ;        search area                 *
*              ;--------------+        ;                                    *
*            (0,v)          (h,v)      ;                                    *
*              ;                       ;                                    *
*              ;-----------------------;                                    *
*            (0, v+16)                 (v+16,h+16)                          *
*                                                                           *
*       The location is returned relative to the above coordinate system    *
*       as x and y packed in two 16-bit quantities in a 32-bit word:        *
*                                                                           *
*                   31             16 15             0                      *
*                   +----------------+----------------+                     *
*        match[0]:  |       x        |       y        |                     *
*                   +----------------+----------------+                     *
*                                                                           *
*                   31                               0                      *
*                   +---------------------------------+                     *
*        match[1]:  |   SAD value at location x, y    |                     *
*                   +---------------------------------+                     *
*                                                                           *
*   C Code                                                                  *
*                                                                           *
*       void IMG_mad_16x16                                                  *
*       (                                                                   *
*           const unsigned char *restrict refImg,                           *
*           const unsigned char *restrict srcImg,                           *
*           int pitch,                                                      *
*           unsigned int *restrict match,                                   *
*           int h, int v                                                    *
*       )                                                                   *
*       {                                                                   *
*           int i, j, x, y, matx, maty;                                     *
*           unsigned matpos, matval;                                        *
*                                                                           *
*           matval = ~0U;                                                   *
*           matx   = maty = 0;                                              *
*                                                                           *
*           for (x = 0; x < h; x++)                                         *
*               for (y = 0; y < v; y++)                                     *
*               {                                                           *
*                   unsigned acc = 0;                                       *
*                                                                           *
*                   for (i = 0; i < 16; i++)                                *
*                       for (j = 0; j < 16; j++)                            *
*                           acc += abs(srcImg[i*16 + j]                     *
*                               - refImg[(i+y)*pitch + x + j]);             *
*                                                                           *
*                   if (acc < matval)                                       *
*                   {                                                       *
*                       matval = acc;                                       *
*                       matx   = x;                                         *
*                       maty   = y;                                         *
*                   }                                                       *
*               }                                                           *
*                                                                           *
*           matpos = (0xffff0000 & (matx << 16)) | (0x0000ffff & maty);     *
*           match[0] = matpos;                                              *
*           match[1] = matval;                                              *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Every inner loop iteration computes 4 pixel differences each for    *
*       two vertically adjacent search locations. 4 iterations are          *
*       therefore required to compute one line and 4*16=64 iterations       *
*       to compute the complete SADs of the two search locations.           *
*       Delay slot stuffing and outer loop branch overhead is minimized.    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       v must be a multiple of 2.                                          *
*       srcImg and refImg do not alias in memory                            *
*       No special alignment of src_data or ref_data is expected.           *
*                                                                           *
*   MEMORY NOTE                                                             *
*       At most one bank conflict can occurr over the whole kernel. No      *
*       special alignment of data arrays is expected. This is because the   *
*       src and ref pixels do not parallelize in their loads.               *
*                                                                           *
*   NOTES                                                                   *
*       This code is Little Endian.                                         *
*       This code masks interrupts for nearly its entire duration.          *
*       As a result, the code is interrupt-tolerant, but not                *
*       interruptible.                                                      *
*                                                                           *
*   CYCLES                                                                  *
*       (63 * 7 + 22) * h * v / 2 + 21 = 463 * h * v / 2 + 21               *
*                                                                           *
*       Example: h= 4, v= 4:   3,725 cycles                                 *
*                h=64, v=32: 474,133 cycles                                 *
*                                                                           *
*   CODESIZE                                                                *
*       832 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_mad_16x16"
        .global _IMG_mad_16x16
_IMG_mad_16x16:
; parameters: A_refImg, B_srcImg, A_pitch, B_h, A_v, B_motvec
;             A4,       B4,       A6,      B6,  A8,  B8

        .asg            B6,         B_motvec
        .asg            A8,         A_h
        .asg            B8,         B_v

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_refImg
        .asg            B4,         B_srcImg
        .asg            A6,         A_pitch
        .asg            A7,         A_srcImg
        .asg            B7,         B_refImg
        .asg            A4,         A_refImg1
        .asg            B9,         B_srcImg_
        .asg            B5,         B_matchi0
        .asg            A5,         A_matchi1
        .asg            B13,        B_i2
        .asg            A2,         A_i
        .asg            A1,         A_vl
        .asg            A10,        A_bptch
        .asg            A11,        A_vptch
        .asg            B10,        B_hl
        .asg            B2,         B_ml
        .asg            A12,        A_vl1
        .asg            A2,         A_vl1c
        .asg            B12,        B_matval
        .asg            A13,        A_matpos
        .asg            A14,        A_ffff
        .asg            A15,        A_patch
        .asg            B14,        B_pitch_16
        .asg            A3,         A_w
        .asg            A8,         A_srcIm0
        .asg            A0,         A_img_ip0
        .asg            A4,         A_refImg1
; ============================================================================

        .asg            B9,         B_csr
        .asg            B7,         B_csr2


        STW     .D2     B14,    *B15--[14]
||      MV      .S1     A8,     A_vl                          ;vert loop v .. 1
||      MV      .L1X    B6,     A_h
||      MV      .L2X    A8,     B_v
||      MV      .S2     B8,     B_motvec

        STW     .D2     A15, *+B15[5]                         ;a15->
||      MV      .L1X    B15,   A15
||      MVC     .S2     CSR,    B_csr                         ;Disable GIE bit

        STW     .D2     B13, *+B15[1]
||      STW     .D1     A14, *+A15[6]                         ;a14->
||      ADD     .S1X    B_v,       14,          A_w
||      AND     .L2     B_csr, -2, B_csr2

        MVK     .S1     -1,         A_ffff
||      STW     .D2     B12, *+B15[2]
||      STW     .D1     A13, *+A15[7]
||      ZERO    .L1     A_matpos
||      MV      .L2X    A_refImg,   B_refImg                 ; copy to B side
||      MVC     .S2     B_csr2,    CSR

;-
        STW     .D2     B11, *+B15[3]
||      STW     .D1     A12, *+A15[8]
||      ADD     .L1     A_refImg,   A_pitch,    A_refImg1    ; refImg[pitch]
||      MV      .S1X    B_v,        A_vl1                    ; master loop ctr

        MPY     .M1     A_w,        A_pitch,    A_vptch      ; w*pitch
||      STW     .D2     B10, *+B15[4]
||      STW     .D1     A11, *+A15[9]
||      SHRU    .S1     A_ffff,     16,         A_ffff       ; 0x0000FFFF

;-
        MPY     .M1     14,          A_pitch,    A_bptch     ; bptch = 6*pitch
||      STW     .D2T1   A10, *+B15[10]
||      STW     .D1T2   B3,  *+A15[11]
||      OR      .S2     -1,         B_matval,   B_matval     ; 0xFFFFFFFF
||      ADD     .L1     -2,         A_vl,       A_vl         ; if (vl) vl-=2
||      SUB     .L2X    A_pitch,    16,         B_pitch_16    ; pitch -16

        ADD     .L1     -1,         A_vptch,    A_vptch      ; vptch--
||      MPY     .M2X    A_h,        B_v,        B_ml         ; from h*v .. 1
||      ZERO    .L2     B_hl,                                ; horiz 0 .. h
||      STW     .D2T2   B_csr,  *+B15[12]
||      STW     .D1T1   A_vl1,  *+A15[13]                    ; for reset
||      MV      .S1     A_vl1,      A_vl1c

m_loop:
  [A_vl1c]MPY   .M1     1, A_vl1c,  A_vl1                   ; squash reset
||[!A_vl]MV     .D1     A_vptch,    A_patch                 ; (!vl) patch = vptch
||[!A_vl]MV     .S1     A_vl1,      A_vl                    ; (!vl) vl = V
||       LDBU   .D2T1   *B_srcImg,         A_srcIm0         ; src0 (even)
||[A_vl] MV     .L1     A_bptch,    A_patch                 ; patch = bptch

        MVK     .S1     252,         A_i                    ; i  = 256 - 4
||      ZERO    .S2     B_i2                                ; i2 = 0
||      ZERO    .L2     B_matchi0                           ; matchi0 = 0
||      ADD     .D2     B_srcImg,   1,          B_srcImg_   ; src[1]
||      ADD     .L1X    B_srcImg,   2,          A_srcImg    ; src[0]
||      LDBU    .D1T1   *A_refImg1++,           A_img_ip0   ; ref10
        ;==== Branch occurs

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A7,         A_srcImg
        .asg            B7,         B_refImg
        .asg            A4,         A_refImg1
        .asg            B9,         B_srcImg_
        .asg            B5,         B_matchi0
        .asg            A5,         A_matchi1
        .asg            B13,        B_i2
        .asg            A2,         A_i
        .asg            B14,        B_pitch_16
        .asg            A8,         A_srcIm0
        .asg            B3,         B_img_i0
        .asg            A0,         A_img_ip0
        .asg            B0,         B_s0
        .asg            B0,         B_p0
        .asg            A0,         A_t0
        .asg            A0,         A_p0
        .asg            B8,         B_srcIm1
        .asg            B3,         B_img_i1
        .asg            A3,         A_img_ip1
        .asg            B3,         B_s1
        .asg            B0,         B_p1
        .asg            A3,         A_t1
        .asg            A0,         A_p1
        .asg            A9,         A_srcIm2
        .asg            B8,         B_img_i2
        .asg            A3,         A_img_ip2
        .asg            B3,         B_s2
        .asg            B3,         B_p2
        .asg            A3,         A_t2
        .asg            A0,         A_p2
        .asg            B11,        B_srcIm3
        .asg            B8,         B_img_i3
        .asg            A8,         A_img_ip3
        .asg            B0,         B_s3
        .asg            B3,         B_p3
        .asg            A3,         A_t3
        .asg            A9,         A_p3
        .asg            B1,         B_ro
; ============================================================================
; START:
; ============================ PIPE LOOP PROLOG ==============================
; PROLOG:

        ADD     .L2     B_i2,       4,          B_i2            ; i2 += 4
||      LDBU    .D1T1   *A_refImg1++,           A_img_ip1       ; ref11
||      B       .S1      L_5 +  8                               ;
||      ZERO    .L1     A_matchi1                               ; matchi1 = 0

        LDBU    .D2T2   *B_srcImg_++[2],        B_srcIm1        ; src1 (odd)
||      LDBU    .D1T1   *A_srcImg++[2],         A_srcIm2        ; src2 ( even)
||      B       .S1      L_6 + 4                                ;

        LDBU    .D2T2   *B_srcImg_++[2],        B_srcIm3        ; src3(odd)
||      AND     .S2     15,          B_i2,      B_ro            ; (i2>15) ro = 1

        LDBU    .D1T1   *A_refImg1++,           A_img_ip2       ; ref12
||      LDBU    .D2T2   *B_refImg++,            B_img_i0        ; ref00
||      B       .S2      LOOP_X                                 ;

        SUB     .S1     A_img_ip0,  A_srcIm0,   A_t0            ; t0 =ref10-src00
||      LDBU    .D1T1   *A_refImg1++,           A_img_ip3       ; ref13
||      LDBU    .D2T2   *B_refImg++,            B_img_i1        ; ref01

  [!B_ro]ADD    .S1X    A_refImg1,  B_pitch_16, A_refImg1       ; refImg1 -=pitch16
||      LDBU    .D1T1   *A_srcImg++[2],         A_srcIm0        ; src0 (even)


; ============================ PIPE LOOP KERNEL ==============================
LOOP_X:

  [ A_i]SUB     .D1     A_i,        4,          A_i             ; (i) i-=4
||      ABS     .L1     A_t2,       A_p2                        ; p1=abs(t0)
||      SUB     .S1X    A_img_ip3,  B_srcIm3,   A_t3            ; t0=ref13-src3
||      ABS     .L2     B_s0,       B_p0                        ; p0=abs(s0)
||      LDBU    .D2T2   *B_srcImg_++[2],        B_srcIm3        ; src3(odd)
||      AND     .S2     15,          B_i2,      B_ro            ; if(i2>15)ro = 1

        ADD     .L2     B_p0,       B_matchi0,  B_matchi0       ; matchi0+= p0
||      ADD     .L1     A_p2,       A_matchi1,  A_matchi1       ; matchi1+= p1
||      SUB     .S2     B_img_i1,   B_srcIm1,   B_s1            ; s0=ref01 - src1
||[ A_i]B       .S1     LOOP_X                                  ; if(i)B LOOP
||      LDBU    .D1T1   *A_refImg1++,           A_img_ip2       ; ref12
||      LDBU    .D2T2   *B_refImg++,            B_img_i0        ; ref00

        ABS     .L1     A_t3,       A_p3                        ; p1=abs(t0)
||      ABS     .L2     B_s1,       B_p1                        ; p0=abs(s0)
||      SUB     .S2X    B_img_i2,   A_srcIm2,   B_s2            ; s0=ref02-src
||      SUB     .S1     A_img_ip0,  A_srcIm0,   A_t0            ; t0=ref10-src00
||      LDBU    .D1T1   *A_refImg1++,           A_img_ip3       ; ref13
||      LDBU    .D2T2   *B_refImg++,            B_img_i1        ; ref01

        ADD     .L1     A_p3,       A_matchi1,  A_matchi1       ; matchi1+=p1
||      ABS     .L2     B_s2,       B_p2                        ; p0=abs(s0)
||      SUB     .S2     B_img_i3,   B_srcIm3,   B_s3            ; s0=ref03-src3
||      ADD     .D2     B_p1,       B_matchi0,  B_matchi0       ; matchi0+=p0
||[!B_ro]ADD    .S1X    A_refImg1,  B_pitch_16, A_refImg1       ; (!ro)ref+=p16
||[A_i]  LDBU    .D1T1   *A_srcImg++[2],        A_srcIm0        ; src0(even)

L_5:
        ABS     .L2     B_s3,       B_p3                        ; p0=abs(s0)
||      ADD     .S2     B_p2,       B_matchi0,  B_matchi0       ; matchi0 +=p0
||      ABS     .L1     A_t0,       A_p0                        ; p1=abs(t0)
||      SUB     .S1X    A_img_ip1,  B_srcIm1,   A_t1            ; t0=ref11-src1
||      LDBU    .D2T2   *B_refImg++,            B_img_i2        ; ref02
||[A_i] LDBU    .D1T1   *A_refImg1++,           A_img_ip0       ; ref10

L_6:
        ADD     .S2     B_p3,       B_matchi0,  B_matchi0       ; matchi0+=p0
||      ADD     .S1     A_p0,       A_matchi1,  A_matchi1       ; matchi1+=p1
||      ABS     .L1     A_t1,       A_p1                        ; p1=abs(t0)
||      LDBU    .D2T2   *B_refImg++,            B_img_i3        ; ref03
||[A_i] ADD     .L2     B_i2,       4,          B_i2            ; i2+=4
||[A_i] LDBU    .D1T1   *A_refImg1++,           A_img_ip1       ; ref11

L_7:    ADD     .L1     A_p1,       A_matchi1,  A_matchi1       ; matchi1 +=p1
||      SUB     .S1     A_img_ip2,  A_srcIm2,   A_t2            ; t0=ref12-src
||[!B_ro]ADD    .S2     B_refImg,   B_pitch_16, B_refImg        ; (!ro)rmg+=pitch16
||      SUB     .L2X    B_img_i0,   A_srcIm0,   B_s0            ; s0 = ref00-src00
||[A_i] LDBU    .D2T2   *B_srcImg_++[2],        B_srcIm1        ; src1(odd)
||[A_i] LDBU    .D1T1   *A_srcImg++[2],         A_srcIm2        ; src2(even)

; ============================ PIPE LOOP EPILOG ==============================

  [ A_i]SUB     .D1     A_i,        4,          A_i             ;if (i) i-=4
||      ABS     .L1     A_t2,       A_p2                        ;p1 = abs(t0)
||      SUB     .S1X    A_img_ip3,  B_srcIm3,   A_t3            ;t0 = ref13 - src3
||      ABS     .L2     B_s0,       B_p0                        ;p0 = abs(s0)

        ADD     .L2     B_p0,       B_matchi0,  B_matchi0       ;matchi0 += p0
||      ADD     .L1     A_p2,       A_matchi1,  A_matchi1       ;matchi1 += p1
||      SUB     .S2     B_img_i1,   B_srcIm1,   B_s1            ;s0 = ref01 - src1

        ABS     .L1     A_t3,       A_p3                        ;p1 = abs(t0)
||      ABS     .L2     B_s1,       B_p1                        ;p0 = abs(s0)
||      SUB     .S2X    B_img_i2,   A_srcIm2,   B_s2            ;s0 = ref02 - src

        ADD     .L1     A_p3,       A_matchi1,  A_matchi1       ;matchi1 += p1
||      ABS     .L2     B_s2,       B_p2                        ;p0 = abs(s0)
||      SUB     .S2     B_img_i3,   B_srcIm3,   B_s3            ;s0 = ref03 - src3
||      ADD     .D2     B_p1,       B_matchi0,  B_matchi0       ;matchi0  +=p0

        ABS     .L2     B_s3,       B_p3                        ;p0 = abs(s0)
||      ADD     .S2     B_p2,       B_matchi0,  B_matchi0       ;matchi0 +=p0
||[ B_ml]ADD    .D2     -2,         B_ml,       B_ml            ;if (!ml) ml-=2

        ADD     .S2     B_p3,       B_matchi0,  B_matchi0       ;matchi0 += p0
||[ B_ml]B      .S1     m_loop                                  ;if (!ml) B m_loop

; ============================================================================
; END:

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B7,         B_refImg                    ;
        .asg            A15,        A_patch                     ;
        .asg            A4,         A_refImg1                   ;
        .asg            A12,        A_vl1                       ;
        .asg            B10,        B_hl                        ;
        .asg            B5,         B_matchi0                   ;
        .asg            A14,        A_ffff                      ;
        .asg            A13,        A_matpos                    ;
        .asg            A5,         A_matchi1                   ;
        .asg            B2,         B_ml                        ;
        .asg            B12,        B_matval                    ;
        .asg            A3,         A_vl1t                      ;
        .asg            A2,         A_vl1c                      ;
        .asg            B13,        B_hlt                       ;
        .asg            B1,         B_best                      ;
        .asg            A3,         A_subtract                  ;
; ============================================================================

        ADD     .L1     -1,         A_vl1,      A_vl1           ;[ 9,0]
||      CMPLTU  .L2     B_matchi0,  B_matval,   B_best          ;[ 9,0]
||      LDW     .D2T1   *+B15[13],  A_vl1                       ; spec. reset

  [ B_best]AND  .L1     A_ffff,     A_vl1,      A_vl1t          ;[10,0]
||[ B_best]MV   .D2     B_matchi0,  B_matval                    ;[10,0]
||      SHL     .S2     B_hl,       16,         B_hlt           ;[10,0]

        ADD     .S1     -1,         A_vl1,      A_vl1           ;[11,0]
||[ B_best]OR   .L1X    A_vl1t,     B_hlt,      A_matpos        ;[11,0]
||      CMPLTU  .L2X    A_matchi1,  B_matval,   B_best          ;[11,0]

        MV      .D1     A_vl1,      A_vl1c                      ;[12,0]
||[ B_best]AND  .L1     A_ffff,     A_vl1,      A_vl1t          ;[12,0]
||[ B_best]MV   .L2X    A_matchi1,  B_matval                    ;[12,0]
||        ADD   .S1     -2,         A_vl,       A_vl            ;if (vl) vl-=2

  [!A_vl1c]ADD  .L2     1,          B_hl,       B_hl            ;[13,0]
||[ B_best]OR   .L1X    A_vl1t,     B_hlt,      A_matpos        ;[13,0]
||      SUB     .D1     A_refImg1,  A_patch,    A_refImg1       ;[13,0]
||      SUB     .S2X    B_refImg,   A_patch,    B_refImg        ;[13,0]

        ;==== Branch occurs
        LDW     .D2T2   *+B15[11],      B3
||      MV      .S1     A_vl1,          A_subtract
||      AND     .L1     A_matpos,       A_ffff, A_vl

        LDW     .D2T1   *+B15[6],A14
||      MV              B15,   A15
||      SHL     .S1     A_ffff,         16,     A_ffff

        LDW     .D2     *+B15[4],B10
||      LDW     .D1     *+A15[9],A11;
||      SUB     .L1     A_subtract,     1,      A_subtract

        LDW     .D2     *+B15[3],B11
||      LDW     .D1     *+A15[10],A10
||      SUB             A_subtract,     A_vl,   A_vl
||      AND             A_matpos,       A_ffff, A_matpos

        LDW     .D2     *+B15[1],B13
||      LDW     .D1     *+A15[8],A12
||      ADD             A_matpos,       A_vl,   A_matpos

        LDW     .D2     *+B15[5],A15
||      LDW     .D1     *+A15[12],B8

        LDW     .D2     *+B15[2],B12
||      LDW     .D1     *+A15[7],A13

        LDW     .D2     *++B15[14],B14
||      RET     .S2     B3

        STW     .D2T1   A_matpos,   *B_motvec++

        STW     .D2T2   B_matval,   *B_motvec++

        MVC     .S2     B8,         CSR

        NOP             2

* ========================================================================= *
*   End of file:  img_mad_16x16.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
mad_8x8.asm/    1066929161  0     0     0       33597     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.19    Sun Sep 29 03:31:26 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mad_8x8  - 8x8 Minimum Absolute Differences                     *
*                                                                           *
*   REVISION DATE                                                           *
*       03-Jan-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_mad_8x8                                                    *
*       (                                                                   *
*           const unsigned char *restrict refImg,                           *
*           const unsigned char *restrict srcImg,                           *
*           int pitch,                                                      *
*           int                 h,                                          *
*           int                 v,                                          *
*           unsigned            *restrict match                             *
*       )                                                                   *
*                                                                           *
*       refImg          Reference image.                                    *
*       srcImg[64]      8x8 block image to look for.                        *
*       pitch           Width of reference image.                           *
*       h               Horiz. size of search area.                         *
*       v               Vert.  size of search area.                         *
*                       Must be multiple of 2.                              *
*       match[2]        Result:                                             *
*                           match[0] is packed x, y.                        *
*                           match[1] is MAD value.                          *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine returns the location of the minimum absolute           *
*       difference between a 8x8 search block and some block in a           *
*       (h + 8) x (v + 8) search area. h and v are the sizes of the         *
*       search space for the top left coordinate of the search block.       *
*       refImg points to the top left pixel of the search area.             *
*                                                                           *
*            (0,0)          (h,0)      (h+8,0)                              *
*              ;--------------+--------;                                    *
*              ;    search    |        ;                                    *
*              ;    space     |        ;                                    *
*              ;              |        ;        search area                 *
*              ;--------------+        ;        within reference image      *
*            (0,v)          (h,v)      ;                                    *
*              ;                       ;                                    *
*              ;-----------------------;                                    *
*            (0, v+8)                 (v+8,h+8)                             *
*                                                                           *
*       The location is returned relative to the above coordinate system    *
*       as x and y packed in two 16-bit quantities in a 32-bit word:        *
*                                                                           *
*                   31             16 15             0                      *
*                   +----------------+----------------+                     *
*        match[0]:  |       x        |       y        |                     *
*                   +----------------+----------------+                     *
*                                                                           *
*                   31                               0                      *
*                   +---------------------------------+                     *
*        match[1]:  |   SAD value at location x, y    |                     *
*                   +---------------------------------+                     *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       void IMG_mad_8x8                                                    *
*       (                                                                   *
*           const unsigned char *restrict refImg,                           *
*           const unsigned char *restrict srcImg,                           *
*           unsigned int pitch,                                             *
*           unsigned int h,                                                 *
*           unsigned int v,                                                 *
*           unsigned int *restrict match                                    *
*       )                                                                   *
*       {                                                                   *
*           int    i,         j,        x,     y;                           *
*           int              matx,      maty;                               *
*           unsigned int     matpos,    matval;                             *
*                                                                           *
*           matval  =   ~0U;               // init. set to MAXPOS           *
*           matx = maty = 0;                                                *
*                                                                           *
*           for (x = 0; x < h ; x++)                                        *
*           {                                                               *
*               for (y = 0; y < v ; y++)                                    *
*               {                                                           *
*                   unsigned acc = 0;                                       *
*                                                                           *
*                   for (i = 0; i < 8; i++)                                 *
*                   {                                                       *
*                       for (j = 0; j < 8; j++)                             *
*                       {                                                   *
*                            acc += abs(srcImg[i*8 + j]                     *
*                                - refImg[(i+y)*pitch + x + j]);            *
*                       }                                                   *
*                   }                                                       *
*                                                                           *
*                   if (acc < matval)                                       *
*                   {                                                       *
*                       matval = acc;                                       *
*                       matx   = x;                                         *
*                       maty   = y;                                         *
*                   }                                                       *
*               }                                                           *
*           }                                                               *
*                                                                           *
*                                                                           *
*           matpos   = (0xffff0000 & (matx << 16)) | (0x0000ffff & maty);   *
*           match[0] = matpos;                                              *
*           match[1] = matval;                                              *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Every inner loop iteration computes 4 pixel differences each for    *
*       two vertically adjacent search locations. 4 iterations are          *
*       therefore required to compute one line and 4*16=64 iterations       *
*       to compute the complete SADs of the two search locations.           *
*       Delay slot stuffing and outer loop branch overhead is minimized.    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       v must be a multiple of 2.                                          *
*       srcImg and refImg do not alias in memory                            *
*       No special alignment of srcImg or refImg is expected.               *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The least number of bank conflicts (every 2 iterations of the       *
*       loop) occur if pitch is a multiple of 8.                            *
*       No special alignment of data arrays is expected. This is because    *
*       the src and ref pixels do not parallelize in their loads.           *
*                                                                           *
*   NOTES                                                                   *
*       This code is Little Endian.                                         *
*       This code masks interrupts for nearly its entire duration.          *
*       As a result, the code is interrupt-tolerant, but not                *
*       interruptible.                                                      *
*                                                                           *
*   CYCLES                                                                  *
*       h * v / 2 * (22 + 15 * 7.5) = 134.5 * h * v / 2                     *
*       (assuming pitch is a multiple of 8)                                 *
*                                                                           *
*       For h = 64, v = 32, cycles = 137,728                                *
*                                                                           *
*   CODESIZE                                                                *
*       864 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_mad_8x8"
        .global _IMG_mad_8x8
_IMG_mad_8x8:

; ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
; ========================================================================= ;
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T1   A15,        *B_SP--[14]             ; Get stk, Save A15
||      MV              B_SP,       A_SP                    ; Twin Stack Ptr

        STW     .D1T1   A14,        *-A_SP[ 2]              ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]              ; Save B14
||      MVC     .S2     CSR,        B_csr                   ; Get CSR's state

        STW     .D1T1   A13,        *-A_SP[ 4]              ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]              ; Save B13
||      AND             B_csr,      -2,         B_no_gie    ; Clear GIE
;-
        STW     .D1T1   A12,        *-A_SP[ 6]              ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]              ; Save B12
||      MV      .L1X    B_csr,      A_csr                   ; Partitioning MV


; ===== Interrupts masked here =====
;-
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_refImg
        .asg            B4,         B_srcImg
        .asg            A6,         A_pitch
        .asg            B6,         B_h
        .asg            A8,         A_v
        .asg            B8,         B_motvec
        .asg            A5,         A_srcImg
        .asg            B11,        B_refImg
        .asg            A3,         A_refImg1
        .asg            B10,        B_srcImg_
        .asg            B12,        B_matchi0
        .asg            A0,         A_matchi1
        .asg            B2,         B_i2
        .asg            A2,         A_i
        .asg            B3,         B_pitch_16
        .asg            A1,         A_vl
        .asg            A6,         A_bptch
        .asg            A11,        A_vptch
        .asg            B1,         B_ml
        .asg            A12,        A_vl1
        .asg            B13,        B_matval
        .asg            A13,        A_matpos
        .asg            A14,        A_ffff
        .asg            A15,        A_patch
        .asg            B14,        B_hl
        .asg            A7,         A_w
* ========================================================================= *
        ADD     .L1     A_v,        6,          A_w       ; v + 6
||      STW     .D1T1   A_csr,      *-A_SP[12]            ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]            ; Save return addr.
||      MV      .S1     A_v,        A_vl                  ; v .. 1
||      OR      .S2     -1,         B_matval,   B_matval  ; 0xFFFFFFFF

        SUB     .L2X    A_pitch,    8,          B_pitch_16; pitch - 8
||      MPY     .M1     A_w,        A_pitch,    A_vptch   ; w*pitch
||      ZERO    .L1     A_matpos                          ; matpos = 0
||      STW     .D1T1   A10,        *-A_SP[10]            ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]            ; Save B10
||      MVC     .S2     B_no_gie,   CSR                   ; Disable ints.
||      MVK     .S1     -1,         A_ffff                ;
||      MPY     .M2     B_i2,       0,          B_i2      ; i2 = 0

        ADD     .L1     A_refImg,   A_pitch,    A_refImg1 ; refImg[pitch]
||      MPY     .M1     6,          A_pitch,    A_bptch   ; 6*pitch
||      SHRU    .S1     A_ffff,     16,         A_ffff    ; 0x0000FFFF
||      STW     .D1T1   A11,        *-A_SP[ 8]            ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]            ; Save B11

        MV      .L2X    A_refImg,   B_refImg              ; copy B
||      MV      .D1     A_v,        A_vl1                 ; copy
||      ADD     .S1     -1,         A_vptch,    A_vptch   ; vptch--

m_loop:
        MV      .L1     A_bptch,    A_patch               ; patch = bptch
||      ADD     .D1     -2,         A_vl,       A_vl      ; if (vl) vl-=2
||      MVK     .S1     56,         A_i                   ; i  = 64
||      MPY     .M2X    B_h,        A_v,        B_ml      ; h*v .. 1

        B      .S2     L_3 + 16                           ;
||      ZERO    .D2     B_hl                              ; 0 .. h

        B      .S2     L_4 + 20                           ;

        ;==== Branch occurs

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A5,         A_srcImg
        .asg            B11,        B_refImg
        .asg            A3,         A_refImg1
        .asg            B10,        B_srcImg_
        .asg            B12,        B_matchi0
        .asg            A0,         A_matchi1
        .asg            B2,         B_i2
        .asg            A2,         A_i
        .asg            B3,         B_pitch_16
        .asg            A4,         A_srcIm0
        .asg            B7,         B_img_i0
        .asg            A9,         A_img_ip0
        .asg            B7,         B_s0
        .asg            B7,         B_p0
        .asg            A4,         A_t0
        .asg            A9,         A_p0
        .asg            B9,         B_srcIm1
        .asg            B5,         B_img_i1
        .asg            A9,         A_img_ip1
        .asg            B7,         B_s1
        .asg            B5,         B_p1
        .asg            A4,         A_t1
        .asg            A9,         A_p1
        .asg            A7,         A_srcIm2
        .asg            B5,         B_img_i2
        .asg            A10,        A_img_ip2
        .asg            B0,         B_s2
        .asg            B5,         B_p2
        .asg            A7,         A_t2
        .asg            A9,         A_p2
        .asg            B5,         B_srcIm3
        .asg            B7,         B_img_i3
        .asg            A9,         A_img_ip3
        .asg            B9,         B_s3
        .asg            B5,         B_p3
        .asg            A10,        A_t3
        .asg            A9,         A_p3
        .asg            B0,         B_ro
        .asg            B0,         B_bst
* =========================== PIPE LOOP PROLOG ============================ *
m_loop_new:
        ADD     .S2     B_i2,       4,          B_i2      ;[ 1,1] i2 += 4
||      B       .S1     L_5 + 12                          ;
||[!A_vl]MV     .L1     A_vptch,    A_patch               ;[ 8,0] patch = vptch

        B       .S1      L_6 + 12                         ;
||      ZERO    .D1     A_matchi1                         ;[ 9,0] matchi1 = 0
||      ZERO    .L2     B_matchi0                         ;[ 9,0] matchi0 = 0
||      ADD     .D2     B_srcImg,   1,          B_srcImg_ ;[ 9,0] src[1]
||      MV      .L1X    B_srcImg,   A_srcImg              ;[ 9,0] src[0]

        LDBU    .D1T1   *A_srcImg++[2],         A_srcIm0  ;[ 3,1] src0 (even)
||      B       .S1      L_7 + 12                         ;
||[!A_vl]MV     .L1     A_v,        A_vl                  ;[ 8,0] vl = V

        LDBU    .D2T2   *B_refImg++,            B_img_i0  ;[ 4,1] ref00
||      B       .S1      LOOP_X                           ;
||      ZERO    .L1     A_t3                              ;
||      ZERO    .D1     A_p2                              ;
||      ZERO    .L2     B_p3                              ;

* =========================== PIPE LOOP KERNEL ============================ *
LOOP_X:
L_1:
        ABS     .L1     A_t3,       A_p3                  ;[17,1] p1 = abs(t0)
||      ADD     .S2     B_p3,       B_matchi0,  B_matchi0 ;[17,1] matchi0 += p0
||      ADD     .S1     A_p2,       A_matchi1,  A_matchi1 ;[17,1] matchi1 += p1
||      LDBU    .D2T2   *B_srcImg_++[2],        B_srcIm3  ;[10,2] src3(odd)
||      ABS     .L2     B_s0,       B_p0                  ;[10,2] p0 = abs(s0)
||      LDBU    .D1T1   *A_srcImg++[2],         A_srcIm0  ;[ 3,3] src0 (even)

L_2:
  [ A_i]B       .S1     LOOP_X                            ;[18,1] if (i) B LOOP
||      ADD     .L1     A_p3,       A_matchi1,  A_matchi1 ;[18,1] matchi1 += p1
||      LDBU    .D1T1   *A_refImg1++,           A_img_ip3 ;[11,2] ref13
||      SUB     .S2     B_img_i1,   B_srcIm1,   B_s1      ;[11,2] ref01 - src1
||      ADD     .L2     B_p0,       B_matchi0,  B_matchi0 ;[11,2] matchi0 += p0
||      LDBU    .D2T2   *B_refImg++,            B_img_i0  ;[ 4,3] ref00

L_3:
  [!B_ro]ADD    .L1X    A_refImg1,  B_pitch_16, A_refImg1 ;[12,2]
||      SUB     .S2X    B_img_i2,   A_srcIm2,   B_s2      ;[12,2] ref02 - src
||      ABS     .L2     B_s1,       B_p1                  ;[12,2] abs(s0)
||      SUB     .S1     A_img_ip0,  A_srcIm0,   A_t0      ;[12,2] ref10 - src00
||      LDBU    .D1T1   *A_srcImg++[2],         A_srcIm2  ;[ 5,3] src2 ( even)
||      LDBU    .D2T2   *B_srcImg_++[2],        B_srcIm1  ;[ 5,3] src1 (odd)

L_4:
  [ A_i]SUB     .D1     A_i,        4,          A_i       ;[13,2] if (i) i-=4
||      ABS     .L2     B_s2,       B_p2                  ;[13,2] p0 = abs(s0)
||      SUB     .S1X    A_img_ip1,  B_srcIm1,   A_t1      ;[13,2] ref11 - src1
||      ADD     .S2     B_p1,       B_matchi0,  B_matchi0 ;[13,2] matchi0  +=p0
||      ABS     .L1     A_t0,       A_p0                  ;[13,2] p1 = abs(t0)
||      LDBU    .D2T2   *B_refImg++,            B_img_i1  ;[ 6,3] ref01

L_5:
        ADD     .L2     B_p2,       B_matchi0,  B_matchi0 ;[14,2] matchi0 +=p0
||      ABS     .L1     A_t1,       A_p1                  ;[14,2] p1 = abs(t0)
||      ADD     .S1     A_p0,       A_matchi1,  A_matchi1 ;[14,2] matchi1 += p1
||      AND     .S2     7,          B_i2,       B_ro      ;[ 7,3] ro = 1
||      LDBU    .D2T2   *B_refImg++,            B_img_i2  ;[ 7,3] ref02
||      LDBU    .D1T1   *A_refImg1++,           A_img_ip0 ;[ 7,3] ref10

L_6:
        SUB     .L2     B_img_i3,   B_srcIm3,   B_s3      ;[15,2] ref03 - src3
||      SUB     .S1     A_img_ip2,  A_srcIm2,   A_t2      ;[15,2] ref12 - src
||      ADD     .L1     A_p1,       A_matchi1,  A_matchi1 ;[15,2] matchi1 +=p1
||      LDBU    .D2T2   *B_refImg++,            B_img_i3  ;[ 8,3] ref03
||      LDBU    .D1T1   *A_refImg1++,           A_img_ip1 ;[ 8,3] ref11
||      ADD     .S2     B_i2,       4,          B_i2      ;[ 1,4] i2 += 4

L_7:
        SUB     .S1X    A_img_ip3,  B_srcIm3,   A_t3      ;[16,2] ref13 - src3
||      ABS     .L2     B_s3,       B_p3                  ;[16,2] p0 = abs(s0)
||      ABS     .L1     A_t2,       A_p2                  ;[16,2] p1 = abs(t0)
||[!B_ro]ADD    .D2     B_refImg,   B_pitch_16, B_refImg  ;[ 9,3] rmg+=pitch16
||      LDBU    .D1T1   *A_refImg1++,           A_img_ip2 ;[ 9,3] ref12
||      SUB     .S2X    B_img_i0,   A_srcIm0,   B_s0      ;[ 9,3] ref00 - src00

* =========================== PIPE LOOP EPILOG ============================ *

        ABS     .L1     A_t3,       A_p3                  ;[17,3] p1 = abs(t0)
||      ADD     .S2     B_p3,       B_matchi0,  B_matchi0 ;[17,3] matchi0 += p0
||      ADD     .S1     A_p2,       A_matchi1,  A_matchi1 ;[17,3] matchi1 += p1
||      LDBU    .D2T2   *B_srcImg_++[2],        B_srcIm3  ;[10,4] src3(odd)
||      ABS     .L2     B_s0,       B_p0                  ;[10,4] p0 = abs(s0)

        ADD     .L1     A_p3,       A_matchi1,  A_matchi1 ;[18,3] matchi1 += p1
||      LDBU    .D1T1   *A_refImg1++,           A_img_ip3 ;[11,4] ref13
||      SUB     .S2     B_img_i1,   B_srcIm1,   B_s1      ;[11,4] ref01 - src1
||      ADD     .L2     B_p0,       B_matchi0,  B_matchi0 ;[11,4] matchi0 += p0

  [!B_ro]ADD    .L1X    A_refImg1,  B_pitch_16, A_refImg1 ;[12,4]
||      SUB     .S2X    B_img_i2,   A_srcIm2,   B_s2      ;[12,4] ref02 - src
||      ABS     .L2     B_s1,       B_p1                  ;[12,4] p0 = abs(s0)
||      SUB     .S1     A_img_ip0,  A_srcIm0,   A_t0      ;[12,4] ref10 - src00
||[B_ml]ADD     .D2     -2,         B_ml,       B_ml      ;[11,0]

  [ A_i]SUB     .D1     A_i,        4,          A_i       ;[13,4] if (i) i-=4
||      ABS     .L2     B_s2,       B_p2                  ;[13,4] p0 = abs(s0)
||      SUB     .S1X    A_img_ip1,  B_srcIm1,   A_t1      ;[13,4] ref11 - src1
||      ADD     .S2     B_p1,       B_matchi0,  B_matchi0 ;[13,4] matchi0  +=p0
||      ABS     .L1     A_t0,       A_p0                  ;[13,4] p1 = abs(t0)

        ADD     .L2     B_p2,       B_matchi0,  B_matchi0 ;[14,4] matchi0 +=p0
||      ABS     .L1     A_t1,       A_p1                  ;[14,4] p1 = abs(t0)
||      ADD     .S1     A_p0,       A_matchi1,  A_matchi1 ;[14,4] matchi1 += p1

        SUB     .L2     B_img_i3,   B_srcIm3,   B_s3      ;[15,4] ref03 - src3
||      SUB     .S1     A_img_ip2,  A_srcIm2,   A_t2      ;[15,4] ref12 - src
||      ADD     .L1     A_p1,       A_matchi1,  A_matchi1 ;[15,4] matchi1 +=p1

        SUB     .S1X    A_img_ip3,  B_srcIm3,   A_t3      ;[16,4] ref13 - src3
||      ABS     .L2     B_s3,       B_p3                  ;[16,4] p0 = abs(s0)
||      ABS     .L1     A_t2,       A_p2                  ;[16,4] p1 = abs(t0)

        ABS     .L1     A_t3,       A_p3                  ;[17,4] p1 = abs(t0)
||      ADD     .S2     B_p3,       B_matchi0,  B_matchi0 ;[17,4] matchi0 += p0
||      ADD     .D1     A_p2,       A_matchi1,  A_matchi1 ;[17,4] matchi1 += p1
||[ B_ml]B      .S1     m_loop_new                        ;[12,0]

        ADD     .S1     A_p3,       A_matchi1,  A_matchi1 ;[18,4] matchi1 += p1
||      CMPLTU  .L2     B_matchi0,  B_matval,   B_bst     ;[13,0]
||      ADD     .L1     -1,         A_vl1,      A_vl1     ;[13,0]

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            B11,        B_refImg
        .asg            A15,        A_patch
        .asg            A3,         A_refImg1
        .asg            A12,        A_vl1
        .asg            B14,        B_hl
        .asg            B12,        B_matchi0
        .asg            A14,        A_ffff
        .asg            A13,        A_matpos
        .asg            A0,         A_matchi1
        .asg            B8,         B_motvec
        .asg            B1,         B_ml
        .asg            B13,        B_matval
        .asg            A4,         A_vl1t
        .asg            A8,         A_v
        .asg            A2,         A_vl1c
        .asg            B5,         B_hlt
        .asg            B0,         B_bst
        .asg            A2,         A_subtract
        .asg            A4,         A_vl2
        .asg            A2,         A_mat
        .asg            A2,         A_mat_new
* ========================================================================= *

  [ B_bst]AND   .L1     A_ffff,     A_vl1,      A_vl1t   ;
||[ B_bst]MV    .D2     B_matchi0,  B_matval             ;
||      SHL     .S2     B_hl,       16,         B_hlt    ;
||      SUB     .S1     A_refImg1,  A_patch,    A_refImg1;
||      SUB     .L2X    B_refImg,   A_patch,    B_refImg ;
||      ADD     .D1     -2,         A_vl,       A_vl     ; if (vl) vl-=2

  [ B_bst]OR    .L1X    A_vl1t,     B_hlt,      A_matpos ;
||      ADD     .S1     -1,         A_vl1,      A_vl1    ;
||      CMPLTU  .L2X    A_matchi1,  B_matval,   B_bst    ;
||[B_ml]ZERO    .D2     B_i2                             ; i2 = 0

        MV      .D1     A_vl1,      A_vl1c               ;
||[ B_bst]AND   .L1     A_ffff,     A_vl1,      A_vl1t   ;
||[ B_bst]MV    .L2X    A_matchi1,  B_matval             ;
||[B_ml]  B     .S2     L_3 + 16                         ;
||      MV      .S1     A_bptch,    A_patch              ; patch = bptch

  [ B_bst]OR    .L1X    A_vl1t,     B_hlt,      A_matpos ;
||[!A_vl1c]MV   .D1     A_v,        A_vl1                ;
||[!A_vl1c]ADD  .L2     1,          B_hl,       B_hl     ;
||      MVK     .S1     56,         A_i                  ; i  = 64
||[B_ml]  B     .S2     L_4 + 20                         ;

        ;==== Branch occurs                              ;

        MV      .S1X    B_SP,       A_SP        ; Twin Stack Pointer
||      SUB     .L1     A_v,        1,          A_subtract

        AND     .L1     A_matpos,   A_ffff,     A_vl2
||      SHL     .S1     A_ffff,     16,         A_ffff
||      LDW     .D1T2   *+A_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr       ; Get CSR's value

        SUB     .L1     A_subtract, A_vl2,      A_vl2
||      AND     .S1     A_matpos,   A_ffff,     A_mat
||      LDW     .D1T2   *+A_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10         ; Restore A10

        ADD     .L1     A_mat,      A_vl2,      A_mat_new
||      LDW     .D1T2   *+A_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11         ; Restore A11


        LDW     .D1T2   *+A_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12         ; Restore A12

        LDW     .D1T2   *+A_SP[ 9], B13         ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13         ; Restore A13

        LDW     .D1T2   *+A_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14         ; Restore A14
||      RET     .S2     B_ret                   ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
||      LDW     .D2T1   *++B_SP[14],A15         ; Restore A15

        STW     .D2T1   A_mat_new,  *B_motvec++

        STW     .D2T2   B_matval,   *B_motvec++

        NOP             2

        ;==== Branch occurs

* ========================================================================= *
*   End of file:  img_mad_8x8.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

median_3x3.asm/ 1066929161  0     0     0       30135     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Sun Sep 29 03:31:26 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*  TEXAS INSTRUMENTS, INC.                                                  *
*                                                                           *
*  NAME                                                                     *
*      IMG_median_3x3                                                       *
*                                                                           *
*                                                                           *
*  REVISION DATE                                                            *
*      31-Jan-2002                                                          *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_median_3x3                                                 *
*       (                                                                   *
*           unsigned char   *in_data,                                       *
*           int             cols,                                           *
*           unsigned char   *out_data                                       *
*       );                                                                  *
*                                                                           *
*       in_data  : Pointer to input array of unsigned chars                 *
*       cols     : Width of in_data                                         *
*       out_data : Pointer to output array of unsigned chars                *
*                                                                           *
*   DESCRIPTION                                                             *
*       The routine performs a 3x3 median filtering algorithm. It comes     *
*       under the class of non-linear signal processing algorithms.         *
*       Rather than replace the gray level at a pixel by a weighted         *
*       average of the nine pixels including and surrounding it, the gray   *
*       level at each pixel is replaced by the median of the nine values.   *
*       The median of a set of nine numbers is the middle element so that   *
*       half of the elements in the list are larger and half are smoother.  *
*       Median filtering removes the effect of extreme values from data.    *
*       Using a wide mask to reduce the effect of noise results in          *
*       unacceptable blurring of sharp edges in the original image.         *
*                                                                           *
*       void IMG_median_3x3()                                               *
*       {                                                                   *
*           read new vertical column of data into moving 3 column window    *
*                                                                           *
*           l00 = *IN1++;                                                   *
*           l10 = *IN2++;                                                   *
*           l20 = *IN3++;                                                   *
*                                                                           *
*           The data is pre-arranged as follows                             *
*               l00, l01, l02           MAX                                 *
*               l10, l11, l12           MED                                 *
*               l20, l21, l22           MIN                                 *
*                                                                           *
*           First sort l00,l10,l20 into MAX, MED, MIN                       *
*                                                                           *
*           Compare l00,l10 and sort into MAX, MIN                          *
*           Compare l10,l20 and sort into MAX, MIN                          *
*           Compare l00,l10 and sort into MAX, MIN                          *
*                                                                           *
*           3 compares and 6 moves                                          *
*           Now sort l00,l01,l02 to find out minimum of max                 *
*               sort l10,l11,l12 to find ot median of median                *
*               sort l20,l21,l22 to find out maximum of min                 *
*                                                                           *
*           Now sort these three values, the middle value                   *
*           of these three is the minimum.                                  *
*       }                                                                   *
*                                                                           *
*   C CODE                                                                  *
*       void IMG_median_3x3(unsigned char *in_data, int cols,               *
*                       unsigned char *out_data)                            *
*       {                                                                   *
*       unsigned char   * line0, * line1, *line2;                           *
*       int    l00_0, l01_0, l02_0, l10_0, l11_0, l12_0, l20_0, l21_0,      *
*              l22_0;                                                       *
*       int    l00_1, l10_1, l10_2, l10_3, l20_1, l20_2;                    *
*       int    t0_1, t1_1, t1_2;                                            *
*       int    i, minmax_0, maxmin_0, medmed_0;                             *
*       int    minmax_1, medmed_1, medmed_2, medmed_3;                      *
*                                                                           *
*       line0 = in_data;                                                    *
*       line1 = line0 + cols;                                               *
*       line2 = line1 + cols;                                               *
*                                                                           *
*       //    l00   l01  l02        max's           //                      *
*       //    l10   l11  l12        med's           //                      *
*       //    l20   l21  l22        min's           //                      *
*                                                                           *
*       l01_0 = l11_0 = l21_0 = 127;                                        *
*       l02_0 = l12_0 = l22_0 = 127;                                        *
*                                                                           *
*       minmax_0 = l02_0;                                                   *
*       maxmin_0 = l22_0;                                                   *
*                                                                           *
*       for (i = 0; i < cols; i++)                                          *
*       {                                                                   *
*            l00_0 = *line0++;                                              *
*            l10_0 = *line1++;                                              *
*            l20_0 = *line2++;                                              *
*                                                                           *
*            // sort l00_0, l10_0, l20_0                                    *
*                                                                           *
*            l20_1 = l20_0; l10_1 = l10_0;                                  *
*            if (l20_0 > l10_0) { l10_1 = l20_0;  l20_1 = l10_0; }          *
*                                                                           *
*            l00_1 = l00_0; l10_2 = l10_1;                                  *
*            if (l10_1 > l00_0) { l00_1 = l10_1;  l10_2 = l00_0; }          *
*                                                                           *
*            l20_2 = l20_1;  l10_3 = l10_2;                                 *
*            if (l20_1 > l10_2) { l10_3 = l20_1;  l20_2 = l10_2; }          *
*                                                                           *
*            if (l01_0 < minmax_0) minmax_0 = l01_0;                        *
*            if (l00_1 < minmax_0) minmax_0 = l00_1;                        *
*                                                                           *
*            if (l21_0 > maxmin_0) maxmin_0 = l21_0;                        *
*            if (l20_2 > maxmin_0) maxmin_0 = l20_2;                        *
*                                                                           *
*            // sort l10 l11 l12                                            *
*                                                                           *
*            t0_1 = l10_3;                                                  *
*            t1_1 = l11_0;                                                  *
*            if (l10_3 > l11_0)                                             *
*            {                                                              *
*              t0_1 = l11_0;                                                *
*              t1_1 = l10_3;                                                *
*            }                                                              *
*            t1_2 = t1_1;                                                   *
*            if (t1_1 > l12_0)                                              *
*            {                                                              *
*              t1_2 = l12_0;                                                *
*            }                                                              *
*                                                                           *
*            medmed_0  = t1_2;                                              *
*            if (t0_1 > t1_2) { medmed_0 = t0_1; } // swap                  *
*                                                                           *
*            // minmax, medmed, maxmin                                      *
*                                                                           *
*            medmed_1 = medmed_0; minmax_1 = minmax_0;                      *
*            if (minmax_0 > medmed_0)                                       *
*               { medmed_1 = minmax_0; minmax_1 = medmed_0; }               *
*                                                                           *
*            medmed_2 = medmed_1;                                           *
*            if (medmed_1 > maxmin_0)                                       *
*               { medmed_2 = maxmin_0; }                                    *
*                                                                           *
*            medmed_3 = medmed_2;                                           *
*            if (minmax_1 > medmed_2)                                       *
*               { medmed_3 = minmax_1; }                                    *
*                                                                           *
*            // Move data along by one column              //               *
*                                                                           *
*            minmax_0 = l01_0;                                              *
*            l12_0 = l11_0;                                                 *
*            maxmin_0 = l21_0;                                              *
*            l01_0 = l00_1;                                                 *
*            l11_0 = l10_3;                                                 *
*            l21_0 = l20_2;                                                 *
*                                                                           *
*            *out_data++ = medmed_3;                                        *
*        }                                                                  *
*   }                                                                       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       No allignment restrictions.                                         *
*       The code is ENDIAN NEUTRAL.                                         *
*       Interupt tolerant, being disabled during execution.                 *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is bank conflict free.                                    *
*                                                                           *
*   CYCLES                                                                  *
*       9 * cols + 49                                                       *
*                                                                           *
*       For cols = 256: 2353 cycles                                         *
*       For cols = 720: 6529 cycles                                         *
*                                                                           *
*   CODESIZE                                                                *
*       544 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_median_3x3"
        .global _IMG_median_3x3
_IMG_median_3x3:
*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
*==============================================================================*
        STW     .D2T1   A15,        *B_SP--[14] ; Reserve stack, Save A15

        MV      .L1X    B_SP,       A_SP        ; Twin Stack Pointer

        STW     .D1T1   A14,        *+A_SP[12]  ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]  ; Save B14
||      MVC     .S2     CSR,        B_csr       ; Capture CSR's state

        STW     .D1T1   A13,        *+A_SP[10]  ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]  ; Save B13
||      AND     .L2     B_csr,     -2, B_no_gie ; Clear GIE
;-
        STW     .D1T1   A12,        *+A_SP[ 8]  ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]  ; Save B12

        STW     .D1T1   A11,        *+A_SP[ 6]  ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]  ; Save B11
||      MV              B_csr,      A_csr       ; Partitioning MV

        STW     .D1T1   A10,        *+A_SP[ 4]  ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]  ; Save B10
||      MVC     .S2     B_no_gie,   CSR         ; Disable interrupts
; ===== Interrupts masked here =====
;-
        STW     .D1T1   A_csr,      *+A_SP[ 2]  ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]  ; Remember return address
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_in_data   ;1st of 3 line block
        .asg            B4,         B_n         ;width of image
        .asg            A2,         A_i         ;loop count
        .asg            A8,         A_line0     ;pntr to 1st line
        .asg            B6,         B_line1     ;pntr to 2nd line
        .asg            B7,         B_line2     ;pntr to 3rd line
        .asg            A5,         A_minmax_0  ;minimum of maximums
        .asg            A3,         A_maxmin_0  ;maximum of minimums
        .asg            A6,         A_out_data  ;pnt to output array
        .asg            B8,         B_l12_0     ;local sort variable
        .asg            A9,         A_l01_0     ;local sort variable
        .asg            B9,         B_l11_0     ;local sort variable
        .asg            A0,         A_l21_0     ;local sort variable
        .asg            A11,        A_l00_0     ;local sort variable
        .asg            B10,        B_l10_0     ;local sort variable
        .asg            B11,        B_l20_0     ;local sort variable
        .asg            B14,        B_l20_1     ;local sort variable
        .asg            B15,        B_l10_1     ;local sort variable
        .asg            B0,         B_p0        ;local sort variable
        .asg            A4,         A_l00_1     ;local sort variable
        .asg            B12,        B_l10_2     ;local sort variable
        .asg            B0,         B_p1        ;local sort variable
        .asg            B13,        B_l20_2     ;local sort variable
        .asg            B3,         B_l10_3     ;local sort variable
        .asg            B2,         B_p2        ;local sort variable
        .asg            A1,         A_q0        ;local sort variable
        .asg            A1,         A_q2        ;local sort variable
        .asg            B2,         B_q2        ;local sort variable
        .asg            B4,         B_t0_1      ;local sort variable
        .asg            B5,         B_t1_1      ;local sort variable
        .asg            B0,         B_r0        ;local sort variable
        .asg            A10,        A_t1_2      ;local sort variable
        .asg            B2,         B_r1        ;local sort variable
        .asg            A7,         A_medmed_0  ;local medians
        .asg            A11,        A_medmed_1  ;local medians
        .asg            A10,        A_minmax_1  ;minimum of maximums
        .asg            A1,         A_s0        ;local sort variable
        .asg            A7,         A_medmed_2  ;local median
        .asg            A1,         A_s1        ;local sort variable
        .asg            A7,         A_medmed_3  ;global median
        .asg            B1,         B_pro       ;prolog collapser
; ============================ PIPE LOOP PROLOG ==============================
        MVK     .S1     127,        A_l01_0                     ;
||      MVK     .S2     127,        B_l12_0                     ;
||      MV      .D1     A_in_data,  A_line0                     ;

        MV      .L1X    B_l12_0,    A_maxmin_0                  ;
||      MVK     .S1     127,        A_l21_0                     ;
||      ADD     .L2X    B_n,        A_line0,    B_line1         ;
||      MVK     .S2     0,          B_pro

        MV      .S2X    A_l01_0,    B_l11_0                     ;
||      MV      .L1     A_l21_0,    A_minmax_0                  ;
||      ADD     .L2     B_line1,    B_n,        B_line2         ;
||      ADD     .S1X    B_n,        1,          A_i             ;

        LDBU    .D2T2   *B_line2++, B_l20_0                     ;

        LDBU    .D2T2   *B_line1++, B_l10_0                     ;

        NOP             5

        LDBU    .D2T2   *B_line2++, B_l20_0                     ;

        LDBU    .D2T2   *B_line1++, B_l10_0                     ;

        MV      .D2     B_l10_0,    B_l10_1                     ;
||      CMPGTU  .L2     B_l20_0,    B_l10_0,    B_p0            ;

  [ B_p0]MV     .S2     B_l20_0,    B_l10_1                     ;
||      LDBU    .D1T1   *A_line0++, A_l00_0                     ;

        MV      .D2     B_l20_0,    B_l20_1                     ;

  [ B_p0]MV     .S2     B_l10_0,    B_l20_1                     ; swap

        NOP             2

        CMPGTU  .L2X    B_l10_1,    A_l00_0,    B_p1            ;
||      MV      .D2     B_l11_0,    B_t1_1                      ;
||      MV      .S2     B_l10_1,    B_l10_2                     ;

        LDBU    .D2T2   *B_line2++, B_l20_0                     ;
||      MVK     .S2      1,         B_pro

; ============================ PIPE LOOP KERNEL ==============================
LOOP:
  [!B_pro]CMPGTU.L2X    B_l20_2,    A_maxmin_0, B_q2            ;
||[!B_pro]MPY   .M1     1,          A_l00_1,    A_l01_0         ;
||[ B_r1]MV     .L1X    B_t0_1,     A_medmed_0                  ; swap
||      MV      .S1     A_l00_0,    A_l00_1                     ;
||      SUB     .D1     A_i,        1,          A_i             ;
||      LDBU    .D2T2   *B_line1++, B_l10_0                     ;

  [!B_pro]CMPGTU.L1     A_minmax_0, A_medmed_0, A_s0            ;
||[!B_pro]MPY   .M1     1,          A_l01_0,    A_minmax_0      ; A_l02_0
||[!B_pro]MV    .D1     A_medmed_0, A_medmed_1                  ;
||[ B_p1]MV     .S2X    A_l00_0,    B_l10_2                     ; swap
||[ B_p1]MV     .S1X    B_l10_1,    A_l00_1                     ;
||      MV      .D2     B_l10_0,    B_l10_1                     ;
||      CMPGTU  .L2     B_l20_0,    B_l10_0,    B_p0            ;

  [ B_q2]MV     .L1X    B_l20_2,    A_maxmin_0                  ;
||[ A_s0]MV     .S1     A_minmax_0, A_medmed_1                  ;
||[ A_s0]MPY    .M1     1,          A_medmed_0, A_minmax_1      ;
||      LDBU    .D1T1   *A_line0++, A_l00_0                     ;
||      MV      .D2     B_l10_2,    B_l10_3                     ;
||      CMPGTU  .L2     B_l20_1,    B_l10_2,    B_p2            ;
||[ B_p0]MV     .S2     B_l20_0,    B_l10_1                     ;

  [ A_i]B       .S1     LOOP                                    ;
||[!B_pro]CMPGTU.L1     A_medmed_1, A_maxmin_0, A_s1            ;
||[!B_pro]MV    .D1     A_medmed_1, A_medmed_2                  ;
||[!B_pro]MPY   .M1X    1,          B_l20_2,    A_l21_0         ;
||[ B_p2]MV     .S2     B_l20_1,    B_l10_3                     ;
||      MV      .L2     B_l20_1,    B_l20_2                     ;
||      MV      .D2     B_l20_0,    B_l20_1                     ;

  [!B_pro]MPY   .M1     1,          A_l21_0,    A_maxmin_0      ; A_l22_0
||[ A_s1]MV     .S1     A_maxmin_0, A_medmed_2                  ;
||      MV      .D2     B_l10_3,    B_t0_1                      ;
||      CMPGTU  .L2     B_l10_3,    B_l11_0,    B_r0            ;
||      CMPLTU  .L1     A_l01_0,    A_minmax_0, A_q0            ;
||[ B_p0]MV     .S2     B_l10_0,    B_l20_1                     ; swap

  [!B_pro]CMPGTU.L1     A_minmax_1, A_medmed_2, A_s1            ;
||[!B_pro]MPY   .M1     1,          A_medmed_2, A_medmed_3      ;
||[ A_q0]MV     .D1     A_l01_0,    A_minmax_0                  ;
||[ B_r0]MV     .L2     B_l11_0,    B_t0_1                      ;
||      MPY     .M2     1,          B_l10_3,    B_l11_0         ;
||[ B_r0]MV     .D2     B_l10_3,    B_t1_1                      ; swap

  [ A_s1]MPY    .M1     1,          A_minmax_1, A_medmed_3      ;
||      MV      .S1X    B_t1_1,     A_t1_2                      ;
||      CMPLTU  .L1     A_l00_1,    A_minmax_0, A_q0            ;
||[ B_p2]MV     .S2     B_l10_2,    B_l20_2                     ; swap
||      CMPGTU  .L2     B_t1_1,     B_l12_0,    B_r1            ;
||      MPY     .M2     1,          B_l11_0,    B_l12_0         ;

         MPY    .M2     0,          B_pro,      B_pro           ;
||[ A_q0]MV     .D1     A_l00_1,    A_minmax_0                  ;
||[ B_r1]MV     .S1X    B_l12_0,    A_t1_2                      ;
||      CMPGTU  .L1     A_l21_0,    A_maxmin_0, A_q2            ;
||      CMPGTU  .L2X    B_l10_1,    A_l00_0,    B_p1            ;
||      MV      .D2     B_l11_0,    B_t1_1                      ;
||      MV      .S2     B_l10_1,    B_l10_2                     ;

  [!B_pro]STB   .D1T1   A_medmed_3, *A_out_data++               ;
||[ A_q2]MV     .L1     A_l21_0,    A_maxmin_0                  ;
||      CMPGTU  .L2X    B_t0_1,     A_t1_2,     B_r1            ;
||      MPY     .M1     1,          A_minmax_0, A_minmax_1      ;
||      MV      .S1     A_t1_2,     A_medmed_0                  ;
||      LDBU    .D2T2   *B_line2++, B_l20_0                     ;
; ============================ PIPE LOOP EPILOG ==============================
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            A0,         A_csr       ; CSR value to restore
        .asg            B3,         B_ret       ; Return address
*==============================================================================*
        MV              A_SP,       B_SP        ; Twin Stack Pointer

        LDW     .D1T2   *+A_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr       ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10         ; Restore A10

        LDW     .D1T2   *+A_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11         ; Restore A11

        LDW     .D1T2   *+A_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12         ; Restore A12

        LDW     .D1T2   *+A_SP[ 9], B13         ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13         ; Restore A13

        LDW     .D1T2   *+A_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14         ; Restore A14
||      RET     .S2     B_ret                   ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
||      LDW     .D2T1   *++B_SP[14],A15         ; Restore A15
*====== Interruptibility state restored here ==================================*
        NOP             4
;====== Branch Occurs =====
*==============================================================================*
*=  End of file:  img_median_3x3.asm                                          =*
*==============================================================================*
*=            Copyright (c) 1999 Texas Instruments, Incorporated.             =*
*=                           All Rights Reserved.                             =*
*==============================================================================*

mpeg2_vld0.asm/ 1066929161  0     0     0       48738     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.9     Sun Sep 29 03:31:27 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mpeg2_vld_inter                                                 *
*                                                                           *
*   PLATFORM                                                                *
*       C6200                                                               *
*                                                                           *
*   REVISION DATE                                                           *
*       03-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*         void IMG_mpeg2_vld_inter                                          *
*         (                                                                 *
*             const short   *restrict Wptr,                                 *
*             short         *restrict outi,                                 *
*             IMG_mpeg2_vld *restrict Mpeg2v                                *
*         );                                                                *
*                                                                           *
*         Wptr:       Pointer to the quantization matrix.  Must be in       *
*                     the scan order corresponding to the inverse scan      *
*                     matrix.                                               *
*                                                                           *
*         outi[6*64]: Pointer to the output array where the decoded and     *
*                     dequantized IDCT coefficients are placed.             *
*                     Elements assumed to be set to zero prior to           *
*                     function call.  The routine assumes 6 8x8 blocks      *
*                     per MB, i.e. 4:2:0 format.                            *
*                                                                           *
*         Mpeg2v:     Pointer to the context object, which includes the     *
*                     input buffer variables.  The structure Mpeg2v is      *
*                     defined as follows:                                   *
*                                                                           *
*C          #ifndef IMG_MPEG2_VLD_STRUCT_                                   *
*C          #define IMG_MPEG2_VLD_STRUCT_ 1                                 *
*C                                                                          *
*C          typedef struct {                                                *
*C            unsigned int  *bsbuf;      // pointer to bitstream buffer     *
*C            unsigned int  next_wptr;   // next word to read from buffer   *
*C            unsigned int  bptr;        // bit position within word        *
*C            unsigned int  word1;       // word aligned buffer             *
*C            unsigned int  word2;       // word aligned buffer             *
*C            unsigned int  top0;        // top 32 bits of bitstream        *
*C            unsigned int  top1;        // next 32 bits of bitstream       *
*C            const unsigned char *scan; // inverse zigzag scan matrix      *
*C            unsigned int  intravlc;    // intra_vlc_format                *
*C            unsigned int  quant_scale; // quant_scale                     *
*C            unsigned int  dc_prec;     // intra_dc_precision              *
*C            unsigned int  cbp;         // coded_block_pattern             *
*C            unsigned int  fault;       // fault condition (returned)      *
*C            unsigned int  reserved;                                       *
*C          } IMG_mpeg2_vld;                                                *
*C                                                                          *
*C          #endif                                                          *
*                                                                           *
*         All variables in this structure must have the layout as shown     *
*         since they are being accessed by this routine through             *
*         appropriate offsets.  Other variables may be appended to the      *
*         structure.                                                        *
*                                                                           *
*         The routine sets the fault flag Mpeg2v.fault to 1 if an invalid   *
*         VLC code was encountered or the total run for a block exceeded    *
*         63.  In theses cases the decoder has to resynchronize.            *
*                                                                           *
*       The routine requires proprietary variable length decoding           *
*       look-up tables.  The tables are based on Table B-14 and B-15 in     *
*       the MPEG-2 standard text.                                           *
*                                                                           *
*       The required lookup tables for this routine are provided in         *
*       IMGLIB and are linked in automatically when linking against         *
*       IMGLIB.                                                             *
*                                                                           *
*       Before calling the routine the bitstream varaibles in Mpeg2v have   *
*       to be initialized.  If bsbuf[] is a circular buffer of size         *
*       BSBUF_SIZE words and bsptr contains the number of bits in the       *
*       buffer that already have been consumed, then next_wptr, bptr,       *
*       word1, word2, top0 and top1 are initialized as follows:             *
*                                                                           *
*       1. nextwptr:  bsptr may not be a multiple of 32 (e.g. it points     *
*          to bit number 40 in the bitstream), therefore set it to the      *
*          next lower multiple of 32 by shift left by 5 (divide by 32).     *
*          In case of 40 this yields 1.  Since memory is addressed in       *
*          units of bytes this needs to be multiplied by 4 to get the       *
*          address pointer.  Use next_wptr as index into bsbuf[].           *
*                                                                           *
*              next_wptr = (bsptr >> 5);                                    *
*                                                                           *
*       2. bptr:  bptr is the bit pointer which points to the current       *
*          bit WITHIN the word pointed to by next_wptr.                     *
*                                                                           *
*             bptr = bsptr & 31;                                            *
*             bptr_cmpl = 32 - bptr;                                        *
*                                                                           *
*       3. word1 and word2:  read next 3 words from the bitstream buffer    *
*          (word0 is a temporary variable).                                 *
*                                                                           *
*             word0 = bsbuf[next_wptr];                                     *
*             next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 *
*                                                                           *
*             word1 = bsbuf[next_wptr];                                     *
*             next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 *
*                                                                           *
*             word2 = bsbuf[next_wptr];                                     *
*             next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 *
*                                                                           *
*       4. top0 and top1:  Shift words word0, word1, word2 by bptr to       *
*          the left so that the current bit becomes the MSB in word0.       *
*          word0 can simply be shifted by bptr; the then empty LSBs of      *
*          word0 have to be filled with the MSBs of word1.  To do that      *
*          the required MSBs are brought into the position of empty         *
*          LSBs of word0 by shifting word1 to the right by (32-bptr).       *
*          The result is then copied into word0 by an addition.  Rather     *
*          than overwriting word0, top0 is used to hold the new bit         *
*          aligned word.  The same procedure is used to obtain top1.        *
*          top0 and top1 contain the next 64 bits of the bitstream.         *
*                                                                           *
*             s1 = SHL(word0, bptr);                                        *
*             s2 = SHR(word1, bptr_cmpl);  // unsigned right-shift          *
*             top0 = s1 + s2;                                               *
*                                                                           *
*             s3 = SHL(word1, bptr);                                        *
*             s4 = SHR(word2, bptr_cmpl);  //  unsigned right-shift         *
*             top1 = s3 + s4;                                               *
*                                                                           *
*         SHL/SHR are macros that simulate C6000 shift functions if the     *
*         routine is to be run on a PC or UNIX platform. They are           *
*         defined as follows:                                               *
*                                                                           *
*             #ifdef _TMS320C6X                                             *
*             # define SHL(x,y) ( (x) << (y) )                              *
*             # define SHR(x,y) ( (x) >> (y) )                              *
*             #else                                                         *
*             # define SHL(x,y) ( ((y) & 32) ? 0 : ((x) << (y)) )           *
*             # define SHR(x,y) ( ((y) & 32) ? 0 : ((x) >> (y)) )           *
*             #endif                                                        *
*                                                                           *
*   DESCRIPTION                                                             *
*       Decodes all coefficients of an MPEG-2 non-intra coded macroblock.   *
*                                                                           *
*       Checks coded block pattern (cbp), performs DC and AC decoding       *
*       inlcuding, variable length decode, run-length expansion,            *
*       inverse zigzag, dequantization, saturation and mismatch             *
*       control.                                                            *
*                                                                           *
*   ASSUMPTIONS                                                             *
*     - bitstream buffer is set to 512 32-bit words (=2048 bytes),          *
*       buffer needs to be aligned at a 2048 boundary because it is         *
*       circular.  If this needs to be changed, AMR register setup has to   *
*       be modified  and alignment changed accordingly. Register B7 is      *
*       used as the address pointer to the bitstream buffer in              *
*       circular addressing mode with a size of 2^(10+1) bytes = 2048       *
*       bytes = 512 words. Accordingly, AMR is set to 0x000A0004. Note      *
*       that the AMR register is set to zero on exit.                       *
*                                                                           *
*     - zigzag matrix (Zptr) is 64 bytes circularly addressed and needs to  *
*       be aligned at a 64 byte boundary (serves protection from random     *
*       stores into memory)                                                 *
*                                                                           *
*     - inside the routine word1 (next_wptr-2) and word2 (next_wptr-1)      *
*       are reconstructed from the bitstream buffer and therfore have to    *
*       be kept alive in the bitstream buffer. For instance, in a double    *
*       buffering scheme the bitstream buffer can only be updated when      *
*       next_wptr-2 (and not next_wptr) has crossed the half buffer         *
*       boundary.                                                           *
*                                                                           *
*     - look-up tables len and len_c should be offset against each other    *
*       so that they start in different memory banks to avoid bank          *
*       conflicts.                                                          *
*                                                                           *
*   NOTES                                                                   *
*     - little endian                                                       *
*                                                                           *
*     - non-interruptible                                                   *
*                                                                           *
*     - 4:2:0 color format supported only                                   *
*                                                                           *
*     - Wptr is allowed to overrun once (to detect total run overrun), so   *
*       maximum overrun that can occur is 66 (Error mark). Therefore,       *
*       in memory 66+1 half-words behind the weighting matrix should be     *
*       valid (e.g. no cache or peripherals). No memory is overwritten,     *
*       only loads occurr.                                                  *
*                                                                           *
*   CYCLES                                                                  *
*       10 * S + 48 * CB + 15 * NCB + 60                                    *
*       where S:   Number of symbols in MB, CB: Number of coded blocks,     *
*             NCB: Number of not-coded blocks, and CB+NCB=6                 *
*                                                                           *
*   CODE SIZE                                                               *
*       1376 bytes                                                          *
*                                                                           *
*   DATA SIZE                                                               *
*       2176 bytes for the lookup tables                                    *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            B6,         B_word2
        .asg            B5,         B5_word2
        .asg            A4,         A_word1
        .asg            A4,         A4_word1
        .asg            B7,         B_bsbuf_circ
        .asg            B7,         B7_bsbuf_circ
        .asg            A11,        A_len_c_tbl_adr
        .asg            A11,        A11_len_c_tbl_adr
        .asg            B10,        B_len_tbl_adr
        .asg            B10,        B10_len_tbl_adr
        .asg            A12,        A_rld_table_adr
        .asg            A12,        A12_rld_table_adr
        .asg            A13,        A_rld_table_adr_1
        .asg            A14,        A_const31
        .asg            B12,        B_const32
        .asg            B12,        B12_const32
        .asg            B0,         B0_const63
        .asg            A7,         A_top0
        .asg            A7,         A7_top0
        .asg            A8,         A8_top0
        .asg            B4,         B_top1
        .asg            B4,         B4_top1
        .asg            B8,         B8_top1
        .asg            A6,         A_bptr
        .asg            A6,         A6_bptr
        .asg            A12,        A12_bptr
        .asg            A9,         A_outi
        .asg            A9,         A9_outi
        .asg            B3,         B_Wptr
        .asg            B3,         B3_Wptr
        .asg            B13,        B_Zptr
        .asg            B13,        B13_Zptr
        .asg            A15,        A_qscl
        .asg            A15,        A15_qscl
        .asg            A10,        A_sum
        .asg            A10,        A10_sum
        .asg            A3,         A_nrm
        .asg            A0,         A_t1
        .asg            B1,         B_t2
        .asg            B2,         B_t3
        .asg            A0,         A_t3b
        .asg            B1,         B_t4
        .asg            A2,         A_t4b
        .asg            A2,         A2_t4b
        .asg            A15,        A15_t4b         ; table mod
        .asg            A8,         A_len
        .asg            B1,         B_len_c
        .asg            A5,         A_t6
        .asg            B1,         B_t7
        .asg            B4,         B_top0_bk
        .asg            B4,         B4_top0_bk
        .asg            B8,         B8_top0_bk
        .asg            A3,         A_bptr1
        .asg            A1,         A_test2
        .asg            B8,         B_bptr_cmpl
        .asg            B8,         B8_bptr_cmpl
        .asg            A5,         A_t8
        .asg            B1,         B_t9
        .asg            A1,         A_test1
        .asg            B9,         B_run
        .asg            B8,         B_level
        .asg            B1,         B_test3
        .asg            B5,         B_rld_left
        .asg            A5,         A_t12
        .asg            B5,         B_t13
        .asg            B1,         B_t14
        .asg            A3,         A_t15
        .asg            A3,         A_t16
        .asg            B2,         B_eob_err
        .asg            B2,         B2_eob_err
        .asg            A2,         A2_neg
        .asg            B5,         B_level2
        .asg            B11,        B_level3
        .asg            A8,         A_W
        .asg            A6,         A_qw
        .asg            A6,         A6_qw
        .asg            A1,         A_level4
        .asg            A0,         A_level5
        .asg            A0,         A_level_f
        .asg            A3,         A_Z
* ========================================================================= *

; ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A3,         A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address

        .asg            B15,        B15_SP
        .asg            A14,        A14_SP
        .asg            B2,         B2_len_c
        .asg            B1,         B1_bcomp
        .asg            A0,         A0_cnt
        .asg            A2,         A2_cnt

        .asg            A1,         A1_odd
        .asg            B2,         B2_error
        .asg            B9,         B9_cbp_mask
        .asg            A1,         A1_coded
        .asg            B12,        B12_run_bk
        .asg            A15,        A15_last_coeff
        .asg            A5,         A5_len
        .asg            B9,         B9_bptr_cmpl
        .asg            A2,         A2_test2
        .asg            B1,         B1_cnt
        .asg            B14,        B14_Wptr_end
        .asg            B14,        B14_const126

        .asg            A2,         A2_tm
        .asg            B0,         B0_tm_neg
        .asg            A0,         A0_const126
        .asg            A3,         A3_const65

        .global _IMG_len_tbl0
        .global _IMG_len_c_tbl0
        .global _IMG_rld_table0

; Mpeg2v structure:
BSBUF_M2OFF      .set   0x0
NEXTWPTR_M2OFF   .set   0x1
BPTR_M2OFF       .set   0x2
WORD1_M2OFF      .set   0x3
WORD2_M2OFF      .set   0x4
TOP0_M2OFF       .set   0x5
TOP1_M2OFF       .set   0x6
ZPTR_M2OFF       .set   0x7
QSCL_M2OFF       .set   0x9
CBP_M2OFF        .set   0xB
FAULT_M2OFF      .set   0xC

; stack layout:
BSBUF_SPOFF      .set   0x0
MPEG2V_SPOFF     .set   0x1
TOP1_SPOFF       .set   0x2
BPTR_SPOFF       .set   0x3
WPTR_SPOFF       .set   0x5
CNT_SPOFF        .set   0x6
ZPTR_SPOFF       .set   0x7
CBP_SPOFF        .set   0x8
QSCL_SPOFF       .set   0xA
BSBUFC_SPOFF     .set   0xB



        .sect ".text:_mpeg2_vld_inter"
        .global _IMG_mpeg2_vld_inter
_IMG_mpeg2_vld_inter:  ; B_Wptr, A_outi, A_Mpeg2v
;                        A4,     B4,     A6,

* ========================================================================= *
*  Setup
* ========================================================================= *

; ========================================================================= ;
; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
; Order:  A15, A14, B14, A13, B13, A12, B12, A11, B11, A10, B10, CSR, B3,
; empty
; ========================================================================= ;

        STW     .D2T1   A15,        *B_SP--[14]          ; Get stk, Save A15
||      MV              B_SP,       A_SP                 ; Twin Stack Ptr

        STW     .D1T1   A14,        *-A_SP[ 2]           ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]           ; Save B14
||      MVC     .S2     CSR,        B_csr                ; Get CSR's state

        STW     .D1T1   A13,        *-A_SP[ 4]           ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]           ; Save B13
||      AND             B_csr,      -2,         B_no_gie ; Clear GIE
;-
        STW     .D1T1   A12,        *-A_SP[ 6]           ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]           ; Save B12

        STW     .D1T1   A11,        *-A_SP[ 8]           ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]           ; Save B11
||      MV              B_csr,      A_csr                ; Partitioning MV

        STW     .D1T1   A10,        *-A_SP[10]           ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]           ; Save B10
||      MVC     .S2     B_no_gie,   CSR                  ; Disable ints.
; ===== Interrupts masked here =====
;-
        STW     .D1T1   A_csr,      *-A_SP[12]           ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]           ; Save return addr.

* ========================================================================= *
||      MV      .L1X    B4,         A9_outi
||      MV      .L2X    A4,         B3_Wptr

* ======================================================================== *
*  Get bitstream info
* ======================================================================== *
    .asg        A6,     A6_Mpeg2v
    .asg        B14,    B14_Mpeg2v
    .asg        B4,     B4_bsbuf
    .asg        A2,     A2_next_wptr
    .asg        B9,     B9_next_wptr
    .asg        A7,     A7_cbp

    MV         .L2X     A6_Mpeg2v,   B14_Mpeg2v

    LDW        .D1T1    *+A6_Mpeg2v[CBP_M2OFF],    A7_cbp
||  LDW        .D2T2    *+B14_Mpeg2v[BSBUF_M2OFF], B4_bsbuf

    LDW        .D2T2    *+B14_Mpeg2v[NEXTWPTR_M2OFF], B9_next_wptr
||  LDW        .D1T1    *+A6_Mpeg2v[BPTR_M2OFF],   A12_bptr

    LDW        .D2T2    *+B14_Mpeg2v[ZPTR_M2OFF],  B13_Zptr
||  LDW        .D1T1    *+A6_Mpeg2v[WORD1_M2OFF],  A4_word1

    LDW        .D2T2    *+B14_Mpeg2v[WORD2_M2OFF], B5_word2
||  LDW        .D1T1    *+A6_Mpeg2v[QSCL_M2OFF],   A15_qscl

* ======================================================================== *
*  Setup circuar bitstream buffer
* ======================================================================== *
    .asg     B0,   B0_amr_config

    MVKL    .S2 0x00AA4800, B0_amr_config  ;B7 circular mode, 2^(10+1) bytes

    MVKH    .S2 0x00AA4800, B0_amr_config  ;(=2048 bytes=512 words x 32 bit)

    MVC     .S2 B0_amr_config, AMR

    ADDAW   .D2 B4_bsbuf,   B9_next_wptr,  B7_bsbuf_circ

* ======================================================================== *
*  Block loop setup
*  Load table addresses and constants
* ======================================================================== *
          .asg       A3,    A3_const1

          SUBAW   .D2       B15_SP,        11,          B15_SP ;rsrv stack
          MV      .S1X      B15_SP,        A14_SP

          STW     .D1T1     A6_Mpeg2v,     *+A14_SP[MPEG2V_SPOFF]
||        STW     .D2T2     B4_bsbuf,      *+B15_SP[BSBUF_SPOFF]
||        MVK     .S2       6,             B1_cnt
||        MVK     .S1       1,             A3_const1

          LDW     .D1T2     *+A6_Mpeg2v[TOP0_M2OFF], B4_top0_bk
||        MVKL    .S2       _IMG_len_tbl0,     B10_len_tbl_adr
||        MVKL    .S1       _IMG_len_c_tbl0,   A11_len_c_tbl_adr

          STW     .D2T2     B13_Zptr,      *+B15_SP[ZPTR_SPOFF]
||        STW     .D1T1     A7_cbp,        *+A14_SP[CBP_SPOFF]
||        MVKH    .S2       _IMG_len_tbl0,     B10_len_tbl_adr
||        MVKH    .S1       _IMG_len_c_tbl0,   A11_len_c_tbl_adr

          STW     .D1T1     A12_bptr,      *+A14_SP[BPTR_SPOFF]
||        STW     .D2T2     B7_bsbuf_circ, *+B_SP[BSBUFC_SPOFF]    ;preserve
||        MVKL    .S1       _IMG_rld_table0,   A12_rld_table_adr

          STW     .D1T1     A15_qscl,      *+A14_SP[QSCL_SPOFF]
||        STW     .D2T2     B3_Wptr,       *+B15_SP[WPTR_SPOFF]
||        MVKH    .S1       _IMG_rld_table0,   A12_rld_table_adr

* ------------------------------------------------------------------------

block_loop:
; do not use B2 in the next to cycles, preserves B2_error
* --------------------------------------------------------------------
*  check cbp
* -------------------------------------------------------------------- *
            SUB   .S2     B1_cnt,       1,        B1_bcomp    ; cbp, cnt--
||          ZERO  .S1     A_sum

            SHL   .S2X    A3_const1,    B1_bcomp, B9_cbp_mask ; cbp
||          STW   .D2T2   B1_bcomp,     *+B15_SP[CNT_SPOFF]   ; cnt
||          MVK   .S1     126,          A0_const126           ; const

            AND   .S1X    B9_cbp_mask,  A7_cbp,   A1_coded    ; cbp

  [!A1_coded]B    .S1     mismatch                            ; not coded

  [!A1_coded]ADD  .L1     A_outi,       A0_const126, A_outi   ; not coded
||[!A1_coded]MV   .L2     B3_Wptr,      B14_Wptr_end          ; not coded
||[!A1_coded]ZERO .S2     B12_run_bk                          ; not coded

            MV    .L1X    B1_bcomp,     A2_cnt                ; cnt/mismatch

            LDW   .D2T1   *+B15_SP[BPTR_SPOFF],   A_bptr      ; adv bit
||          MV    .L1X    B4_top0_bk,   A7_top0               ; live out

            LDW   .D2T2   *-B7_bsbuf_circ[1],     B_word2     ; adv bit
||          MVK   .S1     31,                     A_const31   ; const
||          ZERO  .L1     A15_last_coeff                      ; mismatch

            LDW   .D2T1   *-B7_bsbuf_circ[2],     A_word1     ; adv bit
||          ADD   .L1     A15_last_coeff, 1, A15_last_coeff   ; not coded (no mism)

; branch occurs

* =========================== PIPE LOOP PROLOG ============================ *
        NORM    .L1     A_top0,     A_nrm                       ;[ 1,1]
||      SHRU    .S1     A_top0,     31,         A2_tm           ;table mod

        SHL     .S2X    A_nrm,      4,          B_t2            ;[ 2,1]
||      SHL     .S1     A_top0,     A_nrm,      A_t1            ;[ 2,1]

        SHRU    .S1     A_t1,       28,         A15_t4b         ;[ 3,1]
||      SHRU    .S2X    A_t1,       28,         B_t4            ;[ 3,1]
||      ADD     .L1X    A_len_c_tbl_adr,        B_t2,      A_t3b;[ 3,1]
||      ADD     .L2     B_len_tbl_adr,          B_t2,       B_t3;[ 3,1]

  [!A2_tm]LDBU  .D1T2   *A_t3b[A15_t4b],        B_len_c         ;[ 4,1]
||[!A2_tm]LDBU  .D2T1   *B_t3[B_t4],            A_len           ;[ 4,1]
||[A2_tm]MVK    .S1     2,                      A_len           ;table mod
||[A2_tm]MVK    .S2     30,                     B_len_c         ;table mod

        MVK     .S2     32,     B12_const32                     ;const

        SUB     .L2X    B_const32,  A_bptr,     B8_bptr_cmpl    ;reconstr

        SHL     .S1     A_word1,    A_bptr,     A5              ;reconstr
||      SHRU    .S2     B_word2,    B8_bptr_cmpl,B8             ;reconstr

        ADD     .L2X    A5,         B8,         B_top1          ;reconstr

        MPY     .M1X    B_const32,  A_len,      A_t12           ;[ 9,1]
||      ADD     .L1     A_bptr,     A_len,      A_bptr1         ;[ 9,1]
||      MV      .L2X    A_top0,     B_top0_bk                   ;[ 9,1]
||      SHRU    .S2     B_top1,     B_len_c,    B_t7            ;[ 9,1]
||      SHL     .S1     A_top0,     A_len,      A_t6            ;[ 9,1]

        CMPLT   .L2X    A_len,      5,          B_test3         ;[10,1]
||      CMPGT   .L1     A_bptr1,    A_const31,  A_test2         ;[10,1]
||      ADD     .S1X    A_t6,       B_t7,       A_top0          ;[10,1]

        SUB     .L2X    A_len,      5,          B_rld_left      ;[11,1]
||      AND     .S1     A_const31,  A_bptr1,    A_bptr          ;[11,1]
||[ A_test2]LDW .D2T2   *B_bsbuf_circ++,        B_word2         ;[11,1]
||      NORM    .L1     A_top0,     A_nrm                       ;[ 1,2]
||[A2_tm]EXTU   .S2     B_top0_bk,  1, 31,      B0_tm_neg       ;table mod

  [B_test3] MPY .M2     B_const32,  0,          B_rld_left      ;[12,1]
||[ A_test2]MV  .L1X    B_word2,    A_word1                     ;[12,1]
||      SHL     .S2X    A_nrm,      4,          B_t2            ;[ 2,2]
||      SHL     .S1     A_top0,     A_nrm,      A_t1            ;[ 2,2]

        SHRU    .S1     A_t1,       28,         A15_t4b         ;[ 3,2]
||      SHRU    .S2X    A_t1,       28,         B_t4            ;[ 3,2]
||      ADD     .L1X    A_len_c_tbl_adr,        B_t2,      A_t3b;[ 3,2]
||      ADD     .L2     B_len_tbl_adr,          B_t2,       B_t3;[ 3,2]

        SHL     .S2     B_top0_bk,  B_rld_left, B_t13           ;[14,1]
||      LDBU    .D1T2   *A_t3b[A15_t4b],        B_len_c         ;[ 4,2]
||      LDBU    .D2T1   *B_t3[B_t4],            A_len           ;[ 4,2]

        SHRU    .S2     B_t13,      27,         B_t14           ;[15,1]
||      SUB     .L2X    B_const32,  A_bptr,     B_bptr_cmpl     ;[15,1]
||      LDW     .D2T2   *+B_SP[WPTR_SPOFF],     B_Wptr          ; reset
||[A2_tm]ZERO   .S1     A_test1                                 ;table mod

        ADD     .L1X    B_t14,      A_t12,      A_t15           ;[16,1]
||      SHRU    .S2     B_word2,    B_bptr_cmpl,B_t9            ;[16,1]
||      LDW     .D2T2   *+B_SP[ZPTR_SPOFF], B_Zptr              ; reset
||[!A2_tm]ZERO  .L2     B0_tm_neg                               ;table mod
||      ADD     .S1     1, A_rld_table_adr,A_rld_table_adr_1    ; const

        ADD     .L1     A_t15,      A_t15,      A_t16           ;[17,1]
||[!A2_tm]EXT   .S2     B_top0_bk,  12, 20,     B_level         ;[17,1]
||[!A2_tm]SUB   .D1     A_len,      24,         A_test1         ;[17,1]
||      SHL     .S1     A_word1,    A_bptr,     A_t8            ;[17,1]
||      STW     .D2T2   B_bsbuf_circ,   *+B_SP[BSBUFC_SPOFF]    ;preserve
||[A2_tm]AND    .L2X    A_const31,  1,          B_level         ;table mod

  [ A_test1]LDBU.D1T2   *A_rld_table_adr_1[A_t16],   B_run      ;[18,1]
||[!A2_tm]EXTU  .S2     B_top0_bk,  6,  26,     B_run           ;[18,1]
||      ADD     .L2X    A_t8,       B_t9,       B_top1          ;[18,1]
||[A2_tm]SUB    .D2     B_const32,  B_const32,  B_run           ;table mod
||[B0_tm_neg]MPY.M2     -1,         B_level,    B_level         ;table mod

  [ A_test1]LDB .D1T2   *A_rld_table_adr[A_t16],  B_level       ;[19,1]
||      MPY     .M1X    B_const32,  A_len,      A_t12           ;[ 9,2]
||      ADD     .L1     A_bptr,     A_len,      A_bptr1         ;[ 9,2]
||      MV      .L2X    A_top0,     B_top0_bk                   ;[ 9,2]
||      SHRU    .S2     B_top1,     B_len_c,    B_t7            ;[ 9,2]
||      SHL     .S1     A_top0,     A_len,      A_t6            ;[ 9,2]

        CMPLT   .L2X    A_len,      5,          B_test3         ;[10,2]
||      CMPGT   .L1     A_bptr1,    A_const31,  A_test2         ;[10,2]
||      ADD     .S1X    A_t6,       B_t7,       A_top0          ;[10,2]
||      STW     .D2T1   A_bptr,     *+B_SP[BPTR_SPOFF]          ;preserve
||      MVK     .S2     126,        B14_const126                ; const

        SUB     .L2X    A_len,      5,          B_rld_left      ;[11,2]
||      AND     .S1     A_const31,  A_bptr1,    A_bptr          ;[11,2]
||[ A_test2]LDW .D2T2   *B_bsbuf_circ++,        B_word2         ;[11,2]
||      NORM    .L1     A_top0,     A_nrm                       ;[ 1,3]
||      MVK     .S2     63,         B0_const63                  ; const

  [B_test3] MPY .M2     B_const32,  0,          B_rld_left      ;[12,2]
||[ A_test2]MV  .L1X    B_word2,    A_word1                     ;[12,2]
||      SHL     .S2X    A_nrm,      4,          B_t2            ;[ 2,3]
||      SHL     .S1     A_top0,     A_nrm,      A_t1            ;[ 2,3]
||      ADD     .L2     B_Wptr,     B14_const126, B14_Wptr_end  ; const
||      LDW     .D2T1   *+B_SP[QSCL_SPOFF],     A15_qscl        ; const

        LDH     .D2T1   *++B_Wptr[B_run],       A_W             ;[23,1]
||      SHRU    .S1     A_t1,       28,         A2_t4b          ;[ 3,3]
||      SHRU    .S2X    A_t1,       28,         B_t4            ;[ 3,3]
||      ADD     .L1X    A_len_c_tbl_adr,        B_t2,      A_t3b;[ 3,3]
||      ADD     .L2     B_len_tbl_adr,          B_t2,       B_t3;[ 3,3]

        MPY     .M2     B_level,    2,          B_level2        ;[24,1]
||      CMPLT   .L1X    B_level,    0,          A2_neg          ;[24,1]
||      CMPGT   .L2     B_run,      B0_const63, B_eob_err       ;[24,1]
||      SHL     .S2     B_top0_bk,  B_rld_left, B_t13           ;[14,2]
||      LDBU    .D1T2   *A_t3b[A2_t4b],         B_len_c         ;[ 4,3]
||      LDBU    .D2T1   *B_t3[B_t4],            A_len           ;[ 4,3]

        SHRU    .S2     B_t13,      27,         B_t14           ;[15,2]
||      SUB     .L2X    B_const32,  A_bptr,     B_bptr_cmpl     ;[15,2]

        ADD     .L1X    B_t14,      A_t12,      A_t15           ;[16,2]
||      SHRU    .S2     B_word2,    B_bptr_cmpl,            B_t9;[16,2]
||      STW     .D2T2   B_top1,     *+B_SP[TOP1_SPOFF]          ;preserve

* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [ A2_neg]SUB  .L2     B_level2,   1,          B_level3        ;[27,1]
||      ADD     .L1     A_t15,      A_t15,      A_t16           ;[17,2]
||      EXT     .S2     B4_top0_bk, 12, 20,     B_level         ;[17,2]
||      SUB     .D1     A_len,      24,         A_test1         ;[17,2]
||      SHL     .S1     A_word1,    A6_bptr,    A_t8            ;[17,2]
||[!B_eob_err]STW.D2T1  A6_bptr,    *+B_SP[BPTR_SPOFF]          ;preserve

        LDB     .D2T1   *++B_Zptr[B_run],       A_Z             ;[28,1]
||      MPY     .M1     A15_qscl,   A_W,        A6_qw           ;[28,1]
||[ A_test1]LDBU.D1T2   *A_rld_table_adr_1[A_t16],       B_run  ;[18,2]
||      EXTU    .S2     B4_top0_bk, 6,  26,     B_run           ;[18,2]
||[!B_eob_err]ADD.L2X   A_t8,       B_t9,       B4_top1         ;[18,2]
||[B_eob_err]B  .S1     mismatch

  [ A_test1]LDB .D1T2   *A_rld_table_adr[A_t16],        B_level ;[19,2]
||      MPY     .M1X    B12_const32,A_len,      A_t12           ;[ 9,3]
||      ADD     .L1     A6_bptr,    A_len,      A_bptr1         ;[ 9,3]
||[!B_eob_err]MV.L2X    A_top0,     B4_top0_bk                  ;[ 9,3]
||      SHRU    .S2     B4_top1,    B_len_c,    B_t7            ;[ 9,3]
||      SHL     .S1     A_top0,     A_len,      A_t6            ;[ 9,3]
||      ADDAB   .D2     B_Zptr,     1,          B_Zptr          ;[29,1]

  [!A2_neg]ADD  .S2     B_level2,   1,          B_level3        ;[30,1]
||      CMPLT   .L2X    A_len,      5,          B_test3         ;[10,3]
||      CMPGT   .L1     A_bptr1,    A_const31,  A_test2         ;[10,3]
||      ADD     .S1X    A_t6,       B_t7,       A_top0          ;[10,3]
||[B_eob_err]ADDAH.D1   A_outi,     A_const31,  A_outi          ;mismatch
||[!B_eob_err]STW.D2T2  B7_bsbuf_circ,  *+B_SP[BSBUFC_SPOFF]    ;preserve

  [!B_eob_err]B .S2     loop                                    ;[31,1]
||      MPY     .M1X    A6_qw,      B_level3,   A_level4        ;[31,1]
||      SUB     .L2X    A_len,      5,          B_rld_left      ;[11,3]
||      AND     .S1     A_const31,  A_bptr1,    A6_bptr         ;[11,3]
||[ A_test2]LDW .D2T2   *B7_bsbuf_circ++,       B_word2         ;[11,3]
||      NORM    .L1     A_top0,     A_nrm                       ;[ 1,4]
||[B_eob_err]ADDAH.D1   A_outi,     A_const31,  A_outi          ;mismatch

 [!B_eob_err]ADD.L2     B_Wptr,     2,          B_Wptr          ;[32,1]
||[B_test3] ZERO.D2     B_rld_left                              ;[12,3]
||[ A_test2]MV  .L1X    B_word2,    A_word1                     ;[12,3]
||      SHL     .S2X    A_nrm,      4,          B_t2            ;[ 2,4]
||      SHL     .S1     A_top0,     A_nrm,      A_t1            ;[ 2,4]
||[B_eob_err]LDH.D1T1   *++A_outi[1],           A15_last_coeff  ;mismatch

  [ A2_neg]ADD  .D1     A_level4,   A_const31,  A_level4        ;[33,1]
||[!B_eob_err]LDH.D2T1  *++B_Wptr[B_run],       A_W             ;[23,2]
||[!B_eob_err]SHRU.S1   A_t1,       28,         A2_t4b          ;[ 3,4]
||      SHRU    .S2X    A_t1,       28,         B_t4            ;[ 3,4]
||      ADD     .L1X    A_len_c_tbl_adr,        B_t2,     A_t3b ;[ 3,4]
||      ADD     .L2     B_len_tbl_adr,          B_t2,     B_t3  ;[ 3,4]
; ==> Exit                             (B_t3 shares reg with B_eob_err)

        SSHL    .S1     A_level4,   15,         A_level5        ;[34,1]
||      MPY     .M2     B_level,    2,          B_level2        ;[24,2]
||      CMPLT   .L1X    B_level,    0,          A2_neg          ;[24,2]
||      CMPGT   .L2     B_run,      B0_const63, B_eob_err       ;[24,2]
||      SHL     .S2     B4_top0_bk, B_rld_left, B_t13           ;[14,3]
||      LDBU    .D1T2   *A_t3b[A2_t4b],         B_len_c         ;[ 4,4]
||      LDBU    .D2T1   *B_t3[B_t4],            A_len           ;[ 4,4]

        SHR     .S1     A_level5,   20,         A_level_f       ;[35,1]
||      SHRU    .S2     B_t13,      27,         B_t14           ;[15,3]
||      SUB     .L2X    B12_const32,A_bptr,     B_bptr_cmpl     ;[15,3]
||[B_eob_err]MPY.M2     1,          B_run,      B12_run_bk      ;preserve
||[B_eob_err]LDW.D2T1   *+B_SP[CNT_SPOFF],      A2_cnt          ;cnt

        STH     .D1T1   A_level_f,  *+A_outi[A_Z]               ;[36,1]
||      ADD     .S1     A_sum,      A_level_f,  A_sum           ;[36,1]
||      ADD     .L1X    B_t14,      A_t12,      A_t15           ;[16,3]
||      SHRU    .S2     B_word2,    B_bptr_cmpl,            B_t9;[16,3]
||[B_eob_err]MPY.M2     0,          B0_const63, B_Wptr          ;rule out overrun
||[!B_eob_err]CMPGTU.L2 B_Wptr,     B14_Wptr_end, B_eob_err     ;err detec

* =========================== PIPE LOOP EPILOG ============================ *
; live-out: B4_top0_bk, Wptr_end, Wptr, sum, cnt, bsbuf_circ (stack)

        .asg            B6,         B6_bsbuf

mismatch:
; input: A15_last_coeff=0, A2_cnt, B12_run_bk

 [A2_cnt]B      .S2     block_loop                             ; -- BRANCH --
||      MVK     .S1     65,          A3_const65                ; invalid VLC
||      CMPGTU  .L2     B3_Wptr,     B14_Wptr_end,B2_error     ; overrun
||      LDW     .D2T1   *+B15_SP[CBP_SPOFF], A7_cbp            ; cbp
||      MV      .L1X    B15_SP,      A14_SP                    ; exit

 [!B2_error]CMPGT.L2    B12_run_bk,  A3_const65, B2_error      ; invalid VLC
||      LDW      .D2T2  *+B15_SP[BSBUFC_SPOFF],  B7_bsbuf_circ ; adv bit
||      LDW      .D1T1  *+A14_SP[MPEG2V_SPOFF],  A6_Mpeg2v     ; exit

 [B2_error]B    .S2     exit                                   ; -- BRANCH --
||      ADD     .L1     A9_outi,     2,          A9_outi
||      MVK     .S1     1,           A3_const1
||      MV      .L2X    A2_cnt,      B1_cnt
||      LDW     .D2T2   *+B15_SP[BSBUF_SPOFF],   B6_bsbuf      ; exit

        XOR     .L1     0x01,        A15_last_coeff, A15_last_coeff; mismatch
||      AND     .S1     0x01,        A10_sum,    A1_odd        ; mismatch

 [!A1_odd]STH   .D1T1   A15_last_coeff,        *-A9_outi[1]    ; mismatch

        NOP

; branch occurs to block_loop
; branch occurs to exit 2 cycles after block_loop
; (preserve B2_error for exit)

* =========================== EXIT   ============================ *
        .asg            B15,        B15_SP       ; Stack pointer, B datapath
        .asg            A14,        A14_SP       ; Stack pointer, A datapath
        .asg            A0,         A_csr        ; CSR value to restore
        .asg            B3,         B3_ret       ; Return address
        .asg            B6,         B6_byte_diff

exit:
        LDW     .D1T1     *+A14_SP[BPTR_SPOFF],   A12_bptr

        STW     .D1T2     B4_top0_bk,      *+A6_Mpeg2v[TOP0_M2OFF]

        LDW     .D2T2     *-B7_bsbuf_circ[1],   B5_word2

        LDW     .D2T1     *-B7_bsbuf_circ[2],   A4_word1

        MVK     .S2       32,     B12_const32                     ;const

        SUB     .S2       B7_bsbuf_circ,   B6_bsbuf,  B6_byte_diff
||      STW     .D1T2     B2_error,        *+A6_Mpeg2v[FAULT_M2OFF]

        SHR     .S1X      B6_byte_diff,    2,          A2_next_wptr
||      STW     .D1T1     A12_bptr,        *+A6_Mpeg2v[BPTR_M2OFF]

        STW     .D1T1     A2_next_wptr,    *+A6_Mpeg2v[NEXTWPTR_M2OFF]

        STW     .D1T1     A4_word1,        *+A6_Mpeg2v[WORD1_M2OFF]
||      SUB     .L2X      B12_const32,     A12_bptr,     B8_bptr_cmpl ;rcnstr

        STW     .D1T2     B5_word2,        *+A6_Mpeg2v[WORD2_M2OFF]
||      ZERO    .L2       B0_amr_config
||      SHL     .S1       A4_word1,        A12_bptr,     A5          ;rcnstr
||      SHRU    .S2       B5_word2,        B8_bptr_cmpl, B8          ;rcnstr

        MVC     .S2       B0_amr_config, AMR
||      ADD     .L2X      A5,              B8,           B8_top1     ;rcnstr
||      ADDAW   .D2       B15_SP,   11,    B15_SP  ; release preserv. stack

        STW     .D1T2     B8_top1,         *+A6_Mpeg2v[TOP1_M2OFF]
||      MV      .S1X      B15_SP,     A14_SP

; restore stack:
        LDW     .D1T2   *+A14_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B15_SP[ 2], A_csr       ; Get CSR's value

        LDW     .D1T2   *+A14_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B15_SP[ 4], A10         ; Restore A10

        LDW     .D1T2   *+A14_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B15_SP[ 6], A11         ; Restore A11

        LDW     .D1T2   *+A14_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B15_SP[ 8], A12         ; Restore A12

        LDW     .D1T2   *+A14_SP[ 9], B13         ; Restore B13
||      LDW     .D2T1   *+B15_SP[10], A13         ; Restore A13

        LDW     .D1T2   *+A14_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B15_SP[12], A14         ; Restore A14
||      RET     .S2     B3_ret                    ; Return to caller

        MVC     .S2X    A_csr,      CSR           ; Restore CSR
||      LDW     .D2T1   *++B15_SP[14],A15         ; Restore A15
; ===== Interruptibility state restored here =====

        NOP             4
; ===== Branch Occurs =====

* ========================================================================= *
*   End of file:   img_mpeg2_vld_inter.asm                                  *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mpeg2_vld1.asm/ 1066929162  0     0     0       59840     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.10    Sun Sep 29 03:31:27 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mpeg2_vld_intra                                                 *
*                                                                           *
*   PLATFORM                                                                *
*       C6200                                                               *
*                                                                           *
*   REVISION DATE                                                           *
*       03-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*         void IMG_mpeg2_vld_intra                                          *
*         (                                                                 *
*             const short   *restrict Wptr,                                 *
*             short         *restrict outi,                                 *
*             IMG_mpeg2_vld *restrict Mpeg2v,                               *
*             int                     dc_pred[3]                            *
*         );                                                                *
*                                                                           *
*         Wptr:       Pointer to the quantization matrix.  Must be in       *
*                     the scan order corresponding to the inverse scan      *
*                     matrix.                                               *
*                                                                           *
*         outi[6*64]: Pointer to the output array where the decoded and     *
*                     dequantized IDCT coefficients are placed.             *
*                     Elements assumed to be set to zero prior to           *
*                     function call.  The routine assumes 6 8x8 blocks      *
*                     per MB, i.e. 4:2:0 format.                            *
*                                                                           *
*         Mpeg2v:     Pointer to the context object, which includes the     *
*                     input buffer variables.  The structure Mpeg2v is      *
*                     defined as follows:                                   *
*                                                                           *
*C          #ifndef IMG_MPEG2_VLD_STRUCT_                                   *
*C          #define IMG_MPEG2_VLD_STRUCT_ 1                                 *
*C                                                                          *
*C          typedef struct {                                                *
*C            unsigned int  *bsbuf;      // pointer to bitstream buffer     *
*C            unsigned int  next_wptr;   // next word to read from buffer   *
*C            unsigned int  bptr;        // bit position within word        *
*C            unsigned int  word1;       // word aligned buffer             *
*C            unsigned int  word2;       // word aligned buffer             *
*C            unsigned int  top0;        // top 32 bits of bitstream        *
*C            unsigned int  top1;        // next 32 bits of bitstream       *
*C            const unsigned char *scan; // inverse zigzag scan matrix      *
*C            unsigned int  intravlc;    // intra_vlc_format                *
*C            unsigned int  quant_scale; // quant_scale                     *
*C            unsigned int  dc_prec;     // intra_dc_precision              *
*C            unsigned int  cbp;         // coded_block_pattern             *
*C            unsigned int  fault;       // fault condition (returned)      *
*C            unsigned int  reserved;                                       *
*C          } IMG_mpeg2_vld;                                                *
*C                                                                          *
*C          #endif                                                          *
*                                                                           *
*         All variables in this strucure must have the layout as shown      *
*         since they are being accessed by this routine through             *
*         appropriate offsets.  Other variables may be appended to the      *
*         structure.                                                        *
*                                                                           *
*         The routine sets the fault flag Mpeg2v.fault to 1 if an invalid   *
*         VLC code was encountered or the total run for a block exceeded    *
*         63.  In theses cases the decoder has to resynchronize.            *
*                                                                           *
*         dc_pred[3]: Intra DC prediction array.  The first element of      *
*                     dc_pred is the DC prediction for Y, the second        *
*                     for Cr and the third for Cb.                          *
*                                                                           *
*       The routine requires proprietary variable length decoding           *
*       look-up tables.  The tables are based on Table B-14 and B-15 in     *
*       the MPEG-2 standard text.                                           *
*                                                                           *
*       The required lookup tables for this routine are provided in         *
*       IMGLIB and are linked in automatically when linking against         *
*       IMGLIB.                                                             *
*                                                                           *
*       Before calling the routine the bitstream varaibles in Mpeg2v have   *
*       to be initialized.  If bsbuf[] is a circular buffer of size         *
*       BSBUF_SIZE words and bsptr contains the number of bits in the       *
*       buffer that already have been consumed, then next_wptr, bptr,       *
*       word1, word2, top0 and top1 are initialized as follows:             *
*                                                                           *
*       1. nextwptr:  bsptr may not be a multiple of 32 (e.g. it points     *
*          to bit number 40 in the bitstream), therefore set it to the      *
*          next lower multiple of 32 by shift left by 5 (divide by 32).     *
*          In case of 40 this yields 1.  Since memory is addressed in       *
*          units of bytes this needs to be multiplied by 4 to get the       *
*          address pointer.  Use next_wptr as index into bsbuf[].           *
*                                                                           *
*              next_wptr = (bsptr >> 5);                                    *
*                                                                           *
*       2. bptr:  bptr is the bit pointer which points to the current       *
*          bit WITHIN the word pointed to by next_wptr.                     *
*                                                                           *
*             bptr = bsptr & 31;                                            *
*             bptr_cmpl = 32 - bptr;                                        *
*                                                                           *
*       3. word1 and word2:  read next 3 words from the bitstream buffer    *
*          (word0 is a temporary variable).                                 *
*                                                                           *
*             word0 = bsbuf[next_wptr];                                     *
*             next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 *
*                                                                           *
*             word1 = bsbuf[next_wptr];                                     *
*             next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 *
*                                                                           *
*             word2 = bsbuf[next_wptr];                                     *
*             next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 *
*                                                                           *
*       4. top0 and top1:  Shift words word0, word1, word2 by bptr to       *
*          the left so that the current bit becomes the MSB in word0.       *
*          word0 can simply be shifted by bptr; the then empty LSBs of      *
*          word0 have to be filled with the MSBs of word1.  To do that      *
*          the required MSBs are brought into the position of empty         *
*          LSBs of word0 by shifting word1 to the right by (32-bptr).       *
*          The result is then copied into word0 by an addition.  Rather     *
*          than overwriting word0, top0 is used to hold the new bit         *
*          aligned word.  The same procedure is used to obtain top1.        *
*          top0 and top1 contain the next 64 bits of the bitstream.         *
*                                                                           *
*             s1 = SHL(word0, bptr);                                        *
*             s2 = SHR(word1, bptr_cmpl);  // unsigned right-shift          *
*             top0 = s1 + s2;                                               *
*                                                                           *
*             s3 = SHL(word1, bptr);                                        *
*             s4 = SHR(word2, bptr_cmpl);  //  unsigned right-shift         *
*             top1 = s3 + s4;                                               *
*                                                                           *
*         SHL/SHR are macros that simulate C6000 shift functions if the     *
*         routine is to be run on a PC or UNIX platform. They are           *
*         defined as follows:                                               *
*                                                                           *
*             #ifdef _TMS320C6X                                             *
*             # define SHL(x,y) ( (x) << (y) )                              *
*             # define SHR(x,y) ( (x) >> (y) )                              *
*             #else                                                         *
*             # define SHL(x,y) ( ((y) & 32) ? 0 : ((x) << (y)) )           *
*             # define SHR(x,y) ( ((y) & 32) ? 0 : ((x) >> (y)) )           *
*             #endif                                                        *
*                                                                           *
*   DESCRIPTION                                                             *
*       Decodes all coefficients of an MPEG-2 intra coded macroblock.       *
*                                                                           *
*       Checks coded block pattern (cbp), performs DC and AC decoding       *
*       inlcuding, variable length decode, run-length expansion,            *
*       inverse zigzag, dequantization, saturation and mismatch             *
*       control.                                                            *
*                                                                           *
*   ASSUMPTIONS                                                             *
*     - bitstream buffer is set to 512 32-bit words (=2048 bytes),          *
*       buffer needs to be aligned at a 2048 boundary because it is         *
*       circular.  If this needs to be changed, AMR register setup has to   *
*       be modified  and alignment changed accordingly. Register B7 is      *
*       used as the address pointer to the bitstream buffer in              *
*       circular addressing mode with a size of 2^(10+1) bytes = 2048       *
*       bytes = 512 words. Accordingly, AMR is set to 0x000A0004. Note      *
*       that the AMR register is set to zero on exit.                       *
*                                                                           *
*     - The bitstream must be stored in memory in 32-bit words which        *
*       are in little Endian byte order.                                    *
*                                                                           *
*     - zigzag matrix (Zptr) is 64 bytes circularly addressed and needs     *
*       to be aligned at a 64 byte boundary (serves protection from         *
*       random stores into memory)                                          *
*                                                                           *
*     - inside the routine word1 (next_wptr-2) and word2 (next_wptr-1)      *
*       are reconstructed from the bitstream buffer and therfore have       *
*       to be kept alive in the bitstream buffer.  For instance, in a       *
*       double buffering scheme the bitstream buffer can only be            *
*       updated when next_wptr-2 (and not next_wptr) has crossed the        *
*       half buffer boundary.                                               *
*                                                                           *
*   NOTES                                                                   *
*     - little endian                                                       *
*                                                                           *
*     - non-interruptible                                                   *
*                                                                           *
*     - 4:2:0 color format supported only                                   *
*                                                                           *
*     - Wptr is allowed to overrun once (to detect total run overrun),      *
*       so maximum overrun that can occur is 66 (Error mark).               *
*       Therefore, in memory 66+1 half-words behind the weighting           *
*       matrix should be valid (e.g. no cache or peripherals).  No          *
*       memory is overwritten, only loads occur.                            *
*                                                                           *
*     - look-up tables len and len_c are offset against each other so       *
*       that they start in different memory banks to reduce bank            *
*       conflicts.                                                          *
*                                                                           *
*     - Up to 3 bank conflicts can occur on exit of the inner loop due      *
*       to stack accesses                                                   *
*                                                                           *
*   CYCLES                                                                  *
*       10 * (S - CB) + 57 * CB + 15 * NCB + 68                             *
*       where S:   Number of symbols in MB, CB: Number of coded blocks,     *
*             NCB: Number of not-coded blocks, and CB+NCB=6                 *
*                                                                           *
*   CODE SIZE                                                               *
*       1824                                                                *
*                                                                           *
*   DATA SIZE                                                               *
*       4352 bytes for lookup tables                                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

; ===================== SYMBOLIC REGISTER ASSIGNMENTS I ================== *
        .asg            B12,        B_word2
        .asg            A4,         A_word1
        .asg            B7,         B_bsbuf_circ
        .asg            A11,        A_len_c_tbl_adr
        .asg            B13,        B_len_tbl_adr
        .asg            A13,        A_rld_table_adr         ; was A12
        .asg            A12,        A_rld_table_adr_1       ; was A13
        .asg            A14,        A_const31
        .asg            B3,         B_const32
        .asg            B14,        B_const63
        .asg            A8,         A_top0
        .asg            B8,         B_top1
        .asg            A6,         A_bptr
        .asg            A9,         A_outi
        .asg            B9,         B_Wptr
        .asg            B5,         B_Zptr
        .asg            A15,        A_qscl
        .asg            A10,        A_sum
        .asg            B0,         B_Wptr_end
        .asg            B11,        B_run
        .asg            A3,         A_nrm
        .asg            A0,         A_t1
        .asg            B4,         B_t2
        .asg            B6,         B_t3
        .asg            A1,         A_t3b
        .asg            B4,         B_t4
        .asg            A0,         A_t4b
        .asg            A7,         A_len
        .asg            B6,         B_len_c
        .asg            A1,         A_t6
        .asg            B6,         B_t7
        .asg            B8,         B_top0_bk
        .asg            A0,         A_bptr1
        .asg            A1,         A_test2
        .asg            B6,         B_bptr_cmpl
        .asg            A5,         A_t8
        .asg            B6,         B_t9
        .asg            A1,         A_test1
        .asg            B10,        B_level
        .asg            B1,         B_test3
        .asg            B1,         B_rld_left
        .asg            A0,         A_t12
        .asg            B4,         B_t13
        .asg            B4,         B_t14
        .asg            A3,         A_t15
        .asg            A3,         A_t16
        .asg            B2,         B_eob_err
        .asg            A2,         A_neg
        .asg            B4,         B_level3
        .asg            A7,         A_W
        .asg            A3,         A_qw
        .asg            A3,         A_level4
        .asg            A3,         A_level5
        .asg            A3,         A_level_f
        .asg            A5,         A_Z
; ========================================================================= *

; ===================== SYMBOLIC REGISTER ASSIGNMENTS II ================== *
        .asg            B12,        B12_word2
        .asg            A4,         A4_word1
        .asg            B7,         B7_bsbuf_circ
        .asg            A11,        A11_len_c_tbl_adr
        .asg            B13,        B13_len_tbl_adr
        .asg            A13,        A13_rld_table_adr         ; was A12
        .asg            A12,        A12_rld_table_adr_1       ; was A13
        .asg            A14,        A14_const31
        .asg            B3,         B3_const32
        .asg            B14,        B14_const63
        .asg            A8,         A8_top0
        .asg            B8,         B8_top1
        .asg            A6,         A6_bptr
        .asg            A12,        A12_bptr
        .asg            A9,         A9_outi
        .asg            B9,         B9_Wptr
        .asg            B5,         B5_Zptr
        .asg            A15,        A15_qscl
        .asg            A10,        A10_sum
        .asg            B0,         B0_Wptr_end
        .asg            B0,         B0_const126
        .asg            A0,         A0_const126
        .asg            B11,        B11_run
        .asg            A3,         A3_nrm
        .asg            A0,         A0_t1
        .asg            B4,         B4_t2
        .asg            B6,         B6_t3
        .asg            A1,         A1_t3b
        .asg            B4,         B4_t4
        .asg            A0,         A0_t4b
        .asg            A7,         A7_len
        .asg            B6,         B6_len_c
        .asg            A1,         A1_t6
        .asg            B6,         B6_t7
        .asg            B8,         B8_top0_bk
        .asg            A0,         A0_bptr1
        .asg            A1,         A1_test2
        .asg            B6,         B6_bptr_cmpl
        .asg            B8,         B8_bptr_cmpl
        .asg            A5,         A5_t8
        .asg            B6,         B6_t9
        .asg            A1,         A1_test1
        .asg            B10,        B10_level
        .asg            B1,         B1_test3
        .asg            B1,         B1_rld_left
        .asg            A0,         A0_t12
        .asg            B4,         B4_t13
        .asg            B4,         B4_t14
        .asg            A3,         A3_t15
        .asg            A3,         A3_t16
        .asg            B2,         B2_eob_err
        .asg            A2,         A2_neg
        .asg            B4,         B4_level3
        .asg            A7,         A7_W
        .asg            A3,         A3_qw
        .asg            A3,         A3_level4
        .asg            A3,         A3_level5
        .asg            A3,         A3_level_f
        .asg            A5,         A5_Z
; ========================================================================= ;

; ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A3,         A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address

; ========================== DC Decoding and Prolog ======================= ;
        .asg            A6,         A6_r8
        .asg            A6,         A6_r6
        .asg            B6,         B6_block
        .asg            B15,        B15_SP
        .asg            A14,        A14_SP
        .asg            B2,         B2_len_c
        .asg            B1,         B1_bcomp
        .asg            A0,         A0_cnt
        .asg            A2,         A2_cnt
        .asg            A0,         A0_invq
        .asg            B1,         B1_cc1
        .asg            A1,         A1_odd
        .asg            B2,         B2_error
        .asg            B14,        B14_cbp_mask
        .asg            B14,        B14_dc_pred
        .asg            B1,         B1_test0
        .asg            A7,         A7_pred
        .asg            A7,         A7_valdq
        .asg            B10,        B10_d1
        .asg            A5,         A5_lentot
        .asg            A1,         A1_coded
        .asg            B5,         B5_run_bk
        .asg            A15,        A15_last_coeff
        .asg            B11,        B11_dc_diff
        .asg            A2,         A2_b
        .asg            B10,        B10_r9
        .asg            A0,         A0_r1
        .asg            A5,         A5_len
        .asg            B1,         B1_d
        .asg            B2,         B2_c
        .asg            B9,         B9_bptr_cmpl
        .asg            B6,         B6_dc_size
        .asg            A1,         A1_cc0
        .asg            B4,         B4_byte_diff
        .asg            A6,         A6_r6
        .asg            A2,         A2_test2
        .asg            A7,         A7_val
        .asg            B1,         B1_flag
        .asg            B0,         B0_cc
        .asg            B2,         B2_r7
        .asg            B1,         B1_dc_size
        .asg            A15,        A15_half_range
        .asg            A15,        A15_r5
        .asg            B10,        B10_r4
        .asg            A15,        A15_r2
        .asg            B10,        B10_r3
        .asg            B1,         B1_cnt
        .asg            A3,         A3_const65

; ========================================================================= ;

        .global _IMG_len_tbl0
        .global _IMG_len_c_tbl0
        .global _IMG_rld_table0

        .global _IMG_len_tbl1
        .global _IMG_len_c_tbl1
        .global _IMG_rld_table1

; Mpeg2v structure:
BSBUF_M2OFF      .set   0x0
NEXTWPTR_M2OFF   .set   0x1
BPTR_M2OFF       .set   0x2
WORD1_M2OFF      .set   0x3
WORD2_M2OFF      .set   0x4
TOP0_M2OFF       .set   0x5
TOP1_M2OFF       .set   0x6
ZPTR_M2OFF       .set   0x7
;SUM_M2OFF        not used
FORMAT_M2OFF     .set   0x8
QSCL_M2OFF       .set   0x9
DCPREC_M2OFF     .set   0xA
CBP_M2OFF        .set   0xB
FAULT_M2OFF      .set   0xC

; stack layout:
BSBUF_SPOFF      .set   0x0
MPEG2V_SPOFF     .set   0x1
TOP1_SPOFF       .set   0x2
BPTR_SPOFF       .set   0x3
DCPREC_SPOFF     .set   0x4
WPTR_SPOFF       .set   0x5
CNT_SPOFF        .set   0x6
ZPTR_SPOFF       .set   0x7
CBP_SPOFF        .set   0x8
DCPRED_SPOFF     .set   0x9
QSCL_SPOFF       .set   0xA
BSBUFC_SPOFF     .set   0xB



        .sect ".text:_mpeg2_vld_intra"
        .global _IMG_mpeg2_vld_intra
_IMG_mpeg2_vld_intra:
; parameters:  B_Wptr0, A_outi, A_Mpeg2v, B_dc_pred
;              A4,      B4,     A6,       B6

* ========================================================================= *
*  Setup
* ========================================================================= *

; ========================================================================= ;
; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
; Order:  A15, A14, B14, A13, B13, A12, B12, A11, B11, A10, B10, CSR, B3,
; empty
; ========================================================================= ;

        STW     .D2T1   A15,        *B_SP--[14]          ; Get stk, Save A15
||      MV              B_SP,       A_SP                 ; Twin Stack Ptr

        STW     .D1T1   A14,        *-A_SP[ 2]           ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]           ; Save B14
||      MVC     .S2     CSR,        B_csr                ; Get CSR's state

        STW     .D1T1   A13,        *-A_SP[ 4]           ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]           ; Save B13
||      AND             B_csr,      -2,         B_no_gie ; Clear GIE
;-
        STW     .D1T1   A12,        *-A_SP[ 6]           ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]           ; Save B12

        STW     .D1T1   A11,        *-A_SP[ 8]           ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]           ; Save B11
||      MV              B_csr,      A_csr                ; Partitioning MV

        STW     .D1T1   A10,        *-A_SP[10]           ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]           ; Save B10
||      MVC     .S2     B_no_gie,   CSR                  ; Disable ints.
; ===== Interrupts masked here =====  mask interrupts later?
;-
        STW     .D1T1   A_csr,      *-A_SP[12]           ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]           ; Save return addr.

* ========================================================================= *
        MV      .L1X    B4,         A9_outi
||      MV      .L2X    A4,         B9_Wptr

* ======================================================================== *
*  Get bitstream info
* ======================================================================== *
    .asg        A6,     A6_Mpeg2v
    .asg        B14,    B14_Mpeg2v
    .asg        B0,     B0_intra_vlc_format
    .asg        A2,     A2_intra_dc_precision
    .asg        B4,     B4_bsbuf
    .asg        A2,     A2_next_wptr
    .asg        B3,     B3_next_wptr
    .asg        A7,     A7_cbp

    MV         .L2X     A6_Mpeg2v,   B14_Mpeg2v

    LDW        .D2T2    *+B14_Mpeg2v[FORMAT_M2OFF], B0_intra_vlc_format
||  LDW        .D1T1    *+A6_Mpeg2v[CBP_M2OFF], A7_cbp

    LDW        .D1T1    *+A6_Mpeg2v[DCPREC_M2OFF], A2_intra_dc_precision
||  LDW        .D2T2    *+B14_Mpeg2v[BSBUF_M2OFF], B4_bsbuf

    LDW        .D2T2    *+B14_Mpeg2v[NEXTWPTR_M2OFF], B3_next_wptr
||  LDW        .D1T1    *+A6_Mpeg2v[BPTR_M2OFF], A12_bptr

    LDW        .D2T2    *+B14_Mpeg2v[ZPTR_M2OFF], B5_Zptr
||  LDW        .D1T1    *+A6_Mpeg2v[WORD1_M2OFF], A4_word1

    LDW        .D2T2    *+B14_Mpeg2v[WORD2_M2OFF], B12_word2
||  LDW        .D1T1    *+A6_Mpeg2v[QSCL_M2OFF], A15_qscl

* ------------------------------------------------------------------------
*  load table addresses and constants
* ------------------------------------------------------------------------ *
    [!B0_intra_vlc_format] MVKL  .S2    _IMG_len_tbl0,   B13_len_tbl_adr
 || [!B0_intra_vlc_format] MVKL  .S1    _IMG_len_c_tbl0, A11_len_c_tbl_adr

    [!B0_intra_vlc_format] MVKH  .S2    _IMG_len_tbl0,   B13_len_tbl_adr
 || [!B0_intra_vlc_format] MVKH  .S1    _IMG_len_c_tbl0, A11_len_c_tbl_adr

    [!B0_intra_vlc_format] MVKL  .S1    _IMG_rld_table0, A13_rld_table_adr

    [!B0_intra_vlc_format] MVKH  .S1    _IMG_rld_table0, A13_rld_table_adr

    [B0_intra_vlc_format]  MVKL  .S2    _IMG_len_tbl1,   B13_len_tbl_adr
 || [B0_intra_vlc_format]  MVKL  .S1    _IMG_len_c_tbl1, A11_len_c_tbl_adr

    [B0_intra_vlc_format]  MVKH  .S2    _IMG_len_tbl1,   B13_len_tbl_adr
||  [B0_intra_vlc_format]  MVKH  .S1    _IMG_len_c_tbl1, A11_len_c_tbl_adr

    [B0_intra_vlc_format]  MVKL  .S1    _IMG_rld_table1, A13_rld_table_adr

    [B0_intra_vlc_format]  MVKH  .S1    _IMG_rld_table1, A13_rld_table_adr

* ======================================================================== *
*  Setup circuar bitstream buffer (save AMR!)
*     B7 circular mode, 2^(10+1) bytes (=2048 bytes=512 words x 32 bit)
*     B5 circular mode, 2^(5+1) bytes
*
*  Block loop setup
* ======================================================================== *
          .asg       B6,    B6_dc_pred
          .asg       A3,    A3_const1
          .asg       B0,    B0_amr_config

          SUBAW   .D2       B15_SP,     11,          B15_SP  ; reserve stack

          MV      .S1X      B15_SP,     A14_SP
||        MVKL    .S2       0x00AA4800, B0_amr_config
||        LDW     .D1T2     *+A6_Mpeg2v[TOP0_M2OFF], B8_top0_bk

          STW     .D1T1     A6_Mpeg2v,  *+A14_SP[MPEG2V_SPOFF] ; reqd in exit
||        STW     .D2T2     B4_bsbuf,   *+B15_SP[BSBUF_SPOFF]
||        MVKH    .S2       0x00AA4800, B0_amr_config

          STW     .D1T1     A2_intra_dc_precision, *+A14_SP[DCPREC_SPOFF]
||        STW     .D2T2     B9_Wptr,    *+B15_SP[WPTR_SPOFF]
||        MVC     .S2       B0_amr_config,  AMR

          ADDAW   .D2       B4_bsbuf,   B3_next_wptr,  B7_bsbuf_circ
||        MVK     .S2       6,      B1_cnt
||        MVK     .S1       1,      A3_const1

          STW     .D2T2     B5_Zptr,    *+B15_SP[ZPTR_SPOFF]
||        STW     .D1T1     A7_cbp,     *+A14_SP[CBP_SPOFF]

          STW     .D2T2     B6_dc_pred, *+B15_SP[DCPRED_SPOFF]
||        STW     .D1T1     A15_qscl,   *+A14_SP[QSCL_SPOFF]

          STW     .D2T2     B7_bsbuf_circ, *+B15_SP[BSBUFC_SPOFF]
||        STW     .D1T1     A12_bptr,   *+A14_SP[BPTR_SPOFF]
||        MVK     .S2       32,     B3_const32           ; required in kernel


; block loop prolog:
* --------------------------------------------------------------------
*  check cbp, obtain cc, and decode DC size and DC VLC length
*  cc=0 for block 0..3, cc=1 for block 4, cc=2 for block 5
* -------------------------------------------------------------------- *
            SUB   .S2     B1_cnt,       1,        B1_bcomp    ; cbp, cnt--
||          SUB   .L2     6,            B1_cnt,   B6_block    ; cc
||          ZERO  .S1     A10_sum
||          MV    .L1X    B8_top0_bk,   A8_top0               ; live out
||          MPY   .M2     0,            B3_const32, B0_cc     ; cc

            SHL   .S2X    A3_const1,    B1_bcomp, B14_cbp_mask; cbp
||          CMPLT .L2     B6_block,     4,        B1_flag     ; cc
||          LMBD  .L1     0,            A8_top0,  A2_b        ; DC size&len
||          STW   .D2T2   B1_bcomp,     *+B15_SP[CNT_SPOFF]   ; cnt

 [!B1_flag] AND   .L2     B6_block,     1,        B0_cc       ; cc
||          ADD   .D1     A2_b,         1,        A5_len      ; DC size&len
||          AND   .L1X    B14_cbp_mask, A7_cbp,   A1_coded    ; cbp
||          MVK   .S1     126,         A0_const126            ; not coded

block_loop:
; do not use B2 in the next to cycles, preserves B2_error
 [!A1_coded]B     .S1     mismatch                            ; cbp
||          LDW   .D2T1   *+B15_SP[CNT_SPOFF],    A2_cnt      ; not coded
||[!A1_coded]ADD  .D1     A_outi,       A0_const126, A_outi   ; not coded
||[!B1_flag]ADD   .L2     B0_cc,        1,        B0_cc       ; cc
||          ZERO  .L1     A1_cc0                              ; DC size&len
||          SHRU  .S2X    A8_top0,      29,       B10_d1      ; DC size&len

 [!B0_cc]   ADD   .L2X    A2_b,         2,        B6_dc_size  ; DC size&len
||[!B0_cc]  CMPGT .L1     A2_b,         8,        A1_cc0      ; DC size&len
||[!B0_cc]  SHRU  .S1     A2_b,         1,        A2_b        ; DC size&len
||[!B0_cc]  SUB   .S2     B10_d1,       4,        B1_d        ; DC size&len
||          ZERO  .D2     B5_run_bk                           ; not coded

 [B0_cc]    ADD   .L2X    A2_b,         1,        B6_dc_size  ; DC size&len
||[!A2_b]   ADD   .S1     A5_len,       1,        A5_len      ; DC size&len
||[B0_cc]   MVK   .S2     1,            B1_d                  ; anything !=0
||          LDW   .D2T2   *+B15_SP[DCPRED_SPOFF], B14_dc_pred ; QFS[0]

            ZERO  .D2     B1_cc1                              ; DC size&len
||[!B1_d]   SUB   .L2     B6_dc_size,   3,        B6_dc_size  ; DC size&len
||          SHRU  .S2X    A8_top0,      30,       B2_c        ; DC size&len
||          SHL   .S1     A4_word1,     A12_bptr, A6          ;reconstruct

  [B0_cc]   CMPGT .L2X    A2_b,         9,        B1_cc1      ; DC size&len
||[!B2_c]   SUB   .D2     B6_dc_size,   1,        B6_dc_size  ; DC size&len
||          MVK   .S1     31,                     A14_const31 ; const
||          ZERO  .S2     B9_Wptr                             ; not coded
||          ZERO  .L1     A15_last_coeff                      ; not coded


 [A1_cc0]   MVK   .S1     9,            A5_len                ; DC size&len
||[A1_cc0]  MVK   .S2     11,           B6_dc_size            ; DC size&len
||          ADD   .L1     A15_last_coeff, 1, A15_last_coeff   ; not coded (no mism)
; branch occurs
; enable interrupts

 [B1_cc1]   MVK   .S1     10,           A5_len                ; DC size&len
||[B1_cc1]  MVK   .S2     11,           B6_dc_size            ; DC size&len
||          SUB   .L2X    B_const32,    A12_bptr, B8_bptr_cmpl;reconstruct

            SHRU  .S2     B12_word2,    B8_bptr_cmpl, B8      ;reconstruct

            ADD   .L2X    A6,           B8,           B8_top1 ;reconstruct

* --------------------------------------------------------------------
*  Intra DC: obtain QFS[0] from B_dc_size and A_dc_differential
*  Intra DC: de-quantization and store result (DC iQ)
*  Intra DC: mismatch control
*  Intra DC: advance bitstream
* -------------------------------------------------------------------- *
            MV    .L2    B6_dc_size,    B1_dc_size                 ; QFS[0]
||          ZERO  .S2    B11_dc_diff                               ; QFS[0]
||          SHL   .S1    A8_top0,       A5_len,      A0_r1         ; QFS[0]
||          LDW   .D2T1  *B14_dc_pred[B0_cc],        A7_pred       ; QFS[0]
||          ADD   .L1    A5_len,        B6_dc_size,  A5_lentot     ; adv bit

 [B1_dc_size]SUB  .L1X   B1_dc_size,    1,           A15_r2        ; QFS[0]
||[B1_dc_size]SUB .L2    B3_const32,    B1_dc_size,  B10_r3        ; QFS[0]
||          LDW   .D2T1  *+B15_SP[DCPREC_SPOFF],A2_intra_dc_precision; DC iQ
||          SUB   .S2    B3_const32,    A5_lentot,   B2_len_c      ; adv bit
||          SHL   .S1    A8_top0,       A5_lentot,   A6_r6         ; adv bit
||          ADD   .D1    A12_bptr,      A5_lentot,   A12_bptr      ; adv bit

 [B1_dc_size]SHL  .S1    A3_const1,     A15_r2,      A15_half_range; QFS[0]
||[B1_dc_size]SHRU.S2X   A0_r1,         B10_r3,      B11_dc_diff   ; QFS[0]
||[!B1_dc_size]ZERO.D2   B1_test0                                  ; QFS[0]
||          CMPGT .L1    A12_bptr,      A14_const31, A2_test2      ; adv bit

 [B1_dc_size]CMPLT.L2X   B11_dc_diff,   A15_half_range, B1_test0   ; QFS[0]
||          SHRU  .S2    B8_top1,       B2_len_c,    B2_r7         ; adv bit
||[A2_test2]MV    .S1X   B12_word2,     A4_word1                   ; adv bit
||          AND   .L1    A12_bptr,      A14_const31, A12_bptr      ; adv bit

 [B1_test0] ADD   .L2    B11_dc_diff,   1,           B10_r4        ; QFS[0]
||[B1_test0]SHL   .S1    A15_half_range,1,           A15_r5        ; QFS[0]
||          ADD   .L1    A6_r6,         B2_r7,       A8_top0       ; adv bit
||[A2_test2]LDW   .D2T2  *B7_bsbuf_circ++,           B12_word2     ; adv bit
||          SUB   .S2X   B3_const32,    A12_bptr,    B9_bptr_cmpl  ; adv bit

* =========================== PIPE LOOP PROLOG ============================ *
         NORM  .L1       A8_top0,    A3_nrm                     ;[ 1,1]
||[B1_test0]SUB.L2X      B10_r4,     A15_r5,      B11_dc_diff   ; QFS[0]
||       SHL   .S1       A4_word1,   A12_bptr,    A6_r8         ; adv bit

         SHL   .S2X      A3_nrm,     4,           B4_t2         ;[ 2,1]
||       SHL   .S1       A8_top0,    A3_nrm,      A0_t1         ;[ 2,1]
||       ADD   .L1X      A7_pred,    B11_dc_diff, A7_val        ; QFS[0]

         SHRU  .S1       A0_t1,      28,          A0_t4b        ;[ 3,1]
||       SHRU  .S2X      A0_t1,      28,          B4_t4         ;[ 3,1]
||       ADD   .L1X      A11_len_c_tbl_adr,       B4_t2,  A1_t3b;[ 3,1]
||       ADD   .L2       B13_len_tbl_adr,         B4_t2,  B6_t3 ;[ 3,1]

         LDBU  .D1T2     *A1_t3b[A0_t4b],         B6_len_c      ;[ 4,1]
||       LDBU  .D2T1     *B6_t3 [B4_t4],          A7_len        ;[ 4,1]
||       SUB   .S1       3,  A2_intra_dc_precision, A0_invq     ; DC iQ

         STW   .D2T1     A7_val,     *B14_dc_pred[B0_cc]        ; QFS[0]
||       SHL   .S1       A7_val,     A0_invq,     A7_valdq      ; DC iQ

         STH   .D1T1     A7_valdq,   *A9_outi                   ; DC iQ
||       ADD   .L1       A10_sum,    A7_valdq,    A10_sum       ; msmtch

         SHRU  .S2       B12_word2,  B9_bptr_cmpl,B10_r9        ; adv bit

         ADD   .L2X      A6_r8,      B10_r9,      B8_top1       ; adv bit
||       MV    .L1       A12_bptr,   A6_bptr

* -------------------------------------------------------------------- *

        CMPLT   .L2X    A7_len,      5,          B_test3        ;[ 9,1]
||      ADD     .L1     A_bptr,     A7_len,      A_bptr1        ;[ 9,1]
||      SHRU    .S2     B_top1,     B6_len_c,    B_t7           ;[ 9,1]
||      SHL     .S1     A_top0,     A7_len,      A_t6           ;[ 9,1]

        CMPGT   .L1     A_bptr1,    A14_const31,A_test2         ;[10,1]
||      ADD     .S1X    A_t6,       B_t7,       A_top0          ;[10,1]
||      MV      .L2X    A_top0,     B_top0_bk                   ;[10,1]
||      MVK     .S2     126,        B0_const126                 ; const

  [B_test3] MPY .M2     B_const32,  0,          B_rld_left      ;[11,1]
||      SUB     .L2X    A7_len,     5,          B_rld_left      ;[11,1]
||      AND     .S1     A14_const31,  A_bptr1,  A_bptr          ;[11,1]
||      NORM    .L1     A_top0,     A_nrm                       ;[ 1,2]
||      MVK     .S2     63,         B14_const63                 ; const

  [ A_test2]LDW .D2T2   *B_bsbuf_circ++,        B_word2         ;[12,1]
||[ A_test2]MV  .L1X    B_word2,    A_word1                     ;[12,1]
||      SHL     .S2X    A_nrm,      4,          B_t2            ;[ 2,2]
||      SHL     .S1     A_top0,     A_nrm,      A_t1            ;[ 2,2]

        SHRU    .S1     A_t1,       28,         A_t4b           ;[ 3,2]
||      SHRU    .S2X    A_t1,       28,         B_t4            ;[ 3,2]
||      ADD     .L1X    A_len_c_tbl_adr,        B_t2,      A_t3b;[ 3,2]
||      ADD     .L2     B_len_tbl_adr,          B_t2,      B_t3 ;[ 3,2]
||      LDW     .D2T2   *+B_SP[WPTR_SPOFF],     B9_Wptr         ; reset

        SHL     .S2     B_top0_bk,  B_rld_left, B_t13           ;[14,1]
||      MPY     .M1X    B_const32,  A7_len,     A_t12           ;[14,1]
||      SUB     .L2X    B_const32,  A_bptr,     B_bptr_cmpl     ;[14,1]
||      LDBU    .D1T2   *A_t3b[A_t4b],          B_len_c         ;[ 4,2]
||      LDBU    .D2T1   *B_t3[B_t4],            A7_len          ;[ 4,2]

        SHRU    .S2     B_t13,      27,         B_t14           ;[15,1]
||      LDW     .D2T2   *+B_SP[ZPTR_SPOFF],     B5_Zptr         ; reset

        ADD     .L1X    B_t14,      A_t12,      A_t15           ;[16,1]
||      EXT     .S2     B_top0_bk,  12, 20,     B_level         ;[16,1]
||      ADD     .S1     1, A13_rld_table_adr,A12_rld_table_adr_1; const

        ADD     .L1     A_t15,      A_t15,      A_t16           ;[17,1]
||      SUB     .D1     A7_len,     24,         A_test1         ;[17,1]
||      SHRU    .S2     B_word2,    B_bptr_cmpl, B_t9           ;[17,1]
||      SHL     .S1     A_word1,    A_bptr,     A_t8            ;[17,1]
||      STW     .D2T2   B_bsbuf_circ, *+B_SP[BSBUFC_SPOFF]      ; preserve

  [ A_test1]LDBU.D1T2   *A12_rld_table_adr_1[A_t16], B_run      ;[18,1]
||      EXTU    .S2     B_top0_bk,  6,  26,     B_run           ;[18,1]
||      ADD     .L2X    A_t8,       B_t9,       B_top1          ;[18,1]

  [ A_test1]LDB .D1T2   *A13_rld_table_adr[A_t16],   B_level    ;[19,1]
||      CMPLT   .L2X    A7_len,      5,          B_test3        ;[ 9,2]
||      ADD     .L1     A_bptr,     A7_len,      A_bptr1        ;[ 9,2]
||      SHRU    .S2     B_top1,     B_len_c,     B_t7           ;[ 9,2]
||      SHL     .S1     A_top0,     A7_len,      A_t6           ;[ 9,2]
||      ADD     .D2     B9_Wptr,    B0_const126, B0_Wptr_end    ; const

        CMPGT   .L1     A_bptr1,    A14_const31,A_test2         ;[10,2]
||      ADD     .S1X    A_t6,       B_t7,       A_top0          ;[10,2]
||      MV      .L2X    A_top0,     B_top0_bk                   ;[10,2]
||      ADD     .S2     B5_Zptr,    1,          B5_Zptr         ; reset
||      STW     .D2T1   A_bptr,     *+B_SP[BPTR_SPOFF]          ; preserve

  [B_test3] MPY .M2     B_const32,  0,          B_rld_left      ;[11,2]
||      SUB     .L2X    A7_len,     5,          B_rld_left      ;[11,2]
||      AND     .S1     A14_const31,A_bptr1,    A_bptr          ;[11,2]
||      NORM    .L1     A_top0,     A_nrm                       ;[ 1,3]
||      LDW     .D2T1   *+B15_SP[QSCL_SPOFF],   A15_qscl        ; const
||      ADD     .S2     B0_Wptr_end, 2,         B0_Wptr_end     ; const

  [ A_test2]LDW .D2T2   *B_bsbuf_circ++,        B_word2         ;[12,2]
||[ A_test2]MV  .L1X    B_word2,    A_word1                     ;[12,2]
||      SHL     .S2X    A_nrm,      4,          B_t2            ;[ 2,3]
||      SHL     .S1     A_top0,     A_nrm,      A_t1            ;[ 2,3]
||      ADD     .L2     B9_Wptr,    2,          B9_Wptr          ;reset

        LDH     .D2T1   *++B9_Wptr[B_run],      A_W             ;[23,1]
||      SHRU    .S1     A_t1,       28,         A_t4b           ;[ 3,3]
||      SHRU    .S2X    A_t1,       28,         B_t4            ;[ 3,3]
||      ADD     .L1X    A_len_c_tbl_adr,        B_t2,  A_t3b    ;[ 3,3]
||      ADD     .L2     B_len_tbl_adr,          B_t2,  B_t3     ;[ 3,3]

        SHL     .S2     B_top0_bk,  B_rld_left, B_t13           ;[14,2]
||      MPY     .M1X    B_const32,  A7_len,     A_t12           ;[14,2]
||      SUB     .L2X    B_const32,  A_bptr,     B_bptr_cmpl     ;[14,2]
||      LDBU    .D1T2   *A_t3b[A_t4b],          B_len_c         ;[ 4,3]
||      LDBU    .D2T1   *B_t3[B_t4],            A7_len          ;[ 4,3]

        LDB     .D2T1   *++B5_Zptr[B_run],      A_Z             ;[25,1]
||      MPY     .M2     B_level,    2,          B_level3        ;[25,1]
||      CMPLT   .L1X    B_level,    0,          A_neg           ;[25,1]
||      SHRU    .S2     B_t13,      27,         B_t14           ;[15,2]
||      CMPGT   .L2     B_run,      B14_const63,B_eob_err       ;[26,1]

        ADD     .L1X    B_t14,      A_t12,      A_t15           ;[16,2]
||      EXT     .S2     B_top0_bk,  12, 20,     B_level         ;[16,2]
||[B_eob_err]LDW.D2T2   *+B15_SP[BSBUFC_SPOFF],B7_bsbuf_circ    ; adv bit
||[B_eob_err]MPY.M2     0,          B14_const63,B9_Wptr         ;ruleoutoverrun

* =========================== PIPE LOOP KERNEL ============================ *
loop:
              ADD   .L1     A_t15,      A_t15,      A_t16           ;[17,2]
||            SUB   .D1     A_len,      24,         A_test1         ;[17,2]
||            SHRU  .S2     B_word2,    B_bptr_cmpl,B_t9            ;[17,2]
||            SHL   .S1     A_word1,    A_bptr,     A_t8            ;[17,2]
||            STW   .D2T2   B7_bsbuf_circ, *+B_SP[BSBUFC_SPOFF]     ; preserve

              MPY   .M1     A15_qscl,   A_W,        A_qw            ;[28,1]
||[A_test1]   LDBU  .D1T2   *A_rld_table_adr_1[A_t16],    B_run     ;[18,2]
||            EXTU  .S2     B8_top0_bk,  6,  26,    B_run           ;[18,2]
||[!B_eob_err]ADD   .L2X    A_t8,       B_t9,       B8_top1         ;[18,2]
||[B_eob_err] MV    .D2     B_run,      B5_run_bk                   ; preserve
||[B_eob_err] B     .S1     mismatch                                ;EOB_ERR exit

  [A_test1]   LDB   .D1T2   *A_rld_table_adr[A_t16],B_level         ;[19,2]
||            CMPLT .L2X    A_len,      5,          B_test3         ;[ 9,3]
||            ADD   .L1     A_bptr,     A_len,      A_bptr1         ;[ 9,3]
||            SHRU  .S2     B8_top1,    B_len_c,    B_t7            ;[ 9,3]
||            SHL   .S1     A_top0,     A_len,      A_t6            ;[ 9,3]
||[B_eob_err] LDW   .D2T1   *+B15_SP[CNT_SPOFF],    A2_cnt          ; cnt
; possible bank confl at exit only

  [!B_eob_err]CMPGT .L1     A_bptr1,    A14_const31,A_test2         ;[10,3]
||[B_eob_err] MPY   .M1     0,          A14_const31,A_test2         ;preserve
||            ADD   .S1X    A_t6,       B_t7,       A_top0          ;[10,3]
||[!B_eob_err]MV    .S2X    A_top0,     B8_top0_bk                  ;[10,3]prsrv
||[!B_eob_err]STW   .D2T1   A_bptr,     *+B_SP[BPTR_SPOFF]          ; preserve
||[B_eob_err] ADDAH .D1     A_outi,     A14_const31,A_outi          ;mismatch
||[!B_eob_err]ADD   .L2     B9_Wptr,    2,          B9_Wptr         ;[31,1]prsrv

  [!B_eob_err]B     .S2     loop                                    ;[31,1]
||            MPY   .M1X    A_qw,       B_level3,   A_level4        ;[31,1]
||[B_test3]   MPY   .M2     B_const32,  0,          B_rld_left      ;[11,3]
||            SUB   .L2X    A_len,      5,          B_rld_left      ;[11,3]
||            AND   .S1     A14_const31,A_bptr1,    A_bptr          ;[11,3]
||            NORM  .L1     A_top0,     A_nrm                       ;[ 1,4]
||[B_eob_err] ADDAH .D1     A_outi,     A_const31,  A_outi          ;mismatch
||[!B_eob_err]ADDAB .D2     B5_Zptr,    1,          B5_Zptr         ;[27,1]

  [ A_test2]  LDW   .D2T2   *B7_bsbuf_circ++,       B_word2         ;[12,3]
||[ A_test2]  MV    .L1X    B_word2,    A_word1                     ;[12,3]
||            SHL   .S2X    A_nrm,      4,          B_t2            ;[ 2,4]
||            SHL   .S1     A_top0,     A_nrm,      A_t1            ;[ 2,4]
||[B_eob_err] LDH   .D1T1   *++A_outi[1],           A15_last_coeff  ;mismatch
; possible bank confl at exit only

  [ A_neg]    ADD   .D1     A_level4,   A14_const31,A_level4        ;[33,1]
||[!B_eob_err]LDH   .D2T1   *++B9_Wptr[B_run],      A_W             ;[23,2]prsrv
||            SHRU  .S1     A_t1,       28,         A_t4b           ;[ 3,4]
||            SHRU  .S2X    A_t1,       28,         B_t4            ;[ 3,4]
||            ADD   .L1X    A_len_c_tbl_adr,        B_t2,     A_t3b ;[ 3,4]
||            ADD   .L2     B_len_tbl_adr,          B_t2,      B_t3 ;[ 3,4]
; EOB_ERR branch occurs

              SSHL  .S1     A_level4,   15,         A_level5        ;[34,1]
||            SHL   .S2     B8_top0_bk,  B_rld_left, B_t13          ;[14,3]
||            MPY   .M1X    B_const32,  A_len,      A_t12           ;[14,3]
||            SUB   .L2X    B_const32,  A_bptr,     B_bptr_cmpl     ;[14,3]
||            LDBU  .D1T2   *A_t3b[A_t4b],          B_len_c         ;[ 4,4]
||            LDBU  .D2T1   *B_t3[B_t4],            A_len           ;[ 4,4]

              SHR   .S1     A_level5,   20,         A3_level_f      ;[35,1]
||            LDB   .D2T1   *++B5_Zptr[B_run],      A_Z             ;[25,2]
||            MPY   .M2     B_level,    2,          B_level3        ;[25,2]
||            CMPLT .L1X    B_level,    0,          A_neg           ;[25,2]
||            SHRU  .S2     B_t13,      27,         B_t14           ;[15,3]
||            CMPGT .L2     B_run,      B14_const63,B_eob_err       ;[26,2]

              STH   .D1T1   A3_level_f, *+A_outi[A_Z]               ;[36,1]
||            ADD   .S1     A_sum,      A3_level_f, A_sum           ;[36,1]
||            ADD   .L1X    B_t14,      A_t12,      A_t15           ;[16,3]
||            EXT   .S2     B8_top0_bk, 12, 20,     B_level         ;[16,3]
||[B_eob_err] MPY   .M2     0,          B14_const63,B9_Wptr         ;ruleoutoverrun
||[!B_eob_err]CMPGTU.L2     B9_Wptr,    B0_Wptr_end,B_eob_err       ;err detec
||[B_eob_err] LDW   .D2T2   *+B15_SP[BSBUFC_SPOFF],B7_bsbuf_circ    ; adv bit
; possible bank confl only at exit

* =========================== PIPE LOOP EPILOG ============================ *
; live-out: B4_top0_bk, B7_bsbuf_circ, A_sum, A2_cnt, B5_run_bk, Wptr,
; Wptr_end, A15_last_coeff=0

mismatch:

 [A2_cnt]B      .S2     block_loop                         ; -- BRANCH --
||      MVK     .S1     65,          A3_const65            ; invalid VLC
||      CMPGTU  .L2     B9_Wptr,     B0_Wptr_end,B2_error  ; overrun
||      LDW     .D2T1   *+B15_SP[CBP_SPOFF], A7_cbp        ; cbp
||      MV      .L1X    B15_SP,      A14_SP                ; exit

 [!B2_error]CMPGT.L2    B5_run_bk,  A3_const65, B2_error   ; invalid VLC
||      AND     .L1     0x01,        A10_sum,    A1_odd    ; mismatch
||      LDW     .D2T2   *-B7_bsbuf_circ[1],      B12_word2 ; adv bit
||      LDW     .D1T1     *+A14_SP[MPEG2V_SPOFF], A6_Mpeg2v; exit

 [B2_error]B    .S2     exit                               ; -- BRANCH --
||      ADD     .L1     A9_outi,     2,          A9_outi
||      MVK     .S1     1,           A3_const1
||      MV      .L2X    A2_cnt,      B1_cnt
||      LDW     .D2T1   *-B7_bsbuf_circ[2],      A4_word1  ; adv bit

        XOR     .L1     0x01,        A15_last_coeff, A15_last_coeff; mismatch
; - copy from start of block loop - keep updated:
||      SUB     .S2     B1_cnt,      1,        B1_bcomp    ; cbp, cnt--
||      SUB     .L2     6,           B1_cnt,   B6_block    ; cc
||      ZERO    .D1     A10_sum
||      MV      .S1X    B8_top0_bk,  A8_top0               ; live out
||      MPY     .M2     0,           B3_const32, B0_cc     ; cc
||      LDW     .D2T1   *+B15_SP[BPTR_SPOFF],   A12_bptr   ; adv bit

 [!A1_odd]STH   .D1T1   A15_last_coeff,        *-A9_outi[1]; mismatch
; - copy from start of block loop - keep updated:
||      SHL     .S2X    A3_const1,   B1_bcomp, B14_cbp_mask; cbp
||      CMPLT   .L2     B6_block,    4,        B1_flag     ; cc
||      LMBD    .L1     0,           A8_top0,  A2_b        ; DC size&len
||      STW     .D2T2   B1_bcomp,    *+B15_SP[CNT_SPOFF]   ; cnt
||      MVK     .S1     1,           A1_coded
; prevent B mismatch, not in start code!

 [!B1_flag]AND  .L2     B6_block,    1,        B0_cc       ; cc
||      ADD     .D1     A2_b,        1,        A5_len      ; DC size&len
||[!B2_error]AND.L1X    B14_cbp_mask,A7_cbp,   A1_coded    ; cbp
||      MVK     .S1     126,         A0_const126           ; not coded
;prevents B mismatch, not conditional in start code!
; - copy end -

; branch occurs to block_loop
; branch occurs to exit 2 cycles after block_loop
; (preserve B2_error for exit)

        NOP             2

* =========================== EXIT   ============================ *
        .asg            B15,        B15_SP        ; Stack pointer, B datapath
        .asg            A14,        A14_SP        ; Stack pointer, A datapath
        .asg            A0,         A0_csr        ; CSR value to restore
        .asg            B3,         B3_ret        ; Return address

exit:
        LDW     .D2T2     *+B15_SP[BSBUF_SPOFF],  B4_bsbuf
||      STW     .D1T1     A8_top0,      *+A6_Mpeg2v[TOP0_M2OFF]
||      ZERO    .L2       B0_amr_config

        SUB     .L2X      B3_const32,   A12_bptr,   B8_bptr_cmpl   ;reconstr
||      STW     .D1T2     B2_error,     *+A6_Mpeg2v[FAULT_M2OFF]
||      MVC     .S2       B0_amr_config,AMR
||      ADDAW   .D2       B15_SP,   11, B15_SP       ; release preserv stack

        SHL     .S1       A4_word1,     A12_bptr,     A5           ;reconstr
||      SHRU    .S2       B12_word2,    B8_bptr_cmpl, B8           ;reconstr
||      STW     .D1T1     A12_bptr,     *+A6_Mpeg2v[BPTR_M2OFF]
||      MV      .L1X      B15_SP,       A14_SP

        ADD     .L2X      A5,           B8,         B8_top1        ;reconstr
||      STW     .D1T1     A4_word1,     *+A6_Mpeg2v[WORD1_M2OFF]

        STW     .D1T2     B8_top1,      *+A6_Mpeg2v[TOP1_M2OFF]

        SUB     .S2       B7_bsbuf_circ,B4_bsbuf,  B4_byte_diff
||      STW     .D1T2     B12_word2,    *+A6_Mpeg2v[WORD2_M2OFF]

        SHR     .S1X      B4_byte_diff, 2,         A2_next_wptr

        STW     .D1T1     A2_next_wptr, *+A6_Mpeg2v[NEXTWPTR_M2OFF]

; restore stack:

        LDW     .D1T2   *+A14_SP[ 1], B3_ret      ; Get return address
||      LDW     .D2T1   *+B15_SP[ 2], A0_csr      ; Get CSR's value

        LDW     .D1T2   *+A14_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B15_SP[ 4], A10         ; Restore A10

        LDW     .D1T2   *+A14_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B15_SP[ 6], A11         ; Restore A11

        LDW     .D1T2   *+A14_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B15_SP[ 8], A12         ; Restore A12

        LDW     .D1T2   *+A14_SP[ 9], B13         ; Restore B13
||      LDW     .D2T1   *+B15_SP[10], A13         ; Restore A13

        LDW     .D1T2   *+A14_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B15_SP[12], A14         ; Restore A14
||      RET     .S2     B3_ret                    ; Return to caller

        MVC     .S2X    A0_csr,       CSR         ; Restore CSR
||      LDW     .D2T1   *++B15_SP[14],A15         ; Restore A15
; ===== Interruptibility state restored here =====

        NOP             4
; ===== Branch Occurs =====

* ========================================================================= *
*   End of file:   img_mpeg2_vld_intra.asm                                  *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

len_c_tbl0.asm/ 1066929162  0     0     0       9668      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.1     Sun Mar 17 04:30:06 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_len_c_tbl0                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       16-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*C      extern far const unsigned char IMG_len_c_tbl0[512];                 *
*                                                                           *
*   DESCRIPTION                                                             *
*       Length lookup table for MPEG-2 Table B-14.                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _IMG_len_c_tbl0
            .data

            .align  8
            .space  4
        .global _IMG_len_c_tbl0
_IMG_len_c_tbl0:
            .byte   0x20, 0x20, 0x20, 0x20, 0x1B, 0x1B, 0x1C, 0x1C
            .byte   0x1E, 0x1E, 0x1E, 0x1E, 0x20, 0x20, 0x20, 0x20
            .byte   0x20, 0x20, 0x20, 0x20, 0x17, 0x1A, 0x1A, 0x1A
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x19, 0x19, 0x19, 0x19
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x18, 0x18, 0x18, 0x18
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x08, 0x08, 0x08, 0x08
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x15, 0x15, 0x15, 0x15
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x13, 0x13, 0x13, 0x13
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x12, 0x12, 0x12, 0x12
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x11, 0x11, 0x11, 0x11
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x10, 0x10, 0x10, 0x10
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x0F, 0x0F, 0x0F, 0x0F
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D

* ========================================================================= *
*   End of file:  img_len_c_tbl0.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
len_c_tbl1.asm/ 1066929162  0     0     0       9668      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.1     Sun Mar 17 04:30:06 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_len_c_tbl1                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       16-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*C      extern far const unsigned char IMG_len_c_tbl1[512];                 *
*                                                                           *
*   DESCRIPTION                                                             *
*       Length lookup table for MPEG-2 Table B-15.                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _IMG_len_c_tbl1
            .data

            .align  8
            .space  4
        .global _IMG_len_c_tbl1
_IMG_len_c_tbl1:
            .byte   0x20, 0x20, 0x20, 0x20, 0x1C, 0x1C, 0x1C, 0x1B
            .byte   0x1D, 0x1D, 0x1D, 0x1D, 0x20, 0x20, 0x20, 0x20
            .byte   0x20, 0x20, 0x20, 0x20, 0x17, 0x1A, 0x1A, 0x1A
            .byte   0x1C, 0x1C, 0x1C, 0x1C, 0x20, 0x20, 0x20, 0x20
            .byte   0x20, 0x20, 0x20, 0x20, 0x19, 0x19, 0x19, 0x19
            .byte   0x1A, 0x1A, 0x1A, 0x1A, 0x20, 0x20, 0x20, 0x20
            .byte   0x20, 0x20, 0x20, 0x20, 0x18, 0x18, 0x18, 0x18
            .byte   0x18, 0x18, 0x18, 0x18, 0x20, 0x20, 0x20, 0x20
            .byte   0x20, 0x20, 0x20, 0x20, 0x08, 0x08, 0x08, 0x08
            .byte   0x18, 0x18, 0x17, 0x17, 0x20, 0x20, 0x20, 0x20
            .byte   0x20, 0x20, 0x20, 0x20, 0x16, 0x16, 0x15, 0x16
            .byte   0x17, 0x17, 0x17, 0x17, 0x20, 0x20, 0x20, 0x20
            .byte   0x20, 0x20, 0x20, 0x20, 0x13, 0x13, 0x13, 0x13
            .byte   0x17, 0x17, 0x17, 0x17, 0x20, 0x20, 0x20, 0x20
            .byte   0x20, 0x20, 0x20, 0x20, 0x12, 0x12, 0x12, 0x12
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x11, 0x11, 0x11, 0x11
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x10, 0x10, 0x10, 0x10
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x0F, 0x0F, 0x0F, 0x0F
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17
            .byte   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
            .byte   0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17

* ========================================================================= *
*   End of file:  img_len_c_tbl1.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
len_tbl0.asm/   1066929162  0     0     0       9640      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.1     Sun Mar 17 04:30:06 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_len_tbl0                                                        *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       16-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*C      extern far const unsigned char IMG_len_tbl0[512];                   *
*                                                                           *
*   DESCRIPTION                                                             *
*       Length lookup table for MPEG-2 Table B-14.                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _IMG_len_tbl0
            .data

            .align 8
        .global _IMG_len_tbl0
_IMG_len_tbl0:  
            .byte   0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x04, 0x04
            .byte   0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00
            .byte   0x00, 0x00, 0x00, 0x00, 0x09, 0x06, 0x06, 0x06
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x0B
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x0D, 0x0D, 0x0D, 0x0D
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03

* ========================================================================= *
*   End of file:  img_len_tbl0.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
len_tbl1.asm/   1066929162  0     0     0       9640      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.1     Sun Mar 17 04:30:06 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_len_tbl1                                                        *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       16-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*C      extern far const unsigned char IMG_len_tbl1[512];                   *
*                                                                           *
*   DESCRIPTION                                                             *
*       Length lookup table for MPEG-2 Table B-15.                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _IMG_len_tbl1
            .data

            .align 8
        .global _IMG_len_tbl1
_IMG_len_tbl1:  
            .byte   0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x05
            .byte   0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00
            .byte   0x00, 0x00, 0x00, 0x00, 0x09, 0x06, 0x06, 0x06
            .byte   0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00
            .byte   0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07
            .byte   0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00
            .byte   0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08
            .byte   0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00
            .byte   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18
            .byte   0x08, 0x08, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00
            .byte   0x00, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0x0B, 0x0A
            .byte   0x09, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00
            .byte   0x00, 0x00, 0x00, 0x00, 0x0D, 0x0D, 0x0D, 0x0D
            .byte   0x09, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00
            .byte   0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
            .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09

* ========================================================================= *
*   End of file:  img_len_tbl1.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
rld_table0.asm/ 1066929162  0     0     0       11043     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.1     Sun Mar 17 04:30:06 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_rld_table0                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       16-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*C      extern far const unsigned short IMG_rld_table0[576];                *
*                                                                           *
*   DESCRIPTION                                                             *
*       Run-length decode lookup table for MPEG-2 Table B-14.               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _IMG_rld_table0
        .data
        .align  8
        .global _IMG_rld_table0
_IMG_rld_table0:
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x41FF, 0x41FF, 0x41FF, 0x41FF, 0x41FF, 0x41FF, 0x41FF, 0x41FF
        .short  0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0001, 0x0001, 0x0001, 0x0001, 0x00FF, 0x00FF, 0x00FF, 0x00FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x0101, 0x0101, 0x01FF, 0x01FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0002, 0x00FE, 0x0201, 0x02FF, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x0003, 0x00FD, 0x0401, 0x04FF, 0x0301, 0x03FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0701, 0x07FF, 0x0601, 0x06FF, 0x0102, 0x01FE, 0x0501, 0x05FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0202, 0x02FE, 0x0901, 0x09FF, 0x0004, 0x00FC, 0x0801, 0x08FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0D01, 0x0DFF, 0x0006, 0x00FA, 0x0C01, 0x0CFF, 0x0B01, 0x0BFF
        .short  0x0302, 0x03FE, 0x0103, 0x01FD, 0x0005, 0x00FB, 0x0A01, 0x0AFF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x1001, 0x10FF, 0x0502, 0x05FE, 0x0007, 0x00F9, 0x0203, 0x02FD
        .short  0x0104, 0x01FC, 0x0F01, 0x0FFF, 0x0E01, 0x0EFF, 0x0402, 0x04FE
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x000B, 0x00F5, 0x0802, 0x08FE, 0x0403, 0x04FD, 0x000A, 0x00F6
        .short  0x0204, 0x02FC, 0x0702, 0x07FE, 0x1501, 0x15FF, 0x1401, 0x14FF
        .short  0x0009, 0x00F7, 0x1301, 0x13FF, 0x1201, 0x12FF, 0x0105, 0x01FB
        .short  0x0303, 0x03FD, 0x0008, 0x00F8, 0x0602, 0x06FE, 0x1101, 0x11FF
        .short  0x0A02, 0x0AFE, 0x0902, 0x09FE, 0x0503, 0x05FD, 0x0304, 0x03FC
        .short  0x0205, 0x02FB, 0x0107, 0x01F9, 0x0106, 0x01FA, 0x000F, 0x00F1
        .short  0x000E, 0x00F2, 0x000D, 0x00F3, 0x000C, 0x00F4, 0x1A01, 0x1AFF
        .short  0x1901, 0x19FF, 0x1801, 0x18FF, 0x1701, 0x17FF, 0x1601, 0x16FF
        .short  0x001F, 0x00E1, 0x001E, 0x00E2, 0x001D, 0x00E3, 0x001C, 0x00E4
        .short  0x001B, 0x00E5, 0x001A, 0x00E6, 0x0019, 0x00E7, 0x0018, 0x00E8
        .short  0x0017, 0x00E9, 0x0016, 0x00EA, 0x0015, 0x00EB, 0x0014, 0x00EC
        .short  0x0013, 0x00ED, 0x0012, 0x00EE, 0x0011, 0x00EF, 0x0010, 0x00F0
        .short  0x0028, 0x00D8, 0x0027, 0x00D9, 0x0026, 0x00DA, 0x0025, 0x00DB
        .short  0x0024, 0x00DC, 0x0023, 0x00DD, 0x0022, 0x00DE, 0x0021, 0x00DF
        .short  0x0020, 0x00E0, 0x010E, 0x01F2, 0x010D, 0x01F3, 0x010C, 0x01F4
        .short  0x010B, 0x01F5, 0x010A, 0x01F6, 0x0109, 0x01F7, 0x0108, 0x01F8
        .short  0x0112, 0x01EE, 0x0111, 0x01EF, 0x0110, 0x01F0, 0x010F, 0x01F1
        .short  0x0603, 0x06FD, 0x1002, 0x10FE, 0x0F02, 0x0FFE, 0x0E02, 0x0EFE
        .short  0x0D02, 0x0DFE, 0x0C02, 0x0CFE, 0x0B02, 0x0BFE, 0x1F01, 0x1FFF
        .short  0x1E01, 0x1EFF, 0x1D01, 0x1DFF, 0x1C01, 0x1CFF, 0x1B01, 0x1BFF

* ========================================================================= *
*   End of file:  img_rld_table0.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

rld_table1.asm/ 1066929162  0     0     0       11043     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.1     Sun Mar 17 04:30:07 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_rld_table1                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       16-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*C      extern far const unsigned short IMG_rld_table1[576];                *
*                                                                           *
*   DESCRIPTION                                                             *
*       Run-length decode lookup table for MPEG-2 Table B-15.               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _IMG_rld_table1
        .data
        .align  8
        .global _IMG_rld_table1
_IMG_rld_table1:
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0001, 0x0001, 0x0001, 0x0001, 0x00FF, 0x00FF, 0x00FF, 0x00FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0101, 0x0101, 0x01FF, 0x01FF, 0x41FF, 0x41FF, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0002, 0x0002, 0x00FE, 0x00FE, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0003, 0x00FD
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x0201, 0x02FF, 0x0102, 0x01FE, 0x0301, 0x03FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0004, 0x00FC, 0x0005, 0x00FB, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0007, 0x00F9, 0x0006, 0x00FA, 0x0401, 0x04FF, 0x0501, 0x05FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0701, 0x07FF, 0x0801, 0x08FF, 0x0601, 0x06FF, 0x0202, 0x02FE
        .short  0x0901, 0x09FF, 0x0103, 0x01FD, 0x0A01, 0x0AFF, 0x0008, 0x00F8
        .short  0x0009, 0x00F7, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0105, 0x01FB, 0x0B01, 0x0BFF, 0x000B, 0x00F5, 0x000A, 0x00F6
        .short  0x0D01, 0x0DFF, 0x0C01, 0x0CFF, 0x0302, 0x03FE, 0x0104, 0x01FC
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x000C, 0x00F4, 0x000D, 0x00F3
        .short  0x0203, 0x02FD, 0x0402, 0x04FE, 0x000E, 0x00F2, 0x000F, 0x00F1
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0502, 0x05FE, 0x0E01, 0x0EFF, 0x4400, 0x4400, 0x0F01, 0x0FFF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0204, 0x02FC, 0x1001, 0x10FF, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x0802, 0x08FE, 0x0403, 0x04FD, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x0702, 0x07FE, 0x1501, 0x15FF, 0x1401, 0x14FF
        .short  0x4400, 0x4400, 0x1301, 0x13FF, 0x1201, 0x12FF, 0x4400, 0x4400
        .short  0x0303, 0x03FD, 0x4400, 0x4400, 0x0602, 0x06FE, 0x1101, 0x11FF
        .short  0x0A02, 0x0AFE, 0x0902, 0x09FE, 0x0503, 0x05FD, 0x0304, 0x03FC
        .short  0x0205, 0x02FB, 0x0107, 0x01F9, 0x0106, 0x01FA, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x1A01, 0x1AFF
        .short  0x1901, 0x19FF, 0x1801, 0x18FF, 0x1701, 0x17FF, 0x1601, 0x16FF
        .short  0x001F, 0x00E1, 0x001E, 0x00E2, 0x001D, 0x00E3, 0x001C, 0x00E4
        .short  0x001B, 0x00E5, 0x001A, 0x00E6, 0x0019, 0x00E7, 0x0018, 0x00E8
        .short  0x0017, 0x00E9, 0x0016, 0x00EA, 0x0015, 0x00EB, 0x0014, 0x00EC
        .short  0x0013, 0x00ED, 0x0012, 0x00EE, 0x0011, 0x00EF, 0x0010, 0x00F0
        .short  0x0028, 0x00D8, 0x0027, 0x00D9, 0x0026, 0x00DA, 0x0025, 0x00DB
        .short  0x0024, 0x00DC, 0x0023, 0x00DD, 0x0022, 0x00DE, 0x0021, 0x00DF
        .short  0x0020, 0x00E0, 0x010E, 0x01F2, 0x010D, 0x01F3, 0x010C, 0x01F4
        .short  0x010B, 0x01F5, 0x010A, 0x01F6, 0x0109, 0x01F7, 0x0108, 0x01F8
        .short  0x0112, 0x01EE, 0x0111, 0x01EF, 0x0110, 0x01F0, 0x010F, 0x01F1
        .short  0x0603, 0x06FD, 0x1002, 0x10FE, 0x0F02, 0x0FFE, 0x0E02, 0x0EFE
        .short  0x0D02, 0x0DFE, 0x0C02, 0x0CFE, 0x0B02, 0x0BFE, 0x1F01, 0x1FFF
        .short  0x1E01, 0x1EFF, 0x1D01, 0x1DFF, 0x1C01, 0x1CFF, 0x1B01, 0x1BFF

* ========================================================================= *
*   End of file:  img_rld_table1.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

perimeter.asm/  1066929162  0     0     0       21489     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.10    Sun Sep 29 03:31:27 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       Perimeter  detection of a boundary image                            *
*                                                                           *
*   REVISION DATE                                                           *
*       06-Oct-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       int IMG_perimeter(unsigned char *in_data, int  cols, unsigned char  *
*       *out_data );                                                        *
*                                                                           *
*       in_data  : Input binary image                                       *
*       cols     : Number of cols. Must be >= 3.                            *
*       out_data : Output boundary image                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine produces the IMG_perimeter of a binary image, by       *
*       counting the number of boundary pixels of the input image.  It      *
*       echoes the boundary pixels with a value of 0xFF and sets the        *
*       other pixels as 0.  Detection of the boundary of a binary image     *
*       is a segmentation problem and is done by examining spatial          *
*       locality of the neighboring pixels.  This is done by using the      *
*       four connectivity algorithm:                                        *
*                                                                           *
*                        pix_up                                             *
*               pix_lft pix_cent pix_rgt                                    *
*                        pix_dn                                             *
*                                                                           *
*       The output pixel at location pix_cent is echoed as a boundary       *
*       pixel if pix_cent is non-zero and any one of its four neighbors     *
*       is zero.  The four neighbors are shown and stand for the            *
*       following:                                                          *
*                                                                           *
*               pix_up:  top pixel                                          *
*               pix_lft: left pixel                                         *
*               pix_rgt: right pixel                                        *
*               pix_dn:  bottom pixel                                       *
*                                                                           *
*    CODE                                                                   *
*       This is the C equivalent of the assembly code without               *
*       restrictions: Note that the assembly code is hand optimized and     *
*       restrictions may apply.                                             *
*                                                                           *
*       int IMG_perimeter(unsigned char *in_data, int  cols, unsigned char  *
*       *out_data)                                                          *
*       {                                                                   *
*           int icols;                                                      *
*           int count;                                                      *
*                                                                           *
*           unsigned char pix_lft, pix_rgt, pix_top;                        *
*           unsigned char pix_bot, pix_cent;                                *
*                                                                           *
*           count = 0;                                                      *
*                                                                           *
*           for(icols = 1; icols < (cols-1); icols++ )                      *
*           {                                                               *
*               pix_lft = in_data[icols - 1];                               *
*               pix_cent= in_data[icols + 0];                               *
*               pix_rgt = in_data[icols + 1];                               *
*                                                                           *
*               pix_top = in_data[icols - cols];                            *
*               pix_bot = in_data[icols + cols];                            *
*                                                                           *
*               if ( ( (pix_lft == 0) ||                                    *
*                      (pix_rgt == 0) ||                                    *
*                      (pix_top == 0) ||                                    *
*                      (pix_bot == 0) ) && (pix_cent > 0) )                 *
*               {                                                           *
*                   out_data[icols] = pix_cent;                             *
*                   count++;                                                *
*               }                                                           *
*               else                                                        *
*               {                                                           *
*                   out_data[icols] = 0;                                    *
*               }                                                           *
*           }                                                               *
*                                                                           *
*           return(count);                                                  *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       No specific alignment is expected for the input or output array     *
*       cols can be either even or odd.                                     *
*                                                                           *
*       This code expects three input lines each of cols pixels and         *
*       produces one output line of cols - 1 pixels.                        *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts are expected for this kernel.  In addition        *
*       notice that the # of loads that have be performed is reduced        *
*       because of data re-use within the loop. This is also beneficial     *
*       because bank conflicts can be eliminated Notice that pix_cent of    *
*       the present iteration is the pix_lft of the next iteration. Hence   *
*       these can be obtained by moves rather than fresh loads. The set of  *
*       moves are indicated below                                           *
*                                                                           *
*       pix_cent ---> pix_lft                                               *
*       pix_rgt  ---> pix_cent                                              *
*                                                                           *
*       In order for this to be done at the start of the kernel the values  *
*       of pix_cent and pix_rgt are pre-loaded before the start of the      *
*       loop                                                                *
*                                                                           *
*       This code is ENDIAN NEUTRAL                                         *
*                                                                           *
*   NOTES                                                                   *
*       This code masks interrupts for nearly its entire duration. As a     *
*       result, the code is interrupt_tolerant but not interruptible        *
*                                                                           *
*   CYCLES                                                                  *
*       3 * (cols - 2) + 28                                                 *
*                                                                           *
*       for cols = 720, cycles = 2182                                       *
*       for cols = 200, cycles = 622                                        *
*                                                                           *
*   CODESIZE                                                                *
*       352 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_perimeter"
        .global _IMG_perimeter
_IMG_perimeter:

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_in                        ;
        .asg            B4,         B_cols                      ;
        .asg            A6,         A_out                       ;
        .asg            A5,         A_img                       ;
        .asg            A3,         A_imgrt                     ;
        .asg            B8,         B_IMGPTR                    ;
        .asg            A4,         A_IMGPTR                    ;
        .asg            B0,         B_pd                        ;
        .asg            B6,         B_bcount                    ;
        .asg            A6,         A_out_ptr                   ;
        .asg            A2,         A_i                         ;
        .asg            A7,         A_ff
        .asg            B9,         B_CSR
        .asg            B5,         B_no_gie
; ============================================================================
        MV      .L1     A_in,       A_IMGPTR                    ; Image pointer
||      MVC     .S2     CSR,        B_CSR                       ; Capture CSR


        ADD     .L1     A_IMGPTR,   1,          A_IMGPTR        ; Image pointer++
||      AND     .L2     B_CSR,      2,          B_no_gie        ; no_gie

        LDBU    .D1T1   *A_IMGPTR,  A_imgrt                     ; preload imgrt
||      MVC     .S2      B_no_gie,  CSR                         ; Suppress int

        LDBU    .D1T1   *-A_IMGPTR[1],          A_img           ; preload imglft
||      MV      .L1     A_out,      A_out_ptr                   ; Make outptr

        SUB     .S1X    B_cols,     2,          A_i             ; Loop iters
||      MVK     .S2     0,          B_pd                        ; Prolog loop

        MVK     .S1     0FFh,       A_ff                        ; constant FF
||      ADD     .D1     A_out_ptr,  1,          A_out_ptr       ; outptr++
||      ZERO    .D2     B_bcount                                ; Boundary count
||      MV      .L2X    A_IMGPTR,   B_IMGPTR                    ; 2nd copy of imgptr

        ;==== Branch occurs

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A5,         A_img
        .asg            A3,         A_imgrt
        .asg            B8,         B_IMGPTR
        .asg            B4,         B_cols                      ;
        .asg            A4,         A_IMGPTR                    ;
        .asg            B0,         B_pd
        .asg            B6,         B_bcount
        .asg            A6,         A_out_ptr                   ;
        .asg            A2,         A_i
        .asg            A7,         A_imgle
        .asg            B1,         B_imgup
        .asg            B7,         B_imgdn
        .asg            B7,         B_resud
        .asg            A1,         A_reslr
        .asg            A1,         A_res
        .asg            B5,         B_imgc
        .asg            B2,         B_img
        .asg            A0,         A_res_not
        .asg            A1,         A_st
        .asg            A8,         A_out_pix
; ============================================================================
; START:
; ============================ PIPE LOOP PROLOG ==============================
; PROLOG:
        LDBU    .D2T2   *-B_IMGPTR[B_cols],     B_imgup         ; Load imgup

        LDBU    .D1T1   *++A_IMGPTR,            A_imgrt         ; Load imgrt

        ADD     .S2     B_IMGPTR,   1,          B_IMGPTR        ; Incr imgptr
||      LDBU    .D2T2   *+B_IMGPTR[B_cols],     B_imgdn         ; Load imgdn

        LDBU    .D2T2   *-B_IMGPTR[B_cols],     B_imgup         ; Load imgup

        MV      .S1     A_img,      A_imgle                     ; Move imgle
||      LDBU    .D1T1   *++A_IMGPTR,            A_imgrt         ; Load imgrt
||      B       .S2     L_2 + 8

        MV      .S1     A_imgrt,    A_img                       ; Move img
||      ADD     .L2     B_IMGPTR,   1,          B_IMGPTR        ; Incr imgptr
||      LDBU    .D2T2   *+B_IMGPTR[B_cols],     B_imgdn         ; Load imgdn
||      B       .S2     L_3 + 12

        LDBU    .D2T2   *-B_IMGPTR[B_cols],     B_imgup         ; Load imgup
||      B       .S2     L_1 + 4

        MPYU    .M1     A_imgrt,    A_imgle,    A_reslr         ; reslr
||      MPYU    .M2     B_imgup,    B_imgdn,    B_resud         ; resud
||      MV      .S1     A_img,      A_imgle                     ; Move imgle
||      LDBU    .D1T1   *++A_IMGPTR,            A_imgrt         ; Load imgrt
||      B       .S2     L_2 + 8

        MPY     .M2X    A_img,      1,          B_imgc          ; Live too long
||      MV      .S1     A_imgrt,    A_img                       ; Move img
||      ADD     .L2     B_IMGPTR,   1,          B_IMGPTR        ; Incr imgptr
||      LDBU    .D2T2   *+B_IMGPTR[B_cols],     B_imgdn         ; Load imgdn
||      B       .S2     L_3 + 4

        MPYU    .M1X    B_resud,    A_reslr,    A_res           ; res
||[ A_i]SUB     .D1     A_i,        1,          A_i             ; B_i--
||      LDBU    .D2T2   *-B_IMGPTR[B_cols],     B_imgup         ; Load imgup
||      B       .S2     LOOP                                    ;

        MPYU    .M1     A_imgrt,    A_imgle,    A_reslr         ; reslr
||      MPYU    .M2     B_imgup,    B_imgdn,    B_resud         ; resud
||      MV      .S1     A_img,      A_imgle                     ; Move imgle
||      LDBU    .D1T1   *++A_IMGPTR,            A_imgrt         ; Load imgrt


; ============================ PIPE LOOP KERNEL ==============================
LOOP:
L_1:
        ZERO    .L1     A_out_pix                               ; outpix = 0
||[ A_i]B       .S1     LOOP                                    ; B LOOP
||      MPY     .M2     B_imgc,     1,          B_img           ; Live Too Long
||      MPYU    .M1X    B_resud,    A_reslr,    A_res           ; res
||[ A_i]SUB     .D1     A_i,        1,          A_i             ; B_i--
||      LDBU    .D2T2   *-B_IMGPTR[B_cols],     B_imgup         ; Load imgup

L_2:
  [ A_st]MV     .L1X    B_img,      A_out_pix                   ; outiux = pix_cent
||[ A_st]ADD    .D2     B_bcount,   1,          B_bcount        ; bcount++
||      MPYU    .M1     A_imgrt,    A_imgle,    A_reslr         ; reslr
||      MPYU    .M2     B_imgup,    B_imgdn,    B_resud         ; resud
||      MV      .S1     A_img,      A_imgle                     ; Move imgle
||      LDBU    .D1T1   *++A_IMGPTR,            A_imgrt         ; Load imgrt

L_3:
  [!B_pd]STB    .D1T1   A_out_pix,  *A_out_ptr++                ; Store outpix
||      MPYU    .M1X    A_res_not,  B_img,      A_st            ; status
||[ B_pd]SUB    .L2     B_pd,       1,          B_pd            ;
||      CMPEQ   .L1     A_res,      0,          A_res_not       ; resnot
||      MPY     .M2X    A_img,      1,          B_imgc          ; Live too long
||      MV      .S1     A_imgrt,    A_img                       ; Move img
||      ADD     .S2     B_IMGPTR,   1,          B_IMGPTR        ; Incr imgptr
||      LDBU    .D2T2   *+B_IMGPTR[B_cols],     B_imgdn         ; Load imgdn

; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:

; ============================================================================
; END:

         .asg     B6,  B_bcount
         .asg     A4,  A_retval
         .asg     B3,  B_return

         RET     .S2    B3                                      ; Branch to return

         MV      .L1x   B_bcount,  A_retval                     ; boundary count
||       MVC     .S2    B_CSR,  CSR                             ; re-enable int

         NOP            4

* ========================================================================= *
*   End of file:  img_perimeter.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

pix_expand.asm/ 1066929162  0     0     0       17197     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Sun Sep 29 03:31:28 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_pix_expand                                                      *
*                                                                           *
*   REVISION DATE                                                           *
*       14-Dec-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_pix_expand(int cols,unsigned char *in_data,short *out_data)*
*                                                                           *
*           cols     = length of array                                      *
*           in_data  = pointer to input array of unsigned chars             *
*           out_data = pointer to output array of shorts                    *
*                                                                           *
*       (See the C compiler reference guide.)                               *
*                                                                           *
*   DESCRIPTION                                                             *
*       The code takes an array of unsigned chars (pixels) and zero         *
*       extends them up to 16 bits to form shorts.                          *
*                                                                           *
*       This is the C equivalent of the assembly code, without              *
*       restrictions.  The assembly code imposes various restrictions,      *
*       as noted under 'ASSUMPTIONS'.                                       *
*                                                                           *
*           void IMG_pix_expand(int cols, unsigned char *in_data,           *
*                             short *out_data)                              *
*           {                                                               *
*               int j;                                                      *
*               for (j = 0; j < cols; j++)                                  *
*                   out_data[j] = (short) in_data[j];                       *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS:                                                            *
*       Input and Output arrays must be aligned on at least 4 byte          *
*       boundaries.                                                         *
*                                                                           *
*       Input array must be a multiple of 8 elements long and contain       *
*       at least 8 elements.                                                *
*                                                                           *
*       This code is LITTLE ENDIAN.                                         *
*                                                                           *
*   MEMORY NOTE:                                                            *
*       No memory bank hits occur in this code. 6 words of stack frame used.*
*                                                                           *
*   TECHNIQUES                                                              *
*       The code is unrolled 8 times, with two LDWs read in a total of 8    *
*       bytes each iteration.  The bytes are extracted into registers,      *
*       and are then re-packed as shorts.  The packed shorts are then       *
*       written with four STWs.                                             *
*                                                                           *
*       The pack is achieved using MPYU and ADD.  First, the data is        *
*       shifted left by 15 with the MPYU by multiplying with (1 << 15).     *
*       The value is then added to itself to shift it left one more bit.    *
*       A final ADD merges the shifted quantity with a second quantity,     *
*       giving the packed result.                                           *
*                                                                           *
*   CYCLES                                                                  *
*       Total cycle count = 0.5*cols + 26                                   *
*       e.g. cols = 256,  cycles = 154                                      *
*       e.g. cols = 1076, cycles = 562                                      *
*                                                                           *
*   NOTES                                                                   *
*       Interupts are diabled on entry to the function.                     *
*                                                                           *
*   CODESIZE                                                                *
*       288 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ===================*
        .asg            B15,        B_SP        ;Stack pointer, B datapath
        .asg            A3,         A_SP        ;Stack pointer, A datapath
        .asg            B0,         B_csr       ;CSR's value
        .asg            B1,         B_no_gie    ;CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ;Copy of CSR's value
        .asg            B3,         B_ret       ;Return address
        .asg            A14,        A_csro      ;csr saved value
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =====================
        .asg            A4,         A_n         ;number of pixels
        .asg            B4,         B_p         ;pntr to 8 bit pixels
        .asg            A6,         A_x         ;pntr to 16 bit pixels
        .asg            B10,        B_prefetch  ;prefetching pntr to stop cache
        .asg            A7,         A_one       ;const = 1
        .asg            B2,         B_j         ;loop count
        .asg            A6,         A_in_data_0 ;even data
        .asg            B8,         B_in_data_1 ;odd data
        .asg            A8,         A_ff        ;mask value 0xff
        .asg            B13,        B_15        ;value 1<<15
        .asg            A9,         A_8         ;value 8
        .asg            A2,         A_out_data_0;even data
        .asg            B6,         B_out_data_1;odd data
        .asg            A13,        A_ff00      ;mask value 0xff00
        .asg            A7,         A_pixel_3210;4 packed pixels
        .asg            A4,         A_pel_3     ;pixel 3
        .asg            A4,         A_pel_2     ;pixel 2
        .asg            A0,         A_pel_1     ;pixel 1
        .asg            A1,         A_pel_0     ;pixel 0
        .asg            B12,        B_pel_3     ;pixel 3 copy
        .asg            B7,         B_pel_2     ;pixel 2 copy
        .asg            B9,         B_pixel_7654;4 packed pixels
        .asg            B4,         B_pel_7     ;pixel 7
        .asg            B5,         B_pel_6     ;pixel 6
        .asg            B4,         B_pel_5     ;pixel 5
        .asg            A5,         A_pel_4     ;pixel 4
        .asg            A0,         A_pel_5     ;pixel 5 copy
        .asg            B1,         B_pro       ;prolog collapser
*============================================================================*
                .sect    ".data:copyright_h"
*============================================================================*
        .sect ".text:_pix_expand"
        .global _IMG_pix_expand
_IMG_pix_expand:
; ============================ PIPE LOOP PROLOG ==============================
        STW     .D2T2   B13,        *B_SP--[6]         ; Reserve stk, Save B13
||      MV      .L1X    B_SP,       A_SP               ; Twin Stack Pointer
||      MVC     .S2     CSR,        B_csr              ; Capture CSR's state
||      MVK     .S1     1,          A_one              ;[ 5,0]

        STW     .D1T1   A13,        *-A_SP[ 5]         ; Save A13
||      STW     .D2T2   B12,        *+B_SP[ 2]         ; Save B12
||      MV      .L1X    B_csr,      A_csr              ; Partitioning MV
||      AND     .L2     B_csr,  -2,  B_no_gie          ; Clear GIE
;-
        STW     .D1T1   A_csr,      *-A_SP[ 3]         ; Save CSR
||      STW     .D2T2   B10,        *+B_SP[ 4]         ; Save B10
||      MVC     .S2     B_no_gie,   CSR                ; Disable interrupts

        LDW     .D2T1   *B_p[0],    A_pixel_3210       ;[ 1,1]
||      OR      .S2     B_pro,      1,     B_pro
||      B       .S1     LOOP_X+16
||      MV      .D1     A_x,               A_out_data_0;[ 6,0]
||      ADD     .L2X    A_x,        4,     B_out_data_1;[ 4,0]
;-
        B       .S2     LOOP_X1+8
||      MV      .L2X    A_n,        B_j                ;[ 5,0]
||      SUB     .L1     0,          A_one, A_ff        ;[ 2,0]
||      SHL     .S1     A_one,      8,     A_8         ;[ 6,0]

        B       .S1     LOOP_X2+16
||      ADD     .D2     B_p,        4,     B_in_data_1 ;[ 6,0]
||      ADD     .L1X    B_p,        8,     A_in_data_0 ;[ 6,0]
||      SHL     .S2X    A_one,      15,    B_15        ;[ 6,0]
;-
        LDW     .D2T2   *B_in_data_1++[2], B_pixel_7654;[ 5,1]
||      LDW     .D1T1   *A_in_data_0++[2], A_pixel_3210;[ 1,2]
||      B       .S2     LOOP_X3+8

        B       .S2     LOOP_X                         ;[14,1]
||      SHRU    .S1     A_ff,       24,    A_ff        ;[ 3,0]
||      STW     .D1T1   A14,        *-A_SP[1]          ;save A14

        SHL     .S1     A_ff,       8,     A_ff00      ;[ 4,0]
||      LDW     .D1T2   *A_out_data_0[0],   B_prefetch ;[ 2,0]
;-
; ============================ PIPE LOOP KERNEL ==============================
LOOP_X:
 [!B_pro]STW    .D2T2   B_pel_6,   *B_out_data_1++[2]  ;[16,1]
||      ADD     .S2X    B_pel_3,   A_pel_2,    B_pel_2 ;[12,2]
||      STW     .D1T1   A_pel_0,   *A_out_data_0++[2]  ;[12,2]
||      MPYU    .M1X    A_8,       B_pel_5,    A_pel_5 ;[12,2]
||      SHRU    .S1     A_pixel_3210,  24,     A_pel_3 ;[ 8,3]
||      AND     .L1     A_pixel_3210,  A_ff00, A_pel_1 ;[ 8,3]
||[ B_j]SUB     .L2     B_j,        8,         B_j     ;[12,2]
LOOP_X1:
        EXTU    .S2     B_pixel_7654,  8,  24, B_pel_6 ;[13,2]
||      ADD     .L2     B_pel_7,    B_pel_7,   B_pel_7 ;[13,2]
||      MPYU    .M1     A_8,        A_pel_1,   A_pel_1 ;[ 9,3]
||      MPYU    .M2X    B_15,       A_pel_3,   B_pel_3 ;[ 9,3]
||      EXTU    .S1     A_pixel_3210,  8,  24, A_pel_2 ;[ 9,3]
||      AND     .L1     A_ff, A_pixel_3210,    A_pel_0 ;[ 9,3]
||      LDW     .D2T2   *B_in_data_1++[2], B_pixel_7654;[ 5,4]
||      LDW     .D1T1   *A_in_data_0++[2], A_pixel_3210;[ 1,5]
LOOP_X2:
        MPY     .M2     B_pro,      0,        B_pro    ; switch on loop
||      ADD     .L1     A_pel_5,    A_pel_4,  A_pel_4  ;[14,2]
||      ADD     .L2     B_pel_7,    B_pel_6,  B_pel_6  ;[14,2]
||[ B_j]LDW     .D1T2   *A_out_data_0[4], B_prefetch   ;[14,2]
||[ B_j]B       .S1     LOOP_X                         ;[14,2]
||      SHRU    .S2     B_pixel_7654,   24, B_pel_7    ;[10,3]
||[!B_j]LDW     .D2T1   *+B_SP[ 3], A_csro             ; Get CSR's value
LOOP_X3:
        STW     .D2T2   B_pel_2, *B_out_data_1++[2]    ;[15,2]
||      STW     .D1T1   A_pel_4, *A_out_data_0++[2]    ;[15,2]
||      ADD     .L2     B_pel_3, B_pel_3, B_pel_3      ;[11,3]
||      ADD     .L1     A_pel_1, A_pel_0, A_pel_0      ;[11,3]
||      AND     .S1X    A_ff,    B_pixel_7654, A_pel_4 ;[11,3]
||      AND     .S2X    B_pixel_7654, A_ff00,  B_pel_5 ;[11,3]
||      MPYU    .M2     B_15,    B_pel_7, B_pel_7      ;[11,3]
;====== Branch Occurs ====
; ============================ PIPE LOOP EPILOG ==============================
        LDW     .D2T2   *+B_SP[ 4], B10                ; Restore B10
;-
        LDW     .D1T1   *-A_SP[ 5], A13                ; Restore A13
||      LDW     .D2T2   *+B_SP[ 2], B12                ; Restore B12
||      RET     .S2     B_ret                          ; Return to caller

        LDW     .D2T2   *++B_SP[6], B13                ; Restore B13
||      LDW     .D1T1   *-A_SP[1],  A14                ; restore A14

        NOP             2

        MVC     .S2X    A_csro,     CSR                ; Restore CSR

* ===== Interruptibility state restored here ============================== *
        STW     .D2T2   B_pel_6,    *B_out_data_1++[2] ;[16,5]
;====== Branch Occurs =====

* ========================================================================= *
*   End of file:  img_pix_expand.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

pix_sat.asm/    1066929162  0     0     0       19763     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Sun Sep 29 03:31:28 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_pix_sat                                                         *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       21-May-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_pix_sat(int n, short *in_data, unsigned char *out_data);   *
*                                                                           *
*       n        : Length of input array                                    *
*       in_data  : Pointer to array of signed 16 bit numbers                *
*       out_data : Pointer to array of clipped, unsigned 8 bit numbers.     *
*                                                                           *
*   DESCRIPTION                                                             *
*       This code performs the saturation of 16 bit signed numbers to 8     *
*       bit unsigned numbers. If the data is over 255 it is saturated to    *
*       255, if it is less than 0 it is saturated to 0.                     *
*                                                                           *
*   C CODE                                                                  *
*       void IMG_pix_sat(int n, short *in_data, unsigned char * out_data)   *
*       {                                                                   *
*           int j, pixel, pel;                                              *
*           for (j = 0; j < n; j++)                                         *
*           {                                                               *
*               pixel = in_data[j];                                         *
*               pel = (unsigned char) pixel;                                *
*               if (pixel > 0xff) pel = 0xff;                               *
*               if (pixel < 0x00) pel = 0x00;                               *
*               out_data[j] = pel;                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code may have some restrictions, as     *
*       noted below.                                                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       The data is loaded in pairs of shorts, the sign bits are detected   *
*       and the test is done to see if values are over 8 bits.  Outputs     *
*       are packed back to gether to form words, i.e. if ( a & 0xff00) if   *
*       ( a & 0x8000) sat to 0 else sat to 0xff                             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input array must be aligned on an 4 bytes boundary and be a     *
*       multiple of 8 in length. n % 8 = 0. The code is interrupt tolerant  *
*       interrupts are disabled during execution.                           *
*                                                                           *
*   MEMORY NOTE                                                             *
*       There are no bank conflicts in this code.                           *
*       It is LITTLE ENDIAN.                                                *
*                                                                           *
*   CYCLES                                                                  *
*       37 + n                                                              *
*                                                                           *
*       For n = 640 :  677 cycles                                           *
*       For n = 1024: 1061 cycles                                           *
*                                                                           *
*   CODESIZE                                                                *
*       448 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_pix_sat"
        .global _IMG_pix_sat
_IMG_pix_sat: 
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_n         ;no of pixels
        .asg            B4,         B_x         ;pointer to short unsated values
        .asg            A6,         A_p         ;pntr to saturated pixels
        .asg            B2,         B_j         ;loop count
        .asg            A5,         A_nff       ;mask to see if > 255
        .asg            B12,        B_n80       ;mask to see if negative
        .asg            B13,        B_ff        ;maks to see if > 255
        .asg            A8,         A_out_data_a;out data pntr even
        .asg            B6,         B_out_data_c;out data pntr odd
        .asg            A7,         A_x         ;signed sahort pointer
        .asg            A3,         A_100       ;1 << 8
        .asg            B14,        B_1         ;1
        .asg            A9,         A_n80       ;mask to test if < 0
        .asg            B11,        B_100       ;1<< 8
        .asg            A4,         A_pixel_10  ; pair of shorts 0,1
        .asg            B7,         B_pixel_32  ; pair of shorts 2,3
        .asg            A6,         A_pel_1     ;8 bit pixel 1
        .asg            B5,         B_pel_3     ;8 bit pixel 3
        .asg            A11,        A_pel_0     ;8 bit pixel 0
        .asg            B8,         B_pel_2     ;8 bit pixel 2
        .asg            A0,         A_pel_0_    ;8 bit pixel 0 copy
        .asg            A1,         A_t0        ;conditions > 255, < 0
        .asg            A2,         A_t1        ;conditions > 255, < 0
        .asg            A10,        A_pel_1_    ;8 bit pixel 1 copy
        .asg            B10,        B_pel_2_    ;8 bit pixel 2 copy
        .asg            B0,         B_t2        ;conditions > 255, < 0
        .asg            B1,         B_t3        ;conditions > 255, < 0
        .asg            B9,         B_pel_3_    ;8 bit pixel 3 copy
        .asg            A10,        A_pel_01_   ;packed pixels 0,1
        .asg            B9,         B_pel_23_   ;packed pixels 2,3
        .asg            B15,        B_SP        ;Stack pointer, B datapath
        .asg            A15,        A_SP        ;Stack pointer, A datapath
        .asg            B0,         B_csr       ;CSR's value
        .asg            B1,         B_no_gie    ;CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ;Copy of CSR's value
        .asg            B3,         B_ret       ;Return address
*==============================================================================*
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T1   A15,        *B_SP--[14]           ;Reservestack,Save A15

        MV      .S1X    B_SP,       A_SP                  ; Twin Stack Pointer

        STW     .D1T1   A14,        *+A_SP[12]            ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]            ; Save B14
||      MVC     .S2     CSR,        B_csr                 ; Capture CSR's state

        STW     .D1T1   A13,        *+A_SP[10]            ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]            ; Save B13
||      AND     .L2     B_csr,      -2,         B_no_gie  ; Clear GIE
;-
        STW     .D1T1   A12,        *+A_SP[ 8]            ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]            ; Save B12
||      MVKL    .S2     08000h,     B_n80                 ;[ 1,0]
||      MVKL    .S1     0100h,      A_100                 ;[ 2,0]

        STW     .D1T1   A11,        *+A_SP[ 6]            ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]            ; Save B11
||      MV      .L1X    B_csr,      A_csr                 ; Partitioning MV
||      MVKH    .S2     00h,        B_n80                 ;[ 2,0]
;-
        STW     .D1T1   A10,        *+A_SP[ 4]            ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]            ; Save B10
||      MVC     .S2     B_no_gie,   CSR                   ; Disable interrupts
||      MVKH    .S1     00h,        A_100                 ;[ 3,0]
        ; Interrupts masked here
        STW     .D1T1   A_csr,      *+A_SP[ 2]            ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]            ; save return address
||      MVKL    .S2     01h,        B_1                   ;[ 3,0]
||      MV      .L1X    B_x,        A_x                   ;[ 6,0]
;-
        MV      .L2X    A_100,      B_100                 ;[ 4,0]
||      MVKH    .S2     00h,        B_1                   ;[ 4,0]
||      ADD     .D2     B_x,        4,          B_x       ;[ 6,0]
||      MV      .L1X    B_n80,      A_n80                 ;[ 5,0]
||      LDW     .D1T1   *A_x++[2],  A_pixel_10            ;[ 1,1]

        ADD     .L2X    A_p,        2,       B_out_data_c ;[ 5,0]
||      MVKL    .S2     0FFh,       B_ff                  ;[ 5,0]
||      MVKL    .S1     0FF00h,     A_nff                 ;[ 5,0]
;-
        ADD     .L1     A_p,        0,       A_out_data_a ;[ 6,0]
||      MVKH    .S2     00h,        B_ff                  ;[ 6,0]
||      LDW     .D2T2   *B_x++[2],  B_pixel_32            ;[ 3,1]
||      MVKH    .S1     00h,        A_nff                 ;[ 6,0]

        SUB     .L2X    A_n,        8,          B_j       ;[ 6,0]

        LDW     .D1T1   *A_x++[2],  A_pixel_10            ;[ 1,2]

        MPY     .M1     1,          A_pixel_10, A_pel_0   ;[ 6,1]
||      B       .S1     LOOP_X  + 8
;-
        LDW     .D2T2   *B_x++[2],  B_pixel_32            ;[ 3,2]
||      B       .S2     LOOP_X1 + 4

        AND     .L1     A_pel_0,    A_nff,      A_t0      ;[ 8,1]
||      MPY     .M2     1,          B_pixel_32, B_pel_2   ;[ 8,1]
||      B       .S2     LOOP_X2 + 4

        MPYHL   .M1X    A_pixel_10, B_1,        A_pel_1   ;[ 9,1]
||      LDW     .D1T1   *A_x++[2],  A_pixel_10            ;[ 1,3]
||      B       .S2     LOOP_X3
;-
        AND     .L1     A_pel_0,    A_n80,      A_t1      ;[10,1]
||      MPY     .M1     1,          A_pixel_10, A_pel_0   ;[ 6,2]
||      B       .S2     LOOP_X                            ;[14,1]

        AND     .S1     A_pel_1,    A_nff,      A_t0      ;[11,1]
||[ A_t0]MPY    .M1X    1,          B_ff,       A_pel_0_  ;[11,1]
||      MV      .D1     A_pel_0,    A_pel_0_              ;[11,1]
||      MPYHL   .M2     B_pixel_32, B_1,        B_pel_3   ;[11,1]
||      LDW     .D2T2   *B_x++[2],  B_pixel_32            ;[ 3,3]
; ============================ PIPE LOOP KERNEL ==============================
LOOP_X:
        STH     .D1T1   A_pel_01_,  *A_out_data_a++[2]    ;[16,1]
||[ B_t3]ZERO   .D2     B_pel_3_                          ;[16,1]
||[ A_t0]MPY    .M1X    A_100,      B_ff,       A_pel_1_  ;[12,2]
||      SHL     .S1     A_pel_1,    8,          A_pel_1_  ;[12,2]
||      AND     .L2X    B_pel_2,    A_nff,      B_t2      ;[12,2]
||      AND     .S2     B_pel_2,    B_n80,      B_t3      ;[12,2]
||      AND     .L1     A_pel_0,    A_nff,      A_t0      ;[ 8,3]
||      MPY     .M2     1,          B_pixel_32, B_pel_2   ;[ 8,3]
LOOP_X1:
        ADD     .D2     B_pel_2_,   B_pel_3_,   B_pel_23_ ;[17,1]
||[ A_t1]ZERO   .S1     A_pel_0_                          ;[13,2]
||      AND     .L1     A_pel_1,    A_n80,      A_t1      ;[13,2]
||      AND     .L2X    B_pel_3,    A_nff,      B_t2      ;[13,2]
||      MV      .S2     B_pel_2,    B_pel_2_              ;[13,2]
||[ B_t2]MPY    .M2     1,          B_ff,       B_pel_2_  ;[13,2]
||      MPYHL   .M1X    A_pixel_10, B_1,        A_pel_1   ;[ 9,3]
||      LDW     .D1T1   *A_x++[2],  A_pixel_10            ;[ 1,5]
LOOP_X2:
        STH     .D2T2   B_pel_23_,  *B_out_data_c++[2]    ;[18,1]
||[ B_j]B       .S1     LOOP_X                            ;[14,2]
||[ A_t1]ZERO   .D1     A_pel_1_                          ;[14,2]
||[ B_t2]MPY    .M2     B_ff,       B_100,      B_pel_3_  ;[14,2]
||      SHL     .S2     B_pel_3,    8,          B_pel_3_  ;[14,2]
||      AND     .L1     A_pel_0,    A_n80,      A_t1      ;[10,3]
||[ B_j]SUB     .L2     B_j,        4,          B_j       ;[10,3]
||      MPY     .M1     1,          A_pixel_10, A_pel_0   ;[ 6,4]
LOOP_X3:
        ADD     .L1     A_pel_0_,   A_pel_1_,   A_pel_01_ ;[15,2]
||      AND     .L2     B_pel_3,    B_n80,      B_t3      ;[15,2]
||[ B_t3]ZERO   .S2     B_pel_2_                          ;[15,2]
||      AND     .S1     A_pel_1,    A_nff,      A_t0      ;[11,3]
||[ A_t0]MPY    .M1X    1,          B_ff,       A_pel_0_  ;[11,3]
||      MV      .D1     A_pel_0,    A_pel_0_              ;[11,3]
||      MPYHL   .M2     B_pixel_32, B_1,        B_pel_3   ;[11,3]
||      LDW     .D2T2   *B_x++[2],  B_pixel_32            ;[ 3,5]
; ============================ PIPE LOOP EPILOG ==============================
        MV      .S1X    B_SP,       A_SP                  ; Twin Stack Pointer
||      STH     .D1T1   A_pel_01_,  *A_out_data_a++[2]    ;[16,5]

        LDW     .D1T2   *+A_SP[ 1], B_ret                 ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr                 ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 5], B11                   ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11                   ; Restore A11

        LDW     .D1T2   *+A_SP[ 7], B12                   ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12                   ; Restore A12
;-
        LDW     .D1T2   *+A_SP[ 9], B13                   ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13                   ; Restore A13

        LDW     .D1T2   *+A_SP[11], B14                   ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14                   ; Restore A14

        LDW     .D1T2   *+A_SP[ 3], B10                   ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10                   ; Restore A10
||      RET     .S2     B_ret                             ; Return to caller
;-
        MVC     .S2X    A_csr,      CSR                   ; Restore CSR
||      LDW     .D2T1   *++B_SP[14],A15                   ; Restore A15
||[ B_t3]ZERO   .L2     B_pel_3_                          ;[16,5]
*====== Interruptibility state restored here ==================================*
        ADD     .D2     B_pel_2_,   B_pel_3_,   B_pel_23_ ;[17,5]

        STH     .D2T2   B_pel_23_,  *B_out_data_c++[2]    ;[18,5]

        NOP             2
        ;Branch Occurs
*==============================================================================*
*=  End of file:  img_pix_sat.asm                                             =*
*==============================================================================*
*=            Copyright (c) 1999 Texas Instruments, Incorporated.             =*
*=                           All Rights Reserved.                             =*
*==============================================================================*

quantize.asm/   1066929162  0     0     0       48249     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.11    Sun Sep 29 03:31:28 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_quantize -- Matrix Quantization w/ Rounding, Little Endian      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       25-Feb-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_quantize                                                   *
*       (                                                                   *
*           short       *data,      /* Data to be quantized.        */      *
*           int         num_blks,   /* Number of 64-element blocks. */      *
*           int         blk_size,   /* Block size (multiple of 16). */      *
*           const short *recip_tbl, /* Quant. values (reciprocals). */      *
*           int         q_pt        /* Q-point of Quant values.     */      *
*       )                                                                   *
*                                                                           *
*       The number of blocks, num_blks, must be at least 1.  The block      *
*       size (number of elements in each block) must be at least 16,        *
*       and a multiple of 16.  The Q-point, q_pt, controls rounding and     *
*       final truncation; it must be in the range from 0 <= q_pt <= 31.     *
*                                                                           *
*       Both input arrays, data[] and recip_tbl[], must be word aligned.    *
*       The data[] array must be 'num_blks * blk_size' elements, and the    *
*       recip_tbl[] array must be 'blk_size' elements.                      *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_quantize() quantizes matrices by multiplying their *
*       contents with a second matrix that contains reciprocals of the      *
*       quantization terms.  This step corresponds to the quantization      *
*       that is performed in 2-D DCT-based compression techniques,          *
*       although IMG_quantize() may be used on any signed 16-bit data using *
*       signed 16-bit quantization terms.                                   *
*                                                                           *
*       IMG_quantize() merely multiplies the contents of the quantization   *
*       matrix with the data being quantized.  Therefore, it may be used    *
*       for inverse quantization as well, by setting the Q-point            *
*       appropriately.                                                      *
*                                                                           *
*       The assembly code requires 25 + (blk_size/16) * (4 + num_blks*12)   *
*       cycles to execute, including function call overhead.  Interrupts    *
*       are disabled for 14 + (blk_size/16) * (4 + num_blks*12) cycles.     *
*                                                                           *
*       The following C code describes the general implementation of        *
*       IMG_quantize().                                                     *
*                                                                           *
*       void IMG_quantize                                                   *
*       (                                                                   *
*           short       *data,      /* Data to be quantized.        */      *
*           int         num_blks,   /* Number of 64-element blocks. */      *
*           int         blk_size,   /* Block size (multiple of 16). */      *
*           const short *recip_tbl, /* Quant. values (reciprocals). */      *
*           int         q_pt        /* Q-point of Quant values.     */      *
*       )                                                                   *
*       {                                                                   *
*           short recip;                                                    *
*           int i, j, k, quot, round;                                       *
*                                                                           *
*           /* ------------------------------------------------------- */   *
*           /*  Set rounding term as 0.5, effectively.                 */   *
*           /* ------------------------------------------------------- */   *
*           round = q_pt ? 1 << (q_pt - 1) : 0;                             *
*                                                                           *
*           /* ------------------------------------------------------- */   *
*           /*  Outer loop:  Step between quant matrix elements.       */   *
*           /* ------------------------------------------------------- */   *
*           for (i = 0; i < blk_size; i++)                                  *
*           {                                                               *
*               /* --------------------------------------------------- */   *
*               /*  Load a reciprocal and point to appropriate         */   *
*               /*  element of block.                                  */   *
*               /* --------------------------------------------------- */   *
*               recip   = recip_tbl[i];                                     *
*               k       = i;                                                *
*                                                                           *
*               /* --------------------------------------------------- */   *
*               /*  Inner loop:  Step between blocks of elements,      */   *
*               /*  quantizing.                                        */   *
*               /* --------------------------------------------------- */   *
*               for (j = 0; j < num_blks; j++)                              *
*               {                                                           *
*                   quot    = data[k] * recip + round;                      *
*                   data[k] = quot >> q_pt;                                 *
*                   k      += blk_size;                                     *
*               }                                                           *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code has restrictions, as noted above.  *
*                                                                           *
*   TECHNIQUES                                                              *
*       The outer loop is unrolled 16 times to allow greater amounts        *
*       of work to be performed in the inner loop.                          *
*                                                                           *
*       Reciprocals and data terms are loaded in pairs with word-wide       *
*       loads, making better use of the availably memory bandwidth.         *
*                                                                           *
*       The outer loop has been interleaved with the prolog and epilog      *
*       of the inner loop.                                                  *
*                                                                           *
*       The inner loop is software-pipelined, with two iterations in        *
*       parallel.  If "num_blks == 1", the inner loop kernel is branched    *
*       over, thus eliminating the minimum loop-trip-count restriction.     *
*                                                                           *
*       Epilog code from the inner loop has been moved into the exit-       *
*       code delay slots through creative use of branch delay slots.        *
*                                                                           *
*       Twin stack pointers have been used to speed up stack accesses.      *
*                                                                           *
*       The inner loop steps through individual blocks, while the           *
*       outer loop steps through reciprocals for quantization.  This        *
*       eliminates redundant loads for the quantization terms.              *
*                                                                           *
*       The direction of travel for the inner loop oscillates with each     *
*       iteration of the outer loop to simplify pointer updating in the     *
*       outer loop and reduce register pressure.  (eg.  in the first iter.  *
*       of the outer loop, the inner loop steps forward through memory; in  *
*       the second iter. of the outer loop, the inner loop steps backwards  *
*       through memory, etc.)                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The recip_tbl[] and data[] must be word aligned.                    *
*       The block size, blk_size, must be a multiple of 16.                 *
*       The number of blocks, num_blks, must be at least 1.                 *
*       The Q-point, q_pt, must be in the range 0 <= q_pt <= 31.            *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur, regardless of the relative orientation     *
*       of r_tbl[] and data[].                                              *
*                                                                           *
*       A total of 14 words of stack frame are used for saving the          *
*       Save-On-Entry registers.                                            *
*                                                                           *
*   NOTES                                                                   *
*       Interrupts are disabled throughout most of the function.            *
*       Input arrays must be word-aligned for correct operation.            *
*       No checking is performed on the input arguments for correctness.    *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 25 + (blk_size/16) * (4 + num_blks*12)                     *
*                                                                           *
*       For blk_size =  64 and num_blks =  8, cycles =  425                 *
*       For blk_size = 256 and num_blks = 24, cycles = 4695                 *
*                                                                           *
*   CODESIZE                                                                *
*       1024 bytes                                                          *
*                                                                           *
*   SOURCE                                                                  *
*       n/a                                                                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

                .sect ".data:copyright_h"

        .sect ".text:_quantize"
        .global _IMG_quantize
_IMG_quantize:
; ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B2,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
        .asg            B4,         B_num_blks  ; Number of blocks to process
        .asg            A6,         A_blk_sz    ; Size of blocks in shorts
        .asg            B4,         B_di_ptr    ; Data input pointer + 4
        .asg            A4,         A_di_ptr    ; Data input pointer (A_data)
        .asg            B5,         B_do_ptr    ; Data output pointer + 4
        .asg            A5,         A_do_ptr    ; Data output pointer
        .asg            B6,         B_r_ptr     ; Reciprocal table pointer + 4
        .asg            A6,         A_r_ptr     ; Reciprocal table pointer
        .asg            B10,        B_fix_w     ; Block-to-block fixup
        .asg            A0,         A_fix_w     ; Block-to-block fixup
        .asg            A7,         A_rnd_pt    ; Rounding point (q_pt - 1)
        .asg            A10,        A_rnd       ; Rounding term
        .asg            A1,         A_i         ; Outer loop counter
        .asg            B1,         B_j         ; Inner loop counter
        .asg            B8,         B_q_pt      ; Q-point shift amount
        .asg            A8,         A_q_pt      ; Q-point shift amount
        .asg            B14,        B_r_FE      ; Reciprocal terms 15, 14
        .asg            A14,        A_r_DC      ; Reciprocal terms 13, 12
        .asg            B13,        B_r_BA      ; Reciprocal terms 11, 10
        .asg            A13,        A_r_98      ; Reciprocal terms  9,  8
        .asg            B12,        B_r_76      ; Reciprocal terms  7,  6
        .asg            A12,        A_r_54      ; Reciprocal terms  5,  4
        .asg            B11,        B_r_32      ; Reciprocal terms  3,  2
        .asg            A11,        A_r_10      ; Reciprocal terms  1,  0
        .asg            B9,         B_d_FE      ; Data terms 15, 14
        .asg            A9,         A_d_DC      ; Data terms 13, 12
        .asg            B7,         B_d_BA      ; Data terms 11, 10
        .asg            A7,         A_d_98      ; Data terms  9,  8
        .asg            B9,         B_d_76      ; Data terms  7,  6
        .asg            A9,         A_d_54      ; Data terms  5,  4
        .asg            B3,         B_d_32      ; Data terms  3,  2
        .asg            A3,         A_d_10      ; Data terms  1,  0
        .asg            B9,         B_qp_F      ; Quot. "Product": r[15]*d[15]
        .asg            B3,         B_qp_E      ; Quot. "Product": r[14]*d[14]
        .asg            A9,         A_qp_D      ; Quot. "Product": r[13]*d[13]
        .asg            A3,         A_qp_C      ; Quot. "Product": r[12]*d[12]
        .asg            B0,         B_qp_B      ; Quot. "Product": r[11]*d[11]
        .asg            B0,         B_qp_A      ; Quot. "Product": r[10]*d[10]
        .asg            A0,         A_qp_9      ; Quot. "Product": r[ 9]*d[ 9]
        .asg            A0,         A_qp_8      ; Quot. "Product": r[ 8]*d[ 8]
        .asg            B9,         B_qp_7      ; Quot. "Product": r[ 7]*d[ 7]
        .asg            B0,         B_qp_6      ; Quot. "Product": r[ 6]*d[ 6]
        .asg            A9,         A_qp_5      ; Quot. "Product": r[ 5]*d[ 5]
        .asg            A0,         A_qp_4      ; Quot. "Product": r[ 4]*d[ 4]
        .asg            B7,         B_qp_3      ; Quot. "Product": r[ 3]*d[ 3]
        .asg            B0,         B_qp_2      ; Quot. "Product": r[ 2]*d[ 2]
        .asg            A7,         A_qp_1      ; Quot. "Product": r[ 1]*d[ 1]
        .asg            A0,         A_qp_0      ; Quot. "Product": r[ 0]*d[ 0]
        .asg            B2,         B_qr_F      ; Rounded quotient 15
        .asg            B3,         B_qr_E      ; Rounded quotient 14
        .asg            A2,         A_qr_D      ; Rounded quotient 13
        .asg            A3,         A_qr_C      ; Rounded quotient 12
        .asg            B7,         B_qr_B      ; Rounded quotient 11
        .asg            B3,         B_qr_A      ; Rounded quotient 10
        .asg            A7,         A_qr_9      ; Rounded quotient  9
        .asg            A3,         A_qr_8      ; Rounded quotient  8
        .asg            B2,         B_qr_7      ; Rounded quotient  7
        .asg            B3,         B_qr_6      ; Rounded quotient  6
        .asg            A2,         A_qr_5      ; Rounded quotient  5
        .asg            A3,         A_qr_4      ; Rounded quotient  4
        .asg            B7,         B_qr_3      ; Rounded quotient  3
        .asg            B3,         B_qr_2      ; Rounded quotient  2
        .asg            A7,         A_qr_1      ; Rounded quotient  1
        .asg            A3,         A_qr_0      ; Rounded quotient  0
        .asg            B0,         B_qt_F      ; Truncated quotient 15
        .asg            B3,         B_qt_E      ; Truncated quotient 14
        .asg            A0,         A_qt_D      ; Truncated quotient 13
        .asg            A3,         A_qt_C      ; Truncated quotient 12
        .asg            B7,         B_qt_B      ; Truncated quotient 11
        .asg            B7,         B_qt_A      ; Truncated quotient 10
        .asg            A7,         A_qt_9      ; Truncated quotient  9
        .asg            A7,         A_qt_8      ; Truncated quotient  8
        .asg            B2,         B_qt_7      ; Truncated quotient  7
        .asg            B0,         B_qt_6      ; Truncated quotient  6
        .asg            A2,         A_qt_5      ; Truncated quotient  5
        .asg            A0,         A_qt_4      ; Truncated quotient  4
        .asg            B0,         B_qt_3      ; Truncated quotient  3
        .asg            B3,         B_qt_2      ; Truncated quotient  2
        .asg            A0,         A_qt_1      ; Truncated quotient  1
        .asg            A3,         A_qt_0      ; Truncated quotient  0
; ========================================================================= ;

* ========================================================================= *
*   Setup code                                                              *
*                                                                           *
*   The setup code saves A10..A15, B10..B14, B3 and CSR to the stack.       *
*   It also masks interrupts, as the main code is not interruptible.        *
*                                                                           *
*   For speed, the stack pointer is duplicated into two registers.  This    *
*   allows us to save to the stack twice as quickly.                        *
*                                                                           *
*   Note that A_i, the outer loop count, is initialized to 0 instead of     *
*   the loop count.  We reuse this value as a flag to denote the first      *
*   iteration of the loop, since some code from the epilog of the loop      *
*   has been moved into the prolog code of the loop.                        *
*                                                                           *
*   Some of the first outer-loop iteration code has been duplicated in the  *
*   setup code to allow the other copy to be moved into the epilog of the   *
*   inner loop, thereby reducing the cost of the outer loop.                *
* ========================================================================= *

;-
        STW     .D2T1   A15,        *B_SP--[14]  ; Reserve stack, Save A15
||      ZERO    .L1     A_i                      ; Loop count==0 (1st run flag)
||      MV      .L2X    A_q_pt,     B_q_pt       ; Twin Q-point shift value
||      MV      .S1X    B_SP,       A_SP         ; Twin Stack Pointer
||      MVC     .S2     CSR,        B_csr        ; Capture CSR's state

        STW     .D1T1   A10,        *-A_SP[10]   ; Save A10  (SP[ 4])
||      STW     .D2T2   B10,        *+B_SP[ 3]   ; Save B10
||      SHR     .S2X    A_blk_sz,   1,  B_fix_w  ; Calc block-to-block fixup
;-
        STW     .D1T1   A13,        *-A_SP[ 4]   ; Save A13  (SP[10])
||      STW     .D2T2   B13,        *+B_SP[ 9]   ; Save B13
||      AND     .L2     B_csr,      -2, B_no_gie ; Clear GIE
||      ADD     .S1X    B_r_ptr,    4,  A_r_ptr  ; Twin r_ptr

        STW     .D1T1   A12,        *-A_SP[ 6]   ; Save A12  (SP[ 8])
||      STW     .D2T2   B12,        *+B_SP[ 7]   ; Save B12
||      SUB     .L2     B_num_blks, 1,  B_j      ; Initialize j loop count
||      ADD     .S2X    A_di_ptr,   4,  B_di_ptr ; Twin r_ptr
;-
        STW     .D1T1   A11,        *-A_SP[ 8]   ; Save A11  (SP[ 6])
||      STW     .D2T2   B11,        *+B_SP[ 5]   ; Save B11
||      MV      .L1X    B_csr,      A_csr        ; Partitioning MV
||      MVK     .S1     1,          A_rnd        ; Initialize rounding value

        STW     .D1T1   A14,        *-A_SP[ 2]   ; Save A14  (SP[12])
||      STW     .D2T2   B14,        *+B_SP[11]   ; Save B14
||      MVC     .S2     B_no_gie,   CSR          ; Disable interrupts
||      SUB     .S1     A_q_pt,     1,  A_rnd_pt ;
;-
; ===== Interrupts masked here =====

        STW     .D1T1   A_csr,      *-A_SP[12]   ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]   ; Remember return address

* ========================================================================= *
*   Outer Loop (i_loop), Inner Loop (j_loop)                                *
*                                                                           *
*   The outer loop loads reciprocal terms from the r_tbl[] array, and       *
*   updates pointers into the data[] array.  The inner loop quantizes the   *
*   elements in each block which correspond to the reciprocals which were   *
*   loaded in the outer loop.  The outer loop code has been heavily         *
*   interscheduled with the inner loop's prolog and epilog code.            *
*                                                                           *
*   In this discussion, "prolog" refers both to the inner loop's prolog     *
*   code, as well as the outer loop code which comes before the inner       *
*   loop.  Similarly, "epilog" refers both to the inner loop's epilog as    *
*   well as outer loop code which comes after the inner loop.               *
*                                                                           *
*   Extensive code motion has been performed around the outer loop's        *
*   branch, with some code moving from the prolog to the epilog, with       *
*   appropriate copies placed before the loops, in order to preserve        *
*   correct execution.  Additionally, some epilog code has been moved       *
*   _after_ the outer-loop branch into the prolog.                          *
*                                                                           *
*   The outer-loop counter 'A_i' also doubles as a flag to denote whether   *
*   this is the first iteration of the outer loop.  It is used to shut off  *
*   the instructions that were moved from the epilog to the prolog.  On     *
*   the first iteration of the outer loop, 'A_i' is zero.  It then gets     *
*   initialized to the loop trip count within the prolog of the inner loop  *
*   during the outer loop's first iteration.  On subsequent iterations,     *
*   'A_i' is non-zero in the inner loop's prolog code.                      *
*                                                                           *
*   The inner loop is a software pipeline with two iterations in parallel.  *
*   In the case where "num_blks == 1", the inner loop's kernel is branched  *
*   around so that the inner loop executes only one iteration.              *
*                                                                           *
*   In order to save register pressure, the direction in which the inner    *
*   loop processes blocks in the data[] array alternates with each iter.    *
*   of the outer loop.  This allows us to apply a fixed-offset pointer      *
*   adjustment in the outer loop, regardless of data[]'s size.              *
*                                                                           *
*   The epilog code for j_loop has been extensively tweaked for codesize    *
*   and speed.  Tail duplication has been performed for speed, allowing     *
*   epilog code to be executed in the delay slots of the prolog and exit    *
*   code.  To save codesize, the duplication is performed with a number of  *
*   well-placed branches (from 'exit' to 'final_store1' to 'final_store2'   *
*   to the return address) rather than with explicit code duplication.      *
* ========================================================================= *


        LDW     .D1T2   *+A_r_ptr[6],           B_r_FE  ;(outer) Recip. 15, 14
||      LDW     .D2T1   *+B_r_ptr[6],           A_r_DC  ;(outer) Recip. 13, 12

        LDW     .D2T2   *+B_di_ptr[6],          B_d_FE  ;[ 1,1] Data 15, 14
||      LDW     .D1T1   *+A_di_ptr[6],          A_d_DC  ;[ 1,1] Data 13, 12

        LDW     .D2T2   *+B_di_ptr[4],          B_d_BA  ;[ 5,1] Data 11, 10
||      LDW     .D1T1   *+A_di_ptr[4],          A_d_98  ;[ 5,1] Data  9,  8
;-
; ============================ PIPE LOOP PROLOG ==============================
i_loop:
        LDW     .D1T2   *+A_r_ptr[4],           B_r_BA  ;(outer) Recip 11, 10
||      LDW     .D2T1   *+B_r_ptr[4],           A_r_98  ;(outer) Recip  9,  8
||[!A_i]MV      .L1X    B_j,        A15                 ; Save inner loop cnt
||[!B_j]B       .S2     j_epilog                        ; Skip kernel if ...
                                                        ;  ... (num_blks == 1)
final_store2:

  [ A_i]SHR     .S2     B_qr_2,     B_q_pt,     B_qt_2  ;[22,2] qt_2=qr_2>>q_pt
||[ A_i]SHR     .S1     A_qr_0,     A_q_pt,     A_qt_0  ;[22,2] qt_0=qr_0>>q_pt
||[ A_i]STH     .D2T2   B_qt_3,     *-B_di_ptr[15]      ;[22,2] Quotient 3
||[ A_i]STH     .D1T1   A_qt_1,     *-A_di_ptr[15]      ;[22,2] Quotient 1
;-
  [ A_i]STH     .D2T2   B_qt_2,     *-B_di_ptr[16]      ;[23,2] Quotient 2
||[ A_i]STH     .D1T1   A_qt_0,     *-A_di_ptr[16]      ;[23,2] Quotient 0
; ===== If returning: Interruptibility state restored here =====
; ===== If returning: Branch Occurs [Return to caller] =====

        MPYH    .M2     B_r_FE,     B_d_FE,     B_qp_F  ;[ 9,1] qp_F=r_F*d_F
||      MPYH    .M1     A_r_DC,     A_d_DC,     A_qp_D  ;[ 9,1] qp_D=r_D*d_D
||      LDW     .D1T2   *+A_r_ptr[2],           B_r_76  ;(outer) Recip  7,  6
||      LDW     .D2T1   *+B_r_ptr[2],           A_r_54  ;(outer) Recip  5,  4
||[!A_i]SHL     .S1     A_rnd,      A_rnd_pt,   A_rnd   ; rnd=1<<(q_pt-1)
||      MV      .L1X    B_fix_w,    A_fix_w             ;[11,1] part. MV
;-
        MPY     .M2     B_r_FE,     B_d_FE,     B_qp_E  ;[10,1] qp_E=r_E*d_E
||      MPY     .M1     A_r_DC,     A_d_DC,     A_qp_C  ;[10,1] qp_C=r_C*d_C
||      LDW     .D2T2   *+B_di_ptr[2],          B_d_76  ;[ 7,1] Data  7,  6
||      LDW     .D1T1   *+A_di_ptr[2],          A_d_54  ;[ 7,1] Data  5,  4
||[!A_i]SHR     .S1X    B_fix_w,    3,          A_i     ; Init outer loop cnt
;-
        ADD     .S2X    B_qp_F,     A_rnd,      B_qr_F  ;[11,1] qr_F=qp_F+rnd
||      ADD     .S1     A_qp_D,     A_rnd,      A_qr_D  ;[11,1] qr_D=qp_D+rnd
||      MPYH    .M2     B_r_BA,     B_d_BA,     B_qp_B  ;[11,1] qp_B=r_B*d_B
||      MPYH    .M1     A_r_98,     A_d_98,     A_qp_9  ;[11,1] qp_9=r_9*d_9
||      LDW     .D1T2   * A_r_ptr++[8],         B_r_32  ;(outer) Recip  3,  2
||      LDW     .D2T1   * B_r_ptr++[8],         A_r_10  ;(outer) Recip  1,  0
||[!B_j]SUB             A_i,        1,          A_i     ;(outer) i--
||[ B_j]SUB     .L2     B_j,        1,          B_j     ;        j--
;-
; ===== If (num_blks == 1) Branch Occurs [j_epilog] =====
; ========================== PIPE LOOP KERNEL ============================= ;
j_loop:
        ADD     .L2X    B_qp_E,     A_rnd,      B_qr_E  ;[12,1] qr_E=qp_E+rnd
||      ADD     .L1     A_qp_C,     A_rnd,      A_qr_C  ;[12,1] qr_C=qp_C+rnd
||      MV      .S2     B_di_ptr,   B_do_ptr            ;[12,1] Copy in ptr...
||      MV      .S1     A_di_ptr,   A_do_ptr            ;[12,1] ...to out ptr
||      LDW     .D2T2   *B_di_ptr++[B_fix_w],   B_d_32  ;[12,1] Data  3,  2
||      LDW     .D1T1   *A_di_ptr++[A_fix_w],   A_d_10  ;[12,1] Data  1,  0
;-
        ADD     .L2X    B_qp_B,     A_rnd,      B_qr_B  ;[13,1] qr_B=qp_B+rnd
||      ADD     .L1     A_qp_9,     A_rnd,      A_qr_9  ;[13,1] qr_9=qp_9+rnd
||      SHR     .S2     B_qr_F,     B_q_pt,     B_qt_F  ;[13,1] qt_F=qr_F>>q_pt
||      SHR     .S1     A_qr_D,     A_q_pt,     A_qt_D  ;[13,1] qt_D=qr_D>>q_pt
||      MPY     .M2     B_r_BA,     B_d_BA,     B_qp_A  ;[13,1] qp_A=r_A*d_A
||      MPY     .M1     A_r_98,     A_d_98,     A_qp_8  ;[13,1] qp_8=r_8*d_8
||      LDW     .D2T2   *+B_di_ptr[6],          B_d_FE  ;[ 1,2] Data 15, 14
||      LDW     .D1T1   *+A_di_ptr[6],          A_d_DC  ;[ 1,2] Data 13, 12
;-
        SHR     .S2     B_qr_E,     B_q_pt,     B_qt_E  ;[14,1] qt_E=qr_E>>q_pt
||      SHR     .S1     A_qr_C,     A_q_pt,     A_qt_C  ;[14,1] qt_C=qr_C>>q_pt
||      STH     .D2T2   B_qt_F,     *+B_do_ptr[13]      ;[14,1] Quotient 15
||      STH     .D1T1   A_qt_D,     *+A_do_ptr[13]      ;[14,1] Quotient 13
||[!B_j]SUB             A_i,        1,          A_i     ;(outer) if (!j) i--
;-
        SHR     .S2     B_qr_B,     B_q_pt,     B_qt_B  ;[15,1] qt_B=qr_B>>q_pt
||      SHR     .S1     A_qr_9,     A_q_pt,     A_qt_9  ;[15,1] qt_9=qr_9>>q_pt
||      ADD     .L2X    B_qp_A,     A_rnd,      B_qr_A  ;[15,1] qr_A=qp_A+rnd
||      ADD     .L1     A_qp_8,     A_rnd,      A_qr_8  ;[15,1] qr_8=qp_8+rnd
||      MPYH    .M2     B_r_76,     B_d_76,     B_qp_7  ;[15,1] qp_7=r_7*d_7
||      MPYH    .M1     A_r_54,     A_d_54,     A_qp_5  ;[15,1] qp_5=r_5*d_5
||      STH     .D2T2   B_qt_E,     *+B_do_ptr[12]      ;[15,1] Quotient 14
||      STH     .D1T1   A_qt_C,     *+A_do_ptr[12]      ;[15,1] Quotient 12
;-
        MPY     .M2     B_r_76,     B_d_76,     B_qp_6  ;[16,1] qp_6=r_6*d_6
||      MPY     .M1     A_r_54,     A_d_54,     A_qp_4  ;[16,1] qp_4=r_4*d_4
||      SHR     .S2     B_qr_A,     B_q_pt,     B_qt_A  ;[16,1] qt_A=qr_A>>q_pt
||      SHR     .S1     A_qr_8,     A_q_pt,     A_qt_8  ;[16,1] qt_8=qr_8>>q_pt
||      STH     .D2T2   B_qt_B,     *+B_do_ptr[9]       ;[16,1] Quotient 11
||      STH     .D1T1   A_qt_9,     *+A_do_ptr[9]       ;[16,1] Quotient  9
;-
        ADD     .L2X    B_qp_7,     A_rnd,      B_qr_7  ;[17,1] qr_7=qp_7+rnd
||      ADD     .L1     A_qp_5,     A_rnd,      A_qr_5  ;[17,1] qr_5=qp_5+rnd
||      MPYH    .M2     B_r_32,     B_d_32,     B_qp_3  ;[17,1] qp_3=r_3*d_3
||      MPYH    .M1     A_r_10,     A_d_10,     A_qp_1  ;[17,1] qp_1=r_1*d_1
||      LDW     .D2T2   *+B_di_ptr[4],          B_d_BA  ;[ 5,2] Data 11, 10
||      LDW     .D1T1   *+A_di_ptr[4],          A_d_98  ;[ 5,2] Data  9,  8
;-
        ADD     .L2X    B_qp_6,     A_rnd,      B_qr_6  ;[18,1] qr_6=qp_6+rnd
||      ADD     .L1     A_qp_4,     A_rnd,      A_qr_4  ;[18,1] qr_4=qp_4+rnd
||      MPY     .M2     B_r_32,     B_d_32,     B_qp_2  ;[18,1] qp_2=r_2*d_2
||      MPY     .M1     A_r_10,     A_d_10,     A_qp_0  ;[18,1] qp_0=r_0*d_0
||      STH     .D2T2   B_qt_A,     *+B_do_ptr[8]       ;[18,1] Quotient 10
||      STH     .D1T1   A_qt_8,     *+A_do_ptr[8]       ;[18,1] Quotient  8
||[ B_j]SUB     .S2     B_j,        1,          B_j     ;[18,1] j--
||[ B_j]B       .S1     j_loop                          ;[18,1] while (j)
;-
        ADD     .L2X    B_qp_3,     A_rnd,      B_qr_3  ;[19,1] qr_3=qp_3+rnd
||      ADD     .L1     A_qp_1,     A_rnd,      A_qr_1  ;[19,1] qr_1=qp_1+rnd
||      SHR     .S2     B_qr_7,     B_q_pt,     B_qt_7  ;[19,1] qt_7=qr_7>>q_pt
||      SHR     .S1     A_qr_5,     A_q_pt,     A_qt_5  ;[19,1] qt_5=qr_5>>q_pt
||      LDW     .D2T2   *+B_di_ptr[2],          B_d_76  ;[ 7,2] Data  7,  6
||      LDW     .D1T1   *+A_di_ptr[2],          A_d_54  ;[ 7,2] Data  5,  4
;-
        SHR     .S2     B_qr_6,     B_q_pt,     B_qt_6  ;[20,1] qt_6=qr_6>>q_pt
||      SHR     .S1     A_qr_4,     A_q_pt,     A_qt_4  ;[20,1] qt_4=qr_4>>q_pt
||      ADD     .L2X    B_qp_2,     A_rnd,      B_qr_2  ;[20,1] qr_2=qp_2+rnd
||      ADD     .L1     A_qp_0,     A_rnd,      A_qr_0  ;[20,1] qr_0=qp_0+rnd
||      STH     .D2T2   B_qt_7,     *+B_do_ptr[5]       ;[20,1] Quotient  7
||      STH     .D1T1   A_qt_5,     *+A_do_ptr[5]       ;[20,1] Quotient  5
;-
        SHR     .S2     B_qr_3,     B_q_pt,     B_qt_3  ;[21,1] qt_3=qr_3>>q_pt
||      SHR     .S1     A_qr_1,     A_q_pt,     A_qt_1  ;[21,1] qt_1=qr_1>>q_pt
||      STH     .D2T2   B_qt_6,     *+B_do_ptr[4]       ;[21,1] Quotient  6
||      STH     .D1T1   A_qt_4,     *+A_do_ptr[4]       ;[21,1] Quotient  4
||      MPYH    .M2     B_r_FE,     B_d_FE,     B_qp_F  ;[ 9,2] qp_F=r_F*d_F
||      MPYH    .M1     A_r_DC,     A_d_DC,     A_qp_D  ;[ 9,2] qp_D=r_D*d_D
;-
        SHR     .S2     B_qr_2,     B_q_pt,     B_qt_2  ;[22,1] qt_2=qr_2>>q_pt
||      SHR     .S1     A_qr_0,     A_q_pt,     A_qt_0  ;[22,1] qt_0=qr_0>>q_pt
||      STH     .D2T2   B_qt_3,     *+B_do_ptr[1]       ;[22,1] Quotient  3
||      STH     .D1T1   A_qt_1,     *+A_do_ptr[1]       ;[22,1] Quotient  1
||      MPY     .M2     B_r_FE,     B_d_FE,     B_qp_E  ;[10,2] qp_E=r_E*d_E
||      MPY     .M1     A_r_DC,     A_d_DC,     A_qp_C  ;[10,2] qp_C=r_C*d_C
;-
        STH     .D2T2   B_qt_2,     *+B_do_ptr[0]       ;[23,1] Quotient  2
||      STH     .D1T1   A_qt_0,     *+A_do_ptr[0]       ;[23,1] Quotient  0
||      ADD     .S2X    B_qp_F,     A_rnd,      B_qr_F  ;[11,2] qr_F=qp_F+rnd
||      ADD     .S1     A_qp_D,     A_rnd,      A_qr_D  ;[11,2] qr_D=qp_D+rnd
||      MPYH    .M2     B_r_BA,     B_d_BA,     B_qp_B  ;[11,2] qp_B=r_B*d_B
||      MPYH    .M1     A_r_98,     A_d_98,     A_qp_9  ;[11,2] qp_9=r_9*d_9
||      MV      .L1X    B_fix_w,    A_fix_w             ;[11,2] part. MV
;-
; ===== Branch Occurs [j_loop] =====
; =========================== PIPE LOOP EPILOG ============================ ;
j_epilog:
; ==================== SYMBOLIC REGISTER REASSIGNMENTS ==================== ;
        .asg            B3,         B_qt_A
        .asg            A3,         A_qt_8
        .asg            B5,         B_d_32
        .asg            A5,         A_d_10
        .asg            B6,         B_ret
        .asg            A6,         A_csr
; ========================================================================= ;

        ADD     .L2X    B_qp_E,     A_rnd,      B_qr_E  ;[12,2] qr_E=qp_E+rnd
||      ADD     .L1     A_qp_C,     A_rnd,      A_qr_C  ;[12,2] qr_C=qp_C+rnd
||      LDW     .D2T2   *B_di_ptr++[8],         B_d_32  ;[12,2] Data  3,  2
||      LDW     .D1T1   *A_di_ptr++[8],         A_d_10  ;[12,2] Data  1,  0
||[!A_i]B       .S2     exit                            ; if (i==0) break;
;-
        ADD     .L2X    B_qp_B,     A_rnd,      B_qr_B  ;[13,2] qr_B=qp_B+rnd
||      ADD     .L1     A_qp_9,     A_rnd,      A_qr_9  ;[13,2] qr_9=qp_9+rnd
||      SHR     .S2     B_qr_F,     B_q_pt,     B_qt_F  ;[13,2] qt_F=qr_F>>q_pt
||      SHR     .S1     A_qr_D,     A_q_pt,     A_qt_D  ;[13,2] qt_D=qr_D>>q_pt
||      MPY     .M2     B_r_BA,     B_d_BA,     B_qp_A  ;[13,2] qp_A=r_A*d_A
||      MPY     .M1     A_r_98,     A_d_98,     A_qp_8  ;[13,2] qp_8=r_8*d_8
||      LDW     .D1T2   *+A_r_ptr[6],           B_r_FE  ;(outer) Recip 15, 14
||      LDW     .D2T1   *+B_r_ptr[6],           A_r_DC  ;(outer) Recip 13, 12
;-
        SHR     .S2     B_qr_E,     B_q_pt,     B_qt_E  ;[14,2] qt_E=qr_E>>q_pt
||      SHR     .S1     A_qr_C,     A_q_pt,     A_qt_C  ;[14,2] qt_C=qr_C>>q_pt
||      STH     .D2T2   B_qt_F,     *-B_di_ptr[3]       ;[14,2] Quotient 15
||      STH     .D1T1   A_qt_D,     *-A_di_ptr[3]       ;[14,2] Quotient 14
||      NEG     .L2     B_fix_w,    B_fix_w             ;(outer) fix = -fix
;-
        SHR     .S2     B_qr_B,     B_q_pt,     B_qt_B  ;[15,2] qt_B=qr_B>>q_pt
||      SHR     .S1     A_qr_9,     A_q_pt,     A_qt_9  ;[15,2] qt_9=qr_9>>q_pt
||      ADD     .L2X    B_qp_A,     A_rnd,      B_qr_A  ;[15,2] qr_A=qp_A+rnd
||      ADD     .L1     A_qp_8,     A_rnd,      A_qr_8  ;[15,2] qr_8=qp_8+rnd
||      MPYH    .M2     B_r_76,     B_d_76,     B_qp_7  ;[15,2] qp_7=r_7*d_7
||      MPYH    .M1     A_r_54,     A_d_54,     A_qp_5  ;[15,2] qp_5=r_5*d_5
||      STH     .D2T2   B_qt_E,     *-B_di_ptr[4]       ;[15,2] Quotient 14
||      STH     .D1T1   A_qt_C,     *-A_di_ptr[4]       ;[15,2] Quotient 12
;-
        MPY     .M2     B_r_76,     B_d_76,     B_qp_6  ;[16,2] qp_6=r_6*d_6
||      MPY     .M1     A_r_54,     A_d_54,     A_qp_4  ;[16,2] qp_4=r_4*d_4
||      STH     .D2T2   B_qt_B,     *-B_di_ptr[7]       ;[16,2] Quotient 11
||      STH     .D1T1   A_qt_9,     *-A_di_ptr[7]       ;[16,2] Quotient  9
||      MV      .L2X    A15,        B_j                 ;(outer) j = num_blks
||[ A_i]B       .S2     i_loop                          ;(outer) while (i)
||[!A_i]MV      .L1X    B_SP,       A_SP                ;(exit) Twin Stack Ptr
;-
        ADD     .L2X    B_qp_7,     A_rnd,      B_qr_7  ;[17,2] qr_7=qp_7+rnd
||      ADD     .L1     A_qp_5,     A_rnd,      A_qr_5  ;[17,2] qr_5=qp_5+rnd
||      MPYH    .M2     B_r_32,     B_d_32,     B_qp_3  ;[17,2] qp_3=r_3*d_3
||      MPYH    .M1     A_r_10,     A_d_10,     A_qp_1  ;[17,2] qp_1=r_1*d_1
||      SHR     .S2     B_qr_A,     B_q_pt,     B_qt_A  ;[17,2] qt_A=qr_A>>q_pt
||      SHR     .S1     A_qr_8,     A_q_pt,     A_qt_8  ;[17,2] qt_8=qr_8>>q_pt
||[ A_i]LDW     .D2T2   *+B_di_ptr[4],          B_d_BA  ;[ 5,1] Data 11, 10
||[ A_i]LDW     .D1T1   *+A_di_ptr[4],          A_d_98  ;[ 5,1] Data  9,  8
; ===== If (i==0) Branch Occurs [exit] =====
final_store1:
;-
        ADD     .L2X    B_qp_6,     A_rnd,      B_qr_6  ;[18,2] qr_6=qp_6+rnd
||      ADD     .L1     A_qp_4,     A_rnd,      A_qr_4  ;[18,2] qr_4=qp_4+rnd
||      MPY     .M2     B_r_32,     B_d_32,     B_qp_2  ;[18,2] qp_2=r_2*d_2
||      MPY     .M1     A_r_10,     A_d_10,     A_qp_0  ;[18,2] qp_0=r_0*d_0
||      STH     .D2T2   B_qt_A,     *-B_di_ptr[8]       ;[18,2] Quotient 10
||      STH     .D1T1   A_qt_8,     *-A_di_ptr[8]       ;[18,2] Quotient  8
||[!A_i]RET     .S2     B_ret                           ;(exit) Rtn to caller
||      SHR     .S1     A_qr_5,     A_q_pt,     A_qt_5  ;[19,2] qt_5=qr_5>>q_pt
;-
        ADD     .L2X    B_qp_3,     A_rnd,      B_qr_3  ;[19,2] qr_3=qp_3+rnd
||      ADD     .L1     A_qp_1,     A_rnd,      A_qr_1  ;[19,2] qr_1=qp_1+rnd
||      SHR     .S2     B_qr_7,     B_q_pt,     B_qt_7  ;[19,2] qt_7=qr_7>>q_pt
||[ A_i]LDW     .D2T2   *+B_di_ptr[6],          B_d_FE  ;[ 1,1] Data 15, 14
||[ A_i]LDW     .D1T1   *+A_di_ptr[6],          A_d_DC  ;[ 1,1] Data 13, 12
||[!A_i]ADD     .S1     A_i,        1,          A_i     ;(exit) if (exit) i = 1
;-
        SHR     .S2     B_qr_6,     B_q_pt,     B_qt_6  ;[20,2] qt_6=qr_6>>q_pt
||      SHR     .S1     A_qr_4,     A_q_pt,     A_qt_4  ;[20,2] qt_4=qr_4>>q_pt
||      ADD     .L2X    B_qp_2,     A_rnd,      B_qr_2  ;[20,2] qr_2=qp_2+rnd
||      ADD     .L1     A_qp_0,     A_rnd,      A_qr_0  ;[20,2] qr_0=qp_0+rnd
||      STH     .D2T2   B_qt_7,     *-B_di_ptr[11]      ;[20,2] Quotient 7
||      STH     .D1T1   A_qt_5,     *-A_di_ptr[11]      ;[20,2] Quotient 5
;-
        SHR     .S2     B_qr_3,     B_q_pt,     B_qt_3  ;[21,2] qt_3=qr_3>>q_pt
||      SHR     .S1     A_qr_1,     A_q_pt,     A_qt_1  ;[21,2] qt_1=qr_1>>q_pt
||      STH     .D2T2   B_qt_6,     *-B_di_ptr[12]      ;[21,2] Quotient 6
||      STH     .D1T1   A_qt_4,     *-A_di_ptr[12]      ;[21,2] Quotient 4
; ===== Branch Occurs [i_loop, final_store2]
; ========================================================================= ;


* ========================================================================= *
*   Exit Code                                                               *
*                                                                           *
*   The exit code restores registers from the stack frame and prepares      *
*   the function to return to the caller.  At the point that "exit" is      *
*   reached, the epilog code from the combined inner and outer loops has    *
*   not yet completed, since the outer-loop branches to "exit" early, as    *
*   a form of ad-hoc tail duplication.                                      *
*                                                                           *
*   While the stack frame is being restored, a set of branches is set in-   *
*   flight which resume executing the epilog code while values land in the  *
*   stack.  This effectively hides the delay slots associated with          *
*   restoring the stack, and eliminates the codesize increase associated    *
*   with tail duplication.                                                  *
*                                                                           *
*   The exact branching sequence taken during exit is as follows.  The      *
*   numbers refer to relative cycles after which each branch occurs.        *
*   Cycle 1 corresponds to the instruction at the exit label.               *
*                                                                           *
*         0:  Epilog Code  --> exit                                         *
*         7:  exit         --> final_store1                                 *
*        11:  final_store1 --> final_store2                                 *
*        13:  final_store2 --> caller                                       *
*                                                                           *
*   Although the GIE bit is restored in CSR fairly early in the exiting     *
*   process, the multiple chained exit-branches keep interrupts locked out  *
*   until the calling function resumes execution.                           *
* ========================================================================= *

exit:
        LDW     .D1T2   *+A_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr       ; Get CSR's value
;-
        LDW     .D1T2   *+A_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14         ; Restore A14
||      B       .S2     final_store1            ; Perform final stores

        LDW     .D1T2   *+A_SP[ 9], B13         ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13         ; Restore A13

        LDW     .D1T2   *+A_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12         ; Restore A12
;-
        LDW     .D1T2   *+A_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11         ; Restore A11

        LDW     .D1T2   *+A_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10         ; Restore A10
||      B       .S1     final_store2            ; Perform final stores
||      MVC     .S2X    A_csr,      CSR         ; Restore CSR

        LDW     .D2T1   *++B_SP[14],A15         ; Restore A15

; ===== Branch Occurs [final_store1] =====

* ========================================================================= *
*   End of file:  img_quantize.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

sad_16x16.asm/  1066929162  0     0     0       14981     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Sun Sep 29 03:31:29 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_sad_16x16 -- Sum of Absolute Differences on single 16x16 block  *
*                                                                           *
*   USAGE                                                                   *
*       unsigned IMG_sad_16x16                                              *
*       (                                                                   *
*           const unsigned char *restrict srcImg,  /* 16x16 source block */ *
*           const unsigned char *restrict refImg,  /* Reference image    */ *
*           int pitch                              /* Width of ref image */ *
*       );                                                                  *
*                                                                           *
*       The code accepts a pointer to the 16x16 source block (srcImg),      *
*       and a pointer to the upper-left corner of a target position in      *
*       a reference image (refImg).  The width of the reference image       *
*       is given by the pitch argument.                                     *
*                                                                           *
*       The function returns the sum of the absolute differences            *
*       between the source block and the 16x16 region pointed to in the     *
*       reference image.                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       The algorithm takes the difference between the pixel values in      *
*       the source image block and the corresponding pixels in the          *
*       reference image.  It then takes the absolute values of these        *
*       differences, and accumulates them over the entire 16x16 region.     *
*       It returns the final accumulation.                                  *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C code description of the algorithm that lacks   *
*       restrictions.  The assembly code may have additional restrictions   *
*       as noted below.                                                     *
*                                                                           *
*           unsigned IMG_sad_16x16                                          *
*           (                                                               *
*               const unsigned char *restrict srcImg,                       *
*               const unsigned char *restrict refImg,                       *
*               int pitch                                                   *
*           )                                                               *
*           {                                                               *
*               int i, j;                                                   *
*               unsigned sad = 0;                                           *
*                                                                           *
*               for (i = 0; i < 16; i++)                                    *
*                   for (j = 0; j < 16; j++)                                *
*                       sad += abs(srcImg[j+i*16] - refImg[j+i*pitch]);     *
*                                                                           *
*               return sad;                                                 *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       No alignment restrictions.                                          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*       Endian Neutral.                                                     *
*                                                                           *
*   NOTES                                                                   *
*       This kernel blocks interrupts for its entire duration.              *
*                                                                           *
*   CYCLES                                                                  *
*       272 cycles                                                          *
*                                                                           *
*   CODESIZE                                                                *
*       256 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_sad_16x16"
        .global _IMG_sad_16x16
_IMG_sad_16x16:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_sp3
        .asg            A1,         A_j
        .asg            A2,         A_i
        .asg            A3,         A_a3
        .asg            A3,         A_d3
        .asg            A3,         A_rp3
        .asg            A4,         A_retval
        .asg            A4,         A_srcImg
        .asg            A5,         A_refImg
        .asg            A6,         A_pitch
        .asg            A6,         A_sp0
        .asg            A7,         A_sad
        .asg            A8,         A_a0
        .asg            A8,         A_d0
        .asg            A8,         A_rp0
        .asg            A9,         A_j_init
        .asg            B0,         B_a1
        .asg            B0,         B_d1
        .asg            B1,         B_sp2
        .asg            B2,         B_k
        .asg            B3,         B_retaddr
        .asg            B4,         B_refImg
        .asg            B5,         B_srcImg
        .asg            B6,         B_rp2
        .asg            B6,         B_sp1
        .asg            B7,         B_a2
        .asg            B7,         B_d2
        .asg            B7,         B_rp1
        .asg            B8,         B_sad
        .asg            B9,         B_p
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        ADD     .L2X    A_srcImg,   2,          B_srcImg
||      ADD     .L1X    B_refImg,   2,          A_refImg

        LDBU    .D1T2   *A_srcImg[1],           B_sp1           ;[ 2,1]
||      LDBU    .D2T1   *B_srcImg[1],           A_sp3           ;[ 2,1]
||      MVK     .S1     0x2000,     A_j_init
||      MVK     .S2     -0x8000,    B_k
||      SUB     .L2X    A_pitch,    16,         B_p

        ADD     .L1X    B_refImg,   2,          A_refImg        ;[ 3,1]
||      LDBU    .D1T1   *A_srcImg++[4],         A_sp0           ;[ 3,1]
||      LDBU    .D2T2   *B_srcImg++[4],         B_sp2           ;[ 3,1]
||      B       .S2     loop
||      MVK     .S1     62,         A_i

        LDBU    .D2T2   *B_refImg[1],           B_rp1           ;[ 4,1]
||      LDBU    .D1T1   *A_refImg[1],           A_rp3           ;[ 4,1]
||      MVK     .S1     0x4000,     A_j

* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!B_k]ADD     .L1     A_sad,      A_a0,       A_sad           ;[13,1]
||[!B_k]ADD     .S2     B_sad,      B_a1,       B_sad           ;[13,1]
||      SUB     .L2     B_sp1,      B_rp1,      B_d1            ;[ 9,2]
||      SUB     .S1     A_sp3,      A_rp3,      A_d3            ;[ 9,2]
||      LDBU    .D2T1   *B_refImg++[4],         A_rp0           ;[ 5,3]
||      LDBU    .D1T2   *A_refImg++[4],         B_rp2           ;[ 5,3]
||[!A_j]MPY     .M1     A_j_init,   1,          A_j             ;[ 1,4]
||[ B_k]MPY     .M2     B_sad,      0,          B_sad

        ABS     .L1     A_d3,       A_a3                        ;[10,2]
||      SUB     .S1     A_sp0,      A_rp0,      A_d0            ;[10,2]
||      SUB     .S2     B_sp2,      B_rp2,      B_d2            ;[10,2]
||[!A_j]ADD     .L2     B_refImg,   B_p,        B_refImg        ;[ 6,3]
||      LDBU    .D1T2   *A_srcImg[1],           B_sp1           ;[ 2,4]
||      LDBU    .D2T1   *B_srcImg[1],           A_sp3           ;[ 2,4]
||      MPY     .M2     B_k,        2,          B_k
||[ B_k]MPY     .M1     A_sad,      0,          A_sad

  [ A_i]B       .S2     loop                                    ;[11,2]
||      ABS     .L1     A_d0,       A_a0                        ;[11,2]
||      ABS     .L2     B_d2,       B_a2                        ;[11,2]
||      MPY     .M1     A_j,        2,          A_j             ;[ 3,4]
||      ADD     .S1X    B_refImg,   2,          A_refImg        ;[ 3,4]
||      LDBU    .D1T1   *A_srcImg++[4],         A_sp0           ;[ 3,4]
||      LDBU    .D2T2   *B_srcImg++[4],         B_sp2           ;[ 3,4]

  [!B_k]ADD     .S2     B_sad,      B_a2,       B_sad           ;[12,2]
||[!B_k]ADD     .S1     A_sad,      A_a3,       A_sad           ;[12,2]
||      ABS     .L2     B_d1,       B_a1                        ;[12,2]
||[ A_i]SUB     .L1     A_i,        1,          A_i             ;[ 8,3]
||      LDBU    .D2T2   *B_refImg[1],           B_rp1           ;[ 4,4]
||      LDBU    .D1T1   *A_refImg[1],           A_rp3           ;[ 4,4]

* =========================== PIPE LOOP EPILOG ============================ *
        ADD     .L1     A_sad,      A_a0,       A_sad           ;[13,3]
||      ADD     .D2     B_sad,      B_a1,       B_sad           ;[13,3]
||      SUB     .L2     B_sp1,      B_rp1,      B_d1            ;[ 9,4]
||      SUB     .D1     A_sp3,      A_rp3,      A_d3            ;[ 9,4]
||      RET     .S2     B_retaddr

        ABS     .L1     A_d3,       A_a3                        ;[10,4]
||      SUB     .S1     A_sp0,      A_rp0,      A_d0            ;[10,4]
||      SUB     .S2     B_sp2,      B_rp2,      B_d2            ;[10,4]

        ABS     .L1     A_d0,       A_a0                        ;[11,4]
||      ABS     .L2     B_d2,       B_a2                        ;[11,4]

        ADD     .S2     B_sad,      B_a2,       B_sad           ;[12,4]
||      ADD     .S1     A_sad,      A_a3,       A_sad           ;[12,4]
||      ABS     .L2     B_d1,       B_a1                        ;[12,4]

        ADD     .L1     A_sad,      A_a0,       A_sad           ;[13,4]
||      ADD     .S2     B_sad,      B_a1,       B_sad           ;[13,4]

        ADD     .L1X    A_sad,      B_sad,      A_retval

* ========================================================================= *
*   End of file: img_sad_16x16.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

sad_8x8.asm/    1066929162  0     0     0       14919     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Sun Sep 29 03:31:29 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_sad_8x8   -- Sum of Absolute Differences on single 8x8 block    *
*                                                                           *
*   USAGE                                                                   *
*       unsigned IMG_sad_8x8                                                *
*       (                                                                   *
*           const unsigned char *restrict srcImg,  /* 8x8 source block   */ *
*           const unsigned char *restrict refImg,  /* Reference image    */ *
*           int pitch                              /* Width of ref image */ *
*       );                                                                  *
*                                                                           *
*       The code accepts a pointer to the 8x8 source block (srcImg),        *
*       and a pointer to the upper-left corner of a target position in      *
*       a reference image (refImg).  The width of the reference image       *
*       is given by the pitch argument.                                     *
*                                                                           *
*       The function returns the sum of the absolute differences            *
*       between the source block and the 8x8 region pointed to in the       *
*       reference image.                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       The algorithm takes the difference between the pixel values in      *
*       the source image block and the corresponding pixels in the          *
*       reference image.  It then takes the absolute values of these        *
*       differences, and accumulates them over the entire 8x8 region.       *
*       It returns the final accumulation.                                  *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C code description of the algorithm that lacks   *
*       restrictions.  The assembly code may have additional restrictions   *
*       as noted below.                                                     *
*                                                                           *
*           unsigned IMG_sad_8x8                                            *
*           (                                                               *
*               const unsigned char *restrict srcImg,                       *
*               const unsigned char *restrict refImg,                       *
*               int pitch                                                   *
*           )                                                               *
*           {                                                               *
*               int i, j;                                                   *
*               unsigned sad = 0;                                           *
*                                                                           *
*               for (i = 0; i < 8; i++)                                     *
*                   for (j = 0; j < 8; j++)                                 *
*                       sad += abs(srcImg[j+i*8] - refImg[j+i*pitch]);      *
*                                                                           *
*               return sad;                                                 *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       No alignment restrictions.                                          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*       Endian Neutral.                                                     *
*                                                                           *
*   NOTES                                                                   *
*       This kernel blocks interrupts for its entire duration.              *
*                                                                           *
*   CYCLES                                                                  *
*       80 cycles                                                           *
*                                                                           *
*   CODESIZE                                                                *
*       256 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_sad_8x8"
        .global _IMG_sad_8x8
_IMG_sad_8x8:  
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_sp3
        .asg            A1,         A_j
        .asg            A2,         A_i
        .asg            A3,         A_a3
        .asg            A3,         A_d3
        .asg            A3,         A_rp3
        .asg            A4,         A_retval
        .asg            A4,         A_srcImg
        .asg            A5,         A_refImg
        .asg            A6,         A_pitch
        .asg            A6,         A_sp0
        .asg            A7,         A_sad
        .asg            A8,         A_a0
        .asg            A8,         A_d0
        .asg            A8,         A_rp0
        .asg            A9,         A_j_init
        .asg            B0,         B_a1
        .asg            B0,         B_d1
        .asg            B1,         B_sp2
        .asg            B2,         B_k
        .asg            B3,         B_retaddr
        .asg            B4,         B_refImg
        .asg            B5,         B_srcImg
        .asg            B6,         B_rp2
        .asg            B6,         B_sp1
        .asg            B7,         B_a2
        .asg            B7,         B_d2
        .asg            B7,         B_rp1
        .asg            B8,         B_sad
        .asg            B9,         B_p
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        ADD     .L2X    A_srcImg,   2,          B_srcImg
||      ADD     .L1X    B_refImg,   2,          A_refImg

        LDBU    .D1T2   *A_srcImg[1],           B_sp1           ;[ 2,1]
||      LDBU    .D2T1   *B_srcImg[1],           A_sp3           ;[ 2,1]
||      MVK     .S2     -0x8000,    B_k
||      SUB     .L2X    A_pitch,    8,          B_p

        ADD     .L1X    B_refImg,   2,          A_refImg        ;[ 3,1]
||      LDBU    .D1T1   *A_srcImg++[4],         A_sp0           ;[ 3,1]
||      LDBU    .D2T2   *B_srcImg++[4],         B_sp2           ;[ 3,1]
||      B       .S2     loop
||      MVK     .S1     14,         A_i

        LDBU    .D2T2   *B_refImg[1],           B_rp1           ;[ 4,1]
||      LDBU    .D1T1   *A_refImg[1],           A_rp3           ;[ 4,1]
||      ZERO    .S1     A_j

* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!B_k]ADD     .L1     A_sad,      A_a0,       A_sad           ;[13,1]
||[!B_k]ADD     .S2     B_sad,      B_a1,       B_sad           ;[13,1]
||      SUB     .L2     B_sp1,      B_rp1,      B_d1            ;[ 9,2]
||      SUB     .S1     A_sp3,      A_rp3,      A_d3            ;[ 9,2]
||      LDBU    .D2T1   *B_refImg++[4],         A_rp0           ;[ 5,3]
||      LDBU    .D1T2   *A_refImg++[4],         B_rp2           ;[ 5,3]
||[ B_k]MPY     .M2     B_sad,      0,          B_sad

        ABS     .L1     A_d3,       A_a3                        ;[10,2]
||      SUB     .S1     A_sp0,      A_rp0,      A_d0            ;[10,2]
||      SUB     .S2     B_sp2,      B_rp2,      B_d2            ;[10,2]
||[ A_j]ADD     .L2     B_refImg,   B_p,        B_refImg        ;[ 6,3]
||      LDBU    .D1T2   *A_srcImg[1],           B_sp1           ;[ 2,4]
||      LDBU    .D2T1   *B_srcImg[1],           A_sp3           ;[ 2,4]
||      MPY     .M2     B_k,        2,          B_k
||[ B_k]MPY     .M1     A_sad,      0,          A_sad

  [ A_i]B       .S2     loop                                    ;[11,2]
||      ABS     .L1     A_d0,       A_a0                        ;[11,2]
||      ABS     .L2     B_d2,       B_a2                        ;[11,2]
||      MPY     .M1     A_j,        0,          A_j             ;[ 3,4]
||      ADD     .S1X    B_refImg,   2,          A_refImg        ;[ 3,4]
||      LDBU    .D1T1   *A_srcImg++[4],         A_sp0           ;[ 3,4]
||      LDBU    .D2T2   *B_srcImg++[4],         B_sp2           ;[ 3,4]

  [!B_k]ADD     .S2     B_sad,      B_a2,       B_sad           ;[12,2]
||[!B_k]ADD     .S1     A_sad,      A_a3,       A_sad           ;[12,2]
||      ABS     .L2     B_d1,       B_a1                        ;[12,2]
||[ A_i]SUB     .L1     A_i,        1,          A_i             ;[ 8,3]
||      LDBU    .D2T2   *B_refImg[1],           B_rp1           ;[ 4,4]
||      LDBU    .D1T1   *A_refImg[1],           A_rp3           ;[ 4,4]
||[!A_j]MPY     .M1X    B_p,        1,          A_j             ;[ 3,4]

* =========================== PIPE LOOP EPILOG ============================ *
        ADD     .L1     A_sad,      A_a0,       A_sad           ;[13,3]
||      ADD     .D2     B_sad,      B_a1,       B_sad           ;[13,3]
||      SUB     .L2     B_sp1,      B_rp1,      B_d1            ;[ 9,4]
||      SUB     .D1     A_sp3,      A_rp3,      A_d3            ;[ 9,4]
||      RET     .S2     B_retaddr

        ABS     .L1     A_d3,       A_a3                        ;[10,4]
||      SUB     .S1     A_sp0,      A_rp0,      A_d0            ;[10,4]
||      SUB     .S2     B_sp2,      B_rp2,      B_d2            ;[10,4]

        ABS     .L1     A_d0,       A_a0                        ;[11,4]
||      ABS     .L2     B_d2,       B_a2                        ;[11,4]

        ADD     .S2     B_sad,      B_a2,       B_sad           ;[12,4]
||      ADD     .S1     A_sad,      A_a3,       A_sad           ;[12,4]
||      ABS     .L2     B_d1,       B_a1                        ;[12,4]

        ADD     .L1     A_sad,      A_a0,       A_sad           ;[13,4]
||      ADD     .S2     B_sad,      B_a1,       B_sad           ;[13,4]

        ADD     .L1X    A_sad,      B_sad,      A_retval

* ========================================================================= *
*   End of file: img_sad_8x8.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

sobel.asm/      1066929162  0     0     0       27637     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Sun Sep 29 03:31:30 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_sobel, Little Endian.                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       06-Apr-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_sobel                                                      *
*       (                                                                   *
*           const unsigned char    *in_data,      /* Input image data  */   *
*           unsigned char *restrict out_data,     /* Output image data */   *
*           short cols, short rows                /* Image dimensions  */   *
*       );                                                                  *
*                                                                           *
*       The IMG_sobel filter is applied to the input image. The input image *
*       dimensions are given by the arguments 'cols' and 'rows'.  The       *
*       output image is 'cols' pixels wide and 'rows - 2' pixels tall.      *
*                                                                           *
*   DESCRIPTION                                                             *
*       To see how the implementation is going to work on the input         *
*       buffer, lets imagine we have the following input buffer:            *
*       lets imagine we have the following input buffer:                    *
*                                                                           *
*               yyyyyyyyyyyyyyyy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yyyyyyyyyyyyyyyy                                            *
*                                                                           *
*       The output buffer would be:                                         *
*                                                                           *
*               tXXXXXXXXXXXXXXz                                            *
*               zXXXXXXXXXXXXXXz                                            *
*               zXXXXXXXXXXXXXXz                                            *
*               zXXXXXXXXXXXXXXt                                            *
*                                                                           *
*       Where:                                                              *
*                                                                           *
*           X = IMG_sobel(x)    The algorithm is applied to that pixel.     *
*                           The correct output is obtained, the data        *
*                           around the pixels we work on is used            *
*                                                                           *
*           t               Whatever was in the output buffer in that       *
*                           position is kept there.                         *
*                                                                           *
*           z = IMG_sobel(y)    The algorithm is applied to that pixel.     *
*                           The output is not meaningful, because the       *
*                           necessary data to process the pixel is not      *
*                           available.  This is because for each output     *
*                           pixel we need input pixels from the right and   *
*                           from the left of the output pixel.  But this    *
*                           data doesn't exist.                             *
*                                                                           *
*       This means that we will only process (rows-2) lines.  Then, we      *
*       will process all the pixels inside each line. Even though the       *
*       results for the first and last pixels in each line will not         *
*       be relevant, it makes the control much simpler and ends up          *
*       saving cycles.                                                      *
*                                                                           *
*       Also the fist pixel in the first processed line and the             *
*       last pixel in the last processed line will not be computed.         *
*       It is not necessary, since the results would be bogus, and          *
*       not computing them saves some time.                                 *
*                                                                           *
*       The following horizontal and vertical masks that are                *
*       applied to the input buffer to obtain one output pixel.             *
*                                                                           *
*           Horizontal:                                                     *
*               -1 -2 -1                                                    *
*                0  0  0                                                    *
*                1  2  1                                                    *
*                                                                           *
*           Vertical:                                                       *
*               -1  0  1                                                    *
*               -2  0  2                                                    *
*               -1  0  1                                                    *
*                                                                           *
*   C CODE                                                                  *
*       This is a C model of the Sobel implementation.  This C code         *
*       is functionally equivalent to the assembly code without             *
*       restrictions.   The assembly code may impose additional             *
*       restrictions.                                                       *
*                                                                           *
*           void IMG_sobel                                                  *
*           (                                                               *
*               const unsigned char *in_data,  /* Input image data  */      *
*               unsigned char       *out_data, /* Output image data */      *
*               short cols, short rows         /* Image dimensions  */      *
*           )                                                               *
*           {                                                               *
*               /* ------------------------------------------------ */      *
*               /*  Intermediate values.                            */      *
*               /* ------------------------------------------------ */      *
*               int H;    /* Horizontal mask result                 */      *
*               int V;    /* Vertical mask result                   */      *
*               int O;    /* Sum of horizontal and vertical masks   */      *
*               int i;    /* Input pixel offset                     */      *
*               int o;    /* Output pixel offset.                   */      *
*               int xy;   /* Loop counter.                          */      *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Input values.                                   */      *
*               /* ------------------------------------------------ */      *
*               int i00, i01, i02;                                          *
*               int i10,      i12;                                          *
*               int i20, i21, i22;                                          *
*               const unsigned char *in = in_data; /* shorthand */          *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Step through the entire image.  We step         */      *
*               /*  through 'rows - 2' rows in the output image,    */      *
*               /*  since those are the only rows that are fully    */      *
*               /*  defined for our filter.                         */      *
*               /* ------------------------------------------------ */      *
*               for (xy = 0, i = cols + 1, o = 1;                           *
*                    xy < cols*(rows-2) - 2;                                *
*                    xy++, i++, o++)                                        *
*               {                                                           *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Read necessary data to process an input     */      *
*                   /*  pixel.  The following instructions are      */      *
*                   /*  written to reflect the position of the      */      *
*                   /*  input pixels in reference to the pixel      */      *
*                   /*  being processed, which would correspond     */      *
*                   /*  to the blank space left in the middle.      */      *
*                   /* -------------------------------------------- */      *
*                   i00=in[i-cols-1]; i01=in[i-cols]; i02=in[i-cols+1];     *
*                   i10=in[i     -1];                 i12=in[i     +1];     *
*                   i20=in[i+cols-1]; i21=in[i+cols]; i22=in[i+cols+1];     *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Apply the horizontal mask.                  */      *
*                   /* -------------------------------------------- */      *
*                   H = -i00 - 2*i01 -   i02 +   i20 + 2*i21 + i22;         *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Apply the vertical mask.                    */      *
*                   /* -------------------------------------------- */      *
*                   V = -i00 +   i02 - 2*i10 + 2*i12 -   i20 + i22;         *
*                                                                           *
*                   O = abs(H) + abs(V);                                    *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  If the result is over 255 (largest valid    */      *
*                   /*  pixel value), saturate (clamp) to 255.      */      *
*                   /* -------------------------------------------- */      *
*                   if (O > 255) O = 255;                                   *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Store the result.                           */      *
*                   /* -------------------------------------------- */      *
*                   out_data[o] = O;                                        *
*               }                                                           *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       At least eight output pixels must be processed.                     *
*       The image arrays must be half-word aligned.                         *
*       The input image width must be even (eg. 'cols' must be even).       *
*                                                                           *
*   NOTES                                                                   *
*       This is a LITTLE ENDIAN implementation.                             *
*                                                                           *
*       The values of the left-most and right-most pixels on each line      *
*       of the output are not well-defined.                                 *
*                                                                           *
*       This code is fully interruptible.                                   *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur under any conditions.                       *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 34 + 3 * cols * (rows - 2)                                 *
*                                                                           *
*       For cols =  64 and rows = 8, cycles =  1186                         *
*       For cols = 720 and rows = 8, cycles = 12994                         *
*                                                                           *
*   CODESIZE                                                                *
*       416 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_sobel"
        .global _IMG_sobel
_IMG_sobel:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
            .asg            A4,         A_ip
            .asg            B4,         B_op
            .asg            A6,         A_w
            .asg            B6,         B_h
            .asg            B3,         B_ret_addr

            .asg            A9,         A_BA1
            .asg            A8,         A_BA2
            .asg            A7,         A_BA3
            .asg            A9,         A_A1
            .asg            A8,         A_A2
            .asg            A7,         A_A3
            .asg            B7,         B_B1
            .asg            B8,         B_B2
            .asg            B5,         B_B3

            .asg            A5,         A_Av_
            .asg            B1,         B_Bv_

            .asg            A0,         A_C2
            .asg            A0,         A_DC2
            .asg            A0,         A_hmask_
            .asg            A1,         A_MFF
            .asg            A2,         A_wD2
            .asg            A3,         A_7FFFFF00
            .asg            A4,         A_SP
            .asg            A5,         A_Ah
            .asg            A5,         A_Cv
            .asg            A7,         A_Bh
            .asg            A7,         A_vABS
            .asg            A7,         A_vmask
            .asg            A8,         A_C3
            .asg            A8,         A_mask_
            .asg            A9,         A_Ch
            .asg            A9,         A_hABS
            .asg            A10,        A_C1
            .asg            A10,        A_Cv_
            .asg            A10,        A_hmask
            .asg            A10,        A_mask
            .asg            A11,        A_Av
            .asg            B0,         B_cnt
            .asg            B1,         B_Bv
            .asg            B1,         B_vABS
            .asg            B2,         B_D3
            .asg            B2,         B_DC3
            .asg            B2,         B_mask
            .asg            B5,         B_Dh
            .asg            B5,         B_mask_
            .asg            B6,         B_Bh
            .asg            B7,         B_Dv_
            .asg            B7,         B_hABS
            .asg            B7,         B_hmask
            .asg            B7,         B_hmask_
            .asg            B8,         B_Chx2
            .asg            B8,         B_D2
            .asg            B8,         B_vmask
            .asg            B9,         B_D1
            .asg            B9,         B_Dv
            .asg            B10,        B_DC1     ; move to B10 to make intr.
* ========================================================================= *

* =========================== PIPE LOOP PROLOG ============================ *
            LDHU    .D1T1   *+A_ip[A_w],            A_BA3
||          SHRU    .S1     A_w,        1,          A_wD2

            LDHU    .D1T1   *+A_ip[A_wD2],          A_BA2

            LDHU    .D1T1   *A_ip++[1],             A_BA1

            SUB     .L2     B_h,        2,          B_h
||          STW     .D2T1   A10,        *B15--[4]

            MPY     .M2X    A_wD2,      B_h,        B_cnt
||          STW     .D2T1   A11,        *B15[2]
;-
            LDHU    .D1T2   *+A_ip[A_w],            B_DC3       ;[ 1,1]
||          MVK     .S1     0xFF,       A_MFF

            LDHU    .D1T1   *+A_ip[A_wD2],          A_DC2       ;[ 2,1]
||          SHRU    .S2     A_BA3,      8,          B_B3
||          AND     .L1     A_BA3,      A_MFF,      A_A3

            LDHU    .D1T2   *A_ip++[1],             B_DC1       ;[ 3,1]
||          SHRU    .S2     A_BA1,      8,          B_B1
||          AND     .L1     A_BA1,      A_MFF,      A_A1
;-
            ADD     .D1     A_A3,       A_A1,       A_Av_
||          SHRU    .S2     A_BA2,      8,          B_B2
||          AND     .L1     A_BA2,      A_MFF,      A_A2
||          MVKL    .S1     0x7FFFFF00, A_7FFFFF00
||          STW     .D2T2   B10,        *B15[1]
;-
            ADD     .L2     B_B3,       B_B1,       B_Bv_
||          ADDAH   .D1     A_Av_,      A_A2,       A_Cv
||  [ B_cnt]SUB     .D2     B_cnt,      2,          B_cnt
||          B       .S2     loop_4 + 4              ; prolog collapse
||          MVKH    .S1     0x7FFFFF00, A_7FFFFF00
;-
            AND     .L1X    B_DC3,      A_MFF,      A_C3        ;[ 6,1]
||          SHRU    .S2     B_DC3,      8,          B_D3        ;[ 6,1]
||          ADDAH   .D2     B_Bv_,      B_B2,       B_Dv
||          SUB     .L2     B_B3,       B_B1,       B_Dh
||          SUB     .D1     A_A3,       A_A1,       A_Ch
||          B       .S1     loop_5 + 4              ; prolog collapse
;-
* =========================== PIPE LOOP KERNEL ============================ *
loop:
            MPY     .M1     A_Cv,       1,          A_Av        ;[13,1]
||          ABS     .L1     A_vmask,    A_vABS                  ;[13,1]
||          ADD     .D2     B_hmask_,   B_Chx2,     B_hmask     ;[13,1]
||  [ B_cnt]B       .S1     loop                                ;[13,1]
||  [ B_cnt]LDHU    .D1T2   *+A_ip[A_w],            B_DC3       ;[ 1,3]
loop_1:
            MPY     .M2     B_Dv,       1,          B_Bv        ;[14,1]
||          MPY     .M1     A_Ch,       1,          A_Ah        ;[14,1]
||          ABS     .L2     B_hmask,    B_hABS                  ;[14,1]
||          ABS     .L1     A_hmask,    A_hABS                  ;[14,1]
||  [ B_cnt]SUB     .D2     B_cnt,      1,          B_cnt       ;[ 8,2]
||          AND     .S1X    B_DC1,      A_MFF,      A_C1        ;[ 8,2]
||          SHRU    .S2     B_DC1,      8,          B_D1        ;[ 8,2]
||          LDHU    .D1T1   *+A_ip[A_wD2],          A_DC2       ;[ 2,3]
loop_2:
            MPY     .M1X    B_Dh,       1,          A_Bh        ;[15,1]
||          MPY     .M2     B_Dh,       1,          B_Bh        ;[15,1]
||          ADD     .D2     B_hABS,     B_vABS,     B_mask_     ;[15,1]
||          ADD     .L2     B_D3,       B_D1,       B_Dv_       ;[ 9,2]
||          AND     .S1     A_DC2,      A_MFF,      A_C2        ;[ 9,2]
||          SHRU    .S2X    A_DC2,      8,          B_D2        ;[ 9,2]
||          LDHU    .D1T2   *A_ip++[1],             B_DC1       ;[ 3,3]
loop_3:
            SADD    .L2X    B_mask_,    A_7FFFFF00, B_mask      ;[16,1]
||          ADD     .S1     A_vABS,     A_hABS,     A_mask_     ;[16,1]
||          SUB     .S2     B_D3,       B_D1,       B_Dh        ;[10,2]
||          ADDAH   .D2     B_Dv_,      B_D2,       B_Dv        ;[10,2]
||          SUB     .D1     A_C3,       A_C1,       A_Ch        ;[10,2]
||          ADD     .L1     A_C3,       A_C1,       A_Cv_       ;[10,2]
loop_4:
            STB     .D2T2   B_mask,     *++B_op[2]              ;[17,1]
||          SADD    .L1     A_mask_,    A_7FFFFF00, A_mask      ;[17,1]
||          ADD     .L2     B_Bh,       B_Dh,       B_hmask_    ;[11,2]
||          MPY     .M2X    A_Ch,       2,          B_Chx2      ;[11,2]
||          SUB     .S2     B_Dv,       B_Bv,       B_vmask     ;[11,2]
||          ADD     .S1     A_Ah,       A_Ch,       A_hmask_    ;[11,2]
||          ADDAH   .D1     A_Cv_,      A_C2,       A_Cv        ;[11,2]
loop_5:
            STB     .D2T1   A_mask,     *-B_op[1]               ;[18,1]
||          ABS     .L2     B_vmask,    B_vABS                  ;[12,2]
||          ADDAH   .D1     A_hmask_,   A_Bh,       A_hmask     ;[12,2]
||          SUB     .S1     A_Cv,       A_Av,       A_vmask     ;[12,2]
||          AND     .L1X    B_DC3,      A_MFF,      A_C3        ;[ 6,3]
||          SHRU    .S2     B_DC3,      8,          B_D3        ;[ 6,3]
;-
* =========================== PIPE LOOP EPILOG ============================ *
            ABS     .L1     A_vmask,    A_vABS                  ;[13,3]
||          ADD     .L2     B_hmask_,   B_Chx2,     B_hmask     ;[13,3]
||          RET     .S2     B_ret_addr
||          LDW     .D2T1   *B15[2],    A11
||          MV      .S1X    B15,        A_SP

            ABS     .L2     B_hmask,    B_hABS                  ;[14,3]
||          LDW     .D2T1   *++B15[4],  A10
||          LDW     .D1T2   *A_SP[1],   B10
;-
            ADD     .D2     B_hABS,     B_vABS,     B_mask_     ;[15,3]
||          ABS     .L1     A_hmask,    A_hABS                  ;[14,3]

            SADD    .L2X    B_mask_,    A_7FFFFF00, B_mask      ;[16,3]
||          ADD     .S1     A_vABS,     A_hABS,     A_mask_     ;[16,3]

            STB     .D2T2   B_mask,     *++B_op[2]              ;[17,3]
||          SADD    .L1     A_mask_,    A_7FFFFF00, A_mask      ;[17,3]

            STB     .D2T1   A_mask,     *-B_op[1]               ;[18,3]
;-
* ========================================================================= *
*   End of file:  img_sobel.asm                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

thr_gt2max.asm/ 1066929162  0     0     0       26842     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Sun Sep 29 03:31:30 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       threshold                                                           *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       25-Jun-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_gt2max                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     //  Input image data  //      *
*           unsigned char *restrict out_data, //  Output image data //      *
*           short cols, short rows,           //  Image dimensions  //      *
*           unsigned char       threshold     //  Threshold value   //      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are greater than the threshold      *
*       are set to 255 in the output image.                                 *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                  255_|          _________                                 *
*                      |         |                                          *
*                      |         |                                          *
*             O        |         |                                          *
*             U        |         |                                          *
*             T    th _|. . . . .|                                          *
*             P        |        /.                                          *
*             U        |      /  .                                          *
*             T        |    /    .                                          *
*                      |  /      .                                          *
*                    0_|/________.__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2thr,     *
*       and IMG_thr_le2min for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The input and output buffers must be word aligned.                  *
*                                                                           *
*       The total number of pixels rows*cols must be at least               *
*       16 and a multiple of 16.                                            *
*                                                                           *
*       Stack is aligned to a double-word boundary.                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       For performance, the code outside the loop has been interleaved as  *
*       much as possible with the prolog and epilog code of the loops.      *
*                                                                           *
*       Twin stack-pointers are used to accelerate stack acceses.           *
*                                                                           *
*       The inner loop is unrolled 16 times and the data is maniuplated     *
*       in packed format for speed.                                         *
*                                                                           *
*   MEMORY NOTE                                                             *
*       At most, two bank conflicts occur during the setup code.  No        *
*       bank conflicts occur in the loop, regardless of the pointer         *
*       alignment.  (The bank conflicts in the setup code will not occur    *
*       if the stack and the input arrays are both double-word aligned.)    *
*                                                                           *
*       The code requires 8 words of stack space to save Save-On-Entry      *
*       registers.                                                          *
*                                                                           *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   NOTES                                                                   *
*       This routine is fully interruptible.                                *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 24 + 9 * (cols * rows / 16)                                *
*                                                                           *
*       For cols =  64 and rows = 8,  cycles = 312.                         *
*       For cols =  32 and rows = 32, cycles = 600.                         *
*       For cols = 640 and rows = 8,  cycles = 2904.                        *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       512 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_thr_gt2max"
        .global _IMG_thr_gt2max
_IMG_thr_gt2max:
; ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== ;
        .asg         B4,     B_op           ; Output pointer
        .asg         A1,     A_op           ; Output pointer (twin)
        .asg         A4,     A_ip           ; Input pointer
        .asg         B12,    B_ip           ; Input pointer (twin)

        .asg         A6,     A_w            ; Image width
        .asg         B6,     B_h            ; Image height
        .asg         A2,     A_i            ; Loop counter
        .asg         B0,     B_p            ; Prolog collapse counter

        .asg         A8,     A_th           ; Threshold value
        .asg         A7,     A_th_          ; Threshold value << 16
        .asg         A8,     A_thth         ; Threshold value, replicated
        .asg         B10,    B_thth         ; Threshold value, repl. (twin)

        .asg         B15,    B_SP           ; Stack pointer
        .asg         A3,     A_SP           ; Stack pointer (twin)
        .asg         B3,     B_ret          ; Return address


        .asg         A0,     A_MF0F0        ; Odd byte mask
        .asg         B8,     B_M0F0F        ; Even byte mask

        .asg         B13,    B_HGFE         ; Incoming pixels 15..12
        .asg         B11,    B_DCBA         ; Incoming pixels 11.. 8
        .asg         A12,    A_HGFE         ; Incoming pixels  7.. 4
        .asg         A10,    A_DCBA         ; Incoming pixels  3.. 0

        .asg         B7,     B_HGFE_        ; Copy B_HGFE (live too long)
        .asg         B9,     B_DCBA_        ; Copy B_DCBA (live too long)
        .asg         A9,     A_HGFE_        ; Copy A_HGFE (live too long)
        .asg         A7,     A_DCBA_        ; Copy A_DCBA (live too long)

        .asg         B5,     B_H0F0         ; Pixels   15, 13
        .asg         B1,     B_0H0F         ; Pixels   15, 13 (>> 8)
        .asg         B1,     B_0G0E         ; Pixels   14, 12
        .asg         B3,     B_D0B0         ; Pixels   11,  9
        .asg         B3,     B_0D0B         ; Pixels   11,  9 (>> 8)
        .asg         B3,     B_0C0A         ; Pixels   10,  8
        .asg         A5,     A_H0F0         ; Pixels    7,  5
        .asg         A5,     A_0H0F         ; Pixels    7,  5 (>> 8)
        .asg         A5,     A_0G0E         ; Pixels    6,  4
        .asg         A6,     A_D0B0         ; Pixels    3,  1
        .asg         A5,     A_0D0B         ; Pixels    3,  1 (>> 8)
        .asg         A11,    A_0C0A         ; Pixels    2,  0

        .asg         B1,     B_HMXFMX       ; Partial mask for 15, 13
        .asg         B3,     B_GMXEMX       ; Partial mask for 14, 12
        .asg         B2,     B_XGMXEM       ; Partial mask for 14, 12 (>> 8)
        .asg         B6,     B_DMXBMX       ; Partial mask for 11,  9
        .asg         B1,     B_CMXAMX       ; Partial mask for 10,  8
        .asg         B2,     B_XCMXAM       ; Partial mask for 10,  8 (>> 8)
        .asg         A3,     A_HMXFMX       ; Partial mask for  7,  5
        .asg         A11,    A_GMXEMX       ; Partial mask for  6,  4
        .asg         A6,     A_XGMXEM       ; Partial mask for  6,  4 (>> 8)
        .asg         A5,     A_CMXAMX       ; Partial mask for  3,  1
        .asg         A3,     A_DMXBMX       ; Partial mask for  2,  0
        .asg         A5,     A_XCMXAM       ; Partial mask for  2,  0 (>> 8)

        .asg         B6,     B_HM0FM0       ; Final mask for 15, 13
        .asg         B5,     B_0GM0EM       ; Final mask for 14, 12
        .asg         B5,     B_DM0BM0       ; Final mask for 11,  9
        .asg         B2,     B_0CM0AM       ; Final mask for 10,  8
        .asg         A5,     A_HM0FM0       ; Final mask for  7,  5
        .asg         A3,     A_0GM0EM       ; Final mask for  6,  4
        .asg         A3,     A_DM0BM0       ; Final mask for  3,  1
        .asg         A6,     A_0CM0AM       ; Final mask for  2,  0

        .asg         B3,     B_HMGMFMEM     ; Merged mask for 15..12
        .asg         B5,     B_DMCMBMAM     ; Merged mask for 11.. 8
        .asg         A3,     A_HMGMFMEM     ; Merged mask for  7.. 4
        .asg         A3,     A_DMCMBMAM     ; Merged mask for  3.. 0

        .asg         B1,     B_HGFEout      ; Masked pixels 15..12
        .asg         B5,     B_DCBAout      ; Masked pixels 11.. 8
        .asg         A3,     A_HGFEout      ; Masked pixels  7.. 4
        .asg         A7,     A_DCBAout      ; Masked pixels  3.. 0
* ========================================================================= *
*   Initialization code and Stack Management                                *
*                                                                           *
*   This code is responsible for saving registers to the stack and setting  *
*   up values and pointers that will be used through out the kernel.        *
*                                                                           *
*   This function requires 8 words of stack.  A10...A12, B10...B13, and     *
*   the return address are saved.  The code uses twin stack pointers for    *
*   speed.                                                                  *
*                                                                           *
*   This program is fully interruptible, and therefore CSR is not touched.  *
* ============================ PIPE LOOP PROLOG =========================== *
        STW   .D2T2  B13,        *B_SP--[8]            ; B13 ==> +SP[8]
||      MV    .L1X   B_SP,       A_SP                  ; Twin stack ptr
||      SHL   .S1    A_th,       16,        A_th_      ; Replicate 'th'
                                                       ;  in both halves

        MVKL  .S2    0x00FF00FF, B_M0F0F               ; Even byte mask (lo)
||      ADD   .L1X   B_op,       4,         A_op       ; Twin 'op' ptr
||      STW   .D2T1  A12,        *+B_SP[2]             ; A12 ==> +SP[2]
||      ADD   .S1    A_th_,      A_th,      A_thth     ; Finish rep. 'th'
||      LDW   .D1T2  *+A_ip[3],  B_HGFE                ;[ 1,1] Get pix(15..12)
;-
        STW   .D2T2  B12,        *+B_SP[1]             ; B12 ==> +SP[1]
||      LDW   .D1T1  *+A_ip[2],  A_HGFE                ;[ 2,1] Get pix(7..4)

        MVKL  .S1    0xFF00FF00, A_MF0F0               ; Odd byte mask (lo)
||      ADD   .L2X   A_ip,       4,         B_ip       ; Twin 'ip' ptr
||      STW   .D2T2  B11,        *+B_SP[3]             ; B11 ==> +SP[3]
||      STW   .D1T1  A11,        *-A_SP[4]             ; A11 ==> +SP[4]

        STW   .D2T2  B10,        *+B_SP[5]             ; B10 ==> +SP[5]
||      STW   .D1T1  A10,        *-A_SP[2]             ; A10 ==> +SP[6]
;-
        LDW   .D2T2  *B_ip++[4], B_DCBA                ;[ 5,1] Get pix(11..8)
||      MV    .L2X   A_thth,     B_thth                ; Twin threshold
||      MVKH  .S1    0xFF00FF00, A_MF0F0               ; Odd byte mask (hi)
||      MVKH  .S2    0x00FF00FF, B_M0F0F               ; Even byte mask (hi)
||      MPY   .M1X   A_w,        B_h,       A_i        ; Init trip counter

        STW   .D1T2  B_ret,      *-A_SP[1]             ; Ret Addr ==> +SP[7]
||      MV    .S2    B_M0F0F,    B_p                   ; prolog collapse
||      AND   .L2    B_HGFE,     B_M0F0F,   B_0G0E     ;[ 6,1] Get pix(14,12)
;-
; ============================ PIPE LOOP KERNEL =========================== ;
loop:
        OR    .L1    A_HMGMFMEM, A_HGFE_,   A_HGFEout  ;[16,1] Use msk(7..4)
||      ADD   .D2    B_HM0FM0,   B_0GM0EM,  B_HMGMFMEM ;[16,1] Merge masks
||      AND   .L2    B_XCMXAM,   B_M0F0F,   B_0CM0AM   ;[16,1] Fix msk(10,8)
||      SHRU  .S1    A_CMXAMX,   8,         A_XCMXAM   ;[16,1] >>8 msk(2,0)
||      SUB2  .S2    B_thth,     B_0D0B,    B_DMXBMX   ;[16,1] pix(11,9) < th
||[ A_i]LDW   .D1T1  *A_ip++[4], A_DCBA                ;[ 7,2] Get pix(3..0)

        OR    .L2    B_HMGMFMEM, B_HGFE_,   B_HGFEout  ;[17,1] Use msk(15..12)
||      AND   .L1X   A_XCMXAM,   B_M0F0F,   A_0CM0AM   ;[17,1] Fix msk(2,0)
||      SHRU  .S1    A_D0B0,     8,         A_0D0B     ;[17,1] >>8 pix(3,1)
||      SUB2  .S2    B_thth,     B_0G0E,    B_GMXEMX   ;[ 8,2] pix(14,12) < th
||      SUB   .D2    B_HGFE,     B_0G0E,    B_H0F0     ;[ 8,2] Get pix(15,13)
||[ A_i]SUB   .D1    A_i,        16,        A_i        ;[10,2] i -= 16

  [!B_p]STW   .D1T2  B_HGFEout,  *+A_op[2]             ;[18,1] Pux pix(15..12)
||[!B_p]STW   .D2T1  A_HGFEout,  *+B_op[2]             ;[18,1] Put pix(7..4)
||      AND   .L2X   B_DMXBMX,   A_MF0F0,   B_DM0BM0   ;[18,1] Fix msk(11,9)
||      SUB2  .S1    A_thth,     A_0D0B,    A_DMXBMX   ;[18,1] pix(3,1) < th
||      SHRU  .S2    B_H0F0,     8,         B_0H0F     ;[ 9,2] >>8 pix(15,13)
||      AND   .L1X   A_HGFE,     B_M0F0F,   A_0G0E     ;[ 9,2] Get pix(6,4)

  [ A_i]B     .S2    loop                              ;[19,1] while (i)
||      MV    .D1    A_HGFE,     A_HGFE_               ;[ 8,2] live-too-long
||      SUB2  .S1    A_thth,     A_0G0E,    A_GMXEMX   ;[10,2] pix(6,4) < th
||      SUB   .L1    A_HGFE,     A_0G0E,    A_H0F0     ;[10,2] Get pix(7,5)
||      MV    .L2    B_HGFE,     B_HGFE_               ;[10,2] live-too-long
||[ A_i]LDW   .D2T2  *+B_ip[2],  B_HGFE                ;[ 1,3] Get pix(15..12)

        ADD   .D2    B_DM0BM0,   B_0CM0AM,  B_DMCMBMAM ;[20,1] Merge masks
||      AND   .L1    A_DMXBMX,   A_MF0F0,   A_DM0BM0   ;[20,1] Fix msk(3,1)
||      SHRU  .S2    B_GMXEMX,   8,         B_XGMXEM   ;[11,2] >>8 msk(14,12)
||      SHRU  .S1    A_H0F0,     8,         A_0H0F     ;[11,2] >>8 pix(7,5)
||      AND   .L2    B_DCBA,     B_M0F0F,   B_0C0A     ;[11,2] Get pix(10,8)
||[ A_i]LDW   .D1T1  *+A_ip[2],  A_HGFE                ;[ 2,3] Get pix(7..4)

        OR    .L2    B_DMCMBMAM, B_DCBA_,   B_DCBAout  ;[21,1] Use msk(11,8)
||      ADD   .D1    A_DM0BM0,   A_0CM0AM,  A_DMCMBMAM ;[21,1] Merge masks
||      SHRU  .S1    A_GMXEMX,   8,         A_XGMXEM   ;[12,2] >>8 msk(6,4)
||      SUB2  .S2    B_thth,     B_0H0F,    B_HMXFMX   ;[12,2] pix(15,13)<th
||      AND   .L1X   A_DCBA,     B_M0F0F,   A_0C0A     ;[12,2] Get pix(2,0)
||      MV    .D2    B_DCBA,     B_DCBA_               ;[12,2] live-too-long

  [!B_p]STW   .D1T2  B_DCBAout,  *A_op++[4]            ;[22,1] Put pix(11..8)
||      OR    .L1    A_DMCMBMAM, A_DCBA_,   A_DCBAout  ;[22,1] Use msk(3..0)
||      AND   .L2X   B_HMXFMX,   A_MF0F0,   B_HM0FM0   ;[13,2] Fix msk(15,13)
||      SUB2  .S1    A_thth,     A_0H0F,    A_HMXFMX   ;[13,2] pix(7,5)<th
||      SUB2  .S2    B_thth,     B_0C0A,    B_CMXAMX   ;[13,2] pix(10,8)<th
||      SUB   .D2    B_DCBA,     B_0C0A,    B_D0B0     ;[13,2] Get pix(11,9)

        AND   .S1    A_HMXFMX,   A_MF0F0,   A_HM0FM0   ;[14,2] Fix msk(7,5)
||      AND   .L2    B_XGMXEM,   B_M0F0F,   B_0GM0EM   ;[14,2] Fix msk(14,12)
||      AND   .L1X   A_XGMXEM,   B_M0F0F,   A_0GM0EM   ;[14,2] Fix msk(6,4)
||      SHRU  .S2    B_D0B0,     8,         B_0D0B     ;[14,2] >>8 pix(11,9)
||      SUB   .D1    A_DCBA,     A_0C0A,    A_D0B0     ;[14,2] Get pix(3,1)
||[ A_i]LDW   .D2T2  *B_ip++[4], B_DCBA                ;[ 5,3] Get pix(11..8)
||[ B_p]MPY   .M2    B_p,        0,         B_p        ; prolog collapse

  [!B_p]STW   .D2T1  A_DCBAout,  *B_op++[4]            ;[24,1] Put pix(3..0)
||      ADD   .L1    A_HM0FM0,   A_0GM0EM,  A_HMGMFMEM ;[15,2] Merge masks
||      SHRU  .S2    B_CMXAMX,   8,         B_XCMXAM   ;[15,2] >>8 msk(10,8)
||      SUB2  .S1    A_thth,     A_0C0A,    A_CMXAMX   ;[15,2] pix(3,1) < th
||      MV    .D1    A_DCBA,     A_DCBA_               ;[15,2] live-too-long
||      AND   .L2    B_HGFE,     B_M0F0F,   B_0G0E     ;[ 6,3] Get pix(14,12)

* ============================ PIPE LOOP EPILOG =========================== *
*   Epilog / Final Cleanup Code.                                            *
*                                                                           *
*   One stage of the epilog have been collapsed.                            *
*                                                                           *
*   This code performs the final stores from the epilog while restoring     *
*   Save-On-Entry values from the stack.                                    *
* ==================== SYMBOLIC REGISTER REASSIGNMENTS ==================== *
        .asg         A2,         A_SP                  ; Twin stack pointer
        .asg         B0,         B_ret                 ; Return address
        .asg         B6,         B_HMGMFMEM            ; Masked pixels
* ========================================================================= *

        LDW   .D2T2  *+B_SP[7],  B_ret                 ; +SP[7] ==> B_ret
||      MV    .L1X   B_SP,       A_SP                  ; Twin stack ptr
;-
        LDW   .D2T2  *+B_SP[1],  B12                   ; +SP[1] ==> B12
||      LDW   .D1T1  *+A_SP[2],  A12                   ; +SP[2] ==> A12

        LDW   .D2T2  *+B_SP[3],  B11                   ; +SP[3] ==> B11
||      LDW   .D1T1  *+A_SP[4],  A11                   ; +SP[4] ==> A11

        OR    .L1    A_HMGMFMEM, A_HGFE_,   A_HGFEout  ;[16,3] Use msk(7..4)
||      ADD   .D2    B_HM0FM0,   B_0GM0EM,  B_HMGMFMEM ;[16,3] Merge masks
||      AND   .L2    B_XCMXAM,   B_M0F0F,   B_0CM0AM   ;[16,3] Fix msk(10,8)
||      SHRU  .S1    A_CMXAMX,   8,         A_XCMXAM   ;[16,3] >>8 msk(2,0)
;-
        OR    .L2    B_HMGMFMEM, B_HGFE_,   B_HGFEout  ;[17,3] Use msk(15..12)
||      AND   .L1X   A_XCMXAM,   B_M0F0F,   A_0CM0AM   ;[17,3] Fix msk(2,0)
||      SHRU  .S1    A_D0B0,     8,         A_0D0B     ;[17,3] >>8 pix(3,1)
||      SUB2  .S2    B_thth,     B_0D0B,    B_DMXBMX   ;[16,3] pix(11,9) < th
||      LDW   .D2T2  *+B_SP[5],  B10                   ; +SP[5] ==> B10
||      LDW   .D1T1  *+A_SP[6],  A10                   ; +SP[6] ==> A10
;-
        STW   .D1T2  B_HGFEout,  *+A_op[2]             ;[18,3] Pux pix(15..12)
||      STW   .D2T1  A_HGFEout,  *+B_op[2]             ;[18,3] Put pix(7..4)
||      AND   .L2X   B_DMXBMX,   A_MF0F0,   B_DM0BM0   ;[18,3] Fix msk(11,9)
||      RET   .S2    B_ret                             ; Return to caller

        ADD   .L2    B_DM0BM0,   B_0CM0AM,  B_DMCMBMAM ;[20,3] Merge masks
||      SUB2  .S1    A_thth,     A_0D0B,    A_DMXBMX   ;[18,3] pix(3,1) < th
||      LDW   .D2T2  *++B_SP[8], B13                   ; +SP[8] ==> B13

        AND   .L1    A_DMXBMX,   A_MF0F0,   A_DM0BM0   ;[20,3] Fix msk(3,1)
;-
        OR    .L2    B_DMCMBMAM, B_DCBA_,   B_DCBAout  ;[21,3] Use msk(11,8)
||      ADD   .L1    A_DM0BM0,   A_0CM0AM,  A_DMCMBMAM ;[21,3] Merge masks

        STW   .D1T2  B_DCBAout,  *A_op                 ;[22,3] Put pix(11..8)
||      OR    .L1    A_DMCMBMAM, A_DCBA_,   A_DCBAout  ;[22,3] Use msk(3..0)

        STW   .D2T1  A_DCBAout,  *B_op                 ;[24,3] Put pix(3..0)

* ========================================================================= *
*   End of file:  img_thr_gt2max.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
thr_gt2thr.asm/ 1066929162  0     0     0       14927     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Sun Sep 29 03:31:30 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_thr_gt2thr                                                      *
*                                                                           *
*   REVISION DATE                                                           *
*       14-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_gt2thr                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     //  Input image data  //      *
*           unsigned char *restrict out_data, //  Output image data //      *
*           short cols, short rows,           //  Image dimensions  //      *
*           unsigned char       threshold     //  Threshold value   //      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are greater than the threshold      *
*       are set to the threshold value in the output image.                 *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|                                                    *
*                      |                                                    *
*                      |                                                    *
*             O        |                                                    *
*             U        |                                                    *
*             T    th _|. . . . . _________                                 *
*             P        |        /.                                          *
*             U        |      /  .                                          *
*             T        |    /    .                                          *
*                      |  /      .                                          *
*                    0_|/________.__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_le2thr, IMG_thr_le2min      *
*       and IMG_thr_gt2max for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The value rows*cols must be a multiple of 4 pixels, and at least    *
*       4 pixels long.                                                      *
*                                                                           *
*   NOTES                                                                   *
*       This kernel is interrupt tolerant, but not interruptible.           *
*       Interrupts are blocked for the entire duration of the kernel by     *
*       branch delay slots.                                                 *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       No bank conflicts occur, regardless of the relative alignment of    *
*       in_data[] and out_data[].                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = rows * cols + 20.                                          *
*       For rows = 32 and cols = 32, cycles = 1042.                         *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       192 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_thr_gt2thr"
        .global _IMG_thr_gt2thr
_IMG_thr_gt2thr:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_i_ptr
        .asg            B4,         B_o_ptr
        .asg            A6,         A_rows
        .asg            B6,         B_cols
        .asg            A8,         A_th
        .asg            B3,         B_ret_addr

        .asg            B5,         B_i_ptr
        .asg            B9,         B_p3
        .asg            B9,         B_p2
        .asg            A6,         A_p1
        .asg            A6,         A_p0
        .asg            B8,         B_th
        .asg            B1,         B_c3
        .asg            B1,         B_c2
        .asg            A1,         A_c1
        .asg            A1,         A_c0
        .asg            B7,         B_t3
        .asg            B6,         B_t2
        .asg            A7,         A_t1
        .asg            A5,         A_t0
        .asg            A2,         A_pc
        .asg            A3,         A_o_ptr
        .asg            B0,         B_i
* ========================================================================= *
        MPY             A_rows,     B_cols,     B_i

        ADD             A_i_ptr,    2,          B_i_ptr
||      MVK     .S1     1,          A_pc

        SHR             B_i,        2,          B_i
* =========================== PIPE LOOP PROLOG ============================ *
        LDBU    .D1T1   *A_i_ptr[1],            A_p1            ;[ 1,1]
||      LDBU    .D2T2   *B_i_ptr[1],            B_p3            ;[ 1,1]
||[ B_i]SUB             B_i,        1,          B_i

  [ B_i]B       .S1     loop                                    ;[ 6,1]
;-
        LDBU    .D1T1   *A_i_ptr++[4],          A_p0            ;[ 3,1]
||      LDBU    .D2T2   *B_i_ptr++[4],          B_p2            ;[ 3,1]
||      MV              A_th,       B_th
; ===== 1 prolog stage collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!A_pc]STB    .D2T1   A_t1,       *B_o_ptr[1]                 ;[ 8,1]
||[!A_pc]STB    .D1T2   B_t3,       *A_o_ptr[1]                 ;[ 8,1]
||      CMPGTU  .L1     A_p0,       A_th,       A_c0            ;[ 8,1]
||      CMPGTU  .L2     B_p2,       B_th,       B_c2            ;[ 8,1]
||      MPY     .M1     A_th,       1,          A_t1            ;[ 4,2]
;-
  [!A_c0]MV     .L1     A_p0,       A_t0                        ;[ 9,1]
||[!B_c2]MV     .S2     B_p2,       B_t2                        ;[ 9,1]
||      MPY     .M1     A_th,       1,          A_t0            ;[ 5,2]
||      MPY     .M2     A_th,       1,          B_t3            ;[ 5,2]
||      LDBU    .D1T1   *A_i_ptr[1],            A_p1            ;[ 1,3]
||      LDBU    .D2T2   *B_i_ptr[1],            B_p3            ;[ 1,3]
||[ B_i]SUB     .L2     B_i,        1,          B_i             ;[ 1,3]
||[ A_pc]ADD    .S1X    B_o_ptr,    2,          A_o_ptr
;-
  [!A_pc]STB    .D2T1   A_t0,       *B_o_ptr++[4]               ;[10,1]
||[!A_pc]STB    .D1T2   B_t2,       *A_o_ptr++[4]               ;[10,1]
||[ B_i]B       .S1     loop                                    ;[ 6,2]
||      MPY     .M2     B_th,       1,          B_t2            ;[ 6,2]
||      CMPGTU  .L1     A_p1,       A_th,       A_c1            ;[ 6,2]
||      CMPGTU  .L2     B_p3,       B_th,       B_c3            ;[ 6,2]
;-
  [ A_pc]SUB    .L1     A_pc,       1,          A_pc            ;[ 7,2]
||[!A_c1]MV     .S1     A_p1,       A_t1                        ;[ 7,2]
||[!B_c3]MV     .L2     B_p3,       B_t3                        ;[ 7,2]
||      LDBU    .D1T1   *A_i_ptr++[4],          A_p0            ;[ 3,3]
||      LDBU    .D2T2   *B_i_ptr++[4],          B_p2            ;[ 3,3]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 1 epilog stage collapsed
        CMPGTU  .L1     A_p0,       A_th,       A_c0            ;[ 8,3]
||      CMPGTU  .L2     B_p2,       B_th,       B_c2            ;[ 8,3]
||      RET     .S2     B_ret_addr
;-
  [!A_c0]MV     .L1     A_p0,       A_t0                        ;[ 9,3]
||[!B_c2]MV     .S2     B_p2,       B_t2                        ;[ 9,3]
||[!A_pc]STB    .D2T1   A_t1,       *B_o_ptr[1]                 ;[ 8,3]
||[!A_pc]STB    .D1T2   B_t3,       *A_o_ptr[1]                 ;[ 8,3]

  [!A_pc]STB    .D2T1   A_t0,       *B_o_ptr                    ;[10,3]
||[!A_pc]STB    .D1T2   B_t2,       *A_o_ptr                    ;[10,3]

         NOP            3

* ========================================================================= *
*   End of file:  img_thr_gt2thr.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

thr_le2min.asm/ 1066929162  0     0     0       26921     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.12    Sun Sep 29 03:31:30 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       threshold                                                           *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       25-Jun-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_le2min                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     //  Input image data  //      *
*           unsigned char *restrict out_data, //  Output image data //      *
*           short cols, short rows,           //  Image dimensions  //      *
*           unsigned char       threshold     //  Threshold value   //      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are less than or equal to the       *
*       threshold are set to 0 in the output image.                         *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|                                                    *
*                      |                  /                                 *
*                      |                /                                   *
*             O        |              /                                     *
*             U        |            /                                       *
*             T    th _|. . . . . /                                         *
*             P        |         |                                          *
*             U        |         |                                          *
*             T        |         |                                          *
*                      |         |                                          *
*                    0_|_________|__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2thr,     *
*       and IMG_thr_gt2max for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The input and output buffers must be word aligned.                  *
*                                                                           *
*       The total number of pixels rows*cols must be at least               *
*       16 and a multiple of 16.                                            *
*                                                                           *
*       Stack is aligned to a double-word boundary.                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       For performance, the code outside the loop has been interleaved as  *
*       much as possible with the prolog and epilog code of the loops.      *
*                                                                           *
*       Twin stack-pointers are used to accelerate stack acceses.           *
*                                                                           *
*       The inner loop is unrolled 16 times and the data is maniuplated     *
*       in packed format for speed.                                         *
*                                                                           *
*   MEMORY NOTE                                                             *
*       At most, two bank conflicts occur during the setup code.  No        *
*       bank conflicts occur in the loop, regardless of the pointer         *
*       alignment.  (The bank conflicts in the setup code will not occur    *
*       if the stack and the input arrays are both double-word aligned.)    *
*                                                                           *
*       The code requires 8 words of stack space to save Save-On-Entry      *
*       registers.                                                          *
*                                                                           *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   NOTES                                                                   *
*       This routine is fully interruptible.                                *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 24 + 9 * (cols * rows / 16)                                *
*                                                                           *
*       For cols =  64 and rows = 8,  cycles = 312.                         *
*       For cols =  32 and rows = 32, cycles = 600.                         *
*       For cols = 640 and rows = 8,  cycles = 2904.                        *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       512 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_thr_le2min"
        .global _IMG_thr_le2min
_IMG_thr_le2min:
; ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== ;
        .asg         B4,     B_op           ; Output pointer
        .asg         A1,     A_op           ; Output pointer (twin)
        .asg         A4,     A_ip           ; Input pointer
        .asg         B12,    B_ip           ; Input pointer (twin)

        .asg         A6,     A_w            ; Image width
        .asg         B6,     B_h            ; Image height
        .asg         A2,     A_i            ; Loop counter
        .asg         B0,     B_p            ; Prolog collapse counter

        .asg         A8,     A_th           ; Threshold value
        .asg         A7,     A_th_          ; Threshold value << 16
        .asg         A8,     A_thth         ; Threshold value, replicated
        .asg         B10,    B_thth         ; Threshold value, repl. (twin)

        .asg         B15,    B_SP           ; Stack pointer
        .asg         A3,     A_SP           ; Stack pointer (twin)
        .asg         B3,     B_ret          ; Return address


        .asg         A0,     A_MF0F0        ; Odd byte mask
        .asg         B8,     B_M0F0F        ; Even byte mask

        .asg         B13,    B_HGFE         ; Incoming pixels 15..12
        .asg         B11,    B_DCBA         ; Incoming pixels 11.. 8
        .asg         A12,    A_HGFE         ; Incoming pixels  7.. 4
        .asg         A10,    A_DCBA         ; Incoming pixels  3.. 0

        .asg         B7,     B_HGFE_        ; Copy B_HGFE (live too long)
        .asg         B9,     B_DCBA_        ; Copy B_DCBA (live too long)
        .asg         A9,     A_HGFE_        ; Copy A_HGFE (live too long)
        .asg         A7,     A_DCBA_        ; Copy A_DCBA (live too long)

        .asg         B5,     B_H0F0         ; Pixels   15, 13
        .asg         B1,     B_0H0F         ; Pixels   15, 13 (>> 8)
        .asg         B1,     B_0G0E         ; Pixels   14, 12
        .asg         B3,     B_D0B0         ; Pixels   11,  9
        .asg         B3,     B_0D0B         ; Pixels   11,  9 (>> 8)
        .asg         B3,     B_0C0A         ; Pixels   10,  8
        .asg         A5,     A_H0F0         ; Pixels    7,  5
        .asg         A5,     A_0H0F         ; Pixels    7,  5 (>> 8)
        .asg         A5,     A_0G0E         ; Pixels    6,  4
        .asg         A6,     A_D0B0         ; Pixels    3,  1
        .asg         A5,     A_0D0B         ; Pixels    3,  1 (>> 8)
        .asg         A11,    A_0C0A         ; Pixels    2,  0

        .asg         B1,     B_HMXFMX       ; Partial mask for 15, 13
        .asg         B3,     B_GMXEMX       ; Partial mask for 14, 12
        .asg         B2,     B_XGMXEM       ; Partial mask for 14, 12 (>> 8)
        .asg         B6,     B_DMXBMX       ; Partial mask for 11,  9
        .asg         B1,     B_CMXAMX       ; Partial mask for 10,  8
        .asg         B2,     B_XCMXAM       ; Partial mask for 10,  8 (>> 8)
        .asg         A3,     A_HMXFMX       ; Partial mask for  7,  5
        .asg         A11,    A_GMXEMX       ; Partial mask for  6,  4
        .asg         A6,     A_XGMXEM       ; Partial mask for  6,  4 (>> 8)
        .asg         A5,     A_CMXAMX       ; Partial mask for  3,  1
        .asg         A3,     A_DMXBMX       ; Partial mask for  2,  0
        .asg         A5,     A_XCMXAM       ; Partial mask for  2,  0 (>> 8)

        .asg         B6,     B_HM0FM0       ; Final mask for 15, 13
        .asg         B5,     B_0GM0EM       ; Final mask for 14, 12
        .asg         B5,     B_DM0BM0       ; Final mask for 11,  9
        .asg         B2,     B_0CM0AM       ; Final mask for 10,  8
        .asg         A5,     A_HM0FM0       ; Final mask for  7,  5
        .asg         A3,     A_0GM0EM       ; Final mask for  6,  4
        .asg         A3,     A_DM0BM0       ; Final mask for  3,  1
        .asg         A6,     A_0CM0AM       ; Final mask for  2,  0

        .asg         B3,     B_HMGMFMEM     ; Merged mask for 15..12
        .asg         B5,     B_DMCMBMAM     ; Merged mask for 11.. 8
        .asg         A3,     A_HMGMFMEM     ; Merged mask for  7.. 4
        .asg         A3,     A_DMCMBMAM     ; Merged mask for  3.. 0

        .asg         B1,     B_HGFEout      ; Masked pixels 15..12
        .asg         B5,     B_DCBAout      ; Masked pixels 11.. 8
        .asg         A3,     A_HGFEout      ; Masked pixels  7.. 4
        .asg         A7,     A_DCBAout      ; Masked pixels  3.. 0
* ========================================================================= *
*   Initialization code and Stack Management                                *
*                                                                           *
*   This code is responsible for saving registers to the stack and setting  *
*   up values and pointers that will be used through out the kernel.        *
*                                                                           *
*   This function requires 8 words of stack.  A10...A12, B10...B13, and     *
*   the return address are saved.  The code uses twin stack pointers for    *
*   speed.                                                                  *
*                                                                           *
*   This program is fully interruptible, and therefore CSR is not touched.  *
* ============================ PIPE LOOP PROLOG =========================== *
        STW   .D2T2  B13,        *B_SP--[8]            ; B13 ==> +SP[8]
||      MV    .L1X   B_SP,       A_SP                  ; Twin stack ptr
||      SHL   .S1    A_th,       16,        A_th_      ; Replicate 'th'
                                                       ;  in both halves

        MVKL  .S2    0x00FF00FF, B_M0F0F               ; Even byte mask (lo)
||      ADD   .L1X   B_op,       4,         A_op       ; Twin 'op' ptr
||      STW   .D2T1  A12,        *+B_SP[2]             ; A12 ==> +SP[2]
||      ADD   .S1    A_th_,      A_th,      A_thth     ; Finish rep. 'th'
||      LDW   .D1T2  *+A_ip[3],  B_HGFE                ;[ 1,1] Get pix(15..12)
;-
        STW   .D2T2  B12,        *+B_SP[1]             ; B12 ==> +SP[1]
||      LDW   .D1T1  *+A_ip[2],  A_HGFE                ;[ 2,1] Get pix(7..4)

        MVKL  .S1    0xFF00FF00, A_MF0F0               ; Odd byte mask (lo)
||      ADD   .L2X   A_ip,       4,         B_ip       ; Twin 'ip' ptr
||      STW   .D2T2  B11,        *+B_SP[3]             ; B11 ==> +SP[3]
||      STW   .D1T1  A11,        *-A_SP[4]             ; A11 ==> +SP[4]

        STW   .D2T2  B10,        *+B_SP[5]             ; B10 ==> +SP[5]
||      STW   .D1T1  A10,        *-A_SP[2]             ; A10 ==> +SP[6]
;-
        LDW   .D2T2  *B_ip++[4], B_DCBA                ;[ 5,1] Get pix(11..8)
||      MV    .L2X   A_thth,     B_thth                ; Twin threshold
||      MVKH  .S1    0xFF00FF00, A_MF0F0               ; Odd byte mask (hi)
||      MVKH  .S2    0x00FF00FF, B_M0F0F               ; Even byte mask (hi)
||      MPY   .M1X   A_w,        B_h,       A_i        ; Init trip counter

        STW   .D1T2  B_ret,      *-A_SP[1]             ; Ret Addr ==> +SP[7]
||      MV    .S2    B_M0F0F,    B_p                   ; prolog collapse
||      AND   .L2    B_HGFE,     B_M0F0F,   B_0G0E     ;[ 6,1] Get pix(14,12)
;-
; ============================ PIPE LOOP KERNEL =========================== ;
loop:
        AND   .L1    A_HMGMFMEM, A_HGFE_,   A_HGFEout  ;[16,1] Use msk(7..4)
||      ADD   .D2    B_HM0FM0,   B_0GM0EM,  B_HMGMFMEM ;[16,1] Merge masks
||      AND   .L2    B_XCMXAM,   B_M0F0F,   B_0CM0AM   ;[16,1] Fix msk(10,8)
||      SHRU  .S1    A_CMXAMX,   8,         A_XCMXAM   ;[16,1] >>8 msk(2,0)
||      SUB2  .S2    B_thth,     B_0D0B,    B_DMXBMX   ;[16,1] pix(11,9) < th
||[ A_i]LDW   .D1T1  *A_ip++[4], A_DCBA                ;[ 7,2] Get pix(3..0)

        AND   .L2    B_HMGMFMEM, B_HGFE_,   B_HGFEout  ;[17,1] Use msk(15..12)
||      AND   .L1X   A_XCMXAM,   B_M0F0F,   A_0CM0AM   ;[17,1] Fix msk(2,0)
||      SHRU  .S1    A_D0B0,     8,         A_0D0B     ;[17,1] >>8 pix(3,1)
||      SUB2  .S2    B_thth,     B_0G0E,    B_GMXEMX   ;[ 8,2] pix(14,12) < th
||      SUB   .D2    B_HGFE,     B_0G0E,    B_H0F0     ;[ 8,2] Get pix(15,13)
||[ A_i]SUB   .D1    A_i,        16,        A_i        ;[10,2] i -= 16

  [!B_p]STW   .D1T2  B_HGFEout,  *+A_op[2]             ;[18,1] Pux pix(15..12)
||[!B_p]STW   .D2T1  A_HGFEout,  *+B_op[2]             ;[18,1] Put pix(7..4)
||      AND   .L2X   B_DMXBMX,   A_MF0F0,   B_DM0BM0   ;[18,1] Fix msk(11,9)
||      SUB2  .S1    A_thth,     A_0D0B,    A_DMXBMX   ;[18,1] pix(3,1) < th
||      SHRU  .S2    B_H0F0,     8,         B_0H0F     ;[ 9,2] >>8 pix(15,13)
||      AND   .L1X   A_HGFE,     B_M0F0F,   A_0G0E     ;[ 9,2] Get pix(6,4)

  [ A_i]B     .S2    loop                              ;[19,1] while (i)
||      MV    .D1    A_HGFE,     A_HGFE_               ;[ 8,2] live-too-long
||      SUB2  .S1    A_thth,     A_0G0E,    A_GMXEMX   ;[10,2] pix(6,4) < th
||      SUB   .L1    A_HGFE,     A_0G0E,    A_H0F0     ;[10,2] Get pix(7,5)
||      MV    .L2    B_HGFE,     B_HGFE_               ;[10,2] live-too-long
||[ A_i]LDW   .D2T2  *+B_ip[2],  B_HGFE                ;[ 1,3] Get pix(15..12)

        ADD   .D2    B_DM0BM0,   B_0CM0AM,  B_DMCMBMAM ;[20,1] Merge masks
||      AND   .L1    A_DMXBMX,   A_MF0F0,   A_DM0BM0   ;[20,1] Fix msk(3,1)
||      SHRU  .S2    B_GMXEMX,   8,         B_XGMXEM   ;[11,2] >>8 msk(14,12)
||      SHRU  .S1    A_H0F0,     8,         A_0H0F     ;[11,2] >>8 pix(7,5)
||      AND   .L2    B_DCBA,     B_M0F0F,   B_0C0A     ;[11,2] Get pix(10,8)
||[ A_i]LDW   .D1T1  *+A_ip[2],  A_HGFE                ;[ 2,3] Get pix(7..4)

        AND   .L2    B_DMCMBMAM, B_DCBA_,   B_DCBAout  ;[21,1] Use msk(11,8)
||      ADD   .D1    A_DM0BM0,   A_0CM0AM,  A_DMCMBMAM ;[21,1] Merge masks
||      SHRU  .S1    A_GMXEMX,   8,         A_XGMXEM   ;[12,2] >>8 msk(6,4)
||      SUB2  .S2    B_thth,     B_0H0F,    B_HMXFMX   ;[12,2] pix(15,13)<th
||      AND   .L1X   A_DCBA,     B_M0F0F,   A_0C0A     ;[12,2] Get pix(2,0)
||      MV    .D2    B_DCBA,     B_DCBA_               ;[12,2] live-too-long

  [!B_p]STW   .D1T2  B_DCBAout,  *A_op++[4]            ;[22,1] Put pix(11..8)
||      AND   .L1    A_DMCMBMAM, A_DCBA_,   A_DCBAout  ;[22,1] Use msk(3..0)
||      AND   .L2X   B_HMXFMX,   A_MF0F0,   B_HM0FM0   ;[13,2] Fix msk(15,13)
||      SUB2  .S1    A_thth,     A_0H0F,    A_HMXFMX   ;[13,2] pix(7,5)<th
||      SUB2  .S2    B_thth,     B_0C0A,    B_CMXAMX   ;[13,2] pix(10,8)<th
||      SUB   .D2    B_DCBA,     B_0C0A,    B_D0B0     ;[13,2] Get pix(11,9)

        AND   .S1    A_HMXFMX,   A_MF0F0,   A_HM0FM0   ;[14,2] Fix msk(7,5)
||      AND   .L2    B_XGMXEM,   B_M0F0F,   B_0GM0EM   ;[14,2] Fix msk(14,12)
||      AND   .L1X   A_XGMXEM,   B_M0F0F,   A_0GM0EM   ;[14,2] Fix msk(6,4)
||      SHRU  .S2    B_D0B0,     8,         B_0D0B     ;[14,2] >>8 pix(11,9)
||      SUB   .D1    A_DCBA,     A_0C0A,    A_D0B0     ;[14,2] Get pix(3,1)
||[ A_i]LDW   .D2T2  *B_ip++[4], B_DCBA                ;[ 5,3] Get pix(11..8)
||[ B_p]MPY   .M2    B_p,        0,         B_p        ; prolog collapse

  [!B_p]STW   .D2T1  A_DCBAout,  *B_op++[4]            ;[24,1] Put pix(3..0)
||      ADD   .L1    A_HM0FM0,   A_0GM0EM,  A_HMGMFMEM ;[15,2] Merge masks
||      SHRU  .S2    B_CMXAMX,   8,         B_XCMXAM   ;[15,2] >>8 msk(10,8)
||      SUB2  .S1    A_thth,     A_0C0A,    A_CMXAMX   ;[15,2] pix(3,1) < th
||      MV    .D1    A_DCBA,     A_DCBA_               ;[15,2] live-too-long
||      AND   .L2    B_HGFE,     B_M0F0F,   B_0G0E     ;[ 6,3] Get pix(14,12)

* ============================ PIPE LOOP EPILOG =========================== *
*   Epilog / Final Cleanup Code.                                            *
*                                                                           *
*   One stage of the epilog have been collapsed.                            *
*                                                                           *
*   This code performs the final stores from the epilog while restoring     *
*   Save-On-Entry values from the stack.                                    *
* ==================== SYMBOLIC REGISTER REASSIGNMENTS ==================== *
        .asg         A2,         A_SP                  ; Twin stack pointer
        .asg         B0,         B_ret                 ; Return address
        .asg         B6,         B_HMGMFMEM            ; Masked pixels
* ========================================================================= *

        LDW   .D2T2  *+B_SP[7],  B_ret                 ; +SP[7] ==> B_ret
||      MV    .L1X   B_SP,       A_SP                  ; Twin stack ptr
;-
        LDW   .D2T2  *+B_SP[1],  B12                   ; +SP[1] ==> B12
||      LDW   .D1T1  *+A_SP[2],  A12                   ; +SP[2] ==> A12

        LDW   .D2T2  *+B_SP[3],  B11                   ; +SP[3] ==> B11
||      LDW   .D1T1  *+A_SP[4],  A11                   ; +SP[4] ==> A11

        AND   .L1    A_HMGMFMEM, A_HGFE_,   A_HGFEout  ;[16,3] Use msk(7..4)
||      ADD   .D2    B_HM0FM0,   B_0GM0EM,  B_HMGMFMEM ;[16,3] Merge masks
||      AND   .L2    B_XCMXAM,   B_M0F0F,   B_0CM0AM   ;[16,3] Fix msk(10,8)
||      SHRU  .S1    A_CMXAMX,   8,         A_XCMXAM   ;[16,3] >>8 msk(2,0)
;-
        AND   .L2    B_HMGMFMEM, B_HGFE_,   B_HGFEout  ;[17,3] Use msk(15..12)
||      AND   .L1X   A_XCMXAM,   B_M0F0F,   A_0CM0AM   ;[17,3] Fix msk(2,0)
||      SHRU  .S1    A_D0B0,     8,         A_0D0B     ;[17,3] >>8 pix(3,1)
||      SUB2  .S2    B_thth,     B_0D0B,    B_DMXBMX   ;[16,3] pix(11,9) < th
||      LDW   .D2T2  *+B_SP[5],  B10                   ; +SP[5] ==> B10
||      LDW   .D1T1  *+A_SP[6],  A10                   ; +SP[6] ==> A10
;-
        STW   .D1T2  B_HGFEout,  *+A_op[2]             ;[18,3] Pux pix(15..12)
||      STW   .D2T1  A_HGFEout,  *+B_op[2]             ;[18,3] Put pix(7..4)
||      AND   .L2X   B_DMXBMX,   A_MF0F0,   B_DM0BM0   ;[18,3] Fix msk(11,9)
||      RET   .S2    B_ret                             ; Return to caller

        ADD   .L2    B_DM0BM0,   B_0CM0AM,  B_DMCMBMAM ;[20,3] Merge masks
||      SUB2  .S1    A_thth,     A_0D0B,    A_DMXBMX   ;[18,3] pix(3,1) < th
||      LDW   .D2T2  *++B_SP[8], B13                   ; +SP[8] ==> B13

        AND   .L1    A_DMXBMX,   A_MF0F0,   A_DM0BM0   ;[20,3] Fix msk(3,1)
;-
        AND   .L2    B_DMCMBMAM, B_DCBA_,   B_DCBAout  ;[21,3] Use msk(11,8)
||      ADD   .L1    A_DM0BM0,   A_0CM0AM,  A_DMCMBMAM ;[21,3] Merge masks

        STW   .D1T2  B_DCBAout,  *A_op                 ;[22,3] Put pix(11..8)
||      AND   .L1    A_DMCMBMAM, A_DCBA_,   A_DCBAout  ;[22,3] Use msk(3..0)

        STW   .D2T1  A_DCBAout,  *B_op                 ;[24,3] Put pix(3..0)

* ========================================================================= *
*   End of file:  img_thr_le2min.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

thr_le2thr.asm/ 1066929162  0     0     0       14927     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Sun Sep 29 03:31:30 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_thr_le2thr                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       14-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_le2thr                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     //  Input image data  //      *
*           unsigned char *restrict out_data, //  Output image data //      *
*           short cols, short rows,           //  Image dimensions  //      *
*           unsigned char       threshold     //  Threshold value   //      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are less than or equal to the       *
*       threshold are set to the threshold value in the output image.       *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|                                                    *
*                      |                  /                                 *
*                      |                /                                   *
*             O        |              /                                     *
*             U        |            /                                       *
*             T    th _|_________ /                                         *
*             P        |         .                                          *
*             U        |         .                                          *
*             T        |         .                                          *
*                      |         .                                          *
*                    0_|_________.__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2min      *
*       and IMG_thr_gt2max for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The value rows*cols must be a multiple of 4 pixels, and at least    *
*       4 pixels long.                                                      *
*                                                                           *
*   NOTES                                                                   *
*       This kernel is interrupt tolerant, but not interruptible.           *
*       Interrupts are blocked for the entire duration of the kernel by     *
*       branch delay slots.                                                 *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       No bank conflicts occur, regardless of the relative alignment of    *
*       in_data[] and out_data[].                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = rows * cols + 20.                                          *
*       For rows = 32 and cols = 32, cycles = 1042.                         *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       192 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_thr_le2thr"
        .global _IMG_thr_le2thr
_IMG_thr_le2thr:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_i_ptr
        .asg            B4,         B_o_ptr
        .asg            A6,         A_rows
        .asg            B6,         B_cols
        .asg            A8,         A_th
        .asg            B3,         B_ret_addr

        .asg            B5,         B_i_ptr
        .asg            B9,         B_p3
        .asg            B9,         B_p2
        .asg            A6,         A_p1
        .asg            A6,         A_p0
        .asg            B8,         B_th
        .asg            B1,         B_c3
        .asg            B1,         B_c2
        .asg            A1,         A_c1
        .asg            A1,         A_c0
        .asg            B7,         B_t3
        .asg            B6,         B_t2
        .asg            A7,         A_t1
        .asg            A5,         A_t0
        .asg            A2,         A_pc
        .asg            A3,         A_o_ptr
        .asg            B0,         B_i
* ========================================================================= *
        MPY             A_rows,     B_cols,     B_i

        ADD             A_i_ptr,    2,          B_i_ptr
||      MVK     .S1     1,          A_pc

        SHR             B_i,        2,          B_i
* =========================== PIPE LOOP PROLOG ============================ *
        LDBU    .D1T1   *A_i_ptr[1],            A_p1            ;[ 1,1]
||      LDBU    .D2T2   *B_i_ptr[1],            B_p3            ;[ 1,1]
||[ B_i]SUB             B_i,        1,          B_i

  [ B_i]B       .S1     loop                                    ;[ 6,1]
;-
        LDBU    .D1T1   *A_i_ptr++[4],          A_p0            ;[ 3,1]
||      LDBU    .D2T2   *B_i_ptr++[4],          B_p2            ;[ 3,1]
||      MV              A_th,       B_th
; ===== 1 prolog stage collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!A_pc]STB    .D2T1   A_t1,       *B_o_ptr[1]                 ;[ 8,1]
||[!A_pc]STB    .D1T2   B_t3,       *A_o_ptr[1]                 ;[ 8,1]
||      CMPGTU  .L1     A_p0,       A_th,       A_c0            ;[ 8,1]
||      CMPGTU  .L2     B_p2,       B_th,       B_c2            ;[ 8,1]
||      MPY     .M1     A_th,       1,          A_t1            ;[ 4,2]
;-
  [ A_c0]MV     .L1     A_p0,       A_t0                        ;[ 9,1]
||[ B_c2]MV     .S2     B_p2,       B_t2                        ;[ 9,1]
||      MPY     .M1     A_th,       1,          A_t0            ;[ 5,2]
||      MPY     .M2     A_th,       1,          B_t3            ;[ 5,2]
||      LDBU    .D1T1   *A_i_ptr[1],            A_p1            ;[ 1,3]
||      LDBU    .D2T2   *B_i_ptr[1],            B_p3            ;[ 1,3]
||[ B_i]SUB     .L2     B_i,        1,          B_i             ;[ 1,3]
||[ A_pc]ADD    .S1X    B_o_ptr,    2,          A_o_ptr
;-
  [!A_pc]STB    .D2T1   A_t0,       *B_o_ptr++[4]               ;[10,1]
||[!A_pc]STB    .D1T2   B_t2,       *A_o_ptr++[4]               ;[10,1]
||[ B_i]B       .S1     loop                                    ;[ 6,2]
||      MPY     .M2     B_th,       1,          B_t2            ;[ 6,2]
||      CMPGTU  .L1     A_p1,       A_th,       A_c1            ;[ 6,2]
||      CMPGTU  .L2     B_p3,       B_th,       B_c3            ;[ 6,2]
;-
  [ A_pc]SUB    .L1     A_pc,       1,          A_pc            ;[ 7,2]
||[ A_c1]MV     .S1     A_p1,       A_t1                        ;[ 7,2]
||[ B_c3]MV     .L2     B_p3,       B_t3                        ;[ 7,2]
||      LDBU    .D1T1   *A_i_ptr++[4],          A_p0            ;[ 3,3]
||      LDBU    .D2T2   *B_i_ptr++[4],          B_p2            ;[ 3,3]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 1 epilog stage collapsed
        CMPGTU  .L1     A_p0,       A_th,       A_c0            ;[ 8,3]
||      CMPGTU  .L2     B_p2,       B_th,       B_c2            ;[ 8,3]
||      RET     .S2     B_ret_addr
;-
  [ A_c0]MV     .L1     A_p0,       A_t0                        ;[ 9,3]
||[ B_c2]MV     .S2     B_p2,       B_t2                        ;[ 9,3]
||[!A_pc]STB    .D2T1   A_t1,       *B_o_ptr[1]                 ;[ 8,3]
||[!A_pc]STB    .D1T2   B_t3,       *A_o_ptr[1]                 ;[ 8,3]

  [!A_pc]STB    .D2T1   A_t0,       *B_o_ptr                    ;[10,3]
||[!A_pc]STB    .D1T2   B_t2,       *A_o_ptr                    ;[10,3]

         NOP            3

* ========================================================================= *
*   End of file:  img_thr_le2thr.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

wave_horz.asm/  1066929162  0     0     0       36157     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.11    Sun Sep 29 03:31:30 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_wave_horz                                                       *
*                                                                           *
*   REVISION DATE                                                           *
*       21-Oct-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void IMG_wave_horz                                              *
*           (                                                               *
*               const short *restrict in_data,  // Row of input pixels  //  *
*               const short *restrict qmf,      // Low-pass QMF filter  //  *
*               const short *restrict mqmf,     // High-pass QMF filter //  *
*               short       *restrict out_data, // Row of output data   //  *
*               int                   cols      // Length of input.     //  *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This kernel performs a 1D Periodic Orthogonal Wavelet               *
*       decomposition.  This also performs the row decomposition in a 2D    *
*       wavelet transform.  An input signal x[n] is low pass and high pass  *
*       filtered and decimated by two.  This results in a reference signal  *
*       r1[n] which is the decimated output obtained by dropping the odd    *
*       samples of the low pass filtered output and a detail signal d[n]    *
*       obtained by dropping the odd samples of the high-pass output.  A    *
*       circular convolution algorithm is implemented and hence the         *
*       wavelet transform is periodic.  The reference signal and the        *
*       detail signal are half the size of the original signal.  The        *
*       reference signal may then be iterated again to perform another      *
*       scale of multi-resolution analysis.                                 *
*                                                                           *
* C CODE                                                                    *
*       This is the C equivalent of the assembly code without               *
*       restrictions: Note that the assembly code is hand optimized and     *
*       restrictions apply as noted under "ASSUMPTIONS".                    *
*                                                                           *
*           void IMG_wave_horz                                              *
*           (                                                               *
*               const short *restrict in_data,  // Row of input pixels      *
*               const short *restrict qmf,      // Low-pass QMF filter      *
*               const short *restrict mqmf,     // High-pass QMF filter     *
*               short       *restrict out_data, // Row of output data       *
*               int                   cols      // Length of input.         *
*           )                                                               *
*           {                                                               *
*               int         i, res, iters;                                  *
*               int         j, sum, prod;                                   *
*               const short *restrict xptr  = in_data;                      *
*               short       *restrict yptr  = out_data;                     *
*               const short *restrict x_end = &in_data[cols - 1];           *
*               short       xdata, hdata;                                   *
*               const short *restrict xstart;                               *
*               const short *restrict filt_ptr;                             *
*               int         M = 8;                                          *
*                                                                           *
*               // ------------------------------------------------- //     *
*               //  Set our loop trip count and starting x posn.     //     *
*               //  'xstart' is used in the high-pass filter loop.   //     *
*               // ------------------------------------------------- //     *
*               iters  = cols;                                              *
*               xstart = in_data + (cols - M)  + 2;                         *
*                                                                           *
*               // ------------------------------------------------- //     *
*               //  Low pass filter.  Iterate for cols/2 iterations  //     *
*               //  generating cols/2 low pass sample points with    //     *
*               //  the low-pass quadrature mirror filter.           //     *
*               // ------------------------------------------------- //     *
*               for (i = 0; i < iters; i += 2)                              *
*               {                                                           *
*                   // --------------------------------------------- //     *
*                   //  Initialize our sum to the rounding value     //     *
*                   //  and reset our pointer.                       //     *
*                   // --------------------------------------------- //     *
*                   sum  = Qr;                                              *
*                   xptr = in_data + i;                                     *
*                                                                           *
*                   // --------------------------------------------- //     *
*                   //  Iterate over the taps in our QMF.            //     *
*                   // --------------------------------------------- //     *
*                   for (j = 0; j < M; j++)                                 *
*                   {                                                       *
*                       xdata = *xptr++;                                    *
*                       hdata =  qmf[j];                                    *
*                       prod  =  xdata * hdata;                             *
*                       sum  += prod;                                       *
*                       if (xptr > x_end) xptr = in_data;                   *
*                   }                                                       *
*                                                                           *
*                   // --------------------------------------------- //     *
*                   //  Adjust the Qpt of our sum and store result.  //     *
*                   // --------------------------------------------- //     *
*                   res    = (sum >> Qpt);                                  *
*                   *out_data++ = res;                                      *
*               }                                                           *
*                                                                           *
*               // ------------------------------------------------- //     *
*               //  High pass filter.  Iterate for cols/2 iters      //     *
*               //  generating cols/2 high pass sample points with   //     *
*               //  the high-pass quadrature mirror filter.          //     *
*               // ------------------------------------------------- //     *
*               for (i = 0; i < iters ; i+=2)                               *
*               {                                                           *
*                   // --------------------------------------------- //     *
*                   //  Initialize our sum and filter pointer.       //     *
*                   // --------------------------------------------- //     *
*                   sum  = Qr;                                              *
*                   filt_ptr  = mqmf + (M - 1);                             *
*                                                                           *
*                   // --------------------------------------------- //     *
*                   //  Set up our data pointer.  This is slightly   //     *
*                   //  more complicated due to how the data wraps   //     *
*                   //  around the edge of the buffer.               //     *
*                   // --------------------------------------------- //     *
*                   xptr = xstart;                                          *
*                   xstart += 2;                                            *
*                   if (xstart > x_end) xstart = in_data;                   *
*                                                                           *
*                   // --------------------------------------------- //     *
*                   //  Iterate over the taps in our QMF.            //     *
*                   // --------------------------------------------- //     *
*                   for ( j = 0; j < M; j++)                                *
*                   {                                                       *
*                       xdata = *xptr++;                                    *
*                       hdata = *filt_ptr--;                                *
*                       prod  = xdata * hdata;                              *
*                       if (xptr > x_end) xptr = in_data;                   *
*                       sum  += prod;                                       *
*                   }                                                       *
*                                                                           *
*                   // --------------------------------------------- //     *
*                   //  Adjust the Qpt of our sum and store result.  //     *
*                   // --------------------------------------------- //     *
*                   res = (sum >> Qpt);                                     *
*                   *out_data++ =  res;                                     *
*               }                                                           *
*           }                                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*       The main idea in optimizing the code is to issue one set of reads   *
*       to the x array and to perform low-pass and high pass filtering      *
*       together to maximize the number of multiplies.  The last 6          *
*       elements of the low-pass filter and the first 6 elements of the     *
*       high pass filter use the same input. This is used to appropriately  *
*       change the output pointer to the low pass filter after 6            *
*       iterations. However for the first six iterations pointer            *
*       wrap-around can occurr and hence this creates a dependency.         *
*       Pre-reading those 6 values outside the array prevents the checks    *
*       that introduce this dependency.  In addtion the input data is read  *
*       as word wide quantities and the low-pass and high-pass filter       *
*       coefficients are stored in registers allowing for the input loop    *
*       to be completely unrolled. Thus the code has only one               *
*       loop. A predication register is used to reset the low-pass output   *
*       pointer after three iterations. The merging of the loops in this    *
*       fashion allows for the maximum number of multiplies with the        *
*       minimum number of reads.                                            *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This routine assumes that the number of filter taps for the qmf     *
*       and mqmf is 8.                                                      *
*                                                                           *
*       Both the filters are assumed to be word aligned.                    *
*                                                                           *
*       The input line is assumed to be word aligned so that LDWs may be    *
*       performed.                                                          *
*                                                                           *
*       This code assumes that filter coefficients are maintained as        *
*       shorts in Q15 format.                                               *
*                                                                           *
*       It also assumes that input data is an array of shorts (16 bit)      *
*       (The input is assumed to be an array of shorts to allow for         *
*       re-using this kernel to perform Multi Resolution Analysis as        *
*       the output of this code will feedback again as input in the         *
*       next stage.)                                                        *
*                                                                           *
*       Since the transform is a dyadic wavelet cols should be a multiple   *
*       of 2.                                                               *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code has no bank conflicts.                                    *
*                                                                           *
*       This code is ENDIAN Neutral.                                        *
*                                                                           *
*   NOTES                                                                   *
*       This code masks interrupts for nearly its entire duration. As a     *
*       result, the code is interrupt tolerant but not interruptible.       *
*                                                                           *
*       This code can implement the Daubechies D4 filterbank for            *
*       analysis with 4 vansishing moments.  The length of the analyzing    *
*       low-pass and high pass filters is 8 in that case.                   *
*                                                                           *
*   CYCLES                                                                  *
*       cols * 4 + 5                                                        *
*                                                                           *
*       For cols = 256, cycles = 1029.                                      *
*       For cols = 512, cycles = 2058.                                      *
*                                                                           *
*   CODESIZE                                                                *
*       640 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

                   .data
Qr                 .set     16384
M                  .set     8


        .sect ".text:_wave_horz"
        .global _IMG_wave_horz
_IMG_wave_horz: 

*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
*==============================================================================*
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T1   A15,        *B_SP--[14] ; Reserve stack, Save A15

        MV      .S1X    B_SP,       A_SP        ; Twin Stack Pointer

        STW     .D1T1   A14,        *+A_SP[12]  ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]  ; Save B14
||      MVC     .S2     CSR,        B_csr       ; Capture CSR's state

        STW     .D1T1   A13,        *+A_SP[10]  ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]  ; Save B13
||      AND     .L2     B_csr,      -2,         B_no_gie    ; Clear GIE
;-
        STW     .D1T1   A12,        *+A_SP[ 8]  ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]  ; Save B12

        STW     .D1T1   A11,        *+A_SP[ 6]  ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]  ; Save B11
||      MV      .L1X    B_csr,      A_csr       ; Partitioning MV

        STW     .D1T1   A10,        *+A_SP[ 4]  ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]  ; Save B10
||      MVC     .S2     B_no_gie,   CSR         ; Disable interrupts
; ===== Interrupts masked here =====
;-
        STW     .D1T1   A_csr,      *+A_SP[ 2]  ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]  ; Remember return address

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_iptr                      ;
        .asg            B4,         B_qmf                       ;
        .asg            A6,         A_filter                    ;
        .asg            B6,         B_optr                      ;
        .asg            A8,         A_ish_x_dim                 ;
        .asg            A11,        A_qr                        ;
        .asg            B7,         B_iptr                      ;
        .asg            A8,         A_x10                       ;
        .asg            B8,         B_x32                       ;
        .asg            A9,         A_x54                       ;
        .asg            B5,         B_x76                       ;
        .asg            A10,        A_yptr_h                    ;
        .asg            B9,         B_yptr_l0                   ;
        .asg            B10,        B_yptr_l1                   ;
        .asg            A1,         A_p                         ;
        .asg            A2,         A_i                         ;
        .asg            A12,        A_h76                       ;
        .asg            B12,        B_h54                       ;
        .asg            A13,        A_h32                       ;
        .asg            B13,        B_h10                       ;
        .asg            A14,        A_l10                       ;
        .asg            B14,        B_l32                       ;
        .asg            A15,        A_l54                       ;
        .asg            B0,         B_l76                       ;
        .asg            B1,         B_fev_ptr
        .asg            A3,         A_fod_ptr
        .asg            A1,         A_xdim
        .asg            A7,         A_lev_ptr
        .asg            B3,         B_lod_ptr
        .asg            B7,         B_M
        .asg            B7,         B_offset
        .asg            A0,         A_offset
        .asg            A5,         A_xiptr
        .asg            B2,         B_xiptr
        .asg            A6,         A_optr
; ============================================================================

        STW     .D1T1   A_csr,      *+A_SP[ 2]             ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]             ; return address
||      MV      .L1     A_ish_x_dim,            A_xdim     ;
||      MVK     .S2     M,          B_M                    ; M = 8

        SUB     .L2X    A_xdim,     B_M,        B_offset   ; off = x - M + 2

        ADD     .D2     B_offset,   2,          B_offset   ; off

        MV      .L1X    B_offset,   A_offset               ; Make copy
||      ADD     .D2     B_qmf,      4,          B_lod_ptr  ; lowpass odd ptr

;--
        ADDAH   .D1     A_iptr,     A_offset,   A_xiptr    ; xiptr = iptr + off
||      ADD     .L1X    B_qmf,      0,          A_lev_ptr  ; lowpass even ptr
||      LDW     .D2T2   *B_lod_ptr++[2],        B_l32      ; lowpass32

        ADD     .S2X    A_filter,   0,          B_fev_ptr  ; highpass even ptr
||      ADD     .S1     A_filter,   4,          A_fod_ptr  ; high pass odd ptr
||      LDW     .D1T1   *A_lev_ptr++[2],        A_l10      ; lowpass10

        LDW     .D1T1   *A_fod_ptr++[2],        A_h32      ; highpass32
||      LDW     .D2T2   *B_fev_ptr++[2],        B_h10      ; highpass10

;-
        ADD     .S2X    A_xiptr,    4,          B_xiptr    ; twin xiptr
||      LDW     .D1T1   *A_xiptr++[2],          A_x10      ; Load x10

        LDW     .D1T1   *A_lev_ptr++[2],        A_l54      ; lowpass54

        LDW     .D2T2   *B_fev_ptr++[2],        B_h54      ; highpass54
||      LDW     .D1T1   *A_fod_ptr++[2],        A_h76      ; highpass76

        LDW     .D1T1   *A_xiptr++[2],          A_x54      ; Load x54
||      LDW     .D2T2   *B_xiptr++[2],          B_x32      ; Load x32
||      SHRU    .S1     A_xdim,     1,          A_i        ; i = X >> 1

;--

        LDW     .D2T2   *B_lod_ptr++[2],        B_l76      ; lowpass76

        MV      .L1X    B_optr,     A_optr                 ; Copy optr
||      MVKL    .S1     Qr,         A_qr                   ; Qr --> A_qr

        SHRU    .S2     B_offset,   1,          B_offset   ; off = x - M + 2
||      ADDAH   .D1     A_optr,     A_i,        A_yptr_h   ; y_h  = optr[x >>1]
||      MV      .L2     B_optr,     B_yptr_l1              ; y_l1 = optr
||      MVK     .S1     3,          A_p                    ; p to switch ptrs
||      MV      .L1X    B_offset,   A_offset               ; off >>= 1

;--

        ADDAH   .D2     B_optr,     B_offset,   B_yptr_l0  ; y_lo = optr - off
||      MV      .L2X    A_iptr,     B_iptr                 ; B_iptr = iptr
||      MVKH    .S1     Qr,         A_qr                   ; Qr --> A_qr
||      B       .S2     L_5 + 8                            ; Branch prolog

        ;==== Branch occurs

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A11,        A_qr
        .asg            B7,         B_iptr
        .asg            A8,         A_x10
        .asg            B8,         B_x32
        .asg            A9,         A_x54
        .asg            B5,         B_x76
        .asg            A10,        A_yptr_h
        .asg            B9,         B_yptr_l0
        .asg            B10,        B_yptr_l1
        .asg            A1,         A_p
        .asg            A2,         A_i
        .asg            A12,        A_h76
        .asg            B12,        B_h54
        .asg            A13,        A_h32
        .asg            B13,        B_h10
        .asg            A14,        A_l10
        .asg            B14,        B_l32
        .asg            A15,        A_l54
        .asg            B0,         B_l76
        .asg            B4,         B_sum_l
        .asg            A3,         A_sum_h
        .asg            A4,         A_prod_h0
        .asg            A7,         A_prod_h1
        .asg            B11,        B_prod_h2
        .asg            B6,         B_prod_h3
        .asg            A6,         A_prod_h4
        .asg            A3,         A_prod_h5
        .asg            B2,         B_prod_h6
        .asg            B3,         B_prod_h7
        .asg            A0,         A_prod_l0
        .asg            A6,         A_prod_l1
        .asg            B1,         B_prod_l2
        .asg            B3,         B_prod_l3
        .asg            A5,         A_prod_l4
        .asg            A4,         A_prod_l5
        .asg            B1,         B_prod_l6
        .asg            B2,         B_prod_l7
        .asg            A4,         A_sumh10
        .asg            B3,         B_sumh23
        .asg            A3,         A_sumh54
        .asg            B5,         B_sumh67
        .asg            A4,         A_suml10
        .asg            B3,         B_suml23
        .asg            A3,         A_suml54
        .asg            B1,         B_suml67
        .asg            A3,         A_sumh_od
        .asg            B5,         B_sumh_ev
        .asg            A5,         A_suml_od
        .asg            B5,         B_suml_ev
        .asg            B6,         B_suml_new
        .asg            A4,         A_sumh_new
        .asg            B4,         B_acc_low
        .asg            A3,         A_acc_hi
        .asg            B4,         B_res_low
        .asg            A3,         A_res_hi
; ============================================================================
; START:
; ============================ PIPE LOOP PROLOG ==============================

        LDW     .D2T2   *B_iptr++,  B_x76                       ; Load x76
||      B       .S2     L_6 + 8

        MPYLH   .M2     B_x32,      B_h54,      B_prod_h2       ; x0 * h2
||      MPYH    .M1     A_x10,      A_l10,      A_prod_l1       ; x1 * l1
||      B       .S2     L_7 + 4

        MPYH    .M2     B_x32,      B_l32,      B_prod_l3       ; x3 * l3
||      MPY     .M1     A_x54,      A_l54,      A_prod_l4       ; x4 * l4
||      B       .S2     L_8

        MPYHL   .M2     B_x32,      B_h54,      B_prod_h3       ; x0 * h3
||      MPYHL   .M1     A_x10,      A_h76,      A_prod_h1       ; x0 * h1
||      B       .S2     LOOP

        MPY     .M2     B_x32,      B_l32,      B_prod_l2       ; x2 * l2
||      MPYH    .M1     A_x54,      A_l54,      A_prod_l5       ; x5 * l5

; ============================ PIPE LOOP KERNEL ==============================
LOOP:
        ADD     .D2     B_suml23,   B_suml67,   B_suml_ev       ; suml23 + suml67
||      MV      .S1X    B_x76,      A_x54                       ; x76 = x54
||      MPYLH   .M2     B_x32,      B_h54,      B_prod_h2       ; x0 * h2
||      MPYH    .M1     A_x10,      A_l10,      A_prod_l1       ; x1 * l1

        ADD     .L2X    A_suml_od,  B_suml_ev,  B_suml_new      ; suml_ev + suml_od
||      ADD     .S2     B_prod_h6,  B_prod_h7,  B_sumh67        ; prodh6 + prodh7
||[ A_i]SUB     .S1     A_i,        1,          A_i             ; if (i) i--
||      ADD     .L1     A_prod_h4,  A_prod_h5,  A_sumh54        ; prodh4 + prodh5
||      ADD     .D1     A_prod_h0,  A_prod_h1,  A_sumh10        ; prodh0 + prodh1
||      ADD     .D2     B_prod_h2,  B_prod_h3,  B_sumh23        ; prodh2 + prodh3
||      MPYH    .M2     B_x32,      B_l32,      B_prod_l3       ; x3 * l3
||      MPY     .M1     A_x54,      A_l54,      A_prod_l4       ; x4 * l4

  [ A_i]B       .S1     LOOP                                    ; if (i) B LOOP
||      ADD     .L2     B_sum_l,    B_suml_new, B_acc_low       ; sum_l + suml_new
||      ADD     .D2     B_sumh23,   B_sumh67,   B_sumh_ev       ; sumh23 + sumh67
||      ADD     .D1     A_sumh10,   A_sumh54,   A_sumh_od       ; sumh10 + sumh54
||      MPYHL   .M2     B_x32,      B_h54,      B_prod_h3       ; x0 * h3
||      MPYHL   .M1     A_x10,      A_h76,      A_prod_h1       ; x0 * h1

L_4:
        SHR     .S2     B_acc_low,  15,         B_res_low       ; acc_lo >> 15
||      ADD     .L1X    B_sumh_ev,  A_sumh_od,  A_sumh_new      ; sumh_ev + sumh_od
||      MV      .S1     A_qr,       A_sum_h                     ; sum_h = qr
||      MPY     .M2     B_x32,      B_l32,      B_prod_l2       ; x2 * l2
||      MPYH    .M1     A_x54,      A_l54,      A_prod_l5       ; x5 * l5

L_5:
  [ A_p]STH     .D2T2   B_res_low,  *B_yptr_l0++                ; Store *y_lp0
||      ADD     .S1     A_sum_h,    A_sumh_new, A_acc_hi        ; sum_h + sumh_new
||      MPYH    .M2     B_x76,      B_l76,      B_prod_l7       ; x7 * l7
||      MPY     .M1     A_x10,      A_l10,      A_prod_l0       ; x0 * l0

L_6:
  [ A_p]SUB     .D1     A_p,        1,          A_p             ; pred.for LP
||[!A_p]STH     .D2T2   B_res_low,  *B_yptr_l1++                ; Store *y_lp1
||      SHR     .S1     A_acc_hi,   15,         A_res_hi        ; acc_hi >> 15
||      MPY     .M2     B_x76,      B_l76,      B_prod_l6       ; x6 * l6
||      MPYLH   .M1     A_x54,      A_h32,      A_prod_h4       ; x0 * h4
||[!A_i]MV      .L1     B_SP,       A_SP                        ;

L_7:
        STH     .D1T1   A_res_hi,   *A_yptr_h++                 ; Store *y_hp
||      MPYLH   .M2     B_x76,      B_h10,      B_prod_h6       ; x0 * h6
||      MV      .S2X    A_qr,       B_sum_l                     ; sum_l = qr
||      ADD     .S1     A_prod_l0,  A_prod_l1,  A_suml10        ; prodl0 + prodl1
||      ADD     .L1     A_prod_l4,  A_prod_l5,  A_suml54        ; prodl4 + prodl5
||      ADD     .D2     B_prod_l2,  B_prod_l3,  B_suml23        ; prodl2 + prodl3
||      MPYLH   .M1     A_x10,      A_h76,      A_prod_h0       ; x0 * h0

L_8:
  [A_i] ADD     .L2     B_prod_l6,  B_prod_l7,  B_suml67        ; prodl6 + prodl7
||[A_i] MPYHL   .M2     B_x76,      B_h10,      B_prod_h7       ; x0 * h7
||[A_i] MV      .S2X    A_x54,      B_x32                       ; x54 = x32
||[A_i] ADD     .S1     A_suml10,   A_suml54,   A_suml_od       ; suml10 + suml54
||[A_i] MV      .L1X    B_x32,      A_x10                       ; x32 = x10
||[A_i] MPYHL   .M1     A_x54,      A_h32,      A_prod_h5       ; x0 * h5
||[A_i] LDW     .D2T2   *B_iptr++,  B_x76                       ; Load x76

; ============================ PIPE LOOP EPILOG ==============================

*================= SYMBOLIC REGISTER ASSIGNMENTS: CLEANUP =====================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            A0,         A_csr       ; CSR value to restore
        .asg            B3,         B_ret       ; Return address
*==============================================================================*

        LDW     .D1T2   *+A_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr       ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10         ; Restore A10

        LDW     .D1T2   *+A_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11         ; Restore A11

        LDW     .D1T2   *+A_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12         ; Restore A12

        LDW     .D1T2   *+A_SP[ 9], B13         ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13         ; Restore A13

        LDW     .D1T2   *+A_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14         ; Restore A14
||      RET     .S2     B_ret                   ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
||      LDW     .D2T1   *++B_SP[14],A15         ; Restore A15
*====== Interruptibility state restored here ==================================*

        NOP             4
;====== Branch Occurs =====

* ========================================================================= *
*   End of file:  img_wave_horz.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

wave_vert.asm/  1066929162  0     0     0       44950     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.13    Sun Sep 29 03:31:31 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_wave_vert : Vertical Pass of Wavelet Transform                  *
*                                                                           *
*   REVISION DATE                                                           *
*       23-Oct-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_wave_vert                                                  *
*       (                                                                   *
*           const short *restrict                                           *
*                       *restrict in_data,                                  *
*           const short *restrict qmf,                                      *
*           const short *restrict mqmf,                                     *
*           short       *restrict out_ldata,                                *
*           short       *restrict out_hdata,                                *
*           int cols                                                        *
*       );                                                                  *
*                                                                           *
*       in_data   : Array of row pointers. Data must be word aligned.       *
*       qmf[8]    : Low pass QMF filter. Must be 8 taps and word aligned.   *
*       mqmf[8]   : High pass QMF filter. Must be 8 taps and word aligned.  *
*       out_ldata : Low pass output data                                    *
*       out_hdata : High pass output data                                   *
*       cols      : Length of rows to process. Must be a multiple of 2.     *
*                                                                           *
*   DESCRIPTION                                                             *
*       The benchmark performs the vertical pass of 2D wavelet              *
*       transform. It performs a vertical filter on 8 rows which are        *
*       pointed to by the pointers contained in an array of pointers.       *
*       It produces two lines worth of output, one being the low-pass       *
*       and the other being the high pass result. Instead of performing     *
*       a transpose on the column and re-using the wave_horz kernel,        *
*       the vertical filter is traversed over the entire width of the       *
*       line and the low pass and high pass filtering kernels are           *
*       performed together.                                                 *
*                                                                           *
*       This implies that the low-pass and highpass filters be              *
*       overlapped in execution so that the input data array may be         *
*       loaded once and both filters can be exceuted in parallel.           *
*                                                                           *
*   C CODE                                                                  *
*       void IMG_wave_vert                                                  *
*       (                                                                   *
*           const short *restrict                                           *
*                       *restrict in_data,   // Array of row pointers //    *
*           const short *restrict qmf,       // Low pass QMF filter   //    *
*           const short *restrict mqmf,      // High pass QMF filter  //    *
*           short       *restrict out_ldata, // Low pass output data  //    *
*           short       *restrict out_hdata, // High pass output data //    *
*           int cols                     // Length of rows to process //    *
*       )                                                                   *
*       {                                                                   *
*           const int M = 8;                                                *
*           int            i, iters, j;                                     *
*           int            sum_h, sum_l;                                    *
*           int            prod_h, prod_l;                                  *
*                                                                           *
*           short          res_h, res_l;                                    *
*           short          xdata, hdata, ldata;                             *
*           short          *filt_ptr;                                       *
*                                                                           *
*           // ------------------------------------------------------ //    *
*           //  iters: variable for the # of loop iterations.         //    *
*           //                                                        //    *
*           //  Both the low pass and the high pass filters produce   //    *
*           //  'iters' points, which is also the width of the input  //    *
*           //  line.  The low-pass filter reads filter coefficients  //    *
*           //  from qmf and the high pass filter reads filter        //    *
*           //  coefficients from the conjugate mirror filter. In     //    *
*           //  addition note that the low-pass filter coefficients   //    *
*           //  are read in increasing order while the high pass the  //    *
*           //  filter coefficients are read in the opposite order.   //    *
*           // ------------------------------------------------------ //    *
*           iters = cols;                                                   *
*                                                                           *
*           // ------------------------------------------------------ //    *
*           //  Since the filters have fractional point coefficients, //    *
*           //  all math is done using Q15 fixed-point arithmetic.    //    *
*           //  Qr is the associated round value and is set as        //    *
*           //  follows:                                              //    *
*           //                                                        //    *
*           //      #define Qpt 15                                    //    *
*           //      #define Qr 16384                                  //    *
*           //                                                        //    *
*           //  Low-Pass filter: ihptr contains 8 pointers which      //    *
*           //  point to input lines. The filters are placed          //    *
*           //  vertically and input data is read from 8 seperate     //    *
*           //  lines. Hence data-reuse is not possible when          //    *
*           //  traversing horizontally. sum_l is initialized to Qr   //    *
*           //  and contains the low-pass FIR sum at the end of the   //    *
*           //  j loop. sum_h contains the accumulator result for     //    *
*           //  the high pass filter in a similar fashion.  M is      //    *
*           //  assumed to be 8 by all kernels and is # filter taps   //    *
*           //  for D4.                                               //    *
*           // ------------------------------------------------------ //    *
*                                                                           *
*           for ( i = 0; i < iters; i++)                                    *
*           {                                                               *
*               sum_l    = Qr;                                              *
*               filt_ptr = qmf;                                             *
*                                                                           *
*               for ( j = 0; j < M; j++)                                    *
*               {                                                           *
*                   xdata   =  in_data[j][i];                               *
*                   ldata   =  *filt_ptr++;                                 *
*                   prod_l  =  xdata * ldata;                               *
*                   sum_l  +=  prod_l;                                      *
*               }                                                           *
*                                                                           *
*               res_l    = (sum_l >> Qpt);                                  *
*               *out_ldata++ = res_l;                                       *
*           }                                                               *
*                                                                           *
*           // ------------------------------------------------------ //    *
*           //  High-Pass filter:  ihptr contains 8 pointers which    //    *
*           //  point to input lines.  The filters are placed         //    *
*           //  vertically and input data is read from 8 seperate     //    *
*           //  lines.  Hence data-reuse is not possible when         //    *
*           //  traversing horizontally.  sum_h is initialized to     //    *
*           //  Qr and contains the low-pass FIR sum at the end of    //    *
*           //  the j loop.  sum_h contains the accumulator result    //    *
*           //  for the high pass filter in a similar fashion.  M     //    *
*           //  is # filter taps and is assumed to be 8 by all        //    *
*           //  kernels.                                              //    *
*           // ------------------------------------------------------ //    *
*           for ( i = 0; i < iters; i++)                                    *
*           {                                                               *
*               sum_h    = Qr;                                              *
*               filt_ptr = mqmf + M - 1;                                    *
*                                                                           *
*               for ( j = 0; j < M; j++)                                    *
*               {                                                           *
*                   xdata   =  in_data[j][i];                               *
*                   hdata   =  *filt_ptr--;                                 *
*                   prod_h  =  xdata * hdata;                               *
*                   sum_h  +=  prod_h;                                      *
*               }                                                           *
*                                                                           *
*               res_h    = (sum_h >> Qpt);                                  *
*               *out_hdata++ = res_h;                                       *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loop that advances along each filter tap is totally       *
*       optimized by unrolling. Further word wide loads are performed and   *
*       split multiplies are used to perform two iterations of low-pass in  *
*       parallel. The same technique is made use of but the order of        *
*       filter traversal is reversed  By loading the filter coefficients    *
*       in a special fashion one can re-use  the low-pass kernel for doing  *
*       the high-pass thereby saving codesize                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Since the wavelet transform is dyadic, cols is assumed to be a      *
*       multiple of 2.                                                      *
*                                                                           *
*       The input filters qmf and mqmf are assumed to be word aligned       *
*       and have exactly 8 taps.                                            *
*                                                                           *
*       The input data on any line is assumed to be word aligned.           *
*                                                                           *
*       The mqmf filter is constructed from the qmf as follows:             *
*                                                                           *
*           status = -1;                                                    *
*           for (i = 0; i < 8; i++)                                         *
*           {                                                               *
*               status = status * -1;                                       *
*               hdata  = qmf[i] * status;                                   *
*               filter[i] = hdata;                                          *
*           }                                                               *
*                                                                           *
*       The kernels assume that the number of filter taps is exactly        *
*       8.  In addition data that is loaded for producing out_ldata[0]      *
*       and out_hdata[0] is not identical. The data loaded for              *
*       producing out_hdata[0] produces results at the location             *
*                                                                           *
*           out_lstart = o_im + ((rows >> 1) - 3) * cols                    *
*           out_hstart = o_im + (rows >> 1) * cols                          *
*                                                                           *
*       Where o_im is start of output image, rows is # of rows of the       *
*       input image, and cols is # of cols of the output image. Hence       *
*       after three calls to the kernel in which the following output       *
*       lines get filled the low-pass pointer should be reset to point to   *
*       the start. Since the wavelet transform is dyadic rows is assumed    *
*       to be a multiple of 2 as well, just like cols.                      *
*                                                                           *
*       The following table illustrates how ylptr and yhptr need to be      *
*       updated at the start of each call to this function:                 *
*                                                                           *
*       Call#        out_ldata                  out_hdata                   *
*         1          out_lstart                 out_hstart                  *
*         2          out_lstart + cols          out_hstart + cols           *
*         3          out_lstart + 2*cols        out_hstart + 2*cols         *
*                                                                           *
*       At this point ylptr wraps around to become o_im, while yhptr        *
*       proceeds as usual:                                                  *
*                                                                           *
*         4          o_im                       out_hstart + 3*cols         *
*                                                                           *
*       In addition the kernel accepts a pointer to an array of             *
*       pointers for each input line so that a working buffer of 10         *
*       lines can be used to effectively mix DMA's and processing as        *
*       shown below:                                                        *
*                                                                           *
*       ihptr                        LINE BUFFER                            *
*       ptr0   ---->|-------------------------------------------------|     *
*       ptr1   ---->|-------------------------------------------------|     *
*       ...                                                                 *
*       ptr7   ---->|-------------------------------------------------|     *
*                                                                           *
*       At the start of the kernel 8 input lines are filled to the          *
*       first 8 lines and processing begins.  In the background the next    *
*       two lines are fetched.  The pointers are moved up by 2 namely       *
*       ptr[i] = ptr[i+2] and the last two lines now point to lines 9       *
*       and 10 and processing starts again.  In the background the next     *
*       two lines are brought in the first two lines of the line            *
*       buffer.  Pointers move up again by 2 but now the last two           *
*       pointers to line 0 and 1.  This pattern then repeats.               *
*                                                                           *
*       The first line to begin filtering is always obtained from           *
*       ptr[0], the next from ptr[1] and so on.                             *
*                                                                           *
*   MEMORY NOTE                                                             *
*       In order to eliminate bank conflicts succesive lines in the line    *
*       buffer or the pointers to these lines are seperated by exactly one  *
*       word so that loads to any succesive lines may be parallelized       *
*       together.                                                           *
*                                                                           *
*       This code is a LITTLE ENDIAN implementation.                        *
*                                                                           *
*   NOTES                                                                   *
*       This code masks interrupts for nearly its entire duration.  As a    *
*       result the code is interrupt tolerant but not interruptible.        *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 8 *cols + 48                                               *
*                                                                           *
*       For cols = 256, cycles = 2096.                                      *
*       For cols = 512, cycles = 4144.                                      *
*                                                                           *
*   CODESIZE                                                                *
*       736 bytes                                                           *
*                                                                           *
*   BIBLIOGRAPHY                                                            *
*       Mallat, Stephane. "A Wavelet Tour of Signal Processing", pg. 309.   *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
Qr              .set    16384

        .sect ".text:_wave_vert"
        .global _IMG_wave_vert
_IMG_wave_vert: 

*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
*==============================================================================*
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T1   A15,        *B_SP--[18] ; Reserve stack, Save A15

        MV      .S1X    B_SP,       A_SP        ; Twin Stack Pointer

        STW     .D1T1   A14,        *+A_SP[12]  ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]  ; Save B14
||      MVC     .S2     CSR,        B_csr       ; Capture CSR's state

        STW     .D1T1   A13,        *+A_SP[10]  ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]  ; Save B13
||      AND     .L2     B_csr,      -2,         B_no_gie    ; Clear GIE
;-
        STW     .D1T1   A12,        *+A_SP[ 8]  ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]  ; Save B12

        STW     .D1T1   A11,        *+A_SP[ 6]  ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]  ; Save B11
||      MV      .L1X    B_csr,      A_csr       ; Partitioning MV

        STW     .D1T1   A10,        *+A_SP[ 4]  ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]  ; Save B10
||      MVC     .S2     B_no_gie,   CSR         ; Disable interrupts
; ===== Interrupts masked here =====
;-

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_ihptr                     ;
        .asg            B4,         B_qmf                       ;
        .asg            A6,         A_filter                    ;
        .asg            B6,         B_ylptr                     ;
        .asg            A8,         A_yhptr                     ;
        .asg            B8,         B_x                         ;
        .asg            B13,        B_qr                        ;
        .asg            A8,         A_in0ptr                    ;
        .asg            B9,         B_in1ptr                    ;
        .asg            A9,         A_in2ptr                    ;
        .asg            B10,        B_in3ptr                    ;
        .asg            A10,        A_in4ptr                    ;
        .asg            B11,        B_in5ptr                    ;
        .asg            A11,        A_in6ptr                    ;
        .asg            B12,        B_in7ptr                    ;
        .asg            A14,        A_l10                       ;
        .asg            B14,        B_l32                       ;
        .asg            A0,         A_l54                       ;
        .asg            B0,         B_l76                       ;
        .asg            A13,        A_ylptr                     ;
        .asg            B2,         B_p                         ;
        .asg            A2,         A_iters                     ;
        .asg            A15,        A_SP                        ;
        .asg            B15,        B_SP                        ;
        .asg            B13,        B_ihptr
        .asg            A1,         A_qmf
        .asg            A15,        A_jold                      ;
; ============================================================================
        MV      .S1X    B_qmf,      A_qmf                       ; Part. copy
||      STW     .D1T1   A_csr,      *+A_SP[ 2]                  ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]                  ; Return address

        LDW     .D2T2   *+B_qmf[3], B_l76                       ;Lowpass:l7,l6
||      LDW     .D1T1   *+A_qmf[2], A_l54                       ;Lowpass:l5,l4

        MV      .S2X    A_ihptr,    B_ihptr                     ; Part.copy
||      LDW     .D2T2   *+B_qmf[1], B_l32                       ; Lowpass:l3,l2
||      LDW     .D1T1   *+A_qmf[0], A_l10                       ; Lowpass:L1:l0
;--
        LDW     .D2T2   *+B_ihptr[7],           B_in7ptr        ; Pointer: Row 7
||      LDW     .D1T1   *+A_ihptr[6],           A_in6ptr        ; Pointer: Row 6

        LDW     .D2T2   *+B_ihptr[5],           B_in5ptr        ; Pointer: Row 5
||      LDW     .D1T1   *+A_ihptr[4],           A_in4ptr        ; Pointer: Row 4

        LDW     .D2T2   *+B_ihptr[3],           B_in3ptr        ; Pointer: Row 3
||      LDW     .D1T1   *+A_ihptr[2],           A_in2ptr        ; Pointer: Row 2

        LDW     .D2T2   *+B_ihptr[1],           B_in1ptr        ; Pointer: Row 1
||      LDW     .D1T1   *+A_ihptr[0],           A_in0ptr        ; Pointer: Row 0

;--
        MVKL    .S2     Qr,         B_qr                        ; Round value
||      STW     .D1T1   A_yhptr,    *+A_SP[17]                  ; High pass ptr

        SHRU    .S1X    B_x,        1,          A_iters         ;iters =cols>>1
||      STW     .D1T1   A_filter,   *+A_SP[16]                  ;Save filter
||      MVK     .S2     3,          B_p                         ;Predication

        STW     .D2T2   B_x,        *+B_SP[15]                  ; Save cols
||      STW     .D1T1   A_ihptr,    *+A_SP[14]                  ; Save ihptr
||      ADD     .S1     A_iters,    1,          A_iters         ; ADD  iters

;--
        MV      .L1X    B_ylptr,    A_ylptr                     ; Part. copy
||      MVKH    .S2     Qr,         B_qr                        ; Round value
||      MVK     .S1     2,          A_jold                      ; Outer loop
                                                                ; Counter

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B13,        B_qr
        .asg            A8,         A_in0ptr
        .asg            B9,         B_in1ptr
        .asg            A9,         A_in2ptr
        .asg            B10,        B_in3ptr
        .asg            A10,        A_in4ptr
        .asg            B11,        B_in5ptr
        .asg            A11,        A_in6ptr
        .asg            B12,        B_in7ptr
        .asg            A14,        A_l10
        .asg            B14,        B_l32
        .asg            A0,         A_l54
        .asg            B0,         B_l76
        .asg            A13,        A_ylptr
        .asg            B2,         B_p
        .asg            A2,         A_iters
        .asg            B1,         B_sum_l
        .asg            A6,         A_xdataA0
        .asg            B3,         B_xdataB1
        .asg            A7,         A_xdataC2
        .asg            B6,         B_xdataD3
        .asg            A4,         A_xdataE4
        .asg            B6,         B_xdataF5
        .asg            A6,         A_xdataG6
        .asg            B3,         B_xdataH7
        .asg            A3,         A_prodl0
        .asg            B7,         B_prodl1
        .asg            A1,         A_prodl2
        .asg            B8,         B_prodl3
        .asg            A1,         A_prodl4
        .asg            B4,         B_prodl5
        .asg            A3,         A_prodl6
        .asg            B3,         B_prodl7
        .asg            A5,         A_sum0
        .asg            B8,         B_sum1
        .asg            A6,         A_sum2
        .asg            B1,         B_sum3
        .asg            A5,         A_sum_ev
        .asg            B5,         B_sum_od
        .asg            B4,         B_sum
        .asg            A4,         A_res_l
        .asg            A12,        A_prodlA
        .asg            B5,         B_prodlB
        .asg            A1,         A_prodlC
        .asg            B7,         B_prodlD
        .asg            A3,         A_prodlE
        .asg            B4,         B_prodlF
        .asg            A7,         A_prodlG
        .asg            B5,         B_prodlH
        .asg            A4,         A_sum4
        .asg            B7,         B_sum5
        .asg            A3,         A_sum6
        .asg            B4,         B_sum7
; ============================================================================

; ============================ PIPE LOOP KERNEL ==============================

LOOPL:

L_1:                                                            ; Cycle 1
        ADD     .S2     B_sum,      B_sum_l,    B_sum_l         ; sum_l += sum
||      MPYH    .M2X    B_xdataB1,  A_l10,      B_prodlB        ;  l1 * xdataB
||      ADD     .L2     B_prodl1,   B_prodl3,   B_sum1          ; prodl1+prodl3
||      MPY     .M1X    A_xdataG6,  B_l76,      A_prodl6        ; xdata6 * l6
||      LDW     .D2T2   *B_in3ptr++,            B_xdataD3       ; Load for line3
||      LDW     .D1T1   *A_in0ptr++,            A_xdataA0       ; Load for line0

L_2:                                                            ; Cycle 2
  [ A_iters]SUB .S1     A_iters,    1,          A_iters         ; iters--
||      ADD     .L2X    A_sum_ev,   B_sum_od,   B_sum           ; sum_ev+sum_od
||      ADD     .L1     A_prodl0,   A_prodl2,   A_sum0          ; prodl0+prodl2
||      MPYLH   .M2     B_xdataH7,  B_l76,      B_prodl7        ; xdata7 * l7
||      MPY     .M1     A_xdataE4,  A_l54,      A_prodl4        ; xdata4 * l4
||      LDW     .D1T1   *A_in2ptr++,            A_xdataC2       ; Load for line2
||      LDW     .D2T2   *B_in1ptr++,            B_xdataB1       ; Load for line1

L_3:                                                            ; Cycle 3
  [ A_iters]B   .S2     LOOPL                                   ; Branch LOOPL
||      SHR     .S1X    B_sum_l,    15,         A_res_l         ; sum_l >> 15
||      ADD     .L2     B_prodlB,   B_prodlD,   B_sum5          ; prodlB+prodlD
||      MPYH    .M2     B_xdataH7,  B_l76,      B_prodlH        ; xdataH * l7
||      MPYHL   .M1     A_xdataE4,  A_l54,      A_prodlE        ; xdataE * l4
||      LDW     .D1T1   *A_in6ptr++,            A_xdataG6       ; Load for line6

L_4:                                                            ; Cycle 4
        MV      .S2     B_qr,       B_sum_l                     ; Round value
||      MPYHL   .M1X    A_xdataG6,  B_l76,      A_prodlG        ; xdataG * l6
||      ADD     .S1     A_prodl4,   A_prodl6,   A_sum2          ; prodl4+prodl6
||      MPYLH   .M2X    B_xdataF5,  A_l54,      B_prodl5        ; xdata5 * l5
||      LDW     .D2T2   *B_in5ptr++,            B_xdataF5       ; Load for line5
||      LDW     .D1T1   *A_in4ptr++,            A_xdataE4       ; Load for line4

L_5:                                                            ; Cyle 5
        ADD     .S2     B_sum,      B_sum_l,    B_sum_l         ; sum_l += sum
||[ B_p]SUB     .L2     B_p,        1,          B_p             ; p--
||      MPYH    .M2X    B_xdataF5,  A_l54,      B_prodlF        ; xF * l5
||      MPYHL   .M1X    A_xdataC2,  B_l32,      A_prodlC        ; xC * l3
||      ADD     .D1     A_sum0,     A_sum2,     A_sum_ev        ; sum0 + sum2
||      LDW     .D2T2   *B_in7ptr++,            B_xdataH7       ; Load for line7

L_6:                                                            ; Cycle 6
        SHR     .S1X    B_sum_l,    15,         A_res_l         ; sum_l >> 15
||[!B_p]STH     .D1T1   A_res_l,    *A_ylptr++                  ; Store result
||      ADD     .L1     A_prodlE,   A_prodlG,   A_sum6          ; prodlE+prodlG
||      ADD     .L2     B_prodl5,   B_prodl7,   B_sum3          ; prodl5+prodl7
||      MPYHL   .M1     A_xdataA0,  A_l10,      A_prodlA        ; xdataA * l1
||      MPYLH   .M2     B_xdataD3,  B_l32,      B_prodl3        ; xdata3 * l3

L_7:                                                            ; Cycle 7
  [!B_p]STH     .D1T1   A_res_l,    *A_ylptr++                  ; Store result
||      ADD     .L2     B_prodlF,   B_prodlH,   B_sum7          ; prodlF+prodlH
||      ADD     .S1     A_prodlA,   A_prodlC,   A_sum4          ; prodlA+prodlC
||      ADD     .S2     B_sum1,     B_sum3,     B_sum_od        ; sum1+sum3
||      MPYLH   .M2X    B_xdataB1,  A_l10,      B_prodl1        ; xdata1 * l1
||      MPY     .M1     A_xdataA0,  A_l10,      A_prodl0        ; xdata0 * l0

L_8:                                                            ; Cycle 8
        ADD     .S2     B_sum5,     B_sum7,     B_sum_od        ; sum_5 + sum_7
||      ADD     .D1     A_sum4,     A_sum6,     A_sum_ev        ; sum_4 + sum_6
||      ADD     .L2X    A_sum_ev,   B_sum_od,   B_sum           ; sum_ev+ sum_od
||      MV      .D2     B_qr,       B_sum_l                     ; Round value
||      MPYH    .M2     B_xdataD3,  B_l32,      B_prodlD        ; xdataD * l3
||      MPY     .M1X    A_xdataC2,  B_l32,      A_prodl2        ; xdata2 * l2

; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:

        ADD     .S2     B_sum,      B_sum_l,    B_sum_l         ; sum_l += sum
||      LDW     .D2T1   *+B_SP[16], A_filter                    ; High pass ptr

  [ A_iters]SUB .S1     A_iters,    1,          A_iters         ; iters--
||      ADD     .L2X    A_sum_ev,   B_sum_od,   B_sum           ; sum_ev+sum_od1

        SHR     .S1X    B_sum_l,    15,         A_res_l         ; sum_l >> 15

        MV      .S2     B_qr,       B_sum_l                     ; sum_l = qr

        ADD     .S2     B_sum,      B_sum_l,    B_sum_l         ; sum_l += sum

        SHR     .S1X    B_sum_l,    15,         A_res_l         ; sum_l >> 15
||[!B_p]STH     .D1T1   A_res_l,    *A_ylptr++                  ; Store result

  [!B_p]STH     .D1T1   A_res_l,    *A_ylptr++                  ; Store result
||      MVK     .S2       3,        B_p                         ; Predication

; ============================================================================
; END:

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A15,        A_jold                      ;
        .asg            B15,        B_SP                        ;
        .asg            A6,         A_filter                    ;
        .asg            A8,         A_yhptr                     ;
        .asg            B8,         B_x                         ;
        .asg            B13,        B_qr                        ;
        .asg            B2,         B_p                         ;
        .asg            A2,         A_iters                     ;
        .asg            A8,         A_in0ptr                    ;
        .asg            B9,         B_in1ptr                    ;
        .asg            A9,         A_in2ptr                    ;
        .asg            B10,        B_in3ptr                    ;
        .asg            A10,        A_in4ptr                    ;
        .asg            B11,        B_in5ptr                    ;
        .asg            A11,        A_in6ptr                    ;
        .asg            B12,        B_in7ptr                    ;
        .asg            B0,         B_l76                       ;
        .asg            A0,         A_l54                       ;
        .asg            B14,        B_l32                       ;
        .asg            A14,        A_l10                       ;
        .asg            A13,        A_ylptr                     ;
        .asg            A1,         A_j                         ;
        .asg            A5,         A_ihptr
        .asg            B1,         B_ihptr
        .asg            B0,         B_filter
        .asg            A6,         A_kF
        .asg            B8,         B_kF
        .asg            B1,         B_l7
        .asg            A3,         A_l5
        .asg            B6,         B_l3
        .asg            A13,        A_l1
        .asg            B9,         B_l6
        .asg            A0,         A_l4
        .asg            B14,        B_l2
        .asg            A2,         A_l0
; ============================================================================

        LDW     .D2T1   *+B_SP[14], A_ihptr                     ; Lines Pointer

        MV      .S2X    A_filter,   B_filter                    ; Part. move

        LDW     .D2T1   *+B_filter[3],          A_l10           ; Load h76->l10

        LDW     .D2T1   *+B_SP[17], A_yhptr                     ; Output pointer
||      LDW     .D1T2   *+A_filter[2],          B_l32           ; Load h54->l32

        LDW     .D2T1   *+B_filter[1],          A_l54           ; Load h32->l54
||      LDW     .D1T2   *+A_filter[0],          B_l76           ; Load h01->l76

        LDW     .D2T2   *+B_SP[15], B_x                         ; Load cols
||      MV      .S2X    A_ihptr,    B_ihptr                     ; Part. move

        MVKL    .S1     1,          A_kF                        ;
||      MV      .L1     A_jold,     A_j                         ;
||      LDW     .D2T2   *+B_ihptr[7],           B_in7ptr        ; Pointer: Row7
||      LDW     .D1T1   *+A_ihptr[6],           A_in6ptr        ; Pointer: Row6

        SHRU    .S1     A_l10,      16,         A_l1            ;
||[ A_j]SUB     .L1     A_j,        1,          A_j             ;
||      LDW     .D2T2   *+B_ihptr[5],           B_in5ptr        ; Pointer: Row5
||      LDW     .D1T1   *+A_ihptr[4],           A_in4ptr        ; Pointer: Row4

        SHRU    .S2     B_l32,      16,         B_l3            ;
||      LDW     .D2T2   *+B_ihptr[3],           B_in3ptr        ; Pointer: Row3
||      LDW     .D1T1   *+A_ihptr[2],           A_in2ptr        ; Pointer: Row2
||[ A_j]B       .S1     LOOPL                                   ; Branch LOOPL

        SHL     .S1     A_l10,      16,         A_l0            ;
||      SHL     .S2     B_l32,      16,         B_l2            ;
||      LDW     .D2T2   *+B_ihptr[1],           B_in1ptr        ; Pointer: Row1
||      LDW     .D1T1   *+A_ihptr[0],           A_in0ptr        ; Pointer: Row0

        SHRU    .S1     A_l54,      16,         A_l5            ;
||      SHRU    .S2     B_l76,      16,         B_l7            ;

        SHL     .S1     A_l54,      16,         A_l4            ;
||      SHL     .S2     B_l76,      16,         B_l6            ;

        MV      .L2X    A_kF,       B_kF                        ;
||      MV      .D1     A_yhptr,    A_ylptr                     ;
||      ADD     .L1     A_l0,       A_l1,       A_l10           ;
||      SHRU    .S1X    B_x,        1,          A_iters         ; iters = cols/2
||      MVKL    .S2     Qr,         B_qr                        ;

        ADD     .D2     B_l2,       B_l3,       B_l32           ;
||      ADD     .L1     A_l4,       A_l5,       A_l54           ;
||      ADD     .L2     B_l6,       B_l7,       B_l76           ;
||      ADD     .D1     A_iters,    1,          A_iters         ;
||      MVKH    .S2     Qr,         B_qr                        ; Round value
||      MV      .S1     A_j,        A_jold                      ;

        ;==== Branch occurs

*================= SYMBOLIC REGISTER ASSIGNMENTS: CLEANUP =====================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            A0,         A_csr       ; CSR value to restore
        .asg            B3,         B_ret       ; Return address
*==============================================================================*

        MV      .S1X    B_SP,       A_SP        ; Twin Stack Pointer

        LDW     .D1T2   *+A_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr       ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10         ; Restore A10

        LDW     .D1T2   *+A_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11         ; Restore A11

        LDW     .D1T2   *+A_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12         ; Restore A12

        LDW     .D1T2   *+A_SP[ 9], B13         ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13         ; Restore A13

        LDW     .D1T2   *+A_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14         ; Restore A14
||      RET     .S2     B_ret                   ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
||      LDW     .D2T1   *++B_SP[18],A15         ; Restore A15
*====== Interruptibility state restored here ================================*

        NOP             4
;====== Branch Occurs =====

* ========================================================================= *
*   End of file:  img_wave_vert.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
yc_demux_0.asm/ 1066929162  0     0     0       22464     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Sat Mar 16 02:58:56 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_yc_demux_be16 -- De-interleave a 4:2:2 BIG ENDIAN video stream  *
*                        into three separate LITTLE ENDIAN 16-bit planes    *
*                                                                           *
*   REVISION DATE                                                           *
*       02-Oct-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and is called as follows:              *
*                                                                           *
*       void IMG_yc_demux_be16                                              *
*       (                                                                   *
*           int n,                     // Number of luma pixels    //       *
*           const unsigned char * yc,  // Interleaved luma/chroma  //       *
*           short *restrict y,         // Luma plane (16-bit)      //       *
*           short *restrict cr,        // Cr chroma plane (16-bit) //       *
*           short *restrict cb         // Cb chroma plane (16-bit) //       *
*       );                                                                  *
*                                                                           *
*       The input array 'yc' is expected to be an interleaved 4:2:2         *
*       video stream.  The input is expected in BIG ENDIAN byte order       *
*       within each 4-byte word.  This is consistent with reading the       *
*       video stream from a word-oriented BIG ENDIAN device while the       *
*       C6000 device is in a LITTLE ENDIAN configuration.                   *
*                                                                           *
*       In other words, the expected pixel order is:                        *
*                                                                           *
*                   Word 0           Word 1          Word 2                 *
*              +---------------+---------------+---------------+--          *
*        Byte# | 0   1   2   3 | 4   5   6   7 | 8   9  10  11 |...         *
*              |cb0 y1  cr0 y0 |cb2 y3  cr2 y2 |cb4 y5  cr4 y4 |...         *
*              +---------------+---------------+---------------+--          *
*                                                                           *
*       The output arrays 'y', 'cr', and 'cb' are expected to not           *
*       overlap.  The de-interleaved pixels are written as half-words       *
*       in LITTLE ENDIAN order.                                             *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function reads the byte-oriented pixel data, zero-extends      *
*       it, and then writes it to the appropriate result array.  Both       *
*       the luma and chroma values are expected to be unsigned.             *
*                                                                           *
*       The data is expected to be in an order consistent with              *
*       reading byte oriented data from a word-oriented peripheral          *
*       that is operating in BIG ENDIAN mode, while the CPU is              *
*       in LITTLE ENDIAN mode.  This results in a pixel ordering            *
*       which is not immediately obvious.  This function correctly          *
*       reorders the pixel values so that further processing may            *
*       proceed in LITTLE ENDIAN mode.                                      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays are word aligned.                           *
*       The input must be a multiple of 8 luma pixels long.                 *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop has been unrolled a total of 8 times to allow for          *
*       processing 4 pixels in each datapath.                               *
*                                                                           *
*       Word-wide loads and stores maximize memory bandwidth                *
*       utilization.                                                        *
*                                                                           *
*       The 40-bit shifter is used to exchange the luma bytes within        *
*       each word, effectively giving leftward byte rotate.                 *
*                                                                           *
*   MEMORY NOTE                                                             *
*       C6211/C6711 Two Level Cache Considerations:                         *
*                                                                           *
*       In a C6211-style system, this routine will experience cache-        *
*       related stalls, particularly if the incoming data is not present    *
*       in L1D, as is typical when the inputs are provided via DMA.         *
*                                                                           *
*       [Note:  The following analysis applies primarily to the C6211       *
*       and C6711.  It applies only in a general sense to the               *
*       cache-based C64x DSPs, and so may not be accurate in that           *
*       context.  Notably, the cache parameters on C64x differ from         *
*       C6211 and C6711.  Please consult the C6000 Peripherals              *
*       Reference Guide, SPRU190, for more information on the memory        *
*       system.]                                                            *
*                                                                           *
*       There are two primary sources of L1D cache degradation in this      *
*       code:  Read misses on the incoming YC data, and write misses on     *
*       the outgoing Y, Cb, and Cr data.                                    *
*                                                                           *
*       Read misses cost 5 cycles apiece.  In the worst case (no input      *
*       data in L1D), this results in n/16 cache misses, for a total        *
*       of 5*n/16 stall cycles.  There is little that can be done to        *
*       hide these.                                                         *
*                                                                           *
*       Write misses do not automatically stall the CPU, but rather         *
*       are placed in a 4-entry write buffer, where the writes are          *
*       subsequently processed by L2.  The L2 processes these at a rate     *
*       of 1 word every 2 cycles.  Therefore, if none of the output         *
*       arrays for this loop are in L1D, we are limited to one iteration    *
*       every 8 cycles -- that is, 5 cycles stall per iteration, for a      *
*       total of 5*n/4 stall cycles.  If the "y" buffer is brought into     *
*       L1D prior to execution, this overhead drops to 1 stall per          *
*       iteration.  If "y" and one of "Cr" or "Cb" are brought in, the      *
*       overhead due to the store buffer alone drops to zero.               *
*                                                                           *
*       Read misses and write misses interact when a write miss is          *
*       pending in the write buffer and a read miss occurs.  In the         *
*       cases where both "Cr" and "Cb" are not in L1D (and thus the         *
*       write buffer is saturated), one can show that this interaction      *
*       does not change the overall throughput.  In the case where          *
*       "y" and only one of "Cr" or "Cb" is in L1D, the write buffer        *
*       will have one element present in it when read misses occur,         *
*       and will, on average, lengthen read misses by 1 cycle.              *
*                                                                           *
*       For this hand-assembly version, it is safe to overlap the           *
*       output "y" buffer with the input "yc" buffer as long as the two     *
*       buffers start at the same location.  This effectively ensures       *
*       that the stores to the "y" array hit in L1D, and so do not use      *
*       the write buffer.  By further "touching" either "Cb" or "Cr"        *
*       into L1D, the penalty associated with the write buffer can be       *
*       reduced to zero, as discussed above.                                *
*                                                                           *
*       C620x/C670x Flat Memory Considerations:                             *
*                                                                           *
*       In the code below, accesses to the Cb and Cr arrays are allowed     *
*       to parallelize.  In order to avoid bank conflicts, one must         *
*       offset the Cb and Cr arrays by one word (two banks), or place       *
*       them in independent memory blocks.                                  *
*                                                                           *
*       This code accesses all four memory banks every cycle.  If both      *
*       input and output buffers are in the same memory block, then any     *
*       any DMAs to that block will either stall until this code            *
*       completes, or will force the CPU to stall unconditionally.          *
*       To allow DMAs to occur with minimal impact to the CPU and vice      *
*       versa, do one of the following:                                     *
*                                                                           *
*        -- Ensure that your DMAs go to a different memory block            *
*           so that DMA and CPU run independently, or                       *
*                                                                           *
*        -- Set the DMA to lower priority than the CPU, and place your      *
*           input and output buffers in different memory blocks, so         *
*           that the DMA runs during gaps in this code's access pattern.    *
*                                                                           *
*       The code spends 1/3rd of its cycles reading from the input,         *
*       1/3rd writing to 'y', and 1/3rd writing to 'Cb' and 'Cr' in         *
*       parallel.                                                           *
*                                                                           *
*       Please consult the C6000 Peripherals Reference Guide, SPRU190,      *
*       for additional information regarding memory system interactions.    *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt tolerant, but not interruptible.             *
*       Interrupts are masked for nearly its entire duration by branch      *
*       delay slots.                                                        *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 3 * (n / 4) + 21.                                          *
*       For n = 1024, cycles = 789.                                         *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       256 bytes.                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .sect ".text:_yc_demux_be16"
        .global _IMG_yc_demux_be16
_IMG_yc_demux_be16: 
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_00020001
        .asg            A1,         A_i
        .asg            A2,         A_y0r0y1b0
        .asg            A3,         A_b2
        .asg            A3,         A_y0y1
        .asg            A4,         A_n
        .asg            A4,         A_b2_
        .asg            A4,         A_y0_
        .asg            A4,         A_y1y0
        .asg            A5,         A_b2b0
        .asg            A5,         A_r0b0
        .asg            A5,         A_y1
        .asg            A6,         A_y
        .asg            A7,         A_b0
        .asg            A8,         A_cb
        .asg            A9,         A_yc
        .asg            A10,        A_00FF00FF
        .asg            B0,         B_r2r0
        .asg            B0,         B_y2_
        .asg            B0,         B_y3y2
        .asg            B1,         B_r2
        .asg            B1,         B_r2_
        .asg            B1,         B_y3
        .asg            B2,         B_8000
        .asg            B3,         B_ret
        .asg            B4,         B_yc
        .asg            B5,         B_r0
        .asg            B5,         B_y2y3
        .asg            B6,         B_cr
        .asg            B7,         B_y2r2y3b2
        .asg            B8,         B_y
        .asg            B9,         B_r2b2
        .asg            B10,        B_00FF00FF
        .asg            B11,        B_00020001
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        ADD     .L1X    B_yc,       4,          A_yc
||      ADD     .L2X    A_y,        4,          B_y
||      MVKL    .S2     0x00FF00FF, B_00FF00FF
||      STW     .D2T2   B10,        *B15--[4]

        LDW     .D2T1   *B_yc++[2], A_y0r0y1b0                  ;[ 1,1]
||      LDW     .D1T2   *A_yc++[2], B_y2r2y3b2                  ;[ 1,1]
||      MVKH    .S2     0x00FF00FF, B_00FF00FF
||      B       .S1     loop                                    ; no ints
;-
        MVK     .S1     1,          A_00020001
||      B       .S2     loop_1 + 8

        MVKLH   .S1     2,          A_00020001
||      STW     .D2T1   A10,        *B15[1]
||      B       .S2     loop_2 + 8

        LDW     .D2T1   *B_yc++[2], A_y0r0y1b0                  ;[ 1,2]
||      LDW     .D1T2   *A_yc++[2], B_y2r2y3b2                  ;[ 1,2]
||      B       .S1     loop
;-
        STW     .D2T2   B11,        *B15[2]
||      SHR     .S1     A_n,        2,          A_i
||      MV      .L1X    B_00FF00FF, A_00FF00FF
||      MV      .L2X    A_00020001, B_00020001
||      MVK     .S2     0xFFFF8000, B_8000

        AND     .L2     B_y2r2y3b2, B_00FF00FF, B_r2b2          ;[ 6,1]
||[ A_i]SUB             A_i,        2,          A_i
; ===== 1 prolog stage collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        ADD     .S1     A_y1,       A_y0_,      A_y1y0          ;[10,1]
||      ADD     .L2     B_y3,       B_y2_,      B_y3y2          ;[10,1]
||[ A_i]B       .S2     loop                                    ;[ 7,2]
||      MPYLHU  .M1X    B_r2b2,     A_00020001, A_b2_           ;[ 7,2]
||      MPYHU   .M2     B_r2b2,     B_00020001, B_r2_           ;[ 7,2]
||      AND     .L1     A_y0r0y1b0, A_00FF00FF, A_r0b0          ;[ 7,2]
||      LDW     .D2T1   *B_yc++[2], A_y0r0y1b0                  ;[ 1,4]
||      LDW     .D1T2   *A_yc++[2], B_y2r2y3b2                  ;[ 1,4]
loop_1:
        STW     .D1T1   A_y1y0,     *A_y++[2]                   ;[11,1]
||      STW     .D2T2   B_y3y2,     *B_y++[2]                   ;[11,1]
||      ADD     .L1     A_b2,       A_b0,       A_b2b0          ;[11,1]
||      ADD     .S2     B_r2,       B_r0,       B_r2r0          ;[11,1]
||      SUB     .S1     A_y0r0y1b0, A_r0b0,     A_y0y1          ;[ 8,2]
||      SUB     .L2     B_y2r2y3b2, B_r2b2,     B_y2y3          ;[ 8,2]
||      MPYU    .M1     A_r0b0,     A_00020001, A_b0            ;[ 8,2]
||      MPYHLU  .M2X    A_r0b0,     B_00020001, B_r0            ;[ 8,2]
loop_2:
        STW     .D1T1   A_b2b0,     *A_cb++                     ;[12,1]
||      STW     .D2T2   B_r2r0,     *B_cr++                     ;[12,1]
||[ A_i]SUB     .L1     A_i,        1,          A_i             ;[ 9,2]
||      SHL     .S1     A_y0y1,     8,          A_y1:A_y0_      ;[ 9,2]
||      SHL     .S2     B_y2y3,     8,          B_y3:B_y2_      ;[ 9,2]
||      MPYU    .M1X    A_b2_,      B_8000,     A_b2            ;[ 9,2]
||      MPYU    .M2     B_r2_,      B_8000,     B_r2            ;[ 9,2]
||      AND     .L2     B_y2r2y3b2, B_00FF00FF, B_r2b2          ;[ 6,3]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 2 epilog stages collapsed.
        ADD     .S1     A_y1,       A_y0_,      A_y1y0          ;[10,4]
||      ADD     .L2     B_y3,       B_y2_,      B_y3y2          ;[10,4]
||      LDW     .D2T1   *B15[1],    A10

        STW     .D1T1   A_y1y0,     *A_y++[2]                   ;[11,4]
||      STW     .D2T2   B_y3y2,     *B_y++[2]                   ;[11,4]
||      ADD     .L1     A_b2,       A_b0,       A_b2b0          ;[11,4]
||      ADD     .L2     B_r2,       B_r0,       B_r2r0          ;[11,4]
;-
        B       .S2     B_ret
||      LDW     .D2T2   *B15[2],    B11

        LDW     .D2T2   *++B15[4],  B10

        NOP             3

        STW     .D1T1   A_b2b0,     *A_cb                       ;[12,4]
||      STW     .D2T2   B_r2r0,     *B_cr                       ;[12,4]

* ========================================================================= *
*   End of file:  img_yc_demux_be16.asm                                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
yc_demux_1.asm/ 1066929162  0     0     0       21147     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Sat Mar 16 04:03:27 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_yc_demux_le16 -- De-interleave a 4:2:2 LITTLE ENDIAN video stream *
*                        into three separate LITTLE ENDIAN 16-bit planes    *
*                                                                           *
*   REVISION DATE                                                           *
*       15-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and is called as follows:              *
*                                                                           *
*       void IMG_yc_demux_le16                                              *
*       (                                                                   *
*           int n,                       // Number of luma pixels    //     *
*           const unsigned char * yc,    // Interleaved luma/chroma  //     *
*           short *restrict y,           // Luma plane (16-bit)      //     *
*           short *restrict cr,          // Cr chroma plane (16-bit) //     *
*           short *restrict cb           // Cb chroma plane (16-bit) //     *
*       );                                                                  *
*                                                                           *
*       The input array 'yc' is expected to be an interleaved 4:2:2         *
*       video stream.  The input is expected in LITTLE ENDIAN byte          *
*       order within each 4-byte word.  This is consistent with reading     *
*       the video stream from a word-oriented LITTLE ENDIAN device          *
*       while the C6000 device is in a LITTLE ENDIAN configuration.         *
*                                                                           *
*       In other words, the expected pixel order is:                        *
*                                                                           *
*                   Word 0           Word 1          Word 2                 *
*              +---------------+---------------+---------------+--          *
*        Byte# | 0   1   2   3 | 4   5   6   7 | 8   9  10  11 |...         *
*              | y0 cr0 y1 cb0 | y2 cr2 y3 cb2 | y4 cr4 y5 cb4 |...         *
*              +---------------+---------------+---------------+--          *
*                                                                           *
*       The output arrays 'y', 'cr', and 'cb' are expected to not           *
*       overlap.  The de-interleaved pixels are written as half-words       *
*       in LITTLE ENDIAN order.                                             *
*                                                                           *
*       Please see the IMGLIB function IMB_yc_demux_be16 for code which     *
*       handles input coming from a BIG ENDIAN device.                      *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function reads the byte-oriented pixel data, zero-extends      *
*       it, and then writes it to the appropriate result array.  Both       *
*       the luma and chroma values are expected to be unsigned.             *
*                                                                           *
*       The data is expected to be in an order consistent with reading      *
*       byte oriented data from a word-oriented peripheral that is          *
*       operating in LITTLE ENDIAN mode, while the CPU is in LITTLE         *
*       ENDIAN mode.  This function unpacks the byte-oriented data          *
*       so that further processing may proceed in LITTLE ENDIAN mode.       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays are word aligned.                           *
*       The input must be a multiple of 8 luma pixels long.                 *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop has been unrolled a total of 8 times to allow for          *
*       processing 4 pixels in each datapath.                               *
*                                                                           *
*       Word-wide loads and stores maximize memory bandwidth                *
*       utilization.                                                        *
*                                                                           *
*       The 40-bit shifter is used to exchange the luma bytes within        *
*       each word, effectively giving leftward byte rotate.                 *
*                                                                           *
*   MEMORY NOTE                                                             *
*       C6211/C6711 Two Level Cache Considerations:                         *
*                                                                           *
*       In a C6211-style system, this routine will experience cache-        *
*       related stalls, particularly if the incoming data is not present    *
*       in L1D, as is typical when the inputs are provided via DMA.         *
*                                                                           *
*       [Note:  The following analysis applies primarily to the C6211       *
*       and C6711.  It applies only in a general sense to the               *
*       cache-based C64x DSPs, and so may not be accurate in that           *
*       context.  Notably, the cache parameters on C64x differ from         *
*       C6211 and C6711.  Please consult the C6000 Peripherals              *
*       Reference Guide, SPRU190, for more information on the memory        *
*       system.]                                                            *
*                                                                           *
*       There are two primary sources of L1D cache degradation in this      *
*       code:  Read misses on the incoming YC data, and write misses on     *
*       the outgoing Y, Cb, and Cr data.                                    *
*                                                                           *
*       Read misses cost 5 cycles apiece.  In the worst case (no input      *
*       data in L1D), this results in n/16 cache misses, for a total        *
*       of 5*n/16 stall cycles.  There is little that can be done to        *
*       hide these.                                                         *
*                                                                           *
*       Write misses do not automatically stall the CPU, but rather         *
*       are placed in a 4-entry write buffer, where the writes are          *
*       subsequently processed by L2.  The L2 processes these at a rate     *
*       of 1 word every 2 cycles.  Therefore, if none of the output         *
*       arrays for this loop are in L1D, we are limited to one iteration    *
*       every 8 cycles -- that is, 5 cycles stall per iteration, for a      *
*       total of 5*n/4 stall cycles.  If the "y" buffer is brought into     *
*       L1D prior to execution, this overhead drops to 1 stall per          *
*       iteration.  If "y" and one of "Cr" or "Cb" are brought in, the      *
*       overhead due to the store buffer alone drops to zero.               *
*                                                                           *
*       Read misses and write misses interact when a write miss is          *
*       pending in the write buffer and a read miss occurs.  In the         *
*       cases where both "Cr" and "Cb" are not in L1D (and thus the         *
*       write buffer is saturated), one can show that this interaction      *
*       does not change the overall throughput.  In the case where          *
*       "y" and only one of "Cr" or "Cb" is in L1D, the write buffer        *
*       will have one element present in it when read misses occur,         *
*       and will, on average, lengthen read misses by 1 cycle.              *
*                                                                           *
*       For this hand-assembly version, it is safe to overlap the           *
*       output "y" buffer with the input "yc" buffer as long as the two     *
*       buffers start at the same location.  This effectively ensures       *
*       that the stores to the "y" array hit in L1D, and so do not use      *
*       the write buffer.  By further "touching" either "Cb" or "Cr"        *
*       into L1D, the penalty associated with the write buffer can be       *
*       reduced to zero, as discussed above.                                *
*                                                                           *
*       C620x/C670x Flat Memory Considerations:                             *
*                                                                           *
*       In the code below, accesses to the Cb and Cr arrays are allowed     *
*       to parallelize.  In order to avoid bank conflicts, one must         *
*       offset the Cb and Cr arrays by one word (two banks), or place       *
*       them in independent memory blocks.                                  *
*                                                                           *
*       This code accesses all four memory banks every cycle.  If both      *
*       input and output buffers are in the same memory block, then any     *
*       any DMAs to that block will either stall until this code            *
*       completes, or will force the CPU to stall unconditionally.          *
*       To allow DMAs to occur with minimal impact to the CPU and vice      *
*       versa, do one of the following:                                     *
*                                                                           *
*        -- Ensure that your DMAs go to a different memory block            *
*           so that DMA and CPU run independently, or                       *
*                                                                           *
*        -- Set the DMA to lower priority than the CPU, and place your      *
*           input and output buffers in different memory blocks, so         *
*           that the DMA runs during gaps in this code's access pattern.    *
*                                                                           *
*       The code spends 1/3rd of its cycles reading from the input,         *
*       1/3rd writing to 'y', and 1/3rd writing to 'Cb' and 'Cr' in         *
*       parallel.                                                           *
*                                                                           *
*       Please consult the C6000 Peripherals Reference Guide, SPRU190,      *
*       for additional information regarding memory system interactions.    *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt tolerant, but not interruptible.             *
*       Interrupts are masked for nearly its entire duration by branch      *
*       delay slots.                                                        *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 3 * (n / 4) + 18.                                          *
*       For n = 1024, cycles = 786.                                         *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       224 bytes.                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_yc_demux_le16"
        .global _IMG_yc_demux_le16
_IMG_yc_demux_le16:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_n
        .asg            B4,         B_yc
        .asg            A6,         A_y
        .asg            B6,         B_cr
        .asg            A8,         A_cb
        .asg            B3,         B_ret_addr

        .asg            A0,         A_______r0
        .asg            A1,         A_i
        .asg            A2,         A_b0__r0__
        .asg            A3,         A___y1__y0
        .asg            A4,         A_yc
        .asg            A5,         A___r2____
        .asg            A7,         A___r2__r0
        .asg            A7,         A_b0y1r0y0
        .asg            A9,         A_00000100
        .asg            B0,         B_y
        .asg            B1,         B_______b0
        .asg            B2,         B_p
        .asg            B5,         B___b2____
        .asg            B5,         B_b2__r2__
        .asg            B7,         B___y3__y2
        .asg            B8,         B___b2__b0
        .asg            B8,         B_b2y3r2y2
        .asg            B9,         B_00FF00FF
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        ADD     .L1X    B_yc,       4,          A_yc
||      SHR     .S1     A_n,        2,          A_i

        LDW     .D2T1   *B_yc++[2], A_b0y1r0y0                  ;[ 1,1]
||      LDW     .D1T2   *A_yc++[2], B_b2y3r2y2                  ;[ 1,1]

        MVKL    .S2     0x00FF00FF, B_00FF00FF
||      SUB             A_i,        1,          A_i

  [ A_i]B       .S1     loop                                    ;[ 6,1]
||      ADD     .L2X    A_y,        4,          B_y
;-
        LDW     .D2T1   *B_yc++[2], A_b0y1r0y0                  ;[ 1,2]
||      LDW     .D1T2   *A_yc++[2], B_b2y3r2y2                  ;[ 1,2]
||      MVKH    .S2     0x00FF00FF, B_00FF00FF

        MVK     .S1     0x00000100, A_00000100
||      MVK     .S2     1,          B_p
||[ A_i]SUB             A_i,        1,          A_i
; ===== 1 prolog stage collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!B_p]STW     .D1T1   A___y1__y0, *A_y++[2]                   ;[ 9,1]
||[!B_p]STW     .D2T2   B___y3__y2, *B_y++[2]                   ;[ 9,1]
||      SHRU    .S2X    A_b0__r0__, 24,         B_______b0      ;[ 9,1]
||[ A_i]B       .S1     loop                                    ;[ 6,2]
||      AND     .L1X    A_b0y1r0y0, B_00FF00FF, A___y1__y0      ;[ 6,2]
||      AND     .L2     B_b2y3r2y2, B_00FF00FF, B___y3__y2      ;[ 6,2]

        ADD     .L1     A___r2____, A_______r0, A___r2__r0      ;[10,1]
||      ADD     .S2     B___b2____, B_______b0, B___b2__b0      ;[10,1]
||      SUB     .S1     A_b0y1r0y0, A___y1__y0, A_b0__r0__      ;[ 7,2]
||      SUB     .L2     B_b2y3r2y2, B___y3__y2, B_b2__r2__      ;[ 7,2]
||      LDW     .D2T1   *B_yc++[2], A_b0y1r0y0                  ;[ 1,4]
||      LDW     .D1T2   *A_yc++[2], B_b2y3r2y2                  ;[ 1,4]
||      MPY             B_p,        0,          B_p

  [!B_p]STW     .D1T2   B___b2__b0, *A_cb++[1]                  ;[11,1]
||[!B_p]STW     .D2T1   A___r2__r0, *B_cr++[1]                  ;[11,1]
||      MPYU    .M1X    B_b2__r2__, A_00000100, A___r2____      ;[ 8,2]
||      MPYHLU  .M2X    B_b2__r2__, A_00000100, B___b2____      ;[ 8,2]
||      EXTU    .S1     A_b0__r0__, 16, 24,     A_______r0      ;[ 8,2]
||[ A_i]SUB     .L1     A_i,        1,          A_i             ;[ 5,3]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 2 epilog stages collapsed
        STW     .D1T1   A___y1__y0, *A_y                        ;[ 9,4]
||      STW     .D2T2   B___y3__y2, *B_y                        ;[ 9,4]
||      B       .S2     B_ret_addr

        NOP             2

        SHRU    .S2X    A_b0__r0__, 24,         B_______b0      ;[ 9,4]

        ADD     .L1     A___r2____, A_______r0, A___r2__r0      ;[10,4]
||      ADD     .S2     B___b2____, B_______b0, B___b2__b0      ;[10,4]

        STW     .D1T2   B___b2__b0, *A_cb                       ;[11,4]
||      STW     .D2T1   A___r2__r0, *B_cr                       ;[11,4]

* ========================================================================= *
*   End of file:  img_yc_demux_le16.asm                                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

ycbcr422p_.asm/ 1066929162  0     0     0       40237     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Sun Sep 29 03:31:31 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_ycbcr422p_rgb565 -- Planarized YCbCr 4:2:2/4:2:0 to 16-bit      *
*                               RGB 5:6:5 color space conversion.           *
*                                                                           *
*   REVISION DATE                                                           *
*       02-Sep-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and is called according to this        *
*       C prototype:                                                        *
*                                                                           *
*       void IMG_ycbcr422p_rgb565                                           *
*       (                                                                   *
*         const short         coeff[5],  /* Matrix coefficients.        */  *
*         const unsigned char *y_data,   /* Luminence data  (Y')        */  *
*         const unsigned char *cb_data,  /* Blue color-diff (B'-Y')     */  *
*         const unsigned char *cr_data,  /* Red color-diff  (R'-Y')     */  *
*         unsigned short                                                    *
*                    *restrict rgb_data, /* RGB 5:6:5 packed pixel out. */  *
*         unsigned            num_pixels /* # of luma pixels to process */  *
*       );                                                                  *
*                                                                           *
*       The 'coeff[]' array contains the color-space-conversion matrix      *
*       coefficients.  The 'y_data', 'cb_data' and 'cr_data' pointers       *
*       point to the separate input image planes.  The 'rgb_data' pointer   *
*                                                                           *
*       The kernel is designed to process arbitrary amounts of 4:2:2        *
*       image data, although 4:2:0 image data may be processed as well.     *
*       For 4:2:2 input data, the 'y_data', 'cb_data' and 'cr_data'         *
*       arrays may hold an arbitrary amount of image data, including        *
*       multiple scan lines of image data.                                  *
*                                                                           *
*       For 4:2:0 input data, only a single scan-line (or portion           *
*       thereof) may be processed at a time.  This is achieved by           *
*       calling the function twice using the same row data for              *
*       'cr_data' and 'cb_data', and providing new row data for             *
*       'y_data'.  This is numerically equivalent to replicating the Cr     *
*       and Cb pixels vertically.                                           *
*                                                                           *
*       The coefficients in the coeff array must be in signed Q13 form.     *
*       These coefficients correspond to the following matrix equation:     *
*                                                                           *
*           [ coeff[0] 0.0000   coeff[1] ]   [ Y' -  16 ]     [ R']         *
*           [ coeff[0] coeff[2] coeff[3] ] * [ Cb - 128 ]  =  [ G']         *
*           [ coeff[0] coeff[4] 0.0000   ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*       The output from this kernel is 16-bit RGB in 5:6:5 format.          *
*       The RGB components are packed into halfwords as shown below.        *
*                                                                           *
*                      15      11 10       5 4        0                     *
*                     +----------+----------+----------+                    *
*                     |   Red    |  Green   |   Blue   |                    *
*                     +----------+----------+----------+                    *
*                                                                           *
*       This kernel can also return the red, green, and blue values in      *
*       the opposite order if a particular application requires it.         *
*       This is achieved by exchanging the 'cb_data' and 'cr_data'          *
*       arguments when calling the function, and by reversing the order     *
*       of coefficients in coeff[1] through coeff[4].  This essentially     *
*       implements the following matrix multiply:                           *
*                                                                           *
*           [ coeff[0] 0.0000   coeff[4] ]   [ Y' -  16 ]     [ B']         *
*           [ coeff[0] coeff[3] coeff[2] ] * [ Cr - 128 ]  =  [ G']         *
*           [ coeff[0] coeff[1] 0.0000   ]   [ Cb - 128 ]     [ R']         *
*                                                                           *
*       The reversed RGB ordering output by this mode is as follows:        *
*                                                                           *
*                      15      11 10       5 4        0                     *
*                     +----------+----------+----------+                    *
*                     |   Blue   |  Green   |   Red    |                    *
*                     +----------+----------+----------+                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       This kernel performs Y'CbCr to RGB conversion.  From the Color      *
*       FAQ, http://home.inforamp.net/~poynton/ColorFAQ.html :              *
*                                                                           *
*           Various scale factors are applied to (B'-Y') and (R'-Y')        *
*           for different applications.  The Y'PbPr scale factors are       *
*           optimized for component analog video.  The Y'CbCr scaling       *
*           is appropriate for component digital video, JPEG and MPEG.      *
*           Kodak's PhotoYCC(tm) uses scale factors optimized for the       *
*           gamut of film colors.  Y'UV scaling is appropriate as an        *
*           intermediate step in the formation of composite NTSC or PAL     *
*           video signals, but is not appropriate when the components       *
*           are keps separate.  Y'UV nomenclature is now used rather        *
*           loosely, and it sometimes denotes any scaling of (B'-Y')        *
*           and (R'-Y').  Y'IQ coding is obsolete.                          *
*                                                                           *
*       This code can perform various flavors of Y'CbCr to RGB              *
*       conversion as long as the offsets on Y, Cb, and Cr are -16,         *
*       -128, and -128, respectively, and the coefficients match the        *
*       pattern shown.                                                      *
*                                                                           *
*       The kernel implements the following matrix form, which involves 5   *
*       unique coefficients:                                                *
*                                                                           *
*           [ coeff[0] 0.0000   coeff[1] ]   [ Y' -  16 ]     [ R']         *
*           [ coeff[0] coeff[2] coeff[3] ] * [ Cb - 128 ]  =  [ G']         *
*           [ coeff[0] coeff[4] 0.0000   ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*                                                                           *
*       Below are some common coefficient sets, along with the matrix       *
*       equation that they correspond to.   Coefficients are in signed      *
*       Q13 notation, which gives a suitable balance between precision      *
*       and range.                                                          *
*                                                                           *
*       1.  Y'CbCr -> RGB conversion with RGB levels that correspond to     *
*           the 219-level range of Y'.  Expected ranges are [16..235] for   *
*           Y' and [16..240] for Cb and Cr.                                 *
*                                                                           *
*           coeff[] = { 0x2000, 0x2BDD, -0x0AC5, -0x1658, 0x3770 };         *
*                                                                           *
*           [ 1.0000    0.0000    1.3707 ]   [ Y' -  16 ]     [ R']         *
*           [ 1.0000   -0.3365   -0.6982 ] * [ Cb - 128 ]  =  [ G']         *
*           [ 1.0000    1.7324    0.0000 ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*       2.  Y'CbCr -> RGB conversion with the 219-level range of Y'         *
*           expanded to fill the full RGB dynamic range.  (The matrix       *
*           has been scaled by 255/219.)  Expected ranges are [16..235]     *
*           for Y' and [16..240] for Cb and Cr.                             *
*                                                                           *
*           coeff[] = { 0x2543, 0x3313, -0x0C8A, -0x1A04, 0x408D };         *
*                                                                           *
*           [ 1.1644    0.0000    1.5960 ]   [ Y' -  16 ]     [ R']         *
*           [ 1.1644   -0.3918   -0.8130 ] * [ Cb - 128 ]  =  [ G']         *
*           [ 1.1644    2.0172    0.0000 ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*       3.  Y'CbCr -> BGR conversion with RGB levels that correspond to     *
*           the 219-level range of Y'.  This is equivalent to #1 above,     *
*           except that the R, G, and B output order in the packed          *
*           pixels is reversed.  Note:  The 'cr_data' and 'cb_data'         *
*           input arguments must be exchanged for this example as           *
*           indicated under USAGE above.                                    *
*                                                                           *
*           coeff[] = { 0x2000, 0x3770, -0x1658, -0x0AC5, 0x2BDD };         *
*                                                                           *
*           [ 1.0000    0.0000    1.7324 ]   [ Y' -  16 ]     [ B']         *
*           [ 1.0000   -0.6982   -0.3365 ] * [ Cr - 128 ]  =  [ G']         *
*           [ 1.0000    1.3707    0.0000 ]   [ Cb - 128 ]     [ R']         *
*                                                                           *
*       4.  Y'CbCr -> BGR conversion with the 219-level range of Y'         *
*           expanded to fill the full RGB dynamic range.  This is           *
*           equivalent to #2 above, except that the R, G, and B output      *
*           order in the packed pixels is reversed.  Note:  The             *
*           'cr_data' and 'cb_data' input arguments must be exchanged       *
*           for this example as indicated under USAGE above.                *
*                                                                           *
*           coeff[] = { 0x2000, 0x408D, -0x1A04, -0x0C8A, 0x3313 };         *
*                                                                           *
*           [ 1.0000    0.0000    2.0172 ]   [ Y' -  16 ]     [ B']         *
*           [ 1.0000   -0.8130   -0.3918 ] * [ Cr - 128 ]  =  [ G']         *
*           [ 1.0000    1.5960    0.0000 ]   [ Cb - 128 ]     [ R']         *
*                                                                           *
*       Other scalings of the color differences (B'-Y') and (R'-Y')         *
*       (sometimes incorrectly referred to as U and V) are supported, as    *
*       long as the color differences are unsigned values centered around   *
*       128 rather than signed values centered around 0, as noted above.    *
*                                                                           *
*       In addition to performing plain color-space conversion, color       *
*       saturation can be adjusted by scaling coeff[1] through coeff[4].    *
*       Similarly, brightness can be adjusted by scaling coeff[0].          *
*       General hue adjustment can not be performed, however, due to the    *
*       two zeros hard-coded in the matrix.                                 *
*                                                                           *
*   TECHNIQUES                                                              *
*       Pixel replication is performed implicitly on chroma data to         *
*       reduce the total number of multiplies required.  The chroma         *
*       portion of the matrix is calculated once for each Cb, Cr pair,      *
*       and the result is added to both Y' samples.                         *
*                                                                           *
*       Luma is biased downwards to produce R, G, and B values that are     *
*       signed quantities centered around zero, rather than unsigned qtys.  *
*       This allows us to use SSHL to perform saturation, followed by a     *
*       quick XOR to correct the sign bits in the final packed pixels.      *
*       The required downward bias is 128 shifted left by the Q-point, 13.  *
*                                                                           *
*       To save two instructions, "(y0-16)*luma - (128<<13)" is transformed *
*       to the slightly more cryptic "y0*luma - (16*luma + (128<<13))".     *
*       This gives the non-obvious but effective y_bias value               *
*       -((128 << 13) + 16*luma).  The transformation allows the loop to    *
*       fit in 6 cycles.                                                    *
*                                                                           *
*       Twin pointers are used for the stack and coeff[] arrays for speed.  *
*                                                                           *
*       Because the loop accesses four different arrays at three different  *
*       strides, no memory accesses are allowed to parallelize in the       *
*       loop.  No bank conflicts occur, as a result.                        *
*                                                                           *
*       Creatively constructed multiplies are used to avoid a bottleneck    *
*       on shifts in the loop.  In particular, the 5-bit mask 0xF8000000    *
*       doubles as a right-shift constant that happens to negate while      *
*       shifting.  This negation is reversed by merging the bits with a     *
*       SUB instead of an ADD or OR.                                        *
*                                                                           *
*       Prolog and epilog collapsing have been performed, with only a       *
*       partial stage of prolog and epilog left uncollapsed.  The partial   *
*       stages are interscheduled with the rest of the code for speed.      *
*                                                                           *
*       The stack pointer is saved in IRP to allow all 32 registers to      *
*       be used in the loop.  This enabled prolog collapsing by freeing     *
*       up a predicate register.  The prolog collapse counter is            *
*       implemented as a MPY which shifts a constant left by 3 bits each    *
*       iteration.  The counter is initialized from one of the other        *
*       constant registers, thereby reducing the S-unit bottleneck in the   *
*       setup code.                                                         *
*                                                                           *
*       Instructions have been scheduled to minimize fetch-packet padding   *
*       NOPs.  Only 3 padding NOPs and 1 explicit NOP remain.               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       An even number of luma samples needs to be processed.               *
*                                                                           *
*       The output image must be word aligned.                              *
*                                                                           *
*   NOTES                                                                   *
*       No bank conflicts occur.                                            *
*                                                                           *
*       This kernel is interrupt tolerant, but not interruptible.           *
*       Interrupts are masked for 37 + (num_pixels * 3) cycles.             *
*                                                                           *
*   MEMORY NOTES                                                            *
*       On average, one bank per cycle is accessed on a C6201 in the loop,  *
*       with 1 cycle of 6 accessing no banks, and 1 cycle accessing two.    *
*                                                                           *
*       The kernel requires 14 words of stack space.                        *
*                                                                           *
*       This is a little-endian implementation                              *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 46 + (num_pixels * 3).                                     *
*                                                                           *
*       This number includes 6 cycles of function-call overhead.  The       *
*       exact overhead will vary according to the compiler options used.    *
*                                                                           *
*   CODESIZE                                                                *
*       512 bytes.                                                          *
*                                                                           *
*   SOURCE                                                                  *
*       Poynton, Charles et al.  "The Color FAQ,"  1999.                    *
*           http://home.inforamp.net/~poynton/ColorFAQ.html                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

                .sect ".data:copyright_h"

        .sect ".text:_ycbcr422pl_to_rgb565"
        .global _IMG_ycbcr422p_rgb565
_IMG_ycbcr422p_rgb565:
; =============== SYMBOLIC REGISTER ASSIGNMENTS: ARGUMENTS ================ ;
        .asg            A4,         A_coef      ; Coefficients table
        .asg            B4,         B_y_data    ; Pointer to luma
        .asg            A6,         A_cb_data   ; Pointer to B-Y
        .asg            B6,         B_cr_data   ; Pointer to R-Y
        .asg            A8,         A_rgb_data  ; Pointer to RGB output
        .asg            B8,         B_num_pix   ; # of pixels to process
; ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A3,         A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_noGIE     ; CSR w/ GIE bit cleared
        .asg            B2,         B_irp       ; IRP's value
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
        .asg            B7,         B_coef      ; Twin coefficients ptr.
        .asg            A13,        A_rcr       ; Cr's contribution to Red
        .asg            B14,        B_bcb       ; Cb's contribution to Blu
        .asg            A5,         A_gcr_      ; Cr's contribution to Grn
        .asg            A5,         A_gcr       ; A_gcr_ << 16
        .asg            B5,         B_gcb_      ; Cb's contribution to Grn
        .asg            B5,         B_gcb       ; B_gcb_ << 16
        .asg            A1,         A_lneg      ; luma coeff[0] < 0
; ================= SYMBOLIC REGISTER ASSIGNMENTS: KERNEL ================= ;
        .asg            B0,         B_p         ; Prolog collapse counter
        .asg            A2,         A_i         ; Loop trip counter
        .asg            A10,        A_y_ptr     ; Luma data pointer
        .asg            B15,        B_cb_ptr    ; B-Y data pointer
        .asg            B6,         B_cr_ptr    ; R-Y data pointer
        .asg            B11,        B_rgb_ptr   ; RGB output data pointer
        .asg            B12,        B_k32_k128  ; Constant 0x00200080
        .asg            A11,        A_k32_k128  ; Constant 0x00200080
        .asg            A12,        A_one_lum   ; Constant 1 packed w/coeff[0]
        .asg            A13,        A_gcr_rcr   ; coeff[3], coeff[1] packed
        .asg            B14,        B_gcb_bcb   ; coeff[2], coeff[4] packed
        .asg            B10,        B_y_bias    ; -((128<<13) + 16*coeff[0])
        .asg            B13,        B_ms5       ; Mask:  upper 5 bits
        .asg            A14,        A_ms6       ; Mask:  upper 6 bits
        .asg            A15,        A_sflip     ; Sign-flip const 0x84108410
        .asg            A0,         A_y0        ; y0 value from y_data[]
        .asg            B4,         B_y1        ; y1 value from y_data[]
        .asg            B1,         B_cb_       ; cb value prior to level shift
        .asg            A3,         A_cr_       ; cr value prior to level shift
        .asg            B3,         B_cb        ; level-shifted cb value.
        .asg            A4,         A_cr        ; level-shifted cr value
        .asg            B5,         B_y1t_      ; scaled y1, before level shift
        .asg            A3,         A_y0t_      ; scaled y0, before level shift
        .asg            B9,         B_y1t       ; scaled, level-shifted y1
        .asg            A5,         A_y0t       ; scaled, level-shifted y0
        .asg            B3,         B_bt        ; Scaled blue color-diff
        .asg            B1,         B_gt_       ; Scaled green color-diff (a)
        .asg            A8,         A_gt_       ; Scaled green color-diff (b)
        .asg            A6,         A_gt        ; Scaled green color-diff
        .asg            A9,         A_rt        ; Scaled red color-diff
        .asg            B1,         B_r1        ; Pixel 1 red  (16Q16)
        .asg            B3,         B_g1        ; Pixel 1 grn  (17Q15)
        .asg            B4,         B_b1        ; Pixel 1 blu  (16Q16)
        .asg            A3,         A_r0        ; Pixel 0 red  (16Q16)
        .asg            A5,         A_g0        ; Pixel 0 grn  (17Q15)
        .asg            A0,         A_b0        ; Pixel 0 blu  (16Q16)
        .asg            B5,         B_r1s       ; Saturated pixel 1 red (5Q27)
        .asg            B4,         B_g1s       ; Saturated pixel 1 grn (6Q26)
        .asg            B5,         B_b1s       ; Saturated pixel 1 blu (5Q27)
        .asg            A1,         A_r0s       ; Saturated pixel 0 red (5Q27)
        .asg            A4,         A_g0s       ; Saturated pixel 0 grn (6Q26)
        .asg            A4,         A_b0s       ; Saturated pixel 0 blu (5Q27)
        .asg            B8,         B_r1t       ; Truncated pixel 1 red
        .asg            B7,         B_g1t       ; Truncated pixel 1 grn
        .asg            B2,         B_b1t       ; Truncated pixel 1 blu
        .asg            A7,         A_r0t       ; Truncated pixel 0 red
        .asg            A4,         A_g0t       ; Truncated pixel 0 grn
        .asg            A5,         A_b0t       ; Truncated pixel 0 blu
        .asg            B2,         B_g1f       ; Pixel 1 grn in final position
        .asg            B1,         B_b1f       ; Pixel 1 blu in final position
        .asg            B8,         B_r_b1      ; Pixel 1 red, blue merged
        .asg            B4,         B_rgb1      ; Pixel 1 red, grn, blu merged
        .asg            A3,         A_g0f       ; Pixel 0 grn in final position
        .asg            A6,         A_b0f       ; Pixel 0 blu in final position
        .asg            A7,         A_r_b0      ; Pixel 0 red, blue merged
        .asg            A9,         A_rgb0_     ; Pixel 0 red, grn, blu merged
        .asg            A6,         A_rgb0      ; Pixel 0 in low half word
        .asg            B5,         B_rgb_      ; Combined pixels pre-sign-fix
        .asg            B7,         B_rgb       ; Combined pixels w/ sign-fix
; ========================================================================= ;
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, IRP
;-
        STW     .D2T1   A15,        *B_SP--[14]         ; Save A15, get stack
||      MVC     .S2     CSR,        B_csr               ; Capture CSR's state
||      MV      .L2X    A_coef,     B_coef              ; Twin coef pointer
||      MVK     .S1     0xFFFF8410, A_sflip             ; Sign-flip cst, low

        MV      .S1X    B_SP,       A_SP                ; Twin Stack Pointer
||      AND     .L2     B_csr,      -2,         B_noGIE ; Clear GIE
||      LDHU    .D1T2   *A_coef[2], B_gcb_              ; gcb = coeff[2]
||      LDHU    .D2T1   *B_coef[3], A_gcr_              ; gcb = coeff[3]
;-
        STW     .D1T1   A14,        *+A_SP[12]          ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]          ; Save B14
||      MVC     .S2     B_noGIE,    CSR                 ; Disable interrupts
||      ZERO    .L1     A_ms6                           ; Mask 6, low
; ===== Interrupts masked here =====
        STW     .D1T1   A13,        *+A_SP[10]          ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]          ; Save B13
||      MVC     .S2     IRP,        B_irp               ; Capture IRP's state
||      ZERO    .L2     B_ms5                           ; Mask 5, low
;-
        STW     .D1T1   A12,        *+A_SP[ 8]          ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]          ; Save B12
||      MVC     .S2     B_SP,       IRP                 ; Save SP in IRP
||      MVKLH   .S1     0xFC00,     A_ms6               ; Mask 6, high

        LDH     .D1T1   *A_coef[0], A_one_lum           ; lum = coeff[0]
||      MV      .L1X    B_csr,      A_csr               ; Partitioning MV

        STW     .D1T1   A11,        *+A_SP[ 6]          ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]          ; Save B11
;-
        LDHU    .D2T1   *B_coef[1], A_rcr               ; rcr = coeff[1]
||      LDHU    .D1T2   *A_coef[4], B_bcb               ; rcr = coeff[2]

        STW     .D1T1   A10,        *+A_SP[ 4]          ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]          ; Save B10
||      MV      .L1X    B_y_data,   A_y_ptr             ; Partitioning MV

        STW     .D1T1   A_csr,      *+A_SP[ 2]          ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]          ; Save return address
||      MVK     .S2     128,        B_k32_k128          ; Constant: 128
;-
; =========================== PIPE LOOP PROLOG ============================ ;
        LDBU    .D2T1   *B_cr_ptr++,            A_cr_   ;[ 1,1] cr = *cr_ptr++
||      AND     .L1X    B_num_pix,  -2,         A_i     ; Make num_pix even
||      MV      .L2X    A_cb_data,  B_cb_ptr            ; Partitioning MV
||      MVKLH   .S1     1,          A_one_lum           ; Constant: 1
||      MVKLH   .S2     32,         B_k32_k128          ; Constant: 32
||      MPY     .M2     B_k32_k128, 1,          B_p     ; Prolog collapse count
||      MPYH    .M1     A_one_lum,  A_one_lum,  A_lneg  ; lneg = coeff[0] < 0
;-
        LDBU    .D1T1   *A_y_ptr++[2],          A_y0    ;[ 2,1] y0 = *y_ptr++
||      SHL     .S2X    A_one_lum,  4,          B_y_bias; ((128<<13)+16*luma)
||      MVKH    .S1     0x84108410, A_sflip             ; Sign-flip cst, high

        LDBU    .D2T2   *B_cb_ptr++,            B_cb_   ;[ 3,1] cb = *cb_ptr++
||      ADD     .D1     A_i,        2,          A_i     ; Adjust for para iter
||      SHL     .S1     A_lneg,     20,         A_lneg  ; Handle luma < 0
||      MV      .L1X    B_k32_k128, A_k32_k128          ; Twin constant reg.
||      MV      .L2X    A_rgb_data, B_rgb_ptr           ; Partitioning MV
;-
        LDBU    .D1T2   *-A_y_ptr[1],           B_y1    ;[ 4,1] y1 = *y_ptr++
||      SHL     .S1     A_gcr_,     16,         A_gcr   ; Put gcr in high half
||      SHL     .S2     B_gcb_,     16,         B_gcb   ; Put gcb in high half
||      SUB     .L2X    B_y_bias,   A_lneg,     B_y_bias; Sign bit, coeff[0]<0

        STW     .D1T2   B_irp,      *+A_SP[13]          ; Save IRP
||      ADD     .L1     A_gcr,      A_rcr,      A_gcr_rcr ; Merge gcr, rcr
||      ADD     .L2     B_gcb,      B_bcb,      B_gcb_bcb ; Merge gcb, rcb
||      MVKLH   .S2     0xF800,     B_ms5               ; Mask 5, high
;-
; =========================== PIPE LOOP KERNEL ============================ ;
conv_loop:
  [ A_i]B       .S1     conv_loop                       ;[24,1] while (i)
||      ADD     .L2X    B_rgb1,     A_rgb0,     B_rgb_  ;[24,1] merge pix 0, 1
||      MPYHUS  .M1X    A_g0t,      B_ms5,      A_g0f   ;[18,2] >> 5 and negate
||      SSHL    .S2     B_g1,       11,         B_g1s   ;[18,2] g1s = sat(g1)
||      ADD     .D1     A_y0t,      A_rt,       A_r0    ;[12,3] r0  = y0t + rt
||      SUB     .D2     B_y1t_,     B_y_bias,   B_y1t   ;[12,3] y1t-= y_bias
||      SUB     .L1     A_cr_,      A_k32_k128, A_cr    ;[ 6,4] cr -= 128
||      MPYUS   .M2     B_p,        8,          B_p     ; prolog collapse count
;-
        ADD     .D1     A_r0t,      A_b0f,      A_r_b0  ;[19,2] Merge r0, b0
||      MPYHU   .M2     B_b1t,      B_k32_k128, B_b1f   ;[19,2] >> 11
||      AND     .S2X    B_g1s,      A_ms6,      B_g1t   ;[19,2] g1t = g1s & ms6
||      SSHL    .S1     A_r0,       11,         A_r0s   ;[13,3] r0s = sat(r0)
||      ADD     .L2     B_y1t,      B_bt,       B_b1    ;[13,3] b1  = y1t + bt
||      ADD     .L1X    B_gt_,      A_gt_,      A_gt    ;[13,3]gt=gcr*cr+gcb*cb
||      MPYLH   .M1     A_cr,       A_gcr_rcr,  A_gt_   ;[ 7,4] gcr *c r
||      LDBU    .D2T1   *B_cr_ptr++,            A_cr_   ;[ 1,5] cr  = *cr_ptr++
;-
        XOR     .L2X    B_rgb_,     A_sflip,    B_rgb   ;[26,1] Fix sign bits
||      MPYHUS  .M2     B_g1t,      B_ms5,      B_g1f   ;[20,2] >> 5 and negate
||      SSHL    .S2     B_b1,       11,         B_b1s   ;[14,3] b1s = sat(b1)
||      ADD     .L1X    A_y0t,      B_bt,       A_b0    ;[14,3] b0  = y0t + bt
||      ADD     .S1     A_y0t,      A_gt,       A_g0    ;[14,3] g0  = y0t + gt
||      MPY     .M1     A_y0,       A_one_lum,  A_y0t_  ;[ 8,4] y0t = y0 * luma
||      SUB     .D2     B_cb_,      B_k32_k128, B_cb    ;[ 8,4] cb -= 128
||      LDBU    .D1T1   *A_y_ptr++[2],          A_y0    ;[ 2,5] y0  = *y_ptr++
;-
        SUB     .D1     A_r_b0,     A_g0f,      A_rgb0_ ;[21,2] merge r0,g0,b0
||      ADD     .L2     B_r1t,      B_b1f,      B_r_b1  ;[21,2] merge r1, b1
||      AND     .L1X    A_r0s,      B_ms5,      A_r0t   ;[15,3] r0s = r0t & ms5
||      SSHL    .S1     A_b0,       11,         A_b0s   ;[15,3] b0s = sat(b0)
||      ADD     .S2X    B_y1t,      A_rt,       B_r1    ;[15,3] r1  = y1t + rt
||      MPY     .M1     A_cr,       A_gcr_rcr,  A_rt    ;[ 9,4] rt  = rcr * cr
||      MPYLH   .M2     B_cb,       B_gcb_bcb,  B_gt_   ;[ 9,4] gcb * cb
||      LDBU    .D2T2   *B_cb_ptr++,            B_cb_   ;[ 3,5] cb  = *cb_ptr++
;-
        MPYHU   .M1     A_rgb0_,    A_one_lum,  A_rgb0  ;[22,2] rgb0 in lo half
||      SUB     .D2     B_r_b1,     B_g1f,      B_rgb1  ;[22,2] merge r1,g1,b1
||      AND     .L1X    A_b0s,      B_ms5,      A_b0t   ;[16,3] b0t = b0s & ms5
||      AND     .L2     B_b1s,      B_ms5,      B_b1t   ;[16,3] b1t = b1s & ms5
||      SSHL    .S1     A_g0,       11,         A_g0s   ;[16,3] g0s = sat(g0)
||      SSHL    .S2     B_r1,       11,         B_r1s   ;[16,3] r1s = sat(r1)
||      MPY     .M2X    B_y1,       A_one_lum,  B_y1t_  ;[10,4] y1t = y1 * luma
||      LDBU    .D1T2   *-A_y_ptr[1],           B_y1    ;[ 4,5] y1  = *y_ptr++
;-
  [!B_p]STW     .D2T2   B_rgb,      *B_rgb_ptr++        ;[29,1] *rgb_ptr++=rgb
||      SUB     .D1     A_i,        2,          A_i     ;[23,2] i -= 2
||      MPYHU   .M1     A_b0t,      A_k32_k128, A_b0f   ;[17,3] >> 11
||      AND     .L1     A_g0s,      A_ms6,      A_g0t   ;[17,3] g0t = g0s & ms6
||      AND     .L2     B_r1s,      B_ms5,      B_r1t   ;[17,3] r1t = r1s & ms5
||      ADD     .S2X    B_y1t,      A_gt,       B_g1    ;[17,3] g1  = y1t + gt
||      MPY     .M2     B_cb,       B_gcb_bcb,  B_bt    ;[11,4] bt  = bcb * cb
||      SUB     .S1X    A_y0t_,     B_y_bias,   A_y0t   ;[11,4] y0t-= y_bias
; =========================== PIPE LOOP EPILOG ============================ ;

; ================ SYMBOLIC REGISTER ASSIGNMENTS: CLEANUP ================= ;
        .asg            B15,        B_SP                ; Stack ptr, B side
        .asg            A3,         A_SP                ; Stack ptr, A side
        .asg            A0,         A_csr               ; CSR value
        .asg            B0,         B_irp               ; IRP value
        .asg            B3,         B_ret               ; Return address
; ========================================================================= ;
;-
        MVC     .S2     IRP,        B_SP                ; Restore stack ptr
||      ADD     .L2X    B_rgb1,     A_rgb0,     B_rgb_  ;[24,5] merge pix 0, 1

        MV      .L1X    B_SP,       A_SP                ; Twin Stack Pointer
||      LDW     .D2T2   *+B_SP[13], B_irp               ; Get IRP's value

        LDW     .D1T2   *+A_SP[ 1], B_ret               ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr               ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 3], B10                 ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10                 ; Restore A10
;-
        LDW     .D1T2   *+A_SP[11], B14                 ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14                 ; Restore A14
||      XOR     .L2X    B_rgb_,     A_sflip,    B_rgb   ;[26,5] fix sign bits

        LDW     .D1T2   *+A_SP[ 7], B12                 ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12                 ; Restore A12

        LDW     .D1T2   *+A_SP[ 9], B13                 ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13                 ; Restore A13
||      MVC     .S2     B_irp,      IRP                 ; Restore IRP
;-
        LDW     .D1T2   *+A_SP[ 5], B11                 ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11                 ; Restore A11
||      RET     .S2     B_ret                           ; Return to caller

        MVC     .S2X    A_csr,      CSR                 ; Restore CSR
||      LDW     .D2T1   *++B_SP[14],A15                 ; Restore A15
; ===== Interruptibility state (GIE) restored here =====

        STW     .D2T2   B_rgb,      *B_rgb_ptr          ;[29,5] *rgb_ptr++=rgb

        NOP             3

; ===== Branch occurs =====
; ===== Interrupts may occur here =====

* ========================================================================= *
*   End of file:  img_ycbcr422p_rgb565.asm                                  *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

