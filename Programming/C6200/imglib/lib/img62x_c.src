!<arch>
boundary.c/     1066929161  0     0     0       5698      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.2     Wed Jul 11 06:21:06 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_boundary -- Returns coordinates of IMG_boundary pixels.         */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      10-Jul-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C callable, and is called as follows:               */
/*                                                                          */
/*          void IMG_boundary                                               */
/*          (                                                               */
/*              const unsigned char *restrict i_data,                       */
/*              int rows, int cols,                                         */
/*              int *restrict o_coord,                                      */
/*              int *restrict o_grey                                        */
/*          );                                                              */
/*                                                                          */
/*      The arguments are defined as follows:                               */
/*                                                                          */
/*          i_data   Input images that is cols-by-rows in size.             */
/*          rows     Height of the input image                              */
/*          cols     Width of the input image                               */
/*          o_coord  Array to write output coordinates to                   */
/*          o_grey   Array to write output grey levels to                   */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This routine scans an image looking for non-zero pixels.            */
/*      The locations of those pixels are stored out to the o_coord         */
/*      as packed Y/X pairs, with Y in the upper half, and X in             */
/*      the lower half.  The grey levels encountered are stored             */
/*      in the o_grey array in parallel.                                    */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void IMG_boundary
(
    const unsigned char *restrict i_data,
    int rows, int cols,
    int *restrict o_coord,
    int *restrict o_grey
)
{
    int x, y, p;

    for (y = 0; y < rows; y++)
        for (x = 0; x < cols; x++)
            if ((p = *i_data++) != 0)
            {
                *o_coord++ = ((y & 0xFFFF) << 16) | (x & 0xFFFF);
                *o_grey++  = p;
            }
}

/* ======================================================================== */
/*  End of file:  img_boundary.c                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
conv_3x3.c/     1066929161  0     0     0       8861      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Tue Mar 12 04:21:09 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_conv_3x3 -- 3x3 convolution                                     */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      21-Jul-2000                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*         void IMG_conv_3x3(const unsigned char *restrict inptr,           */
/*                             unsigned char *restrict outptr,              */
/*                             int            x_dim,                        */
/*                             const          char *restrict mask,          */
/*                             int            shift)                        */
/*                                                                          */
/*      The IMG_conv_3x3 routine accepts three rows of 'x_dim' input points */
/*      and performs some operation on each.  A total of 'x_dim' outputs    */
/*      are written to the output array. The 'mask' array has the 3 by 3    */
/*      array of coefficients.                                              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The IMG_conv_3x3 kernel accepts three rows of 'x_dim' input points  */
/*      and produces one output row of 'x_dim' points using the input mask  */
/*      of 3 by 3. The user defined shift value is used to shift the convo- */
/*      lution value, down to the byte range. The IMG_conv_3x3 sum is also  */
/*      range limited to 0..255.                                            */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The inner loop that performs the convolution sum is unrolled thrice,*/
/*      so that three convolution products are calculated together. There-  */
/*      fore the inner loop iterates only 3 times, to accomplish the nine   */
/*      convolution sums.                                                   */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      No assumptions arer made on any allignment in this code.            */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void IMG_conv_3x3(const unsigned char   *restrict inptr,
                 unsigned char          *restrict outptr,
                 int                    x_dim,
                 const char             *restrict mask,
                 int                    shift)
{
     const   unsigned char   *IN1,*IN2,*IN3;
     unsigned char           *OUT;

     short    pix10,  pix20,  pix30;
     short    mask10, mask20, mask30;

     int      sum,      sum00,  sum11;
     int      i;
     int      sum22,    j;

     /*-------------------------------------------------------------------*/
     /* Set imgcols to the width of the image and set three pointers for  */
     /* reading data from the three input rows. Alos set the output poin- */
     /* ter.                                                              */
     /*-------------------------------------------------------------------*/

     IN1      =   inptr;
     IN2      =   IN1 + x_dim;
     IN3      =   IN2 + x_dim;
     OUT      =   outptr;

     /*-------------------------------------------------------------------*/
     /* The j: loop iterates to produce one output pixel per iteration.   */
     /* The mask values and the input values are read using the i loop.   */
     /* The convolution sum is then computed. The convolution sum is      */
     /* then shifted and range limited to 0..255                          */
     /*-------------------------------------------------------------------*/

     for (j = 0; j < x_dim ; j++)
     {
         /*---------------------------------------------------------------*/
         /* Initialize convolution sum to zero, for every iteration of    */
         /* outer loop. The inner loop computes convolution sum.          */
         /*---------------------------------------------------------------*/

         sum = 0;

         for (i = 0; i < 3; i++)
         {
             pix10  =   IN1[i];
             pix20  =   IN2[i];
             pix30  =   IN3[i];

             mask10 =   mask[i];
             mask20 =   mask[i + 3];
             mask30 =   mask[i + 6];

             sum00  =   pix10 * mask10;
             sum11  =   pix20 * mask20;
             sum22  =   pix30 * mask30;

             sum   +=   sum00 + sum11+ sum22;
         }

         /*---------------------------------------------------------------*/
         /*  Increment input pointers and shift sum and range limit to    */
         /*  0..255.                                                      */
         /*---------------------------------------------------------------*/

         IN1++;
         IN2++;
         IN3++;

         sum = (sum >> shift);

         if ( sum <  0  )       sum = 0;
         if ( sum > 255 )       sum = 255;

         /*--------------------------------------------------------------*/
         /* Store output sum into the output pointer OUT                 */
         /*--------------------------------------------------------------*/

         *OUT++   =       sum;
     }
}

/* ======================================================================== */
/*  End of file:  img_conv_3x3.c                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

corr_3x3.c/     1066929161  0     0     0       7810      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.1     Fri Mar 15 19:57:31 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      corr_3x3: 3x3 correlation with rounding for 8 bit data              */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      14-Mar-2002                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*          void IMG_corr_3x3                                               */
/*          (                                                               */
/*              const unsigned char *i_data,       // input image       //  */
/*              int        *restrict o_data,       // output image      //  */
/*              const unsigned char  mask[3][3],   // convolution mask  //  */
/*              int                  x_dim,        // width of image    //  */
/*              int                  n_out         // number of outputs //  */
/*          );                                                              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The correlation performs a point by point multiplication of the     */
/*      3 by 3 mask with the input image.  The result of the nine           */
/*      multiplications are then summed up together to produce a            */
/*      convolution sum.  This sum is then stored to the output array.      */
/*                                                                          */
/*      The image mask to be correlated is typically part of the input      */
/*      image and indicates the area of the best match between the          */
/*      input image and mask.  The mask is moved one column at a time,      */
/*      advancing the mask over the portion of the row specified by         */
/*      'n_out'.  When 'n_out' is larger than 'x_dim', multiple rows        */
/*      will be processed.                                                  */
/*                                                                          */
/*      An application may call this kernel once per row to calculate       */
/*      the correlation for an entire image:                                */
/*                                                                          */
/*          for (i = 0; i < rows; i++)                                      */
/*          {                                                               */
/*              IMG_corr_3x3(&i_data[i * x_dim], &o_data[i * n_out],        */
/*                          mask, x_dim, n_out);                            */
/*          }                                                               */
/*                                                                          */
/*      Alternately, the kernel may be invoked for multiple rows at         */
/*      a time, although the two outputs at the end of each row will        */
/*      have meaningless values.  For example:                              */
/*                                                                          */
/*          IMG_corr_3x3(i_data, o_data, mask, x_dim, 2 * x_dim);           */
/*                                                                          */
/*      This will produce two rows of outputs into 'o_data'.  The           */
/*      outputs at locations o_data[x_dim - 2], o_data[x_dim - 1],          */
/*      o_data[2*x_dim - 2] and o_data[2*x_dim - 1] will have               */
/*      meaningless values.  This is harmless, although the application     */
/*      will have to account for this when interpreting the results.        */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The array pointed to by o_data does not alias with the array        */
/*      pointed to by i_data or mask.                                       */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void IMG_corr_3x3
(
    const unsigned char *i_data,       /* input image       */
    int        *restrict o_data,       /* output image      */
    const unsigned char  mask[3][3],   /* convolution mask  */
    int                  x_dim,        /* width of image    */
    int                  n_out         /* number of outputs */
)
{
    int i, j, k;

    for (i = 0; i < n_out; i++)
    {
        int sum = 0;

        for (j = 0; j < 3; j++)
            for (k = 0; k < 3; k++)
                sum += i_data[j * x_dim + i + k] * mask[j][k];

        o_data[i] = sum;
    }
}
/* ======================================================================== */
/*  End of file:  img_corr_3x3.c                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
corr_gen.c/     1066929161  0     0     0       6249      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.5     Tue Mar 12 04:25:43 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================= */
/*                                                                         */
/*  TEXAS INSTRUMENTS, INC.                                                */
/*                                                                         */
/*  NAME                                                                   */
/*      IMG_corr_gen                                                       */
/*                                                                         */
/*  REVISION DATE                                                          */
/*      20-Sep-1999                                                        */
/*                                                                         */
/*  USAGE                                                                  */
/*      This routine is C callable, and has the following C prototype:     */
/*                                                                         */
/*      void IMG_corr_gen                                                  */
/*      (                                                                  */
/*          short *in_data,      //  Input: pixel array           //       */
/*          short *h,            //  Input: 1-by-M mask           //       */
/*          short *out_data,     //  Output: correlation sum      //       */
/*          int M,               //  Input: # of filter taps      //       */
/*          int cols             //  Input: Width of input image  //       */
/*      );                                                                 */
/*                                                                         */
/*  DESCRIPTION                                                            */
/*      This routine performs a generalized correlation with a 1 by M      */
/*      tap filter. It can be called repetitively to form an arbitrary     */
/*      M by n 2D generalized correlation kernel.  The correlation sum     */
/*      is currently stored as half words.  The input pixel, and mask      */
/*      data is assumed to come in as shorts.  No restrictions are         */
/*      placed cols and M.                                                 */
/*                                                                         */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================= */

void IMG_corr_gen(short *x, short *h, short *y, int  m, int x_dim )
{

     int            i, j, sum, iters;
     short          *xptr, *hptr;

  /*========================================================================*/
  /* Set xptr and hptr to point to the start of the image and filter arrays */
  /* At the start of evry iteration hptr resets to the start of the filter  */
  /* while xptr advances by 1 pixel. sum is used to read the previous sum   */
  /* for this output pixel that was computed for a previous line as in the  */
  /* case of a 2D filter. The convolution sum is then accumulated into the  */
  /* existing sum. This read from memory and accumulation into the previous */
  /* sum allows this kernel to be used for a 2D generalized correlation     */
  /* kernel. The correlation sum is then computed for the m tap filter and  */
  /* accumulated into the existing sum. This is then stored out back into   */
  /* memory.                                                                */
  /*========================================================================*/

     xptr  = x;
     hptr  = h;

     iters  = (x_dim - m) ;

     for (j = 0; j < iters; j++)
     {
          sum =  y[j];

          for (i = 0; i < m; i++)
          {
               sum += xptr[i + j] * hptr[i];
          }

          y[j] = sum;
     }
}

/*============================================================================*/
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/*============================================================================*/

dilate_bin.c/   1066929161  0     0     0       12701     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Wed Nov 29 09:44:25 2000 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_dilate_bin-- This code performs 3x3 binary dilation             */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      29-Nov-2000                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void IMG_dilate_bin                                                 */
/*      (                                                                   */
/*          const unsigned char *restrict in_data,   // Incoming image  //  */
/*          unsigned char       *restrict out_data,  // Filtered output //  */
/*          const char          *restrict mask,      // Filter mask     //  */
/*          int cols  // Number of columns to process, in bytes.        //  */
/*      );                                                                  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The function IMG_dilate_bin() implements binary dilation using an   */
/*      arbitrary 3x3 mask.  The dilation operator generates output pixels  */
/*      by ORing the pixels under the input mask together to generate       */
/*      the output pixel.  The input mask specifies whether one or more     */
/*      pixels from the input are to be ignored.                            */
/*                                                                          */
/*      In pseudo-code, the filtering operation for a pixel at (x, y)       */
/*      works like so:                                                      */
/*                                                                          */
/*          result = 0;                                                     */
/*          if (mask[0][0] != DONT_CARE) result |= input[y + 0][x + 0];     */
/*          if (mask[0][1] != DONT_CARE) result |= input[y + 1][x + 1];     */
/*          if (mask[0][2] != DONT_CARE) result |= input[y + 2][x + 2];     */
/*          if (mask[1][0] != DONT_CARE) result |= input[y + 0][x + 0];     */
/*          if (mask[1][1] != DONT_CARE) result |= input[y + 1][x + 1];     */
/*          if (mask[1][2] != DONT_CARE) result |= input[y + 2][x + 2];     */
/*          if (mask[2][0] != DONT_CARE) result |= input[y + 0][x + 0];     */
/*          if (mask[2][1] != DONT_CARE) result |= input[y + 1][x + 1];     */
/*          if (mask[2][2] != DONT_CARE) result |= input[y + 2][x + 2];     */
/*          output[y][x] = result;                                          */
/*                                                                          */
/*      For this code, "DONT_CARE" is specified by a negative value         */
/*      in the input mask.  Non-negative values in the mask cause the       */
/*      corresponding pixel to be included in the dilation operation.       */
/*                                                                          */
/*      Note that this code operates on a bitmap where each pixel is        */
/*      represented as a single bit within a byte or word.  Although        */
/*      the pseudo-code above operates only on one pixel at a time,         */
/*      with a single pixel in each array element, this implementation      */
/*      operates on a bitmap which contains 8 pixels in each byte.          */
/*                                                                          */
/*      Pixels are organized within each byte such that the pixel with      */
/*      the smallest index is in the LSB position, and the pixel with       */
/*      the largest index is in the MSB position.  (That is, the code       */
/*      assumes a LITTLE ENDIAN bit ordering.)                              */
/*                                                                          */
/*      Note that the "cols" argument actually specifies the number of      */
/*      BYTES in the output, not the number of columns.  The number of      */
/*      columns is 8 times this argument.                                   */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The 3x3 dilation mask is applied to 32 output pixels                */
/*      simultaneously.  This is done with 32-bit-wide bitwise              */
/*      operators in the register file.  In order to do this, the code      */
/*      reads in a 34-bit-wide input window, and 40-bit operations          */
/*      are used to manipulate the pixels initially.                        */
/*                                                                          */
/*      Because the code reads a 34-bit context for each 32-bits of         */
/*      output, the input needs to be one byte longer than the output       */
/*      in order to make the rightmost two pixels well-defined.             */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      1.  Negative values in the mask specify "DONT_CARE", and non-       */
/*          negative values specify that pixels are included in the         */
/*          dilation operation.                                             */
/*                                                                          */
/*      2.  The input image needs to have a multiple of 32 pixels(bits)     */
/*          per row.  Therefore, "cols" must be a multiple of 4.            */
/*                                                                          */
/*  NOTES                                                                   */
/*      Little Endian                                                       */
/*                                                                          */
/*      "Digital Image Processing: Principles and Applications"             */
/*      by Gregory A. Baxes, Chapter 5                                      */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void IMG_dilate_bin
(
    const unsigned char *restrict in_data,
    unsigned char       *restrict out_data,
    const char          *restrict mask,
    int cols
)
{
    int i;
    unsigned long p0l, p3l, p6l;
    unsigned p0, p1, p2, p3, p4, p5, p6, p7, p8, r;

    /* -------------------------------------------------------------------- */
    /*  Iterate over the input, processing 32 pixels per iteration.         */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < cols; i += 4)
    {
        /* ---------------------------------------------------------------- */
        /*  Load in our 34-bit by 3-bit context for applying the 3x3 mask.  */
        /* ---------------------------------------------------------------- */
        p0l = ((unsigned)     in_data[i +          0]      ) |
              ((unsigned)     in_data[i +          1] << 8 ) |
              ((unsigned)     in_data[i +          2] << 16) |
              ((unsigned)     in_data[i +          3] << 24) |
              ((unsigned long)in_data[i +          4] << 32);

        p3l = ((unsigned)     in_data[i + cols   + 0]      ) |
              ((unsigned)     in_data[i + cols   + 1] << 8 ) |
              ((unsigned)     in_data[i + cols   + 2] << 16) |
              ((unsigned)     in_data[i + cols   + 3] << 24) |
              ((unsigned long)in_data[i + cols   + 4] << 32);

        p6l = ((unsigned)     in_data[i + cols*2 + 0]      ) |
              ((unsigned)     in_data[i + cols*2 + 1] << 8 ) |
              ((unsigned)     in_data[i + cols*2 + 2] << 16) |
              ((unsigned)     in_data[i + cols*2 + 3] << 24) |
              ((unsigned long)in_data[i + cols*2 + 4] << 32);

        /* ---------------------------------------------------------------- */
        /*  Generate 3 offset copies of each row so that we can perform     */
        /*  ANDs between pixels that are neighbors.                         */
        /* ---------------------------------------------------------------- */
        p0 = p0l;   p1 = p0l >> 1;   p2 = p0l >> 2;
        p3 = p3l;   p4 = p3l >> 1;   p5 = p3l >> 2;
        p6 = p6l;   p7 = p6l >> 1;   p8 = p6l >> 2;

        /* ---------------------------------------------------------------- */
        /*  Now sum the filtered pixels together by ORing.                  */
        /* ---------------------------------------------------------------- */
        r = 0;
        if (mask[0] >= 0) r |= p0;
        if (mask[1] >= 0) r |= p1;
        if (mask[2] >= 0) r |= p2;
        if (mask[3] >= 0) r |= p3;
        if (mask[4] >= 0) r |= p4;
        if (mask[5] >= 0) r |= p5;
        if (mask[6] >= 0) r |= p6;
        if (mask[7] >= 0) r |= p7;
        if (mask[8] >= 0) r |= p8;

        /* ---------------------------------------------------------------- */
        /*  Write the result as four bytes.                                 */
        /* ---------------------------------------------------------------- */
        out_data[i + 0] = (r >>  0) & 0xFF;
        out_data[i + 1] = (r >>  8) & 0xFF;
        out_data[i + 2] = (r >> 16) & 0xFF;
        out_data[i + 3] = (r >> 24) & 0xFF;
    }
}

/* ======================================================================== */
/*  End of file:  img_dilate_bin.c                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

erode_bin.c/    1066929161  0     0     0       12702     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Wed Nov 29 08:53:28 2000 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_erode_bin-- This code performs 3x3 binary dilation              */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      29-Nov-2000                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void IMG_erode_bin                                                  */
/*      (                                                                   */
/*          const unsigned char *restrict in_data,   // Incoming image  //  */
/*          unsigned char       *restrict out_data,  // Filtered output //  */
/*          const char          *restrict mask,      // Filter mask     //  */
/*          int cols  // Number of columns to process, in bytes.        //  */
/*      );                                                                  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The function IMG_erode_bin() implements binary erosion using an     */
/*      arbitrary 3x3 mask.  The erosion operator generates output pixels   */
/*      by ANDing the pixels under the input mask together to generate      */
/*      the output pixel.  The input mask specifies whether one or more     */
/*      pixels from the input are to be ignored.                            */
/*                                                                          */
/*      In pseudo-code, the filtering operation for a pixel at (x, y)       */
/*      works like so:                                                      */
/*                                                                          */
/*          result = 1;                                                     */
/*          if (mask[0][0] != DONT_CARE) result &= input[y + 0][x + 0];     */
/*          if (mask[0][1] != DONT_CARE) result &= input[y + 1][x + 1];     */
/*          if (mask[0][2] != DONT_CARE) result &= input[y + 2][x + 2];     */
/*          if (mask[1][0] != DONT_CARE) result &= input[y + 0][x + 0];     */
/*          if (mask[1][1] != DONT_CARE) result &= input[y + 1][x + 1];     */
/*          if (mask[1][2] != DONT_CARE) result &= input[y + 2][x + 2];     */
/*          if (mask[2][0] != DONT_CARE) result &= input[y + 0][x + 0];     */
/*          if (mask[2][1] != DONT_CARE) result &= input[y + 1][x + 1];     */
/*          if (mask[2][2] != DONT_CARE) result &= input[y + 2][x + 2];     */
/*          output[y][x] = result;                                          */
/*                                                                          */
/*      For this code, "DONT_CARE" is specified by a negative value         */
/*      in the input mask.  Non-negative values in the mask cause the       */
/*      corresponding pixel to be included in the erosion operation.        */
/*                                                                          */
/*      Note that this code operates on a bitmap where each pixel is        */
/*      represented as a single bit within a byte or word.  Although        */
/*      the pseudo-code above operates only on one pixel at a time,         */
/*      with a single pixel in each array element, this implementation      */
/*      operates on a bitmap which contains 8 pixels in each byte.          */
/*                                                                          */
/*      Pixels are organized within each byte such that the pixel with      */
/*      the smallest index is in the LSB position, and the pixel with       */
/*      the largest index is in the MSB position.  (That is, the code       */
/*      assumes a LITTLE ENDIAN bit ordering.)                              */
/*                                                                          */
/*      Note that the "cols" argument actually specifies the number of      */
/*      BYTES in the output, not the number of columns.  The number of      */
/*      columns is 8 times this argument.                                   */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The 3x3 erosion mask is applied to 32 output pixels                 */
/*      simultaneously.  This is done with 32-bit-wide bitwise              */
/*      operators in the register file.  In order to do this, the code      */
/*      reads in a 34-bit-wide input window, and 40-bit operations          */
/*      are used to manipulate the pixels initially.                        */
/*                                                                          */
/*      Because the code reads a 34-bit context for each 32-bits of         */
/*      output, the input needs to be one byte longer than the output       */
/*      in order to make the rightmost two pixels well-defined.             */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      1.  Negative values in the mask specify "DONT_CARE", and non-       */
/*          negative values specify that pixels are included in the         */
/*          erosion operation.                                              */
/*                                                                          */
/*      2.  The input image needs to have a multiple of 32 pixels(bits)     */
/*          per row.  Therefore, "cols" must be a multiple of 4.            */
/*                                                                          */
/*  NOTES                                                                   */
/*      Little Endian                                                       */
/*                                                                          */
/*      "Digital Image Processing: Principles and Applications"             */
/*      by Gregory A. Baxes, Chapter 5                                      */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void IMG_erode_bin
(
    const unsigned char *restrict in_data,
    unsigned char       *restrict out_data,
    const char          *restrict mask,
    int cols
)
{
    int i;
    unsigned long p0l, p3l, p6l;
    unsigned p0, p1, p2, p3, p4, p5, p6, p7, p8, r;

    /* -------------------------------------------------------------------- */
    /*  Iterate over the input, processing 32 pixels per iteration.         */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < cols; i += 4)
    {
        /* ---------------------------------------------------------------- */
        /*  Load in our 34-bit by 3-bit context for applying the 3x3 mask.  */
        /* ---------------------------------------------------------------- */
        p0l = ((unsigned)     in_data[i +          0]      ) |
              ((unsigned)     in_data[i +          1] << 8 ) |
              ((unsigned)     in_data[i +          2] << 16) |
              ((unsigned)     in_data[i +          3] << 24) |
              ((unsigned long)in_data[i +          4] << 32);

        p3l = ((unsigned)     in_data[i + cols   + 0]      ) |
              ((unsigned)     in_data[i + cols   + 1] << 8 ) |
              ((unsigned)     in_data[i + cols   + 2] << 16) |
              ((unsigned)     in_data[i + cols   + 3] << 24) |
              ((unsigned long)in_data[i + cols   + 4] << 32);

        p6l = ((unsigned)     in_data[i + cols*2 + 0]      ) |
              ((unsigned)     in_data[i + cols*2 + 1] << 8 ) |
              ((unsigned)     in_data[i + cols*2 + 2] << 16) |
              ((unsigned)     in_data[i + cols*2 + 3] << 24) |
              ((unsigned long)in_data[i + cols*2 + 4] << 32);

        /* ---------------------------------------------------------------- */
        /*  Generate 3 offset copies of each row so that we can perform     */
        /*  ANDs between pixels that are neighbors.                         */
        /* ---------------------------------------------------------------- */
        p0 = p0l;   p1 = p0l >> 1;   p2 = p0l >> 2;
        p3 = p3l;   p4 = p3l >> 1;   p5 = p3l >> 2;
        p6 = p6l;   p7 = p6l >> 1;   p8 = p6l >> 2;

        /* ---------------------------------------------------------------- */
        /*  Now sum the filtered pixels together by ANDing.                 */
        /* ---------------------------------------------------------------- */
        r = ~0U;
        if (mask[0] >= 0) r &= p0;
        if (mask[1] >= 0) r &= p1;
        if (mask[2] >= 0) r &= p2;
        if (mask[3] >= 0) r &= p3;
        if (mask[4] >= 0) r &= p4;
        if (mask[5] >= 0) r &= p5;
        if (mask[6] >= 0) r &= p6;
        if (mask[7] >= 0) r &= p7;
        if (mask[8] >= 0) r &= p8;

        /* ---------------------------------------------------------------- */
        /*  Write the result as four bytes.                                 */
        /* ---------------------------------------------------------------- */
        out_data[i + 0] = (r >>  0) & 0xFF;
        out_data[i + 1] = (r >>  8) & 0xFF;
        out_data[i + 2] = (r >> 16) & 0xFF;
        out_data[i + 3] = (r >> 24) & 0xFF;
    }
}

/* ======================================================================== */
/*  End of file:  img_erode_bin.c                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
errdif_bin.c/   1066929161  0     0     0       14093     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.9     Mon Jan  7 20:23:52 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_errdif_bin -- Binary Floyd-Steinberg Error Diffusion. Endian Neutral*/
/*                                                                          */
/*  REVISION DATE                                                           */
/*      10-Jul-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*              void IMG_errdif_bin                                         */
/*              (                                                           */
/*                  unsigned char *restrict errdif_data,                    */
/*                  int           cols,                                     */
/*                  int           rows,                                     */
/*                  short         *restrict err_buf,                        */
/*                  unsigned char thresh                                    */
/*              )                                                           */
/*                                                                          */
/*      errdif_data:     Input/Output image ptr                             */
/*      cols:            Number of columns (Width)                          */
/*      rows:            Number of rows    (Height)                         */
/*      err_buf:         Buffer where one row of errors is to be saved      */
/*      thresh:          Threshold in the range [0x00, 0xFF]                */
/*                                                                          */
/*      errdif_data[] is used for both input and output and the number      */
/*      of colums, cols, must be at least 4.  No restriction on number      */
/*      of rows.                                                            */
/*                                                                          */
/*      err_buf[], additional buffer, should be provided with               */
/*      initialized to all-zero's for the first call with an image.         */
/*      The subsequent call with the same image should provide this         */
/*      kernel the returned err_buf The size of err_buf should be           */
/*      (cols+1)*Half-Word.                                                 */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The code implements the Binary Floyd-Steinberg error diffusion      */
/*      filter.  The filter kernel used is this one:                        */
/*                                                                          */
/*                                  +---+                                   */
/*                                P | 7 |                                   */
/*                          +---+---+---+                                   */
/*                          | 3 | 5 | 1 |                                   */
/*                          +---+---+---+                                   */
/*                                                                          */
/*                                                                          */
/*      Pixels are processed from left-to-right, top-to-bottom.  Each       */
/*      pixel is compared against a user-defined threshold.  Pixels         */
/*      that are larger than the threshold are set to 255, and pixels       */
/*      that are smaller or equal to the threshold are set to 0.  The       */
/*      error value for the pixel (eg. the difference between the           */
/*      thresholded pixel and its original grey level) is propagated to     */
/*      the neighboring pixels according to the filter above.  This         */
/*      error propagation diffuses the error over a larger area, hence      */
/*      the term "error diffusion."                                         */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      Constants, 7, 5, 3, 1 for multiplication are shifted left 12 to     */
/*      avoid 'SHR 4' operation in the critical path.                       */
/*                                                                          */
/*      The processing of the filter itself is inverted so that the         */
/*      errors from previous pixels "propagate into" a given pixel at       */
/*      the time the pixel is processed, rather than "accumulate into"      */
/*      a pixel as its neighbors are processed.  This allows us to          */
/*      keep our image as an 8-bit image, and reduces the number of         */
/*      accesses to the image array.  The inverted filter kernel            */
/*      performs identically to the kernel's original form.  In this        */
/*      form, the weights specify the weighting assigned to the errors      */
/*      coming from the neighboring pixels.                                 */
/*                                                                          */
/*                          +---+---+---+                                   */
/*                          | 1 | 5 | 3 |                                   */
/*                          +---+---+---+                                   */
/*                          | 7 | P                                         */
/*                          +---+                                           */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The number of columns must be at least 4.                           */
/*                                                                          */
/*      err_buf[] must be initialized to zeros for the first call and       */
/*      the returned err_buf should be provided for the next call.          */
/*                                                                          */
/*  NOTES                                                                   */
/*      No special alignment of data arrays is expected.                    */
/*                                                                          */
/*  SOURCE                                                                  */
/*      Floyd-Steinberg Error Diffusion.                                    */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

#include "IMG_errdif_bin.h"

void IMG_errdif_bin
(
    unsigned char *restrict errdif_data, /* Input/Output image ptr       */
    int           cols,                  /* Number of columns (Width)    */
    int           rows,                  /* Number of rows    (Height)   */
    short         *restrict err_buf,     /* row-to-row error buffer.     */
    unsigned char thresh                 /* Threshold from [0x00, 0xFF]  */
)
{
    int   x, i, y;                /* Loop counters                       */
    int   F;                      /* Current pixel value at [x,y]        */
    int   errA;                   /* Error value at [x-1, y-1]           */
    int   errB;                   /* Error value at [  x, y-1]           */
    int   errC;                   /* Error value at [x+1, y-1]           */
    int   errE;                   /* Error value at [x-1,   y]           */
    int   errF;                   /* Error value at [  x,   y]           */

    /* --------------------------------------------------------- */
    /*  Step through rows of pixels.                             */
    /* --------------------------------------------------------- */
    for (y = 0, i = 0; y < rows; y++)
    {
        /* ----------------------------------------------------- */
        /*  Start off with our initial errors set to zero at the */
        /*  start of the line since we do not have any pixels to */
        /*  the left of the row.  These error terms are          */
        /*  maintained within the inner loop.                    */
        /* ----------------------------------------------------- */
        errA = 0; errE = 0;
        errB = err_buf[0];


        /* ----------------------------------------------------- */
        /*  Step through pixels in each row.                     */
        /* ----------------------------------------------------- */
        for (x = 0; x < cols; x++, i++)
        {
            /* ------------------------------------------------- */
            /*  Load the error being propagated from pixel 'C'   */
            /*  from our error buffer.  This was calculated      */
            /*  during the previous line.                        */
            /* ------------------------------------------------- */
            errC = err_buf[x+1];

            /* ------------------------------------------------- */
            /*  Load our pixel value to quantize.                */
            /* ------------------------------------------------- */
            F = errdif_data[i];

            /* ------------------------------------------------- */
            /*  Calculate our resulting pixel.  If we assume     */
            /*  that this pixel will be set to zero, this also   */
            /*  doubles as our error term.                       */
            /* ------------------------------------------------- */
            errF = F + ((errE*7 + errA + errB*5 + errC*3) >> 4);

            /* ------------------------------------------------- */
            /*  Set pixels that are larger than the threshold to */
            /*  255, and pixels that are smaller than the        */
            /*  threshold to 0.                                  */
            /* ------------------------------------------------- */
            if (errF > thresh)  errdif_data[i] = 0xFF;
            else                errdif_data[i] = 0;

            /* ------------------------------------------------- */
            /*  If the pixel was larger than the threshold, then */
            /*  we need subtract 255 from our error.  In any     */
            /*  case, store the error to the error buffer.       */
            /* ------------------------------------------------- */
            if (errF > thresh)  err_buf[x] = errF = errF - 0xFF;
            else                err_buf[x] = errF;

            /* ------------------------------------------------- */
            /*  Propagate error terms for the next pixel.        */
            /* ------------------------------------------------- */
            errE = errF;
            errA = errB;
            errB = errC;
        }
    }
}

/* ========================================================================= */
/*  End of file:  img_errdif_bin.c                                           */
/* ------------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ========================================================================= */

fdct_8x8.c/     1066929161  0     0     0       17177     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Sun Dec 12 06:32:28 1999 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  NAME                                                                    */
/*      IMG_fdct_8x8 -- 8x8 Block FDCT With Rounding, Endian Neutral.       */
/*                                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      28-Oct-1999                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*          void IMG_fdct_8x8(short fdct_data[], unsigned num_fdcts)        */
/*                                                                          */
/*      The fdct routine accepts a list of 8x8 pixel blocks and performs    */
/*      FDCTs on each.  The array should be laid out identically to         */
/*      "fdct_data[num_fdcts][8][8]".  All operations in this array are     */
/*      performed entirely in-place.                                        */
/*                                                                          */
/*      Input values are stored in shorts, and may be in the range          */
/*      [-512,511].  Larger input values may result in overflow.            */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The IMG_fdct_8x8 function implements a Chen FDCT. Output values are */
/*      rounded, providing improved accuracy.  Input terms are expected     */
/*      to be signed 11Q0 values, producing signed 15Q0 results.  (A        */
/*      smaller dynamic range may be used on the input, producing a         */
/*      correspondingly smaller output range.  Typical applications         */
/*      include processing signed 9Q0 and unsigned 8Q0 pixel data,          */
/*      producing signed 13Q0 or 12Q0 outputs, respectively.)  No           */
/*      saturation is performed.                                            */
/*                                                                          */
/*      Note:  This code guarantees correct operation, even in the case     */
/*      that 'num_fdcts == 0'.  In this case, the function performs no      */
/*      FDCTs.                                                              */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The cosine terms have all been scaled by sqrt(2), so that the       */
/*      "c4" term is basically an even power of 2.  This allows easy        */
/*      calculation of the "F0" and "F4" terms, which have no multiplies.   */
/*                                                                          */
/*      The horizontal pass does not explicitly jump from block-to-block,   */
/*      since all horizontal rows are adjacent in memory.  (eg. Moving      */
/*      between rows within a block is identical to moving between the      */
/*      last row of one block and the first row of the next block.)         */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      n/a                                                                 */
/*                                                                          */
/*  NOTES                                                                   */
/*      n/a                                                                 */
/*                                                                          */
/*  SOURCE                                                                  */
/*      Chen FDCT.                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void IMG_fdct_8x8(short *dct_data, unsigned num_fdcts)
{
    /* -------------------------------------------------------------------- */
    /*  Set up the cosine coefficients c0..c7.  c4 is replaced by a shift.  */
    /* -------------------------------------------------------------------- */
    const unsigned short c1 = 0x2C62, c3 = 0x25A0, c5 = 0x1924, c7 = 0x08D4;
    const unsigned short c0 = 0xB505, c2 = 0x29CF, c6 = 0x1151;

    /* -------------------------------------------------------------------- */
    /*  Intermediate calculations.                                          */
    /* -------------------------------------------------------------------- */
    short f0, f1, f2, f3, f4, f5, f6, f7;   /* Spatial domain samples.      */
    int   g0, g1, h0, h1, p0, p1;           /* Even-half intermediate.      */
    short r0, r1;                           /* Even-half intermediate.      */
    int   P0, P1, R0, R1;                   /* Even-half intermediate.      */
    short g2, g3, h2, h3;                   /* Odd-half intermediate.       */
    short q0a,s0a,q0, q1, s0, s1;           /* Odd-half intermediate.       */
    short Q0, Q1, S0, S1;                   /* Odd-half intermediate.       */
    int   F0, F1, F2, F3, F4, F5, F6, F7;   /* Freq. domain results.        */
    int   F0r,F1r,F2r,F3r,F4r,F5r,F6r,F7r;  /* Rounded, truncated results.  */

    /* -------------------------------------------------------------------- */
    /*  Input and output pointers, loop control.                            */
    /* -------------------------------------------------------------------- */
    unsigned i, j;
    short    *dct_io_ptr;

    /* -------------------------------------------------------------------- */
    /*  Outer vertical loop -- Process each 8x8 block.                      */
    /* -------------------------------------------------------------------- */
    dct_io_ptr = dct_data;
    for (i = 0; i < num_fdcts; i++)
    {
        /* ---------------------------------------------------------------- */
        /*  Perform Vertical 1-D FDCT on columns within each block.         */
        /* ---------------------------------------------------------------- */
        for (j = 0; j < 8; j++)
        {
            /* ------------------------------------------------------------ */
            /*  Load the spatial-domain samples.                            */
            /* ------------------------------------------------------------ */
            f0 = dct_io_ptr[ 0];
            f1 = dct_io_ptr[ 8];
            f2 = dct_io_ptr[16];
            f3 = dct_io_ptr[24];
            f4 = dct_io_ptr[32];
            f5 = dct_io_ptr[40];
            f6 = dct_io_ptr[48];
            f7 = dct_io_ptr[56];

            /* ------------------------------------------------------------ */
            /*  Stage 1:  Separate into even and odd halves.                */
            /* ------------------------------------------------------------ */
            g0 = f0 + f7;               h2 = f0 - f7;
            g1 = f1 + f6;               h3 = f1 - f6;
            h1 = f2 + f5;               g3 = f2 - f5;
            h0 = f3 + f4;               g2 = f3 - f4;

            /* ------------------------------------------------------------ */
            /*  Stage 2                                                     */
            /* ------------------------------------------------------------ */
            p0 = g0 + h0;               r0 = g0 - h0;
            p1 = g1 + h1;               r1 = g1 - h1;
            q1 = g2;                    s1 = h2;

            s0a= h3 + g3;               q0a= h3 - g3;
            s0 = (s0a * c0 + 0x7FFF) >> 16;
            q0 = (q0a * c0 + 0x7FFF) >> 16;

            /* ------------------------------------------------------------ */
            /*  Stage 3                                                     */
            /* ------------------------------------------------------------ */
            P0 = p0 + p1;               P1 = p0 - p1;
            R1 = c6 * r1 + c2 * r0;     R0 = c6 * r0 - c2 * r1;

            Q1 = q1 + q0;               Q0 = q1 - q0;
            S1 = s1 + s0;               S0 = s1 - s0;

            /* ------------------------------------------------------------ */
            /*  Stage 4                                                     */
            /* ------------------------------------------------------------ */
            F0 = P0;                    F4 = P1;
            F2 = R1;                    F6 = R0;

            F1 = c7 * Q1 + c1 * S1;     F7 = c7 * S1 - c1 * Q1;
            F5 = c3 * Q0 + c5 * S0;     F3 = c3 * S0 - c5 * Q0;

            /* ------------------------------------------------------------ */
            /*  Store the frequency domain results.                         */
            /* ------------------------------------------------------------ */
            dct_io_ptr[ 0] = F0;
            dct_io_ptr[ 8] = F1 >> 13;
            dct_io_ptr[16] = F2 >> 13;
            dct_io_ptr[24] = F3 >> 13;
            dct_io_ptr[32] = F4;
            dct_io_ptr[40] = F5 >> 13;
            dct_io_ptr[48] = F6 >> 13;
            dct_io_ptr[56] = F7 >> 13;

            dct_io_ptr++;
        }
        /* ---------------------------------------------------------------- */
        /*  Update pointer to next 8x8 FDCT block.                          */
        /* ---------------------------------------------------------------- */
        dct_io_ptr += 56;
    }

    /* -------------------------------------------------------------------- */
    /*  Perform Horizontal 1-D FDCT on each 8x8 block.                      */
    /* -------------------------------------------------------------------- */
    dct_io_ptr = dct_data;
    for (i = 0; i < 8 * num_fdcts; i++)
    {
        /* ---------------------------------------------------------------- */
        /*  Load the spatial-domain samples.                                */
        /* ---------------------------------------------------------------- */
        f0 = dct_io_ptr[0];
        f1 = dct_io_ptr[1];
        f2 = dct_io_ptr[2];
        f3 = dct_io_ptr[3];
        f4 = dct_io_ptr[4];
        f5 = dct_io_ptr[5];
        f6 = dct_io_ptr[6];
        f7 = dct_io_ptr[7];

        /* ---------------------------------------------------------------- */
        /*  Stage 1:  Separate into even and odd halves.                    */
        /* ---------------------------------------------------------------- */
        g0 = f0 + f7;               h2 = f0 - f7;
        g1 = f1 + f6;               h3 = f1 - f6;
        h1 = f2 + f5;               g3 = f2 - f5;
        h0 = f3 + f4;               g2 = f3 - f4;

        /* ---------------------------------------------------------------- */
        /*  Stage 2                                                         */
        /* ---------------------------------------------------------------- */
        p0 = g0 + h0;               r0 = g0 - h0;
        p1 = g1 + h1;               r1 = g1 - h1;
        q1 = g2;                    s1 = h2;

        s0a= h3 + g3;               q0a= h3 - g3;
        q0 = (q0a * c0 + 0x7FFF) >> 16;
        s0 = (s0a * c0 + 0x7FFF) >> 16;

        /* ---------------------------------------------------------------- */
        /*  Stage 3                                                         */
        /* ---------------------------------------------------------------- */
        P0 = p0 + p1;               P1 = p0 - p1;
        R1 = c6 * r1 + c2 * r0;     R0 = c6 * r0 - c2 * r1;

        Q1 = q1 + q0;               Q0 = q1 - q0;
        S1 = s1 + s0;               S0 = s1 - s0;

        /* ---------------------------------------------------------------- */
        /*  Stage 4                                                         */
        /* ---------------------------------------------------------------- */
        F0 = P0;                    F4 = P1;
        F2 = R1;                    F6 = R0;

        F1 = c7 * Q1 + c1 * S1;     F7 = c7 * S1 - c1 * Q1;
        F5 = c3 * Q0 + c5 * S0;     F3 = c3 * S0 - c5 * Q0;

        /* ---------------------------------------------------------------- */
        /*  Round and truncate values.                                      */
        /*                                                                  */
        /*  Note: F0 and F4 have different rounding since no MPYs have      */
        /*  been applied to either term.  Also, F0's rounding is slightly   */
        /*  different to offset the truncation effects from the horizontal  */
        /*  pass (which does not round).                                    */
        /* ---------------------------------------------------------------- */
        F0r = (F0 + 0x0006) >>  3;
        F1r = (F1 + 0x7FFF) >> 16;
        F2r = (F2 + 0x7FFF) >> 16;
        F3r = (F3 + 0x7FFF) >> 16;
        F4r = (F4 + 0x0004) >>  3;
        F5r = (F5 + 0x7FFF) >> 16;
        F6r = (F6 + 0x7FFF) >> 16;
        F7r = (F7 + 0x7FFF) >> 16;

        /* ---------------------------------------------------------------- */
        /*  Store the results                                               */
        /* ---------------------------------------------------------------- */
        dct_io_ptr[0] = F0r;
        dct_io_ptr[1] = F1r;
        dct_io_ptr[2] = F2r;
        dct_io_ptr[3] = F3r;
        dct_io_ptr[4] = F4r;
        dct_io_ptr[5] = F5r;
        dct_io_ptr[6] = F6r;
        dct_io_ptr[7] = F7r;

        /* ---------------------------------------------------------------- */
        /*  Update pointer to next FDCT row.                                */
        /* ---------------------------------------------------------------- */
        dct_io_ptr += 8;
    }

    return;
}

/* ======================================================================== */
/*  fdct_8x8_stub -- this is here to get the call overhead                  */
/* ======================================================================== */
void fdct_8x8_stub(short *fdct_data, unsigned num_fdcts)
{
    asm("* comment to defeat inlining");
    return;
}

/* ======================================================================== */
/*  End of file:  img_fdct_8x8.c                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

histogram.c/    1066929161  0     0     0       11077     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.6     Tue Mar 12 04:30:55 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================= */
/*  TEXAS INSTRUMENTS, INC.                                                */
/*                                                                         */
/*  NAME                                                                   */
/*      IMG_histogram                                                      */
/*                                                                         */
/*  REVISION DATE                                                          */
/*      04-Sep-1999                                                        */
/*                                                                         */
/*  USAGE                                                                  */
/*      This routine is C-callable and can be called as:                   */
/*                                                                         */
/*      void IMG_histogram                                                 */
/*      (                                                                  */
/*          unsigned char * in_data,  // input data to IMG_histogram   //  */
/*          int n,                    // number of points              //  */
/*          int accumulate,           // sign of accumulation (+1/-1)  //  */
/*          unsigned short * t_hist,  // temporary IMG_histogram buffer // */
/*          unsigned short * hist     // final IMG_histogram output    //  */
/*      );                                                                 */
/*                                                                         */
/*  DESCRIPTION                                                            */
/*      This code takes a IMG_histogram of an array of n, 8 bit inputs. It */
/*      returns the IMG_histogram of 256 bins at 16 bit precision.  It can */
/*      either add or subtract to an existing IMG_histogram, using the     */
/*      'accumulate' control.                                              */
/*                                                                         */
/*      It requires some temporary storage for 4 temporary histograms,     */
/*      which are later summed together.                                   */
/*                                                                         */
/*  ASSUMPTIONS                                                            */
/*      It is assumed that the temporary array of data, t_hist is          */
/*      initialised to zero.                                               */
/*                                                                         */
/*  TECHNIQUES                                                             */
/*      This code operates on four interleaved IMG_histogram bins.  The    */
/*      loop is divided into two halves.  The even half operates on        */
/*      even words full of pixels and the odd half operates on odd         */
/*      words.  Both halves operate on the same 4 IMG_histogram bins. This */
/*      introduces a memory dependency which ordinarily would degrade      */
/*      performance.  To break the memory depenencies, the two halves      */
/*      forward their results to each other.  Exact memory access          */
/*      ordering obviates the need to predicate stores The algorithm is    */
/*      ordered as follows:                                                */
/*                                                                         */
/*      1.  Load from IMG_histogram for even half                          */
/*                                                                         */
/*      2.  Store odd_bin to IMG_histogram for odd half (previous itn.)    */
/*                                                                         */
/*      3.  if data_even == previous data_odd increment even_bin by 2      */
/*          else increment even_bin by 1, forward to odd                   */
/*                                                                         */
/*      4.  Load from IMG_histogram for odd half (current itn.)            */
/*                                                                         */
/*      5.  Store even_bin to IMG_histogram for even half                  */
/*                                                                         */
/*      6.  if data_odd == previous data_even increment odd_bin by 2       */
/*      else increment odd_bin by 1, forward to even                       */
/*                                                                         */
/*      7.  goto 1.                                                        */
/*                                                                         */
/*      With this particular ordering, forwarding is necessary between     */
/*      even/odd halves when pixels in adjacent halves need to be          */
/*      placed in the same bin.  The store is never predicated and         */
/*      occurs speculatively as it will be overwritten by the next         */
/*      value containing the extra forwarded value.                        */
/*                                                                         */
/*      The four histograms are interleaved with each bin spaced four      */
/*      half-words apart and each IMG_histogram starting in a different    */
/*      memory bank.  This allows the four IMG_histogram accesses to       */
/*      proceed in any order without worrying about bank conflicts.        */
/*      The diagram below illustrates this: (addresses are halfword        */
/*      offsets)                                                           */
/*                                                                         */
/*             0       1       2       3       4       5       6   ...     */
/*         | hst 0 | hst 1 | hst 2 | hst 3 | hst 0 | hst 1 | ...   ...     */
/*         | bin 0 | bin 0 | bin 0 | bin 0 | bin 1 | bin 1 | ...   ...     */
/*                                                                         */
/*  NOTE                                                                   */
/*      With small modification this code can be used without the          */
/*      summing stage.  The sparse IMG_histogram can be accumulated into   */
/*      and the final summing loop left until the end of a series of       */
/*      histograms.                                                        */
/*                                                                         */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================= */

void IMG_histogram(unsigned char * in_data, int n, int accumulate,
                  unsigned short * t_hist, unsigned short * hist)
{
#if 0
    /* -------------------------------------------------------------------- */
    /*  This is the cannonical form for Histogram.                          */
    /* -------------------------------------------------------------------- */
    int pixel, j;
    for (j = 0; j < n; j++)
    {
        pixel = (int) in_data[j];
        hist[pixel] += accumulate;
    }
#else
    /* -------------------------------------------------------------------- */
    /*  This is pretty much bit-exact with our optimized implementation.    */
    /* -------------------------------------------------------------------- */
    int p0, p1, p2, p3, i;

    /* -------------------------------------------------------------------- */
    /*  This loop is unrolled four times, producing four interleaved        */
    /*  histograms into a temporary buffer.                                 */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < n; i += 4)
    {
        p0 = in_data[i + 0] * 4 + 0;
        p1 = in_data[i + 1] * 4 + 1;
        p2 = in_data[i + 2] * 4 + 2;
        p3 = in_data[i + 3] * 4 + 3;

        t_hist[p0]++;
        t_hist[p1]++;
        t_hist[p2]++;
        t_hist[p3]++;
    }

    /* -------------------------------------------------------------------- */
    /*  Accumulate the interleaved histograms back into the final           */
    /*  IMG_histogram buffer.                                               */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < 256; i++)
    {
        hist[i] += (t_hist[i*4 + 0] +
                    t_hist[i*4 + 1] +
                    t_hist[i*4 + 2] +
                    t_hist[i*4 + 3]) * accumulate;
    }
#endif
}
/*============================================================================*/
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/*============================================================================*/

idct_8x8.c/     1066929161  0     0     0       19953     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.6     Thu Mar 14 14:06:50 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  NAME                                                                    */
/*      IMG_idct_8x8 -- IEEE-1180 Compliant IDCT                            */
/*                                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      27-Jul-1999                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*          void IMG_idct_8x8(short idct_data[], unsigned num_idcts)        */
/*                                                                          */
/*      The IMG_idct_8x8 routine accepts a list of 8x8 DCT coeffient blocks */
/*      and performs IDCTs on each.  The array should be laid out           */
/*      equivalently to the C array idct_data[num_idcts+1][8][8].           */
/*                                                                          */
/*      The routine requires one 8x8-block's worth of extra storage at      */
/*      the end of the list of DCT blocks.  When processing 'num_idcts'     */
/*      blocks, an area of length 'num_idcts + 1' must be provided.  The    */
/*      contents of the extra block are ignored and overwritten with        */
/*      intermediate results by IMG_idct_8x8().                             */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The IMG_idct_8x8 algorithm performs an IEEE-1180 compliant IDCT,    */
/*      complete with rounding and saturation to signed 9-bit quantities.   */
/*      The input coefficients are assumed to be signed 12-bit cosine       */
/*      terms.                                                              */
/*                                                                          */
/*      Note:  This code guarantees correct operation, even in the case     */
/*      that 'num_idcts == 0'.  In that case, the function performs an      */
/*      early exit without storing any results or intermediate values.      */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The IDCTs cannot be performed completely in-place due to the        */
/*      transpose that each pass performs.  In order to save data memory,   */
/*      the horizontal pass works from the end of the array towards the     */
/*      beginning, writing its result one IDCT block later in memory,       */
/*      thus performing the IDCT nearly-in-place.  The vertical pass        */
/*      performs its IDCTs in the opposite direction, working from the      */
/*      start of the array towards the end, writing the result in-place.    */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      One extra block's worth of storage must be present after the list   */
/*      of IDCT input blocks.                                               */
/*                                                                          */
/*  NOTES                                                                   */
/*      The cosine terms have all been scaled by sqrt(2), so that the       */
/*      "c4" term is basically an even power of 2.                          */
/*                                                                          */
/*      The precision of the final results can be changed by modifying      */
/*      the constants at the top of the code and reassembling.  Usually,    */
/*      modifying the final-shift constants in the "Symbolic Constants"     */
/*      section is sufficient.                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

/* ======================================================================== */
/*  IMG_idct_8x8   -- Natural C version of IMG_idct_8x8().                  */
/* ======================================================================== */
void IMG_idct_8x8(short *idct_data, unsigned num_dcts)
{
    /* -------------------------------------------------------------------- */
    /*  Set up the cosine coefficients c1..c6.  c4 is replaced by a shift.  */
    /* -------------------------------------------------------------------- */
    const short c1 = 0x0B19, c2 = 0x0A74, c3 = 0x0968;
    const short c5 = 0x0649, c6 = 0x0454, c7 = 0x0235;
    const int   c4_shift = 11;

    /* -------------------------------------------------------------------- */
    /*  Rounding terms.  First pass is Q9, second pass is Q16.              */
    /*  These rouding terms are added to the DC component so that they      */
    /*  propagate to all of the outputs with a single ADD.  Clever, eh?     */
    /* -------------------------------------------------------------------- */
    const int round1 = 256, round2 = 32768;

    /* -------------------------------------------------------------------- */
    /*  Truncation amounts for the two passes.  Each pass truncates         */
    /*  slightly differently due to the need to retain precision between    */
    /*  the horizontal and vertical passes.                                 */
    /* -------------------------------------------------------------------- */
    const int trunc1 = 9, trunc2 = 16;

    /* -------------------------------------------------------------------- */
    /*  Input and output pointers, loop control.                            */
    /* -------------------------------------------------------------------- */
    short *i_ptr;
    short *o_ptr;
    unsigned    i, j;

    /* -------------------------------------------------------------------- */
    /*  Intermediate calculations.                                          */
    /* -------------------------------------------------------------------- */
    short X0, X1, X2, X3, X4, X5, X6, X7;   /* Frequency domain terms.      */
    int   P0, P1, p0, p1, r0, r1;           /* Even-half intermediate.      */
    int   g0, g1, h1, h0;                   /* Even-half results.           */
    int   g2, g3, h3, h2;                   /* Odd-half results.            */
    int   x0, x1, x2, x3, x4, x5, x6, x7;   /* Sample-domain results.       */
    int   x0t,x1t,x2t,x3t,x4t,x5t,x6t,x7t;  /* Truncated results.           */
    int   x0s,x1s,x2s,x3s,x4s,x5s,x6s,x7s;  /* Saturated/Truncated results. */

    /* -------------------------------------------------------------------- */
    /*  Avoid running the code if we don't have any IDCTs to do.            */
    /* -------------------------------------------------------------------- */
    if (!num_dcts) return;

    /* -------------------------------------------------------------------- */
    /*  Loop over the provided DCT blocks started at the end of the array   */
    /*  and working towards the beginning.  We initialize our input ptr     */
    /*  to point at the last row of the last valid 8x8 block.  The output   */
    /*  pointer is initialized to point to the rightmost column of the      */
    /*  scratch block which exists just after the last valid 8x8 block.     */
    /*  The horizontal pass ends up sliding the data set "forward" by a     */
    /*  whole block as a result.                                            */
    /* -------------------------------------------------------------------- */
    i_ptr = idct_data + num_dcts * 64 - 8;
    o_ptr = idct_data + num_dcts * 64 + 7;

    for (j = 0; j < num_dcts; j++)
    {
        /* ---------------------------------------------------------------- */
        /*  Perform Horizontal 1-D IDCT on each 8x8 block.  Store out       */
        /*  the results transposed.                                         */
        /* ---------------------------------------------------------------- */
        for (i = 0; i < 8; i++)
        {
            /* ------------------------------------------------------------ */
            /*  Load the freq-domain coefficients.                          */
            /* ------------------------------------------------------------ */
            X0 = i_ptr[0];
            X1 = i_ptr[1];
            X2 = i_ptr[2];
            X3 = i_ptr[3];
            X4 = i_ptr[4];
            X5 = i_ptr[5];
            X6 = i_ptr[6];
            X7 = i_ptr[7];

            i_ptr -= 8;             /* decrement pointer to next row    */

            /* ------------------------------------------------------------ */
            /*  Even part of decomposition (upper-half of flow graph).      */
            /*  (Note: rounding term is added to the "DC" value so that     */
            /*  it gets automagically applied to the whole IDCT.)           */
            /* ------------------------------------------------------------ */
            P0 = (((int)X0) << c4_shift) + round1;  /* c4 replaced by shift */
            P1 = (((int)X4) << c4_shift);           /* c4 replaced by shift */

            p0 = P0 + P1;
            p1 = P0 - P1;

            r1 = X2*c6 - X6*c2;
            r0 = X2*c2 + X6*c6;

            g0 = p0 + r0;
            g1 = p1 + r1;
            h1 = p1 - r1;
            h0 = p0 - r0;

            /* ------------------------------------------------------------ */
            /*  Odd part of decomposition (lower-half of flow graph).       */
            /* ------------------------------------------------------------ */
            g2 = (X1*c7 - X3*c5) + (X5*c3 - X7*c1);
            g3 = (X1*c5 - X3*c1) + (X5*c7 + X7*c3);
            h3 = (X1*c3 - X3*c7) - (X5*c1 + X7*c5);
            h2 = (X1*c1 + X3*c3) + (X5*c5 + X7*c7);

            /* ------------------------------------------------------------ */
            /*  Final butterfly.                                            */
            /* ------------------------------------------------------------ */
            x0 = g0 + h2;
            x1 = g1 + h3;
            x2 = h1 + g3;
            x3 = h0 + g2;
            x4 = h0 - g2;
            x5 = h1 - g3;
            x6 = g1 - h3;
            x7 = g0 - h2;

            /* ------------------------------------------------------------ */
            /*  Truncate to fit back into 16 bits before storing.           */
            /* ------------------------------------------------------------ */
            x0t = x0 >> trunc1;
            x1t = x1 >> trunc1;
            x2t = x2 >> trunc1;
            x3t = x3 >> trunc1;
            x4t = x4 >> trunc1;
            x5t = x5 >> trunc1;
            x6t = x6 >> trunc1;
            x7t = x7 >> trunc1;

            /* ------------------------------------------------------------ */
            /*  Store the results transposed in the result area.            */
            /* ------------------------------------------------------------ */
            o_ptr[ 0] = x0t;
            o_ptr[ 8] = x1t;
            o_ptr[16] = x2t;
            o_ptr[24] = x3t;
            o_ptr[32] = x4t;
            o_ptr[40] = x5t;
            o_ptr[48] = x6t;
            o_ptr[56] = x7t;

            o_ptr--;                /* decrement pointer to next column */
        }

        /* ---------------------------------------------------------------- */
        /*  Update output pointer to point to next block.  Input pointer    */
        /*  is already pointing to next block, so it doesn't need an        */
        /*  update.                                                         */
        /* ---------------------------------------------------------------- */
        o_ptr = o_ptr + 8 - 64;
    }

    /* -------------------------------------------------------------------- */
    /*  Reset our pointers for the vertical pass.  We start off with our    */
    /*  input pointer pointing to the first row of the 2nd block, and       */
    /*  our output pointer pointing to the leftmost column of the 1st       */
    /*  block.  As a result, the output data slides "back" by one block,    */
    /*  ultimately landing in-place.                                        */
    /* -------------------------------------------------------------------- */
    i_ptr = idct_data + 64;
    o_ptr = idct_data;

    for (j = 0; j < num_dcts; j++)
    {
        /* ---------------------------------------------------------------- */
        /*  Perform Vertical 1-D IDCT on each 8x8 block.  Store out the     */
        /*  results transposed.                                             */
        /* ---------------------------------------------------------------- */
        for (i = 0; i < 8; i++)
        {
            /* ------------------------------------------------------------ */
            /*  Load the freq-domain coefficients.                          */
            /* ------------------------------------------------------------ */
            X0 = i_ptr[0];
            X1 = i_ptr[1];
            X2 = i_ptr[2];
            X3 = i_ptr[3];
            X4 = i_ptr[4];
            X5 = i_ptr[5];
            X6 = i_ptr[6];
            X7 = i_ptr[7];
            i_ptr += 8;             /* increment pointer to next row    */

            /* ------------------------------------------------------------ */
            /*  Even part of decomposition (upper-half of flow graph).      */
            /*  (Note: rounding term is added to the "DC" value so that     */
            /*  it gets automagically applied to the whole IDCT.)           */
            /* ------------------------------------------------------------ */
            P0 = (((int)X0) << c4_shift) + round2;  /* c4 replaced by shift */
            P1 = (((int)X4) << c4_shift);           /* c4 replaced by shift */

            p0 = P0 + P1;
            p1 = P0 - P1;

            r1 = X2*c6 - X6*c2;
            r0 = X2*c2 + X6*c6;

            g0 = p0 + r0;
            g1 = p1 + r1;
            h1 = p1 - r1;
            h0 = p0 - r0;

            /* ------------------------------------------------------------ */
            /*  Odd part of decomposition (lower-half of flow graph).       */
            /* ------------------------------------------------------------ */
            g2 = (X1*c7 - X3*c5) + (X5*c3 - X7*c1);
            g3 = (X1*c5 - X3*c1) + (X5*c7 + X7*c3);
            h3 = (X1*c3 - X3*c7) - (X5*c1 + X7*c5);
            h2 = (X1*c1 + X3*c3) + (X5*c5 + X7*c7);

            /* ------------------------------------------------------------ */
            /*  Final butterfly.                                            */
            /* ------------------------------------------------------------ */
            x0 = g0 + h2;
            x1 = g1 + h3;
            x2 = h1 + g3;
            x3 = h0 + g2;
            x4 = h0 - g2;
            x5 = h1 - g3;
            x6 = g1 - h3;
            x7 = g0 - h2;

            /* ------------------------------------------------------------ */
            /*  Truncate and saturate final results.                        */
            /* ------------------------------------------------------------ */
            x0t = x0 >> trunc2;
            x1t = x1 >> trunc2;
            x2t = x2 >> trunc2;
            x3t = x3 >> trunc2;
            x4t = x4 >> trunc2;
            x5t = x5 >> trunc2;
            x6t = x6 >> trunc2;
            x7t = x7 >> trunc2;

            x0s = x0t < -256 ? -256 : x0t > 255 ? 255 : x0t;
            x1s = x1t < -256 ? -256 : x1t > 255 ? 255 : x1t;
            x2s = x2t < -256 ? -256 : x2t > 255 ? 255 : x2t;
            x3s = x3t < -256 ? -256 : x3t > 255 ? 255 : x3t;
            x4s = x4t < -256 ? -256 : x4t > 255 ? 255 : x4t;
            x5s = x5t < -256 ? -256 : x5t > 255 ? 255 : x5t;
            x6s = x6t < -256 ? -256 : x6t > 255 ? 255 : x6t;
            x7s = x7t < -256 ? -256 : x7t > 255 ? 255 : x7t;

            /* ------------------------------------------------------------ */
            /*  Store the results transposed in the result area.            */
            /* ------------------------------------------------------------ */
            o_ptr[ 0] = x0s;
            o_ptr[ 8] = x1s;
            o_ptr[16] = x2s;
            o_ptr[24] = x3s;
            o_ptr[32] = x4s;
            o_ptr[40] = x5s;
            o_ptr[48] = x6s;
            o_ptr[56] = x7s;

            o_ptr++;                /* increment pointer to next column */
        }
        /* ---------------------------------------------------------------- */
        /*  Update output pointer to point to next block.  (See above.)     */
        /* ---------------------------------------------------------------- */
        o_ptr = o_ptr - 8 + 64;
    }
}

/* ======================================================================== */
/*  End of file:  img_idct_8x8.c                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

mad_16x16.c/    1066929161  0     0     0       7863      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.10    Tue Mar 12 04:36:21 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================= */
/*                                                                         */
/*  TEXAS INSTRUMENTS, INC.                                                */
/*                                                                         */
/*  NAME                                                                   */
/*      IMG_mad_16x16                                                      */
/*                                                                         */
/*  REVISION DATE                                                          */
/*      05-Jul-2001                                                        */
/*                                                                         */
/*  USAGE                                                                  */
/*      This routine is C-callable and can be called as:                   */
/*                                                                         */
/*      void IMG_mad_16x16                                                 */
/*      (                                                                  */
/*          const unsigned char *refImg,// reference image                 */
/*          const unsigned char *srcImg,// 16x16 block image to look for   */
/*          int pitch,                  // Width of reference image        */
/*          int                 h,      // horiz. size of search area      */
/*          int                 v,      // vert.  size of search area      */
/*          unsigned            *match  // Result                          */
/*      )                               //     match[0] is packed x, y.    */
/*                                      //     match[1] is MAD value.      */
/*                                                                         */
/*  DESCRIPTION                                                            */
/*      This routine returns the location of the minimum absolute          */
/*      difference between a 16x16 search block and some block in a        */
/*      (h + 16) x (v + 16) search area. h and v are the sizes of the      */
/*      search space for the top left coordinate of the search block.      */
/*      refImg points to the top left pixel of the search area.            */
/*                                                                         */
/*           (0,0)          (h,0)      (h+16,0)                            */
/*             ;--------------+--------;                                   */
/*             ;    search    |        ;                                   */
/*             ;    space     |        ;                                   */
/*             ;              |        ;        search area                */
/*             ;--------------+        ;                                   */
/*           (0,v)          (h,v)      ;                                   */
/*             ;                       ;                                   */
/*             ;-----------------------;                                   */
/*           (0, v+16)                 (v+16,h+16)                         */
/*                                                                         */
/*      The location is returned relative to the above coordinate system   */
/*      as x and y packed in two 16-bit quantities in a 32-bit word:       */
/*                                                                         */
/*                  31             16 15             0                     */
/*                  +----------------+----------------+                    */
/*       match[0]:  |       x        |       y        |                    */
/*                  +----------------+----------------+                    */
/*                                                                         */
/*                  31                               0                     */
/*                  +---------------------------------+                    */
/*       match[1]:  |   SAD value at location x, y    |                    */
/*                  +---------------------------------+                    */
/*                                                                         */
/*  ASSUMPTIONS                                                            */
/*      srcImg and refImg do not alias in memory                           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================= */

#include "IMG_mad_16x16.h"

void IMG_mad_16x16
(
    const unsigned char *restrict refImg,
    const unsigned char *restrict srcImg,
    int pitch,
    int h, int v,
    unsigned int *restrict match
)
{
    int i, j, x, y, matx, maty;
    unsigned matpos, matval;

    matval = ~0U;
    matx   = maty = 0;

    for (x = 0; x < h; x++)
        for (y = 0; y < v; y++)
        {
            unsigned acc = 0;

            for (i = 0; i < 16; i++)
                for (j = 0; j < 16; j++)
                    acc += abs(srcImg[i*16 + j] - refImg[(i+y)*pitch + x + j]);

            if (acc < matval)
            {
                matval = acc;
                matx   = x;
                maty   = y;
            }
        }

    matpos    = (0xffff0000 & (matx << 16)) | (0x0000ffff & maty);
    match[0] = matpos;
    match[1] = matval;
}
/* ======================================================================== */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */


mad_8x8.c/      1066929161  0     0     0       9686      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.11    Tue Mar 12 04:59:30 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_mad_8x8  - 8x8 Minimum Absolute Differences                     */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      03-Jan-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*      void IMG_mad_8x8                                                    */
/*      (                                                                   */
/*          const unsigned char *restrict refImg,                           */
/*          const unsigned char *restrict srcImg,                           */
/*          int pitch,                                                      */
/*          int                 h,                                          */
/*          int                 v,                                          */
/*          unsigned            *restrict match                             */
/*      )                                                                   */
/*                                                                          */
/*      refImg          Reference image.                                    */
/*      srcImg[64]      8x8 block image to look for.                        */
/*      pitch           Width of reference image.                           */
/*      h               Horiz. size of search area.                         */
/*      v               Vert.  size of search area.                         */
/*      match[2]        Result:                                             */
/*                          match[0] is packed x, y.                        */
/*                          match[1] is MAD value.                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This routine returns the location of the minimum absolute           */
/*      difference between a 8x8 search block and some block in a           */
/*      (h + 8) x (v + 8) search area. h and v are the sizes of the         */
/*      search space for the top left coordinate of the search block.       */
/*      refImg points to the top left pixel of the search area.             */
/*                                                                          */
/*           (0,0)          (h,0)      (h+8,0)                              */
/*             ;--------------+--------;                                    */
/*             ;    search    |        ;                                    */
/*             ;    space     |        ;                                    */
/*             ;              |        ;        search area                 */
/*             ;--------------+        ;        within reference image      */
/*           (0,v)          (h,v)      ;                                    */
/*             ;                       ;                                    */
/*             ;-----------------------;                                    */
/*           (0, v+8)                 (v+8,h+8)                             */
/*                                                                          */
/*      The location is returned relative to the above coordinate system    */
/*      as x and y packed in two 16-bit quantities in a 32-bit word:        */
/*                                                                          */
/*                  31             16 15             0                      */
/*                  +----------------+----------------+                     */
/*       match[0]:  |       x        |       y        |                     */
/*                  +----------------+----------------+                     */
/*                                                                          */
/*                  31                               0                      */
/*                  +---------------------------------+                     */
/*       match[1]:  |   SAD value at location x, y    |                     */
/*                  +---------------------------------+                     */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      srcImg and refImg do not alias in memory                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

#include "IMG_mad_8x8.h"

void IMG_mad_8x8
(
    const unsigned char *restrict refImg,
    const unsigned char *restrict srcImg,
    unsigned int pitch,
    unsigned int h,
    unsigned int v,
    unsigned int *restrict match
)
{
    int    i,         j,        x,     y;
    int              matx,      maty;
    unsigned int     matpos,    matval;

    matval  =   ~0U;               /* init. set to MAXPOS     */
    matx = maty = 0;

    /*--------------------------------------------------------*/
    /* mh: horizontal loop counter 0 .. H-1                   */
    /* mv: vertical   loop counter 0... V-1                   */
    /*  i: row        loop counter 0... 7                     */
    /*  i2:column     loop counter 0... 7                     */
    /* Perform absolute differnece and accumulate. Compare    */
    /* with previous mad and store off if less                */
    /*--------------------------------------------------------*/

    #ifndef NOASSUME
    _nassert((int)srcImg % 4 == 0);   /* Uncommenting causes perf loss */
    _nassert(pitch >  8);
    _nassert(h     >= 4);
    _nassert(v     >= 4);
    _nassert(v % 2 == 0);
   #endif

    for (x = 0; x < h ; x++)
    {
        for (y = 0; y < v ; y++)
        {
            unsigned acc = 0;

            for (i = 0; i < 8; i++)
            {
                for (j = 0; j < 8; j++)
                {
                     acc += abs(srcImg[i*8 + j] - refImg[(i+y)*pitch + x + j]);
                }
            }

            if (acc < matval)
            {
                matval = acc;
                matx   = x;
                maty   = y;
            }
        }
    }

    matpos    = (0xffff0000 & (matx << 16)) | (0x0000ffff & maty);
    match[0] = matpos;
    match[1] = matval;
}

/* ======================================================================== */
/*  End of file:  img_mad_8x8.c                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
median_3x3.c/   1066929161  0     0     0       10098     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Thu Jan 31 21:29:51 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================= */
/*                                                                         */
/*  TEXAS INSTRUMENTS, INC.                                                */
/*                                                                         */
/*  NAME                                                                   */
/*      IMG_median_3x3                                                     */
/*                                                                         */
/*                                                                         */
/*  REVISION DATE                                                          */
/*      12-Dec-1999                                                        */
/*                                                                         */
/*  USAGE                                                                  */
/*      This routine is C-callable and can be called as:                   */
/*                                                                         */
/*      void IMG_median_3x3                                                */
/*      (                                                                  */
/*          unsigned char   *in_data,                                      */
/*          int             cols,                                          */
/*          unsigned char   *out_data                                      */
/*      );                                                                 */
/*                                                                         */
/*      in_data  : Pointer to input array of unsigned chars                */
/*      cols     : Width of in_data                                        */
/*      out_data : Pointer to output array of unsigned chars               */
/*                                                                         */
/*  DESCRIPTION                                                            */
/*      The routine performs a 3x3 median filtering algorithm. It comes    */
/*      under the class of non-linear signal processing algorithms.        */
/*      Rather than replace the gray level at a pixel by a weighted        */
/*      average of the nine pixels including and surrounding it, the gray  */
/*      level at each pixel is replaced by the median of the nine values.  */
/*      The median of a set of nine numbers is the middle element so that  */
/*      half of the elements in the list are larger and half are smoother. */
/*      Median filtering removes the effect of extreme values from data.   */
/*      Using a wide mask to reduce the effect of noise results in         */
/*      unacceptable blurring of sharp edges in the original image.        */
/*                                                                         */
/*      void IMG_median_3x3()                                              */
/*      {                                                                  */
/*          read new vertical column of data into moving 3 column window   */
/*                                                                         */
/*          l00 = *IN1++;                                                  */
/*          l10 = *IN2++;                                                  */
/*          l20 = *IN3++;                                                  */
/*                                                                         */
/*          The data is pre-arranged as follows                            */
/*              l00, l01, l02           MAX                                */
/*              l10, l11, l12           MED                                */
/*              l20, l21, l22           MIN                                */
/*                                                                         */
/*          First sort l00,l10,l20 into MAX, MED, MIN                      */
/*                                                                         */
/*          Compare l00,l10 and sort into MAX, MIN                         */
/*          Compare l10,l20 and sort into MAX, MIN                         */
/*          Compare l00,l10 and sort into MAX, MIN                         */
/*                                                                         */
/*          3 compares and 6 moves                                         */
/*          Now sort l00,l01,l02 to find out minimum of max                */
/*              sort l10,l11,l12 to find ot median of median               */
/*              sort l20,l21,l22 to find out maximum of min                */
/*                                                                         */
/*          Now sort these three values, the middle value                  */
/*          of these three is the minimum.                                 */
/*      }                                                                  */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================= */

void IMG_median_3x3(unsigned char * in_data, int cols, unsigned char * out_data)
{
    unsigned char   * line0, * line1, *line2;
    int    l00_0, l01_0, l02_0, l10_0, l11_0, l12_0, l20_0, l21_0, l22_0;
    int    l00_1, l10_1, l10_2, l10_3, l20_1, l20_2;
    int    t0_1, t1_1, t1_2;
    int    i, minmax_0, maxmin_0, medmed_0;
    int    minmax_1, medmed_1, medmed_2, medmed_3;

    line0 = in_data;
    line1 = line0 + cols;
    line2 = line1 + cols;

    /*    l00   l01  l02        max's           */
    /*    l10   l11  l12        med's           */
    /*    l20   l21  l22        min's           */

    l01_0 = l11_0 = l21_0 = 127;
    l02_0 = l12_0 = l22_0 = 127;

    minmax_0 = l02_0;
    maxmin_0 = l22_0;

    for (i = 0; i < cols; i++)
    {
         l00_0 = *line0++;
         l10_0 = *line1++;
         l20_0 = *line2++;

         // sort l00_0, l10_0, l20_0

         l20_1 = l20_0; l10_1 = l10_0;
         if (l20_0 > l10_0) { l10_1 = l20_0;  l20_1 = l10_0; } // swap

         l00_1 = l00_0; l10_2 = l10_1;
         if (l10_1 > l00_0) { l00_1 = l10_1;  l10_2 = l00_0; } // swap

         l20_2 = l20_1;  l10_3 = l10_2;
         if (l20_1 > l10_2) { l10_3 = l20_1;  l20_2 = l10_2; } // swap

         if (l01_0 < minmax_0) minmax_0 = l01_0;    /* Compute min of max */
         if (l00_1 < minmax_0) minmax_0 = l00_1;

         if (l21_0 > maxmin_0) maxmin_0 = l21_0;    /* Comput max of min  */
         if (l20_2 > maxmin_0) maxmin_0 = l20_2;

         // sort l10 l11 l12

         t0_1 = l10_3;                /* Compute median of median */
         t1_1 = l11_0;
         if (l10_3 > l11_0)
         {
           t0_1 = l11_0;
           t1_1 = l10_3;
         }
         t1_2 = t1_1;
         if (t1_1 > l12_0)
         {
           t1_2 = l12_0;
         }

         medmed_0  = t1_2;
         if (t0_1 > t1_2) { medmed_0 = t0_1; } // swap

         // minmax, medmed, maxmin

         medmed_1 = medmed_0; minmax_1 = minmax_0;
         if (minmax_0 > medmed_0) { medmed_1 = minmax_0; minmax_1 = medmed_0; }

         medmed_2 = medmed_1;
         if (medmed_1 > maxmin_0) { medmed_2 = maxmin_0; }

         medmed_3 = medmed_2;
         if (minmax_1 > medmed_2) { medmed_3 = minmax_1; }

         /* Move data along by one column              */

         minmax_0 = l01_0;
         l12_0 = l11_0;
         maxmin_0 = l21_0;
         l01_0 = l00_1;
         l11_0 = l10_3;
         l21_0 = l20_2;

         *out_data++ = medmed_3;
     }
}
/*============================================================================*/
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/*============================================================================*/
mpeg2_vld0.c/   1066929162  0     0     0       36607     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.10    Wed May  1 23:05:00 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_mpeg2_vld_inter                                                 */
/*                                                                          */
/*  PLATFORM                                                                */
/*      C6200                                                               */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      16-Mar-2002                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*        void IMG_mpeg2_vld_inter                                          */
/*        (                                                                 */
/*            const short   *restrict Wptr,                                 */
/*            short         *restrict outi,                                 */
/*            IMG_mpeg2_vld *restrict Mpeg2v                                */
/*        );                                                                */
/*                                                                          */
/*        Wptr:       Pointer to the quantization matrix.  Must be in       */
/*                    the scan order corresponding to the inverse scan      */
/*                    matrix.                                               */
/*                                                                          */
/*        outi[6*64]: Pointer to the output array where the decoded and     */
/*                    dequantized IDCT coefficients are placed.             */
/*                    Elements assumed to be set to zero prior to           */
/*                    function call.  The routine assumes 6 8x8 blocks      */
/*                    per MB, i.e. 4:2:0 format.                            */
/*                                                                          */
/*        Mpeg2v:     Pointer to the context object, which includes the     */
/*                    input buffer variables.  The structure Mpeg2v is      */
/*                    defined as follows:                                   */
/*                                                                          */
/*C         #ifndef IMG_MPEG2_VLD_STRUCT_                                  C*/
/*C         #define IMG_MPEG2_VLD_STRUCT_ 1                                C*/
/*C                                                                        C*/
/*C         typedef struct {                                               C*/
/*C           unsigned int  *bsbuf;      // pointer to bitstream buffer    C*/
/*C           unsigned int  next_wptr;   // next word to read from buffer  C*/
/*C           unsigned int  bptr;        // bit position within word       C*/
/*C           unsigned int  word1;       // word aligned buffer            C*/
/*C           unsigned int  word2;       // word aligned buffer            C*/
/*C           unsigned int  top0;        // top 32 bits of bitstream       C*/
/*C           unsigned int  top1;        // next 32 bits of bitstream      C*/
/*C           const unsigned char *scan; // inverse zigzag scan matrix     C*/
/*C           unsigned int  intravlc;    // intra_vlc_format               C*/
/*C           unsigned int  quant_scale; // quant_scale                    C*/
/*C           unsigned int  dc_prec;     // intra_dc_precision             C*/
/*C           unsigned int  cbp;         // coded_block_pattern            C*/
/*C           unsigned int  fault;       // fault condition (returned)     C*/
/*C           unsigned int  reserved;                                      C*/
/*C         } IMG_mpeg2_vld;                                               C*/
/*C                                                                        C*/
/*C         #endif                                                         C*/
/*                                                                          */
/*        All variables in this structure must have the layout as shown     */
/*        since they are being accessed by this routine through             */
/*        appropriate offsets.  Other variables may be appended to the      */
/*        structure.                                                        */
/*                                                                          */
/*        The routine sets the fault flag Mpeg2v.fault to 1 if an invalid   */
/*        VLC code was encountered or the total run for a block exceeded    */
/*        63.  In theses cases the decoder has to resynchronize.            */
/*                                                                          */
/*      The routine requires proprietary variable length decoding           */
/*      look-up tables.  The tables are based on Table B-14 and B-15 in     */
/*      the MPEG-2 standard text.                                           */
/*                                                                          */
/*      The required lookup tables for this routine are provided in         */
/*      IMGLIB and are linked in automatically when linking against         */
/*      IMGLIB.                                                             */
/*                                                                          */
/*      Before calling the routine the bitstream varaibles in Mpeg2v have   */
/*      to be initialized.  If bsbuf[] is a circular buffer of size         */
/*      BSBUF_SIZE words and bsptr contains the number of bits in the       */
/*      buffer that already have been consumed, then next_wptr, bptr,       */
/*      word1, word2, top0 and top1 are initialized as follows:             */
/*                                                                          */
/*      1. nextwptr:  bsptr may not be a multiple of 32 (e.g. it points     */
/*         to bit number 40 in the bitstream), therefore set it to the      */
/*         next lower multiple of 32 by shift left by 5 (divide by 32).     */
/*         In case of 40 this yields 1.  Since memory is addressed in       */
/*         units of bytes this needs to be multiplied by 4 to get the       */
/*         address pointer.  Use next_wptr as index into bsbuf[].           */
/*                                                                          */
/*             next_wptr = (bsptr >> 5);                                    */
/*                                                                          */
/*      2. bptr:  bptr is the bit pointer which points to the current       */
/*         bit WITHIN the word pointed to by next_wptr.                     */
/*                                                                          */
/*            bptr = bsptr & 31;                                            */
/*            bptr_cmpl = 32 - bptr;                                        */
/*                                                                          */
/*      3. word1 and word2:  read next 3 words from the bitstream buffer    */
/*         (word0 is a temporary variable).                                 */
/*                                                                          */
/*            word0 = bsbuf[next_wptr];                                     */
/*            next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 */
/*                                                                          */
/*            word1 = bsbuf[next_wptr];                                     */
/*            next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 */
/*                                                                          */
/*            word2 = bsbuf[next_wptr];                                     */
/*            next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 */
/*                                                                          */
/*      4. top0 and top1:  Shift words word0, word1, word2 by bptr to       */
/*         the left so that the current bit becomes the MSB in word0.       */
/*         word0 can simply be shifted by bptr; the then empty LSBs of      */
/*         word0 have to be filled with the MSBs of word1.  To do that      */
/*         the required MSBs are brought into the position of empty         */
/*         LSBs of word0 by shifting word1 to the right by (32-bptr).       */
/*         The result is then copied into word0 by an addition.  Rather     */
/*         than overwriting word0, top0 is used to hold the new bit         */
/*         aligned word.  The same procedure is used to obtain top1.        */
/*         top0 and top1 contain the next 64 bits of the bitstream.         */
/*                                                                          */
/*            s1 = SHL(word0, bptr);                                        */
/*            s2 = SHR(word1, bptr_cmpl);  // unsigned right-shift          */
/*            top0 = s1 + s2;                                               */
/*                                                                          */
/*            s3 = SHL(word1, bptr);                                        */
/*            s4 = SHR(word2, bptr_cmpl);  //  unsigned right-shift         */
/*            top1 = s3 + s4;                                               */
/*                                                                          */
/*        SHL/SHR are macros that simulate C6000 shift functions if the     */
/*        routine is to be run on a PC or UNIX platform. They are           */
/*        defined as follows:                                               */
/*                                                                          */
/*            #ifdef _TMS320C6X                                             */
/*            # define SHL(x,y) ( (x) << (y) )                              */
/*            # define SHR(x,y) ( (x) >> (y) )                              */
/*            #else                                                         */
/*            # define SHL(x,y) ( ((y) & 32) ? 0 : ((x) << (y)) )           */
/*            # define SHR(x,y) ( ((y) & 32) ? 0 : ((x) >> (y)) )           */
/*            #endif                                                        */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      Decodes all coefficients of an MPEG-2 non-intra coded macroblock.   */
/*                                                                          */
/*      Checks coded block pattern (cbp), performs DC and AC decoding       */
/*      inlcuding, variable length decode, run-length expansion,            */
/*      inverse zigzag, dequantization, saturation and mismatch             */
/*      control.                                                            */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*    - zigzag matrix (Zptr) is 64 bytes circularly addressed and needs to  */
/*      be aligned at a 64 byte boundary (serves protection from random     */
/*      stores into memory)                                                 */
/*                                                                          */
/*    - inside the routine word1 (next_wptr-2) and word2 (next_wptr-1)      */
/*      are reconstructed from the bitstream buffer and therfore have to    */
/*      be kept alive in the bitstream buffer. For instance, in a double    */
/*      buffering scheme the bitstream buffer can only be updated when      */
/*      next_wptr-2 (and not next_wptr) has crossed the half buffer         */
/*      boundary.                                                           */
/*                                                                          */
/*    - look-up tables len and len_c should be offset against each other    */
/*      so that they start in different memory banks to avoid bank          */
/*      conflicts.                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*    - little endian                                                       */
/*                                                                          */
/*    - 4:2:0 color format supported only                                   */
/*                                                                          */
/*    - Wptr is allowed to overrun once (to detect total run overrun), so   */
/*      maximum overrun that can occur is 66 (Error mark). Therefore,       */
/*      in memory 66+1 half-words behind the weighting matrix should be     */
/*      valid (e.g. no cache or peripherals). No memory is overwritten,     */
/*      only loads occurr.                                                  */
/*                                                                          */
/*  DATA SIZE                                                               */
/*      2176 bytes for the lookup tables                                    */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

#ifdef _TMS320C6X
# define SHL(x,y) ( (x) << (y) )
# define SHR(x,y) ( (x) >> (y) )

#else

# define SHL(x,y) ( ((y) & 32) ? 0 : ((x) << (y)) )
# define SHR(x,y) ( ((y) & 32) ? 0 : ((x) >> (y)) )

unsigned int _lmbd(int bit, unsigned num);
unsigned int _norm(unsigned int x);
unsigned int _ext(int x, unsigned int a, unsigned int b);
unsigned int _extu(unsigned int x, unsigned int a, unsigned int b);
int _sshl(int x, unsigned int s);

#endif

#define BSBUF_SIZE  512 /* bitstream buffer size in words */

#ifndef IMG_MPEG2_VLD_STRUCT_
#define IMG_MPEG2_VLD_STRUCT_ 1

typedef struct {
  unsigned int  *bsbuf;      // pointer to bitstream buffer
  unsigned int  next_wptr;   // next word to read from buffer
  unsigned int  bptr;        // bit position within word
  unsigned int  word1;       // word aligned buffer
  unsigned int  word2;       // word aligned buffer
  unsigned int  top0;        // top 32 bits of bitstream
  unsigned int  top1;        // next 32 bits of bitstream
  const unsigned char *scan; // inverse zigzag scan matrix
  unsigned int  intravlc;    // intra_vlc_format
  unsigned int  quant_scale; // quant_scale
  unsigned int  dc_prec;     // intra_dc_precision
  unsigned int  cbp;         // coded_block_pattern
  unsigned int  fault;       // fault condition (returned)
  unsigned int  reserved;
} IMG_mpeg2_vld;

#endif

/* ----------------------------------------------------------------------- */
/*   Run-Level Tables                                                      */
/* ----------------------------------------------------------------------- */
extern unsigned short IMG_rld_table0[576];

/* ----------------------------------------------------------------------- */
/*   Length tables                                                         */
/* ----------------------------------------------------------------------- */
extern const unsigned char IMG_len_c_tbl0[512];
extern const unsigned char IMG_len_tbl0[512];

/* ----------------------------------------------------------------------- */
/*  Function                                                               */
/* ----------------------------------------------------------------------- */
void IMG_mpeg2_vld_inter
(
    const short   *restrict Wptr,
    short         *restrict outi,
    IMG_mpeg2_vld *restrict Mpeg2v
)
{

/* ----------------------------------------------------------------------- */
/*  get bitstream info                                                     */
/* ----------------------------------------------------------------------- */
    unsigned int        *bsbuf    = Mpeg2v->bsbuf;
    int                 next_wptr = Mpeg2v->next_wptr;
    int                 bptr      = Mpeg2v->bptr;
    unsigned int        word1     = Mpeg2v->word1;
    unsigned int        word2     = Mpeg2v->word2;
    unsigned int        top0      = Mpeg2v->top0;
    unsigned int        top1      = Mpeg2v->top1;
    const unsigned char *zzptr    = Mpeg2v->scan;
    int                 qscl      = Mpeg2v->quant_scale;
    int                 cbp       = Mpeg2v->cbp;

    unsigned int bptr_cmpl, top0_bk;

/* ----------------------------------------------------------------------- */
/*  block number (0-3: lum, 4, 5: chrom)                                   */
/* ----------------------------------------------------------------------- */
    int block;

/* ----------------------------------------------------------------------- */
/*  Variables for length, run and level decoding                           */
/* ----------------------------------------------------------------------- */
    unsigned int t1, t2, t4, t4b, t5, t7, t8, t9;
    int rld_left, rld_index;
    unsigned short run_level;
    unsigned char run, len, len_c;
    const unsigned char *t3, *t3b;
    short level;
    unsigned int eob_err, nrm, fault;
    unsigned int test1, test2;

/* ----------------------------------------------------------------------- */
/*  Variables for de-quantization                                          */
/* ----------------------------------------------------------------------- */
    int pos, neg, f1, f3, f5, qW, sum;
#ifdef _TMS320C6X
    int f4;
#else
    _int64 f4;
#endif
    const short *Wptr_origin=Wptr;
    short W;
    unsigned char cnum;

    fault=0;

    for (block=0; block<6; block++)
    {

    /* --------------------------------------------------------------------
     *  cbp: Bit 5 4 3 2 1 0 , if the corresponding bit is zero block no.
     *  (5-bit pos) is not coded
     * -------------------------------------------------------------------- */
        if (!(cbp & (1 << (5-block))))
            continue;

        zzptr = Mpeg2v->scan;
        Wptr=Wptr_origin;

        sum = 0;
        eob_err = 0;

    /* --------------------------------------------------------------------
     *  Decode first coefficient
     *
     *  First code is special case: when the MSB of the first code is '1',
     *  we know it can only be VLC '1s' (because EOB cannot occur and the
     *  only other code is '11s' which is not valid for the first code.)
     *  If MSB=0 skip to normal AC loop, i.e. use NORM+4 extra bits as
     *  table index; if MSB=1 execute special case, do not use
     *  NORM because it may have overrun but set LEN=2, LEN_C=30.
     * -------------------------------------------------------------------- */
        if (top0>>31)
        {

        /* ----------------------------------------------------------------
         *  Length computation, not required since we know LEN is 2.
         * ---------------------------------------------------------------- */
           len  = 2;
           len_c = 30;

        /* ----------------------------------------------------------------
         *  now that we know the length of the current VL code we can
         *  advance bitstream to next one:
         *
         *  1. update top0 from top0 and top1
         * ---------------------------------------------------------------- */
            t5  = top0 << len;
            t7  = top1 >> len_c;
            top0_bk = top0;
            top0 = t5 + t7;

        /* ----------------------------------------------------------------
         *  2. update top1 from word1 and word2 after increasing bptr by
         *  len.  if neccesary (i.e. if new bptr is greater than 32)
         *  update word1 and word2 from memory first. Don't forget that
         *  bptr is always relative to the next lower word boundary and
         *  therefore needs to be ANDed with 31 in case it become >=32.
         * ---------------------------------------------------------------- */
            bptr += len;
            test2 = (bptr >= 32);
            if (test2) {
                word1 = word2;
                word2 = bsbuf[next_wptr];
                next_wptr += 1;
                next_wptr &= (BSBUF_SIZE-1);
            }
            bptr = bptr & 31;
            bptr_cmpl = 32 - bptr;
            t8 = SHL(word1, bptr);
            t9 = SHR(word2, bptr_cmpl);                   /* unsigned shift */
            top1 = t8 + t9;

        /* ----------------------------------------------------------------
         *  Run-Level Decode: run = 0, level = 1
         * ---------------------------------------------------------------- */
            neg = _extu(top0_bk,1,31);

        /* ----------------------------------------------------------------
         *  Run-lengh expansion and DQ
         * ---------------------------------------------------------------- */

        /* ----------------------------------------------------------------
         *  Dequantisation: *out_i = ((2*level + Sign(level)) * W * qscl)
         *  / 32. Sign(x)=-1 for x<0, 0 for x=0, +1 for x>0. Division '/':
         *  "Integer division with truncation of the result toward zero.
         *  For example, 7/4 and -7/-4 are truncated to 1 and -7/4 and
         *  7/-4 are truncated to -1." (MPEG-2 Standard Text)
         * ---------------------------------------------------------------- */
            if (neg)
                f1=-3;                                          /* 2*(-1)-1 */
            else
                f1=3;                                              /* 2*1+1 */

        /* ----------------------------------------------------------------
         *  find quantization matrix element at zigzag position and
         *  multiply f1 with W * qscl
         * ---------------------------------------------------------------- */
            W = *Wptr++;
            qW = qscl * W;
            f3 = f1 * qW;

        /* ----------------------------------------------------------------
         *  for negative numbers we first need to add 31 before dividing
         *  by 32 to achieve truncation towards zero as required by the
         *  standard.
         * ---------------------------------------------------------------- */
            if (neg) f3 += 31;

        /* ----------------------------------------------------------------
         *  saturate to signed 12 bit word (with /32 <-> >>5 incorporated)
         *  SSHL: shift left and saturate to 32 bits
         * ---------------------------------------------------------------- */
            f4 = _sshl(f3, 15);
            f5 = (int)(f4 >> 20);

        /* ----------------------------------------------------------------
         *  mismatch control: determine if sum of coefficents is odd or
         *  even
         * ---------------------------------------------------------------- */
            sum += f5;

        /* ----------------------------------------------------------------
         *  find un-zigzag position of DCT coefficient
         * ---------------------------------------------------------------- */
            zzptr++;                                            /* always 0 */
            outi[block*64] = f5;
        }

    /* --------------------------------------------------------------------
     *  Decode AC coefficients
     * -------------------------------------------------------------------- */
        while (!eob_err)
        {

        /* ----------------------------------------------------------------
         *  Length computation
         * ---------------------------------------------------------------- */

        /* ----------------------------------------------------------------
         *  _norm returns the number of redundant sign bits in top0, e.g.
         *  0001 xxxx ... xxxx returns 2, 1111 10xx ... xxxx returns 4.
         *  Example: top=0000 101s xxxx xxxx, then nrm=3
         * ---------------------------------------------------------------- */
            nrm = _norm(top0);

        /* ----------------------------------------------------------------
         *  get rid of the leading all 0s/1s.
         *  Example: t1=0101 sxxx xxxx xxxx
         * ---------------------------------------------------------------- */
            t1  = top0 << nrm;

        /* ----------------------------------------------------------------
         *  use the number of leading bits (norm) as index,
         *  Example: t2= xxxx xxxx 0011 rrrr
         * ---------------------------------------------------------------- */
            t2  = nrm << 4;
            t3 = &IMG_len_tbl0[t2];

        /* ----------------------------------------------------------------
         *  use 4 extra bits after leading bits to distinguish special
         *  cases (32-4=28)
         * ---------------------------------------------------------------- */
            t4  = t1 >> 28;

        /* ----------------------------------------------------------------
         *  for advancing the bitstream we also need 32-len to shift top1
         *  and merge it with top0
         * ---------------------------------------------------------------- */
            t3b = &IMG_len_c_tbl0[t2];
            t4b = t1 >> 28;

        /* ----------------------------------------------------------------
         *  get len and 32-len from tables
         * ---------------------------------------------------------------- */
            len  = t3[t4];
            len_c = t3b[t4b];

        /* ----------------------------------------------------------------
         *  now that we know the length of the current VL code we can
         *  advance bitstream to next one:
         *
         *  1. update top0 from top0 and top1
         * ---------------------------------------------------------------- */
            t5  = top0 << len;
            t7  = top1 >> len_c;
            top0_bk = top0;
            top0 = t5 + t7;

        /* ---------------------------------------------------------------
         *  2. update top1 from word1 and word2 after increasing bptr by
         *  len.  if neccesary (i.e. if new bptr is greater than 32)
         *  update word1 and word2 from memory first. Don't forget that
         *  bptr is always relative to the next lower word boundary and
         *  therefore needs to be ANDed with 31 in case it become >=32.
         * ---------------------------------------------------------------- */
            bptr += len;
            test2 = (bptr >= 32);
            if (test2) {
                word1 = word2;
                word2 = bsbuf[next_wptr];
                next_wptr += 1;
                next_wptr &= (BSBUF_SIZE-1);
            }
            bptr = bptr & 31;
            bptr_cmpl = 32 - bptr;
            t8 = SHL(word1, bptr);
            t9 = SHR(word2, bptr_cmpl);                   /* unsigned shift */
            top1 = t8 + t9;

        /* ----------------------------------------------------------------
         *  Run-Level Decode
         * ---------------------------------------------------------------- */

        /* ----------------------------------------------------------------
         *  check if it is an ESCAPE code which has a unique fixed length
         *  of 24 bits
         * ---------------------------------------------------------------- */
            test1 = len - 24;

            if (!test1)
            {
            /* ------------------------------------------------------------
             * ESCAPE code: no look up required, just extract bits: 6 bits
             * for ESCAPE, 6 bits for RUN, then 12 bits for LEVEL
             * ------------------------------------------------------------ */
                run = _extu(top0_bk, 6, 26);
                level = _ext(top0_bk, 12, 20);
            }
            else
            {
                rld_left = len-5;
                if (len<5) rld_left=0;

                /* --------------------------------------------------------
                 *  last 5 bits of VLC incl. sign form 2nd part of index
                 * -------------------------------------------------------- */
                rld_index = ((len)<<5) + _extu(top0_bk, rld_left, 32-5);
                run_level = IMG_rld_table0[rld_index];

                /* -------------------------------------------------------
                 *  switch to signed look-up table because sign extraction
                 *  didn't fit in hand-coded loop with II=10. Was:
                 *   sign = _extu(top0_bk, len-1, 31);
                 *   if (sign) level=-level;
                 * ------------------------------------------------------- */
                run   = run_level >> 8;
                level = (char)run_level;
            }

            eob_err = (run >= 64);

        /* ----------------------------------------------------------------
         *  Run-lengh expansion and DQ
         * ---------------------------------------------------------------- */

        /* ----------------------------------------------------------------
         *  Dequantisation: *out_i = ((2*level + Sign(level)) * W * qscl)
         *  / 32. Sign(x)=-1 for x<0, 0 for x=0, +1 for x>0. Division '/':
         *  "Integer division with truncation of the result toward zero.
         *  For example, 7/4 and -7/-4 are truncated to 1 and -7/4 and
         *  7/-4 are truncated to -1." (MPEG-2 Standard Text)
         * ---------------------------------------------------------------- */
            neg = (level < 0);

            f1 = 2*level;

         /* ----------------------------------------------------------------
          *  This needs to be added over intra
          *  -------------------------------------------------------------- */
            pos = (level > 0);
            f1 = f1 - neg;
            f1 = f1 + pos;

        /* ----------------------------------------------------------------
         *  find quantization matrix element at zigzag position and
         *  multiply f1 with W * qscl
         * ---------------------------------------------------------------- */
            if (!eob_err)         /* prevent from accessing memory when EOB */
            {
                W = *(Wptr += run);
                Wptr++;
                /* detect total run overrun */
                eob_err = (Wptr - Wptr_origin)>64;
            }

            qW = qscl * W;
            f3 = f1 * qW;

        /* ----------------------------------------------------------------
         *  for negative numbers we first need to add 31 before dividing
         *  by 32 to achieve truncation towards zero as required by the
         *  standard.
         * ---------------------------------------------------------------- */
            if (neg) f3 += 31;

        /* ----------------------------------------------------------------
         *  saturate to signed 12 bit word (with /32 <-> >>5 incorporated)
         *  SSHL: shift left and saturate to 32 bits
         * ---------------------------------------------------------------- */
            f4 = _sshl(f3, 15);
            f5 = (int)(f4 >> 20);

        /* ----------------------------------------------------------------
         *  mismatch control: determine if sum of coefficents is odd or
         *  even
         * ---------------------------------------------------------------- */
            if (!eob_err)
                sum += f5;

        /* ----------------------------------------------------------------
         *  find un-zigzag position of DCT coefficient
         * ---------------------------------------------------------------- */
            if (!eob_err)         /* prevent from accessing memory when EOB */
                cnum = *(zzptr += run);
            zzptr++;
            if (!eob_err)
                outi[block*64+cnum] = f5;

        } /* while */

    /* --------------------------------------------------------------------
     *  mismatch control: toggle last bit of last coefficient if sum of
     *  coefficents is even.
     * -------------------------------------------------------------------- */

        if ((sum&1)==0)
        {
            outi[block*64+63] ^= 1;
        }

    /* -------------------------------------------------------------------- */
    /*  Determine nature of fault, invalid code word or exceeding of the    */
    /*  allowed total run of 64.                                            */
    /* -------------------------------------------------------------------- */
        fault = (run>65) || ((Wptr - Wptr_origin)>64);

        if (fault) break;

    } /* for */

    Mpeg2v->next_wptr = next_wptr;
    Mpeg2v->bptr      = bptr;
    Mpeg2v->word1     = word1;
    Mpeg2v->word2     = word2;
    Mpeg2v->top0      = top0;
    Mpeg2v->top1      = top1;
    Mpeg2v->fault     = fault;
}

/* ======================================================================== */
/*  End of file:  img_mpeg2_vld_inter.c                                     */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

mpeg2_vld1.c/   1066929162  0     0     0       36601     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.10    Sun Mar 17 04:52:24 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================= */
/*  TEXAS INSTRUMENTS, INC.                                                */
/*                                                                         */
/*  NAME                                                                   */
/*      IMG_mpeg2_vld_intra                                                */
/*                                                                         */
/*  PLATFORM                                                               */
/*      C6200                                                              */
/*                                                                         */
/*  REVISION DATE                                                          */
/*      03-Dec-2001                                                        */
/*                                                                         */
/*  USAGE                                                                   */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*        void IMG_mpeg2_vld_intra                                          */
/*        (                                                                 */
/*            const short   *restrict Wptr,                                 */
/*            short         *restrict outi,                                 */
/*            IMG_mpeg2_vld *restrict Mpeg2v,                               */
/*            int                     dc_pred[3]                            */
/*        );                                                                */
/*                                                                          */
/*        Wptr:       Pointer to the quantization matrix.  Must be in       */
/*                    the scan order corresponding to the inverse scan      */
/*                    matrix.                                               */
/*                                                                          */
/*        outi[6*64]: Pointer to the output array where the decoded and     */
/*                    dequantized IDCT coefficients are placed.             */
/*                    Elements assumed to be set to zero prior to           */
/*                    function call.  The routine assumes 6 8x8 blocks      */
/*                    per MB, i.e. 4:2:0 format.                            */
/*                                                                          */
/*        Mpeg2v:     Pointer to the context object, which includes the     */
/*                    input buffer variables.  The structure Mpeg2v is      */
/*                    defined as follows:                                   */
/*                                                                          */
/*C         #ifndef IMG_MPEG2_VLD_STRUCT_                                  C*/
/*C         #define IMG_MPEG2_VLD_STRUCT_ 1                                C*/
/*C                                                                        C*/
/*C         typedef struct {                                               C*/
/*C           unsigned int  *bsbuf;      // pointer to bitstream buffer    C*/
/*C           unsigned int  next_wptr;   // next word to read from buffer  C*/
/*C           unsigned int  bptr;        // bit position within word       C*/
/*C           unsigned int  word1;       // word aligned buffer            C*/
/*C           unsigned int  word2;       // word aligned buffer            C*/
/*C           unsigned int  top0;        // top 32 bits of bitstream       C*/
/*C           unsigned int  top1;        // next 32 bits of bitstream      C*/
/*C           const unsigned char *scan; // inverse zigzag scan matrix     C*/
/*C           unsigned int  intravlc;    // intra_vlc_format               C*/
/*C           unsigned int  quant_scale; // quant_scale                    C*/
/*C           unsigned int  dc_prec;     // intra_dc_precision             C*/
/*C           unsigned int  cbp;         // coded_block_pattern            C*/
/*C           unsigned int  fault;       // fault condition (returned)     C*/
/*C           unsigned int  reserved;                                      C*/
/*C         } IMG_mpeg2_vld;                                               C*/
/*C                                                                        C*/
/*C         #endif                                                         C*/
/*                                                                          */
/*        All variables in this strucure must have the layout as shown      */
/*        since they are being accessed by this routine through             */
/*        appropriate offsets.  Other variables may be appended to the      */
/*        structure.                                                        */
/*                                                                          */
/*        The routine sets the fault flag Mpeg2v.fault to 1 if an invalid   */
/*        VLC code was encountered or the total run for a block exceeded    */
/*        63.  In theses cases the decoder has to resynchronize.            */
/*                                                                          */
/*        dc_pred[3]: Intra DC prediction array.  The first element of      */
/*                    dc_pred is the DC prediction for Y, the second        */
/*                    for Cr and the third for Cb.                          */
/*                                                                          */
/*      The routine requires proprietary variable length decoding           */
/*      look-up tables.  The tables are based on Table B-14 and B-15 in     */
/*      the MPEG-2 standard text.                                           */
/*                                                                          */
/*      The required lookup tables for this routine are provided in         */
/*      IMGLIB and are linked in automatically when linking against         */
/*      IMGLIB.                                                             */
/*                                                                          */
/*      Before calling the routine the bitstream varaibles in Mpeg2v have   */
/*      to be initialized.  If bsbuf[] is a circular buffer of size         */
/*      BSBUF_SIZE words and bsptr contains the number of bits in the       */
/*      buffer that already have been consumed, then next_wptr, bptr,       */
/*      word1, word2, top0 and top1 are initialized as follows:             */
/*                                                                          */
/*      1. nextwptr:  bsptr may not be a multiple of 32 (e.g. it points     */
/*         to bit number 40 in the bitstream), therefore set it to the      */
/*         next lower multiple of 32 by shift left by 5 (divide by 32).     */
/*         In case of 40 this yields 1.  Since memory is addressed in       */
/*         units of bytes this needs to be multiplied by 4 to get the       */
/*         address pointer.  Use next_wptr as index into bsbuf[].           */
/*                                                                          */
/*             next_wptr = (bsptr >> 5);                                    */
/*                                                                          */
/*      2. bptr:  bptr is the bit pointer which points to the current       */
/*         bit WITHIN the word pointed to by next_wptr.                     */
/*                                                                          */
/*            bptr = bsptr & 31;                                            */
/*            bptr_cmpl = 32 - bptr;                                        */
/*                                                                          */
/*      3. word1 and word2:  read next 3 words from the bitstream buffer    */
/*         (word0 is a temporary variable).                                 */
/*                                                                          */
/*            word0 = bsbuf[next_wptr];                                     */
/*            next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 */
/*                                                                          */
/*            word1 = bsbuf[next_wptr];                                     */
/*            next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 */
/*                                                                          */
/*            word2 = bsbuf[next_wptr];                                     */
/*            next_wptr = (next_wptr + 1) & (BSBUF_SIZE-1);                 */
/*                                                                          */
/*      4. top0 and top1:  Shift words word0, word1, word2 by bptr to       */
/*         the left so that the current bit becomes the MSB in word0.       */
/*         word0 can simply be shifted by bptr; the then empty LSBs of      */
/*         word0 have to be filled with the MSBs of word1.  To do that      */
/*         the required MSBs are brought into the position of empty         */
/*         LSBs of word0 by shifting word1 to the right by (32-bptr).       */
/*         The result is then copied into word0 by an addition.  Rather     */
/*         than overwriting word0, top0 is used to hold the new bit         */
/*         aligned word.  The same procedure is used to obtain top1.        */
/*         top0 and top1 contain the next 64 bits of the bitstream.         */
/*                                                                          */
/*            s1 = SHL(word0, bptr);                                        */
/*            s2 = SHR(word1, bptr_cmpl);  // unsigned right-shift          */
/*            top0 = s1 + s2;                                               */
/*                                                                          */
/*            s3 = SHL(word1, bptr);                                        */
/*            s4 = SHR(word2, bptr_cmpl);  //  unsigned right-shift         */
/*            top1 = s3 + s4;                                               */
/*                                                                          */
/*        SHL/SHR are macros that simulate C6000 shift functions if the     */
/*        routine is to be run on a PC or UNIX platform. They are           */
/*        defined as follows:                                               */
/*                                                                          */
/*            #ifdef _TMS320C6X                                             */
/*            # define SHL(x,y) ( (x) << (y) )                              */
/*            # define SHR(x,y) ( (x) >> (y) )                              */
/*            #else                                                         */
/*            # define SHL(x,y) ( ((y) & 32) ? 0 : ((x) << (y)) )           */
/*            # define SHR(x,y) ( ((y) & 32) ? 0 : ((x) >> (y)) )           */
/*            #endif                                                        */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      Decodes all coefficients of an MPEG-2 intra coded macroblock.       */
/*                                                                          */
/*      Checks coded block pattern (cbp), performs DC and AC decoding       */
/*      inlcuding, variable length decode, run-length expansion,            */
/*      inverse zigzag, dequantization, saturation and mismatch             */
/*      control.                                                            */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*    - The bitstream must be stored in memory in 32-bit words which        */
/*      are in little Endian byte order.                                    */
/*                                                                          */
/*    - zigzag matrix (Zptr) is 64 bytes circularly addressed and needs     */
/*      to be aligned at a 64 byte boundary (serves protection from         */
/*      random stores into memory)                                          */
/*                                                                          */
/*    - inside the routine word1 (next_wptr-2) and word2 (next_wptr-1)      */
/*      are reconstructed from the bitstream buffer and therfore have       */
/*      to be kept alive in the bitstream buffer.  For instance, in a       */
/*      double buffering scheme the bitstream buffer can only be            */
/*      updated when next_wptr-2 (and not next_wptr) has crossed the        */
/*      half buffer boundary.                                               */
/*                                                                          */
/*  NOTES                                                                   */
/*    - little endian                                                       */
/*                                                                          */
/*    - 4:2:0 color format supported only                                   */
/*                                                                          */
/*    - Wptr is allowed to overrun once (to detect total run overrun),      */
/*      so maximum overrun that can occur is 66 (Error mark).               */
/*      Therefore, in memory 66+1 half-words behind the weighting           */
/*      matrix should be valid (e.g. no cache or peripherals).  No          */
/*      memory is overwritten, only loads occur.                            */
/*                                                                          */
/*    - look-up tables len and len_c are offset against each other so       */
/*      that they start in different memory banks to reduce bank            */
/*      conflicts.                                                          */
/*                                                                          */
/*  DATA SIZE                                                               */
/*      4352 bytes for lookup tables                                        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

#define BSBUF_SIZE  512                 /* bitstream buffer size in words */

#ifdef _TMS320C6X
# define SHL(x,y) ( (x) << (y) )
# define SHR(x,y) ( (x) >> (y) )

#else

# define SHL(x,y) ( ((y) & 32) ? 0 : ((x) << (y)) )
# define SHR(x,y) ( ((y) & 32) ? 0 : ((x) >> (y)) )

unsigned int _lmbd(int bit, unsigned num);
unsigned int _norm(unsigned int x);
unsigned int _ext(int x, unsigned int a, unsigned int b);
unsigned int _extu(unsigned int x, unsigned int a, unsigned int b);
int _sshl(int x, unsigned int s);

#endif

/* ----------------------------------------------------------------------- */
/*  Run-Level Tables                                                       */
/* ----------------------------------------------------------------------- */
extern unsigned short IMG_rld_table0[576];
extern unsigned short IMG_rld_table1[576];

/* ----------------------------------------------------------------------- */
/*  Length tables                                                          */
/* ----------------------------------------------------------------------- */
extern const unsigned char IMG_len_c_tbl0[512];
extern const unsigned char IMG_len_tbl0  [512];
extern const unsigned char IMG_len_c_tbl1[512];
extern const unsigned char IMG_len_tbl1  [512];

typedef struct {
    unsigned int  *bsbuf;      // pointer to bitstream buffer
    unsigned int  next_wptr;   // next word to read from buffer
    unsigned int  bptr;        // bit position within word
    unsigned int  word1;       // word aligned buffer
    unsigned int  word2;       // word aligned buffer
    unsigned int  top0;        // top 32 bits of bitstream
    unsigned int  top1;        // next 32 bits of bitstream
    unsigned char *scan;       // inverse zigzag scan matrix
    unsigned int  intravlc;    // intra_vlc_format
    unsigned int  quant_scale; // quant_scale
    unsigned int  dc_prec;     // intra_dc_precision
    unsigned int  cbp;         // coded_block_pattern
    unsigned int  fault;       // fault condition (returned)
    unsigned int  reserved;
} IMG_mpeg2_vld;

/* ----------------------------------------------------------------------- */
/*  Function                                                               */
/* ----------------------------------------------------------------------- */

void IMG_mpeg2_vld_intra
(
    const short   *restrict Wptr,
    short         *restrict outi,
    IMG_mpeg2_vld *restrict Mpeg2v,
    int                     dc_pred[3]
)
{

/* ----------------------------------------------------------------------- */
/*  get bitstream info                                                     */
/* ----------------------------------------------------------------------- */
    unsigned int        *bsbuf    = Mpeg2v->bsbuf;
    int                 next_wptr = Mpeg2v->next_wptr;
    int                 bptr      = Mpeg2v->bptr;
    unsigned int        word1     = Mpeg2v->word1;
    unsigned int        word2     = Mpeg2v->word2;
    unsigned int        top0      = Mpeg2v->top0;
    unsigned int        top1      = Mpeg2v->top1;
    const unsigned char *zzptr    = Mpeg2v->scan;
    int                 intra_vlc_format = Mpeg2v->intravlc;
    int                 qscl      = Mpeg2v->quant_scale;
    int                 intra_dc_precision = Mpeg2v->dc_prec;
    int                 cbp       = Mpeg2v->cbp;

    unsigned int bptr_cmpl, top0_bk;

/* ----------------------------------------------------------------------- */
/*  block number (0-3: lum, 4, 5: chrom)                                   */
/* ----------------------------------------------------------------------- */
    int block;

/* ----------------------------------------------------------------------- */
/*  Variables for intra DC decoding                                        */
/* ----------------------------------------------------------------------- */
    unsigned int cc, a_cc0, a_cc1, b, c, d, dc_size;
    int dc_diff, val, half_range;

/* ----------------------------------------------------------------------- */
/*  Variables for length, run and level decoding                           */
/* ----------------------------------------------------------------------- */
    unsigned int t1, t2, t4, t4b, t5, t7, t8, t9;
    int rld_left, rld_index;
    unsigned short run_level;
    unsigned char run, len, len_c;
    const unsigned char *t3, *t3b;
    short level;
    unsigned int eob_err, nrm, fault;
    unsigned int test1, test2;

/* ----------------------------------------------------------------------- */
/*  Variables for de-quantization                                          */
/* ----------------------------------------------------------------------- */
    int neg, f1, f3, f5, qW, sum;
#ifdef _TMS320C6X
    int f4;
#else
    _int64 f4;
#endif
    const short *Wptr_origin=Wptr;
    short W;
    unsigned char cnum;

    fault = 0;

    for (block=0; block<6; block++)
    {

    /* --------------------------------------------------------------------
     *  cbp: Bit 5 4 3 2 1 0 , if the corresponding bit is zero block no.
     *  (5-bit pos) is not coded
     * -------------------------------------------------------------------- */
        if (!(cbp & (1 << (5-block))))
            continue;

        zzptr = Mpeg2v->scan;
        Wptr=Wptr_origin;

        cc = (block<4) ? 0 : (block&1)+1;

        sum = 0;
        eob_err = 0;

    /* --------------------------------------------------------------------
     *  Decode first coefficient (DC coefficient) for INTRA block
     * -------------------------------------------------------------------- */

    /* --------------------------------------------------------------------
     *  Intra DC: decode dct_size and len (luminance and chrominance)
     * -------------------------------------------------------------------- */
        a_cc0 = a_cc1 = 0;
        b = _lmbd(0, top0);
        c = top0 >> 30;
        d = top0 >> 29;

        len = b + 1;
        if (cc==0)
        {
            dc_size = b + 2;
            a_cc0 = (b>=9);         /* the last VLC doesn't have a final 0! */
            b = b >> 1;
            d -= 4;
        }
        else
        {
            dc_size = b + 1;
            a_cc1 = (b>=10);        /* the last VLC doesn't have a final 0! */
            d = 1;                                          /* anything !=0 */
        }

        if (!b) len++;
        if (!c) dc_size--;
        if (!d) dc_size-=3;
        if (a_cc0)
        {
            len=9;
            dc_size=11;
        }
        if (a_cc1)
        {
            len=10;
            dc_size=11;
        }

    /* --------------------------------------------------------------------
     *  Intra DC: obtain QFS[0] from dc_size and dc_differential
     * -------------------------------------------------------------------- */
        dc_diff=0;
        t1 = top0 << len;
        if (dc_size!=0)
        {
            half_range = 1 << (dc_size-1);
            dc_diff = t1 >> (32-dc_size);
            if (dc_diff < half_range)
                dc_diff = (dc_diff+1)-(2*half_range);
        }
        val = (dc_pred[cc]+= dc_diff);

    /* --------------------------------------------------------------------
     *  Intra DC: de-quantization and store result
     * -------------------------------------------------------------------- */
        outi[block*64+0] = val << (3-intra_dc_precision);

    /* --------------------------------------------------------------------
     *  Intra DC: mismatch control
     * -------------------------------------------------------------------- */
        sum += outi[block*64+0];

    /* --------------------------------------------------------------------
     *  Intra DC: now that we know the length of the current VL code we
     *  can advance bitstream to next one, i.e. by len+dc_size:
     * -------------------------------------------------------------------- */
        len+=dc_size;

    /* --------------------------------------------------------------------
     *  from here it's the same code as used in the loop for the other
     *  coefficients
     * -------------------------------------------------------------------- */

    /* --------------------------------------------------------------------
     *  1. update top0 from top0 and top
     * -------------------------------------------------------------------- */
        t5  = top0 << len;
        t7  = top1 >> (32-len);
        top0_bk = top0;
        top0 = t5 + t7;

    /* --------------------------------------------------------------------
     *  2. update top1 from word1 and word2 after increasing bptr by len.
     *  if neccesary (i.e. if new bptr is greater than 32) update word1
     *  and word2 from memory first. Don't forget that bptr is always
     *  relative to the next lower word boundary and therefore needs to be
     *  ANDed with 31 in case it become >=32.
     * -------------------------------------------------------------------- */
        bptr += len;
        test2 = (bptr >= 32);
        if (test2) {
            word1 = word2;
            word2 = bsbuf[next_wptr];
            next_wptr += 1;
            next_wptr &= (BSBUF_SIZE-1);
        }
        bptr = bptr & 31;
        bptr_cmpl = 32 - bptr;
        t8 = SHL(word1, bptr);
        t9 = SHR(word2, bptr_cmpl);                      /* unsigned shift */
        top1 = t8 + t9;

        Wptr++;
        zzptr++;

    /* --------------------------------------------------------------------
     *  Decode AC coefficients
     * -------------------------------------------------------------------- */
        while (!eob_err)
        {

        /* ----------------------------------------------------------------
         *  Length computation
         * ---------------------------------------------------------------- */

        /* ----------------------------------------------------------------
         *  _norm returns the number of redundant sign bits in top0, e.g.
         *  0001 xxxx ... xxxx returns 2, 1111 10xx ... xxxx returns 4.
         *  Example: top=0000 101s xxxx xxxx, then nrm=3
         * ---------------------------------------------------------------- */
            nrm = _norm(top0);

        /* ----------------------------------------------------------------
         *  get rid of the leading all 0s/1s.
         *  Example: t1=0101 sxxx xxxx xxxx
         * ---------------------------------------------------------------- */
            t1  = top0 << nrm;

        /* ----------------------------------------------------------------
         *  use the number of leading bits (norm) as index,
         *  Example: t2= xxxx xxxx 0011 rrrr
         * ---------------------------------------------------------------- */
            t2  = nrm << 4;

            if (intra_vlc_format==0)
                t3 = &IMG_len_tbl0[t2];
            else /* intra_vlc_format==1 */
                t3 = &IMG_len_tbl1[t2];

        /* ----------------------------------------------------------------
         *  use 4 extra bits after leading bits to distinguish special
         *  cases (32-4=28)
         * ---------------------------------------------------------------- */
            t4  = t1 >> 28;

        /* ----------------------------------------------------------------
         *  for advancing the bitstream we also need 32-len to shift top1
         *  and merge it with top0
         * ---------------------------------------------------------------- */
            if (intra_vlc_format==0)
                t3b = &IMG_len_c_tbl0[t2];
            else /* intra_vlc_format==1 */
                t3b = &IMG_len_c_tbl1[t2];

            t4b = t1 >> 28;

        /* ----------------------------------------------------------------
         *  get len and 32-len from tables
         * ---------------------------------------------------------------- */
            len  = t3[t4];
            len_c = t3b[t4b];

        /* ----------------------------------------------------------------
         *  now that we know the length of the current VL code we can
         *  advance bitstream to next one:
         *
         *  1. update top0 from top0 and top1
         * ---------------------------------------------------------------- */
            t5  = top0 << len;
            t7  = top1 >> len_c;
            top0_bk = top0;
            top0 = t5 + t7;

        /* ---------------------------------------------------------------
         *  2. update top1 from word1 and word2 after increasing bptr by
         *  len.  if neccesary (i.e. if new bptr is greater than 32)
         *  update word1 and word2 from memory first. Don't forget that
         *  bptr is always relative to the next lower word boundary and
         *  therefore needs to be ANDed with 31 in case it become >=32.
         * ---------------------------------------------------------------- */
            bptr += len;
            test2 = (bptr >= 32);
            if (test2) {
                word1 = word2;
                word2 = bsbuf[next_wptr];
                next_wptr += 1;
                next_wptr &= (BSBUF_SIZE-1);
            }
            bptr = bptr & 31;
            bptr_cmpl = 32 - bptr;
            t8 = SHL(word1, bptr);
            t9 = SHR(word2, bptr_cmpl);                   /* unsigned shift */
            top1 = t8 + t9;

        /* ----------------------------------------------------------------
         *  Run-Level Decode
         * ---------------------------------------------------------------- */

        /* ----------------------------------------------------------------
         *  check if it is an ESCAPE code which has a unique fixed length
         *  of 24 bits
         * ---------------------------------------------------------------- */
            test1 = len - 24;

            if (!test1)
            {
            /* ------------------------------------------------------------
             * ESCAPE code: no look up required, just extract bits: 6 bits
             * for ESCAPE, 6 bits for RUN, then 12 bits for LEVEL
             * ------------------------------------------------------------ */
                run = _extu(top0_bk, 6, 26);
                level = _ext(top0_bk, 12, 20);
            }
            else
            {
                rld_left = len-5;
                if (len<5) rld_left=0;

                /* --------------------------------------------------------
                 *  last 5 bits of VLC incl. sign form 2nd part of index
                 * -------------------------------------------------------- */
                rld_index = ((len)<<5) + _extu(top0_bk, rld_left, 32-5);

                if (intra_vlc_format==0)
                   run_level = IMG_rld_table0[rld_index];
                else /* intra_vlc_format==1 */
                   run_level = IMG_rld_table1[rld_index];

                run   = run_level >> 8;
                level = (char)run_level;
            }

            eob_err = (run >= 64);

        /* ----------------------------------------------------------------
         *  Run-lengh expansion and DQ
         * ---------------------------------------------------------------- */

        /* ----------------------------------------------------------------
         *  Dequantisation: *out_i = ((2*level + Sign(level)) * W * qscl)
         *  / 32. Sign(x)=-1 for x<0, 0 for x=0, +1 for x>0. Division '/':
         *  "Integer division with truncation of the result toward zero.
         *  For example, 7/4 and -7/-4 are truncated to 1 and -7/4 and
         *  7/-4 are truncated to -1." (MPEG-2 Standard Text)
         * ---------------------------------------------------------------- */
            neg = (level < 0);

            f1 = 2*level;

        /* ----------------------------------------------------------------
         *  find quantization matrix element at zigzag position and
         *  multiply f1 with W * qscl
         * ---------------------------------------------------------------- */
            if (!eob_err)         /* prevent from accessing memory when EOB */
            {
                W = *(Wptr += run);
                Wptr++;
                /* detect total run overrun */
                eob_err = (Wptr - Wptr_origin)>64;
            }

            qW = qscl * W;
            f3 = f1 * qW;

        /* ----------------------------------------------------------------
         *  for negative numbers we first need to add 31 before dividing
         *  by 32 to achieve truncation towards zero as required by the
         *  standard.
         * ---------------------------------------------------------------- */
            if (neg) f3 += 31;

        /* ----------------------------------------------------------------
         *  saturate to signed 12 bit word (with /32 <-> >>5 incorporated)
         *  SSHL: shift left and saturate to 32 bits
         * ---------------------------------------------------------------- */
            f4 = _sshl(f3, 15);
            f5 = (int)(f4 >> 20);

        /* ----------------------------------------------------------------
         *  mismatch control: determine if sum of coefficents is odd or
         *  even
         * ---------------------------------------------------------------- */
            if (!eob_err)
                sum += f5;

        /* ----------------------------------------------------------------
         *  find un-zigzag position of DCT coefficient
         * ---------------------------------------------------------------- */
            if (!eob_err)         /* prevent from accessing memory when EOB */
                cnum = *(zzptr += run);
            zzptr++;
            if (!eob_err)
                outi[block*64+cnum] = f5;

        } /* while */

    /* --------------------------------------------------------------------
     *  mismatch control: toggle last bit of last coefficient if sum of
     *  coefficents is even.
     * -------------------------------------------------------------------- */

        if ((sum&1)==0)
        {
            outi[block*64+63] ^= 1;
        }

    /* -------------------------------------------------------------------- */
    /*  Determine nature of fault, invalid code word or exceeding of the    */
    /*  allowed total run of 64.                                            */
    /* -------------------------------------------------------------------- */
        fault = (run>65) || ((Wptr - Wptr_origin)>64);

        if (fault) break;

    } /* for */

    Mpeg2v->next_wptr = next_wptr;
    Mpeg2v->bptr      = bptr;
    Mpeg2v->word1     = word1;
    Mpeg2v->word2     = word2;
    Mpeg2v->top0      = top0;
    Mpeg2v->top1      = top1;
    Mpeg2v->fault     = fault;
}

/* ======================================================================== */
/*  End of file:  img_mpeg2_vld_intra.c                                     */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

perimeter.c/    1066929162  0     0     0       10601     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.5     Tue Mar 12 05:09:24 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      Perimeter  detection of a boundary image                            */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      06-Oct-1999                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      int IMG_perimeter(unsigned char *in_data, int  cols, unsigned char  */
/*      *out_data );                                                        */
/*                                                                          */
/*      in_data  : Input binary image                                       */
/*      cols     : Number of cols. Must be >= 3.                            */
/*      out_data : Output boundary image                                    */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This routine produces the IMG_perimeter of a binary image, by       */
/*      counting the number of boundary pixels of the input image.  It      */
/*      echoes the boundary pixels with a value of 0xFF and sets the        */
/*      other pixels as 0.  Detection of the boundary of a binary image     */
/*      is a segmentation problem and is done by examining spatial          */
/*      locality of the neighboring pixels.  This is done by using the      */
/*      four connectivity algorithm:                                        */
/*                                                                          */
/*                       pix_up                                             */
/*              pix_lft pix_cent pix_rgt                                    */
/*                       pix_dn                                             */
/*                                                                          */
/*      The output pixel at location pix_cent is echoed as a boundary       */
/*      pixel if pix_cent is non-zero and any one of its four neighbors     */
/*      is zero.  The four neighbors are shown and stand for the            */
/*      following:                                                          */
/*                                                                          */
/*              pix_up:  top pixel                                          */
/*              pix_lft: left pixel                                         */
/*              pix_rgt: right pixel                                        */
/*              pix_dn:  bottom pixel                                       */
/*                                                                          */
/*   CODE                                                                   */
/*      This is the C equivalent of the assembly code without               */
/*      restrictions: Note that the assembly code is hand optimized and     */
/*      restrictions may apply.                                             */
/*                                                                          */
/*      int IMG_perimeter(unsigned char *in_data, int  cols, unsigned char  */
/*      *out_data)                                                          */
/*      {                                                                   */
/*          int icols;                                                      */
/*          int count;                                                      */
/*                                                                          */
/*          unsigned char pix_lft, pix_rgt, pix_top;                        */
/*          unsigned char pix_bot, pix_cent;                                */
/*                                                                          */
/*          count = 0;                                                      */
/*                                                                          */
/*          for(icols = 1; icols < (cols-1); icols++ )                      */
/*          {                                                               */
/*              pix_lft = in_data[icols - 1];                               */
/*              pix_cent= in_data[icols + 0];                               */
/*              pix_rgt = in_data[icols + 1];                               */
/*                                                                          */
/*              pix_top = in_data[icols - cols];                            */
/*              pix_bot = in_data[icols + cols];                            */
/*                                                                          */
/*              if ( ( (pix_lft == 0) ||                                    */
/*                     (pix_rgt == 0) ||                                    */
/*                     (pix_top == 0) ||                                    */
/*                     (pix_bot == 0) ) && (pix_cent > 0) )                 */
/*              {                                                           */
/*                  out_data[icols] = pix_cent;                             */
/*                  count++;                                                */
/*              }                                                           */
/*              else                                                        */
/*              {                                                           */
/*                  out_data[icols] = 0;                                    */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*          return(count);                                                  */
/*      }                                                                   */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      No specific alignment is expected for the input or output array     */
/*      cols can be either even or odd.                                     */
/*                                                                          */
/*      This code expects three input lines each of cols pixels and         */
/*      produces one output line of cols - 1 pixels.                        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

int IMG_perimeter(unsigned char * in_im, int cols, unsigned char * out_im )
{
    int icols;
    int count;

    unsigned char pix_lft, pix_rgt, pix_top;
    unsigned char pix_bot, pix_cent;

    count = 0;

    for(icols = 1; icols < (cols-1); icols++ )
    {
        pix_lft = in_im[icols - 1];
        pix_cent= in_im[icols + 0];
        pix_rgt = in_im[icols + 1];

        pix_top = in_im[icols - cols];
        pix_bot = in_im[icols + cols];

        if (((pix_lft==0)||(pix_rgt==0)||(pix_top==0)||(pix_bot==0)) &&
            (pix_cent > 0))
        {
            out_im[icols] = pix_cent;
            count++;
        }
        else
        {
            out_im[icols] = 0;
        }
    }

    return(count);
}

/* ======================================================================== */
/*  End of file:  img_perimeter.c                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

pix_expand.c/   1066929162  0     0     0       4982      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Wed Dec 15 11:27:14 1999 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ========================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                   */
/*                                                                            */
/*  NAME                                                                      */
/*      IMG_pix_expand                                                        */
/*                                                                            */
/*  REVISION DATE                                                             */
/*      06-Nov-1999                                                           */
/*                                                                            */
/*  USAGE                                                                     */
/*      This routine is C-callable and can be called as:                      */
/*                                                                            */
/*      void IMG_pix_expand(int cols,unsigned char *in_data,short *out_data) ; */
/*                                                                            */
/*          cols = length of array                                            */
/*          in_data = pointer to input array of unsigned chars                */
/*          out_data = pointer to output array of shorts                      */
/*                                                                            */
/*                                                                            */
/*  DESCRIPTION                                                               */
/*      The code takes an array of unsigned chars (pixels) and zero           */
/*      extends them up to 16 bits to form shorts                             */
/*                                                                            */
/*  ASSUMPTIONS                                                               */
/*      This code is endian neutral.                                          */
/*      Input data is assumed to be unsigned                                  */
/*                                                                            */
/* -------------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ========================================================================== */

void IMG_pix_expand(int cols, const unsigned char *in_data, short *out_data)
{
    int j;

    for (j = 0; j < cols; j++)
    {
        out_data[j] = (short) in_data[j];
    }
}

/* ========================================================================== */
/*  End of file:  img_pix_expand.c                                            */
/* -------------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ========================================================================== */
pix_sat.c/      1066929162  0     0     0       4728      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Mon Mar 11 19:13:04 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================= */
/*                                                                         */
/*  TEXAS INSTRUMENTS, INC.                                                */
/*                                                                         */
/*  NAME                                                                   */
/*      IMG_pix_sat                                                        */
/*                                                                         */
/*                                                                         */
/*  REVISION DATE                                                          */
/*      10-Apr-1998                                                        */
/*                                                                         */
/*  USAGE                                                                  */
/*      This routine is C callable, and has the following C prototype:     */
/*                                                                         */
/*      void IMG_pix_sat(int n, short *in_data, unsigned char *out_data);  */
/*                                                                         */
/*      n        : Length of input array                                   */
/*      in_data  : Pointer to array of signed 16 bit numbers               */
/*      out_data : Pointer to array of clipped, unsigned 8 bit numbers.    */
/*                                                                         */
/*  DESCRIPTION                                                            */
/*      This code performs the saturation of 16 bit signed numbers to 8    */
/*      bit unsigned numbers. If the data is over 255 it is saturated to   */
/*      255, if it is less than 0 it is saturated to 0.                    */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================= */

void IMG_pix_sat(int n, short *in_data, unsigned char * out_data)
{
    int j;
    unsigned char pel;
    short pixel;

    for (j = 0; j < n; j++)
    {
        pixel = in_data[j];
        pel = (unsigned char) pixel;
        if (pixel > 0xff) pel = 0xff;
        if (pixel < 0x00) pel = 0x00;
        out_data[j] = pel;
    }
}
/*============================================================================*/
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/*============================================================================*/
quantize.c/     1066929162  0     0     0       9079      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Tue Mar  7 16:21:23 2000 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_quantize -- Matrix Quantization w/ Rounding, Little Endian      */
/*                                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      10-Dec-1999                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void IMG_quantize                                                   */
/*      (                                                                   */
/*          short       *data,      (* Data to be quantized.        *)      */
/*          int         num_blks,   (* Number of 64-element blocks. *)      */
/*          int         blk_sz,     (* Block size (multiple of 8).  *)      */
/*          const short *recip_tbl, (* Quant. values (reciprocals). *)      */
/*          int         q_pt        (* Q-point of Quant values.     *)      */
/*      )                                                                   */
/*                                                                          */
/*      The number of blocks, num_blks, must be at least 1.  The block      */
/*      size (number of elements in each block) must be at least 1.         */
/*      The Q-point, q_pt, controls rounding and final truncation; it       */
/*      must be in the range from 0 <= q_pt <= 31.                          */
/*                                                                          */
/*      The data[] array must be 'num_blks * blk_sz' elements, and the      */
/*      recip_tbl[] array must be 'blk_sz' elements.                        */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The function IMG_quantize() quantizes matrices by multiplying their */
/*      contents with a second matrix that contains reciprocals of the      */
/*      quantization terms.  This step corresponds to the quantization      */
/*      that is performed in 2-D DCT-based compression techniques,          */
/*      although IMG_quantize() may be used on any signed 16-bit data using */
/*      signed 16-bit quantization terms.                                   */
/*                                                                          */
/*      IMG_quantize() merely multiplies the contents of the quantization   */
/*      matrix with the data being quantized.  Therefore, it may be used    */
/*      for inverse quantization as well, by setting the Q-point            */
/*      appropriately.                                                      */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The inner loop steps through individual blocks, while the           */
/*      outer loop steps through reciprocals for quantization.  This        */
/*      eliminates redundant loads for the quantization terms.              */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The number of blocks, num_blks, must be at least 1.                 */
/*      The Q-point, q_pt, must be in the range 0 <= q_pt <= 31.            */
/*                                                                          */
/*  NOTES                                                                   */
/*      No checking is performed on the input arguments for correctness.    */
/*                                                                          */
/*  SOURCE                                                                  */
/*      n/a                                                                 */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

#include "IMG_quantize.h"

void IMG_quantize
(
    short       *data,          /* Data to be quantized.            */
    int         num_blks,       /* Number of 64-element blocks.     */
    int         blk_size,       /* Block size (multiple of 8).      */
    const short *recip_tbl,     /* Quant. values (reciprocals).     */
    int         q_pt            /* Q-point of Quant values.         */
)
{
    short recip;                /* Reciprocal term.                 */
    int   quot;                 /* Quotient (data * reciprocal)     */
    int   round;                /* Rounding value.                  */
    int   i, j, k;              /* Loop counters.                   */

    round = 1 << (q_pt - 1);    /* 0.5, represented in our q-point  */

    /* -------------------------------------------------------------------- */
    /*  Outer loop:  Step between quantization matrix elements.             */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < blk_size; i++)
    {
        /* ---------------------------------------------------------------- */
        /*  Load a reciprocal and point to appropriate element of block.    */
        /* ---------------------------------------------------------------- */
        recip   = recip_tbl[i];
        k       = i;

        /* ---------------------------------------------------------------- */
        /*  Inner loop:  Step between blocks of elements, quantizing.       */
        /* ---------------------------------------------------------------- */
        for (j = 0; j < num_blks; j++)
        {
            quot    = data[k] * recip + round;
            data[k] = quot >> q_pt;
            k      += blk_size;
        }
    }
}

/* ======================================================================== */
/*  End of file:  img_quantize.c                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

sad_16x16.c/    1066929162  0     0     0       5135      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Wed Jan 23 22:32:35 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  NAME                                                                    */
/*      IMG_sad_16x16 -- Sum of Absolute Differences on single 16x16 block  */
/*                                                                          */
/*  USAGE                                                                   */
/*      unsigned IMG_sad_16x16                                              */
/*      (                                                                   */
/*          const unsigned char *restrict srcImg,  // 16x16 source block // */
/*          const unsigned char *restrict refImg,  // Reference image    // */
/*          int pitch                              // Width of ref image // */
/*      );                                                                  */
/*                                                                          */
/*      The code accepts a pointer to the 16x16 source block (srcImg),      */
/*      and a pointer to the upper-left corner of a target position in      */
/*      a reference image (refImg).  The width of the reference image       */
/*      is given by the pitch argument.                                     */
/*                                                                          */
/*      The function returns the sum of the absolute differences            */
/*      between the source block and the 16x16 region pointed to in the     */
/*      reference image.                                                    */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The algorithm takes the difference between the pixel values in      */
/*      the source image block and the corresponding pixels in the          */
/*      reference image.  It then takes the absolute values of these        */
/*      differences, and accumulates them over the entire 16x16 region.     */
/*      It returns the final accumulation.                                  */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

unsigned IMG_sad_16x16
(
    const unsigned char *restrict srcImg,
    const unsigned char *restrict refImg,
    int pitch
)
{
    int i, j;
    unsigned sad = 0;


    for (i = 0; i < 16; i++)
        for (j = 0; j < 16; j++)
            sad += abs(srcImg[j + i*16] - refImg[j + i*pitch]);

    return sad;
}

/* ======================================================================== */
/*  End of file: img_sad_16x16.c                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

sad_8x8.c/      1066929162  0     0     0       5130      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Wed Jan 23 22:23:22 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  NAME                                                                    */
/*      IMG_sad_8x8   -- Sum of Absolute Differences on single 8x8 block    */
/*                                                                          */
/*  USAGE                                                                   */
/*      unsigned IMG_sad_8x8                                                */
/*      (                                                                   */
/*          const unsigned char *restrict srcImg,  // 8x8 source block   // */
/*          const unsigned char *restrict refImg,  // Reference image    // */
/*          int pitch                              // Width of ref image // */
/*      );                                                                  */
/*                                                                          */
/*      The code accepts a pointer to the 8x8 source block (srcImg),        */
/*      and a pointer to the upper-left corner of a target position in      */
/*      a reference image (refImg).  The width of the reference image       */
/*      is given by the pitch argument.                                     */
/*                                                                          */
/*      The function returns the sum of the absolute differences            */
/*      between the source block and the 8x8 region pointed to in the       */
/*      reference image.                                                    */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The algorithm takes the difference between the pixel values in      */
/*      the source image block and the corresponding pixels in the          */
/*      reference image.  It then takes the absolute values of these        */
/*      differences, and accumulates them over the entire 8x8 region.       */
/*      It returns the final accumulation.                                  */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

unsigned IMG_sad_8x8
(
    const unsigned char *restrict srcImg,
    const unsigned char *restrict refImg,
    int pitch
)
{
    int i, j;
    unsigned sad = 0;


    for (i = 0; i < 8; i++)
        for (j = 0; j < 8; j++)
            sad += abs(srcImg[j + i*8] - refImg[j + i*pitch]);

    return sad;
}

/* ======================================================================== */
/*  End of file: img_sad_8x8.c                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
sobel.c/        1066929162  0     0     0       11890     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Thu Apr 18 01:36:42 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_sobel                                                           */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      22-Jan-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*      void IMG_sobel                                                      */
/*      (                                                                   */
/*          const unsigned char    *in_data,      // Input image data  //   */
/*          unsigned char *restrict out_data,     // Output image data //   */
/*          short cols, short rows                // Image dimensions  //   */
/*      );                                                                  */
/*                                                                          */
/*      The IMG_sobel filter is applied to the input image. The input image */
/*      dimensions are given by the arguments 'cols' and 'rows'.  The       */
/*      output image is 'cols' pixels wide and 'rows - 2' pixels tall.      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      To see how the implementation is going to work on the input         */
/*      buffer, lets imagine we have the following input buffer:            */
/*      lets imagine we have the following input buffer:                    */
/*                                                                          */
/*              yyyyyyyyyyyyyyyy                                            */
/*              yxxxxxxxxxxxxxxy                                            */
/*              yxxxxxxxxxxxxxxy                                            */
/*              yxxxxxxxxxxxxxxy                                            */
/*              yxxxxxxxxxxxxxxy                                            */
/*              yyyyyyyyyyyyyyyy                                            */
/*                                                                          */
/*      The output buffer would be:                                         */
/*                                                                          */
/*              tXXXXXXXXXXXXXXz                                            */
/*              zXXXXXXXXXXXXXXz                                            */
/*              zXXXXXXXXXXXXXXz                                            */
/*              zXXXXXXXXXXXXXXt                                            */
/*                                                                          */
/*      Where:                                                              */
/*                                                                          */
/*          X = IMG_sobel(x)    The algorithm is applied to that pixel.     */
/*                          The correct output is obtained, the data        */
/*                          around the pixels we work on is used            */
/*                                                                          */
/*          t               Whatever was in the output buffer in that       */
/*                          position is kept there.                         */
/*                                                                          */
/*          z = IMG_sobel(y)    The algorithm is applied to that pixel.     */
/*                          The output is not meaningful, because the       */
/*                          necessary data to process the pixel is not      */
/*                          available.  This is because for each output     */
/*                          pixel we need input pixels from the right and   */
/*                          from the left of the output pixel.  But this    */
/*                          data doesn't exist.                             */
/*                                                                          */
/*      This means that we will only process (rows-2) lines.  Then, we      */
/*      will process all the pixels inside each line. Even though the       */
/*      results for the first and last pixels in each line will not         */
/*      be relevant, it makes the control much simpler and ends up          */
/*      saving cycles.                                                      */
/*                                                                          */
/*      Also the fist pixel in the first processed line and the             */
/*      last pixel in the last processed line will not be computed.         */
/*      It is not necessary, since the results would be bogus, and          */
/*      not computing them saves some time.                                 */
/*                                                                          */
/*      The following horizontal and vertical masks that are                */
/*      applied to the input buffer to obtain one output pixel.             */
/*                                                                          */
/*          Horizontal:                                                     */
/*              -1 -2 -1                                                    */
/*               0  0  0                                                    */
/*               1  2  1                                                    */
/*                                                                          */
/*          Vertical:                                                       */
/*              -1  0  1                                                    */
/*              -2  0  2                                                    */
/*              -1  0  1                                                    */
/*                                                                          */
/*  NOTES                                                                   */
/*      This is a LITTLE ENDIAN implementation.                             */
/*                                                                          */
/*      The values of the left-most and right-most pixels on each line      */
/*      of the output are not well-defined.                                 */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void IMG_sobel
(
    const unsigned char    *in,   /* Input image data   */
    unsigned char *restrict out,  /* Output image data  */
    short cols, short rows        /* Image dimensions   */
)
{
    int H, O, V, i;
    int i00, i01, i02;
    int i10,      i12;
    int i20, i21, i22;
    int w = cols;

    /* -------------------------------------------------------------------- */
    /*  Iterate over entire image as a single, continuous raster line.      */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < cols*(rows-2) - 2; i++)
    {
        /* ---------------------------------------------------------------- */
        /*  Read in the required 3x3 region from the input.                 */
        /* ---------------------------------------------------------------- */
        i00=in[i    ]; i01=in[i    +1]; i02=in[i    +2];
        i10=in[i+  w];                  i12=in[i+  w+2];
        i20=in[i+2*w]; i21=in[i+2*w+1]; i22=in[i+2*w+2];

        /* ---------------------------------------------------------------- */
        /*  Apply horizontal and vertical filter masks.  The final filter   */
        /*  output is the sum of the absolute values of these filters.      */
        /* ---------------------------------------------------------------- */

        H = -   i00 - 2*i01 -   i02 +
            +   i20 + 2*i21 +   i22;

        V = -   i00         +   i02
            - 2*i10         + 2*i12
            -   i20         +   i22;

        O = abs(H) + abs(V);

        /* ---------------------------------------------------------------- */
        /*  Clamp to 8-bit range.  The output is always positive due to     */
        /*  the absolute value, so we only need to check for overflow.      */
        /* ---------------------------------------------------------------- */
        if (O > 255) O = 255;

        /* ---------------------------------------------------------------- */
        /*  Store it.                                                       */
        /* ---------------------------------------------------------------- */
        out[i + 1] = O;
    }
}

/* ======================================================================== */
/*  End of file:  img_sobel.c                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
thr_gt2max.c/   1066929162  0     0     0       8165      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.2     Thu Mar 14 08:31:19 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_thr_gt2max                                                      */
/*                                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      13-Mar-2002                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*      void IMG_thr_gt2max                                                 */
/*      (                                                                   */
/*          const unsigned char *in_data,     //  Input image data  //      */
/*          unsigned char *restrict out_data, //  Output image data //      */
/*          short cols, short rows,           //  Image dimensions  //      */
/*          unsigned char       threshold     //  Threshold value   //      */
/*      )                                                                   */
/*                                                                          */
/*      This routine performs a thresholding operation on an input          */
/*      image in in_data[] whose dimensions are given in the arguments      */
/*      'cols' and 'rows'.  The thresholded pixels are written to the       */
/*      output image pointed to by out_data[].  The input and output        */
/*      are exactly the same dimensions.                                    */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      Pixels that are above the threshold value are written to the        */
/*      output unmodified.  Pixels that are greater than the threshold      */
/*      are set to 255 in the output image.                                 */
/*                                                                          */
/*      The exact thresholding function performed is described by           */
/*      the following transfer function diagram:                            */
/*                                                                          */
/*                 255_|          _________                                 */
/*                     |         |                                          */
/*                     |         |                                          */
/*            O        |         |                                          */
/*            U        |         |                                          */
/*            T    th _|. . . . .|                                          */
/*            P        |        /.                                          */
/*            U        |      /  .                                          */
/*            T        |    /    .                                          */
/*                     |  /      .                                          */
/*                   0_|/________.__________                                */
/*                     |         |        |                                 */
/*                     0        th       255                                */
/*                                                                          */
/*                             INPUT                                        */
/*                                                                          */
/*      Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2thr,     */
/*      and IMG_thr_le2min for other thresholding functions.                */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The input and output buffers do not alias.                          */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      This code is ENDIAN NEUTRAL.                                        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void IMG_thr_gt2max
(
    const unsigned char *in_data,                /*  Input image data    */
    unsigned char       *restrict out_data,      /*  Output image data   */
    short cols, short rows,                      /*  Image dimensions    */
    unsigned char       threshold                /*  Threshold value     */
)
{
    int i, pixels = rows * cols;

    /* -------------------------------------------------------------------- */
    /*  Step through input image copying pixels to the output.  If the      */
    /*  pixels are above our threshold, set them to 255.                    */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < pixels; i++)
        out_data[i] = in_data[i] > threshold ? 255 : in_data[i];
}

/* ======================================================================== */
/*  End of file:  img_thr_gt2max.c                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

thr_gt2thr.c/   1066929162  0     0     0       8251      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.1     Thu Mar 14 09:18:32 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_thr_gt2thr                                                      */
/*                                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      14-Mar-2002                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*      void IMG_thr_gt2thr                                                 */
/*      (                                                                   */
/*          const unsigned char *in_data,     //  Input image data  //      */
/*          unsigned char *restrict out_data, //  Output image data //      */
/*          short cols, short rows,           //  Image dimensions  //      */
/*          unsigned char       threshold     //  Threshold value   //      */
/*      )                                                                   */
/*                                                                          */
/*      This routine performs a thresholding operation on an input          */
/*      image in in_data[] whose dimensions are given in the arguments      */
/*      'cols' and 'rows'.  The thresholded pixels are written to the       */
/*      output image pointed to by out_data[].  The input and output        */
/*      are exactly the same dimensions.                                    */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      Pixels that are above the threshold value are written to the        */
/*      output unmodified.  Pixels that are greater than the threshold      */
/*      are set to the threshold value in the output image.                 */
/*                                                                          */
/*      The exact thresholding function performed is described by           */
/*      the following transfer function diagram:                            */
/*                                                                          */
/*                                                                          */
/*                 255_|                                                    */
/*                     |                                                    */
/*                     |                                                    */
/*            O        |                                                    */
/*            U        |                                                    */
/*            T    th _|. . . . . _________                                 */
/*            P        |        /.                                          */
/*            U        |      /  .                                          */
/*            T        |    /    .                                          */
/*                     |  /      .                                          */
/*                   0_|/________.__________                                */
/*                     |         |        |                                 */
/*                     0        th       255                                */
/*                                                                          */
/*                             INPUT                                        */
/*                                                                          */
/*                                                                          */
/*      Please see the IMGLIB functions IMG_thr_le2thr, IMG_thr_le2min      */
/*      and IMG_thr_gt2max for other thresholding functions.                */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The input and output buffers do not alias.                          */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      This code is ENDIAN NEUTRAL.                                        */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void IMG_thr_gt2thr
(
    const unsigned char *in_data,                /*  Input image data    */
    unsigned char       *restrict out_data,      /*  Output image data   */
    short cols, short rows,                      /*  Image dimensions    */
    unsigned char       threshold                /*  Threshold value     */
)
{
    int i, pixels = rows * cols;

    /* -------------------------------------------------------------------- */
    /*  Step through input image copying pixels to the output.  If the      */
    /*  pixels are above our threshold, set them to the threshold value.    */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < pixels; i++)
        out_data[i] = in_data[i] > threshold ? threshold : in_data[i];
}

/* ======================================================================== */
/*  End of file:  img_thr_gt2thr.c                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

thr_le2min.c/   1066929162  0     0     0       8191      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.7     Thu Mar 14 09:31:21 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      threshold                                                           */
/*                                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      16-Jul-1999                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*      void IMG_thr_le2min                                                 */
/*      (                                                                   */
/*          const unsigned char *in_data,     //  Input image data  //      */
/*          unsigned char *restrict out_data, //  Output image data //      */
/*          short cols, short rows,           //  Image dimensions  //      */
/*          unsigned char       threshold     //  Threshold value   //      */
/*      )                                                                   */
/*                                                                          */
/*      This routine performs a thresholding operation on an input          */
/*      image in in_data[] whose dimensions are given in the arguments      */
/*      'cols' and 'rows'.  The thresholded pixels are written to the       */
/*      output image pointed to by out_data[].  The input and output        */
/*      are exactly the same dimensions.                                    */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      Pixels that are above the threshold value are written to the        */
/*      output unmodified.  Pixels that are less than or equal to the       */
/*      threshold are set to 0 in the output image.                         */
/*                                                                          */
/*      The exact thresholding function performed is described by           */
/*      the following transfer function diagram:                            */
/*                                                                          */
/*                                                                          */
/*                 255_|                                                    */
/*                     |                  /                                 */
/*                     |                /                                   */
/*            O        |              /                                     */
/*            U        |            /                                       */
/*            T    th _|. . . . . /                                         */
/*            P        |         |                                          */
/*            U        |         |                                          */
/*            T        |         |                                          */
/*                     |         |                                          */
/*                   0_|_________|__________                                */
/*                     |         |        |                                 */
/*                     0        th       255                                */
/*                                                                          */
/*                             INPUT                                        */
/*                                                                          */
/*      Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2thr,     */
/*      and IMG_thr_gt2max for other thresholding functions.                */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The input and output buffers do not alias.                          */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      This code is ENDIAN NEUTRAL.                                        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void IMG_thr_le2min
(
    const unsigned char *in_data,       /*  Input image data    */
    unsigned char       *out_data,      /*  Output image data   */
    short cols, short rows,             /*  Image dimensions    */
    unsigned char       threshold       /*  Threshold value     */
)
{
    int i;

    /* -------------------------------------------------------------------- */
    /*  Step through input image copying pixels to the output.  If the      */
    /*  pixels are below our threshold, set them to zero.                   */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < rows * cols; i++)
        out_data[i] = in_data[i] <= threshold ? 0 : in_data[i];
}

/* ======================================================================== */
/*  End of file:  img_thr_le2min.c                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

thr_le2thr.c/   1066929162  0     0     0       8172      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.2     Thu Mar 14 09:15:29 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_thr_le2thr                                                      */
/*                                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      14-Mar-2002                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*      void IMG_thr_le2thr                                                 */
/*      (                                                                   */
/*          const unsigned char *in_data,     //  Input image data  //      */
/*          unsigned char *restrict out_data, //  Output image data //      */
/*          short cols, short rows,           //  Image dimensions  //      */
/*          unsigned char       threshold     //  Threshold value   //      */
/*      )                                                                   */
/*                                                                          */
/*      This routine performs a thresholding operation on an input          */
/*      image in in_data[] whose dimensions are given in the arguments      */
/*      'cols' and 'rows'.  The thresholded pixels are written to the       */
/*      output image pointed to by out_data[].  The input and output        */
/*      are exactly the same dimensions.                                    */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      Pixels that are above the threshold value are written to the        */
/*      output unmodified.  Pixels that are less than or equal to the       */
/*      threshold are set to the threshold value in the output image.       */
/*                                                                          */
/*      The exact thresholding function performed is described by           */
/*      the following transfer function diagram:                            */
/*                                                                          */
/*                                                                          */
/*                 255_|                                                    */
/*                     |                  /                                 */
/*                     |                /                                   */
/*            O        |              /                                     */
/*            U        |            /                                       */
/*            T    th _|_________ /                                         */
/*            P        |         .                                          */
/*            U        |         .                                          */
/*            T        |         .                                          */
/*                     |         .                                          */
/*                   0_|_________.__________                                */
/*                     |         |        |                                 */
/*                     0        th       255                                */
/*                                                                          */
/*                             INPUT                                        */
/*                                                                          */
/*      Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2min      */
/*      and IMG_thr_gt2max for other thresholding functions.                */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The input and output buffers do not alias.                          */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      This code is ENDIAN NEUTRAL.                                        */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void IMG_thr_le2thr
(
    const unsigned char *in_data,                /*  Input image data    */
    unsigned char       *restrict out_data,      /*  Output image data   */
    short cols, short rows,                      /*  Image dimensions    */
    unsigned char       threshold                /*  Threshold value     */
)
{
    int i, pixels = rows * cols;

    /* -------------------------------------------------------------------- */
    /*  Step through input image copying pixels to the output.  If the      */
    /*  pixels are below our threshold, set them to the threshold value.    */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < pixels; i++)
        out_data[i] = in_data[i] <= threshold ? threshold : in_data[i];
}

/* ======================================================================== */
/*  End of file:  img_thr_le2thr.c                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
wave_horz.c/    1066929162  0     0     0       11369     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.5     Fri Mar 15 14:58:23 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_wave_horz                                                       */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      21-Oct-1999                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*          void IMG_wave_horz                                              */
/*          (                                                               */
/*              const short *restrict in_data,  // Row of input pixels  //  */
/*              const short *restrict qmf,      // Low-pass QMF filter  //  */
/*              const short *restrict mqmf,     // High-pass QMF filter //  */
/*              short       *restrict out_data, // Row of output data   //  */
/*              int                   cols      // Length of input.     //  */
/*          );                                                              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This kernel performs a 1D Periodic Orthogonal Wavelet               */
/*      decomposition.  This also performs the row decomposition in a 2D    */
/*      wavelet transform.  An input signal x[n] is low pass and high pass  */
/*      filtered and decimated by two.  This results in a reference signal  */
/*      r1[n] which is the decimated output obtained by dropping the odd    */
/*      samples of the low pass filtered output and a detail signal d[n]    */
/*      obtained by dropping the odd samples of the high-pass output.  A    */
/*      circular convolution algorithm is implemented and hence the         */
/*      wavelet transform is periodic.  The reference signal and the        */
/*      detail signal are half the size of the original signal.  The        */
/*      reference signal may then be iterated again to perform another      */
/*      scale of multi-resolution analysis.                                 */
/*                                                                          */
/*  CODE                                                                    */
/*  ASSUMPTIONS                                                             */
/*      This routine assumes that the number of filter taps for the qmf     */
/*      and mqmf is 8.                                                      */
/*                                                                          */
/*      This code assumes that filter coefficients are maintained as        */
/*      shorts in Q15 format.                                               */
/*                                                                          */
/*      It also assumes that input data is an array of shorts (16 bit)      */
/*      (The input is assumed to be an array of shorts to allow for         */
/*      re-using this kernel to perform Multi Resolution Analysis as        */
/*      the output of this code will feedback again as input in the         */
/*      next stage.)                                                        */
/*                                                                          */
/*      Since the transform is a dyadic wavelet cols should be a multiple   */
/*      of 2.                                                               */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      This code is ENDIAN Neutral.                                        */
/*                                                                          */
/*  NOTES                                                                   */
/*      This code can implement the Daubechies D4 filterbank for            */
/*      analysis with 4 vansishing moments.  The length of the analyzing    */
/*      low-pass and high pass filters is 8 in that case.                   */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

#define Qpt 15
#define Qr 16384

void IMG_wave_horz
(
    const short *restrict in_data,  // Row of input pixels
    const short *restrict qmf,      // Low-pass QMF filter
    const short *restrict mqmf,     // High-pass QMF filter
    short       *restrict out_data, // Row of output data
    int                   cols      // Length of input.
)
{
    int         i, res, iters;
    int         j, sum, prod;
    const short *restrict xptr  = in_data;
    const short *restrict x_end = &in_data[cols - 1];
    short       xdata, hdata;
    const short *restrict xstart;
    const short *restrict filt_ptr;
    int         M = 8;

    /* ------------------------------------------------- */
    /*  Set our loop trip count and starting x posn.     */
    /*  'xstart' is used in the high-pass filter loop.   */
    /* ------------------------------------------------- */
    iters  = cols;
    xstart = in_data + (cols - M)  + 2;

    /* ------------------------------------------------- */
    /*  Low pass filter.  Iterate for cols/2 iterations  */
    /*  generating cols/2 low pass sample points with    */
    /*  the low-pass quadrature mirror filter.           */
    /* ------------------------------------------------- */
    for (i = 0; i < iters; i += 2)
    {
        /* --------------------------------------------- */
        /*  Initialize our sum to the rounding value     */
        /*  and reset our pointer.                       */
        /* --------------------------------------------- */
        sum  = Qr;
        xptr = in_data + i;

        /* --------------------------------------------- */
        /*  Iterate over the taps in our QMF.            */
        /* --------------------------------------------- */
        for (j = 0; j < M; j++)
        {
            xdata = *xptr++;
            hdata =  qmf[j];
            prod  =  xdata * hdata;
            sum  += prod;
            if (xptr > x_end) xptr = in_data;
        }

        /* --------------------------------------------- */
        /*  Adjust the Qpt of our sum and store result.  */
        /* --------------------------------------------- */
        res    = (sum >> Qpt);
        *out_data++ = res;
    }

    /* ------------------------------------------------- */
    /*  High pass filter.  Iterate for cols/2 iters      */
    /*  generating cols/2 high pass sample points with   */
    /*  the high-pass quadrature mirror filter.          */
    /* ------------------------------------------------- */
    for (i = 0; i < iters ; i+=2)
    {
        /* --------------------------------------------- */
        /*  Initialize our sum and filter pointer.       */
        /* --------------------------------------------- */
        sum  = Qr;
        filt_ptr  = mqmf + (M - 1);

        /* --------------------------------------------- */
        /*  Set up our data pointer.  This is slightly   */
        /*  more complicated due to how the data wraps   */
        /*  around the edge of the buffer.               */
        /* --------------------------------------------- */
        xptr = xstart;
        xstart += 2;
        if (xstart > x_end) xstart = in_data;

        /* --------------------------------------------- */
        /*  Iterate over the taps in our QMF.            */
        /* --------------------------------------------- */
        for ( j = 0; j < M; j++)
        {
            xdata = *xptr++;
            hdata = *filt_ptr--;
            prod  = xdata * hdata;
            if (xptr > x_end) xptr = in_data;
            sum  += prod;
        }

        /* --------------------------------------------- */
        /*  Adjust the Qpt of our sum and store result.  */
        /* --------------------------------------------- */
        res = (sum >> Qpt);
        *out_data++ =  res;
    }
}

/* ======================================================================== */
/*  End of file:  img_wave_horz.c                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

wave_vert.c/    1066929162  0     0     0       15906     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.5     Tue Mar 12 05:18:08 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_wave_vert : Vertical Pass of Wavelet Transform                  */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      23-Oct-1999                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*      void IMG_wave_vert                                                  */
/*      (                                                                   */
/*          const short *restrict                                           */
/*                      *restrict in_data,                                  */
/*          const short *restrict qmf,                                      */
/*          const short *restrict mqmf,                                     */
/*          short       *restrict out_ldata,                                */
/*          short       *restrict out_hdata,                                */
/*          int cols                                                        */
/*      );                                                                  */
/*                                                                          */
/*      in_data   : Array of row pointers. Data must be word aligned.       */
/*      qmf[8]    : Low pass QMF filter. Must be 8 taps and word aligned.   */
/*      mqmf[8]   : High pass QMF filter. Must be 8 taps and word aligned.  */
/*      out_ldata : Low pass output data                                    */
/*      out_hdata : High pass output data                                   */
/*      cols      : Length of rows to process. Must be a multiple of 2.     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The benchmark performs the vertical pass of 2D wavelet              */
/*      transform. It performs a vertical filter on 8 rows which are        */
/*      pointed to by the pointers contained in an array of pointers.       */
/*      It produces two lines worth of output, one being the low-pass       */
/*      and the other being the high pass result. Instead of performing     */
/*      a transpose on the column and re-using the wave_horz kernel,        */
/*      the vertical filter is traversed over the entire width of the       */
/*      line and the low pass and high pass filtering kernels are           */
/*      performed together.                                                 */
/*                                                                          */
/*      This implies that the low-pass and highpass filters be              */
/*      overlapped in execution so that the input data array may be         */
/*      loaded once and both filters can be exceuted in parallel.           */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      Since the wavelet transform is dyadic, cols is assumed to be a      */
/*      multiple of 2.                                                      */
/*                                                                          */
/*      The mqmf filter is constructed from the qmf as follows:             */
/*                                                                          */
/*          status = -1;                                                    */
/*          for (i = 0; i < 8; i++)                                         */
/*          {                                                               */
/*              status = status * -1;                                       */
/*              hdata  = qmf[i] * status;                                   */
/*              filter[i] = hdata;                                          */
/*          }                                                               */
/*                                                                          */
/*      The kernels assume that the number of filter taps is exactly        */
/*      8.  In addition data that is loaded for producing out_ldata[0]      */
/*      and out_hdata[0] is not identical. The data loaded for              */
/*      producing out_hdata[0] produces results at the location             */
/*                                                                          */
/*          out_lstart = o_im + ((rows >> 1) - 3) * cols                    */
/*          out_hstart = o_im + (rows >> 1) * cols                          */
/*                                                                          */
/*      Where o_im is start of output image, rows is # of rows of the       */
/*      input image, and cols is # of cols of the output image. Hence       */
/*      after three calls to the kernel in which the following output       */
/*      lines get filled the low-pass pointer should be reset to point to   */
/*      the start. Since the wavelet transform is dyadic rows is assumed    */
/*      to be a multiple of 2 as well, just like cols.                      */
/*                                                                          */
/*      The following table illustrates how ylptr and yhptr need to be      */
/*      updated at the start of each call to this function:                 */
/*                                                                          */
/*      Call#        out_ldata                  out_hdata                   */
/*        1          out_lstart                 out_hstart                  */
/*        2          out_lstart + cols          out_hstart + cols           */
/*        3          out_lstart + 2*cols        out_hstart + 2*cols         */
/*                                                                          */
/*      At this point ylptr wraps around to become o_im, while yhptr        */
/*      proceeds as usual:                                                  */
/*                                                                          */
/*        4          o_im                       out_hstart + 3*cols         */
/*                                                                          */
/*      In addition the kernel accepts a pointer to an array of             */
/*      pointers for each input line so that a working buffer of 10         */
/*      lines can be used to effectively mix DMA's and processing as        */
/*      shown below:                                                        */
/*                                                                          */
/*      ihptr                        LINE BUFFER                            */
/*      ptr0   ---->|-------------------------------------------------|     */
/*      ptr1   ---->|-------------------------------------------------|     */
/*      ...                                                                 */
/*      ptr7   ---->|-------------------------------------------------|     */
/*                                                                          */
/*      At the start of the kernel 8 input lines are filled to the          */
/*      first 8 lines and processing begins.  In the background the next    */
/*      two lines are fetched.  The pointers are moved up by 2 namely       */
/*      ptr[i] = ptr[i+2] and the last two lines now point to lines 9       */
/*      and 10 and processing starts again.  In the background the next     */
/*      two lines are brought in the first two lines of the line            */
/*      buffer.  Pointers move up again by 2 but now the last two           */
/*      pointers to line 0 and 1.  This pattern then repeats.               */
/*                                                                          */
/*      The first line to begin filtering is always obtained from           */
/*      ptr[0], the next from ptr[1] and so on.                             */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      In order to eliminate bank conflicts succesive lines in the line    */
/*      buffer or the pointers to these lines are seperated by exactly one  */
/*      word so that loads to any succesive lines may be parallelized       */
/*      together.                                                           */
/*                                                                          */
/*      This code is a LITTLE ENDIAN implementation.                        */
/*                                                                          */
/*  BIBLIOGRAPHY                                                            */
/*      Mallat, Stephane. "A Wavelet Tour of Signal Processing", pg. 309.   */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

#define Qpt 15
#define Qr 16384
#define Qs 32767

void IMG_wave_vert
(
    const short *restrict
    const       *restrict in_data,   /* Array of row pointers */
    const short *restrict qmf,       /* Low pass QMF filter   */
    const short *restrict mqmf,      /* High pass QMF filter  */
    short       *restrict out_ldata, /* Low pass output data  */
    short       *restrict out_hdata, /* High pass output data */
    int cols                     /* Length of rows to process */
)
{
   int   i, iters, j;
   int   sum_h, sum_l;
   int   prod_h, prod_l;
   short res_h, res_l;
   short xdata, hdata, ldata;
   const short *restrict filt_ptr;
   const int M = 8;

   /*-------------------------------------------------------------------*/
   /* iters: variable for the # of loop iterations. Both the low pass   */
   /* and the high pass filters produce iters points, which is also     */
   /* the width of the input line. The low-pass filter reads filter     */
   /* coefficients from qmf and the high pass filter reads filter coeff-*/
   /* icients from the conjugate mirror filter. In addition note that   */
   /* the low-pass filter the coefficients are read in increasing order */
   /* while the high pass the filter coefficients are read in the       */
   /* opposite order.                                                   */
   /*-------------------------------------------------------------------*/

   iters = cols;

   /*--------------------------------------------------------------------*/
   /* Low-Pass filter: in_data contains 8 pointers which point to input  */
   /* lines. The filters are placed vertically and input data is read    */
   /* from 8 seperate lines. Hence data-reuse is not possible when       */
   /* traversing horizontally. sum_l is initialized to Qr and contains   */
   /* the low-pass FIR sum at the end of the j loop. sum_h contains the  */
   /* accumulator result for the high pass filter in a similar fashion.  */
   /* M is assumed to be 8 by all kernels and is # filter taps for D4    */
   /*--------------------------------------------------------------------*/

   for ( i = 0; i < iters; i++)
   {
       sum_l    = Qr;
       filt_ptr = qmf;

       for ( j = 0; j < M; j++)
       {
           xdata   =  in_data[j][i];
           ldata   =  *filt_ptr++;
           prod_l  =  xdata * ldata;
           sum_l  +=  prod_l;
       }

       res_l    = (sum_l >> Qpt);
       *out_ldata++ = res_l;
   }

   /*------------------------------------------------------------------*/
   /* High-Pass filter: in_data contains 8 pointers which point to input */
   /* lines. The filters are placed vertically and input data is read  */
   /* from 8 seperate lines. Hence data-reuse is not possible when     */
   /* traversing horizontally. sum_h is initialized to Qr and contains */
   /* the low-pass FIR sum at the end of the j loop. sum_h contains the*/
   /* accumulator result for the high pass filter in a similar fashion.*/
   /* M is # filter taps and is assumed to be 8 by all kenels          */
   /*------------------------------------------------------------------*/

   for ( i = 0; i < iters; i++)
   {
       sum_h    = Qr;
       filt_ptr = mqmf + M - 1;

       for ( j = 0; j < M; j++)
       {
           xdata   =  in_data[j][i];
           hdata   =  *filt_ptr--;
           prod_h  =  xdata * hdata;
           sum_h  +=  prod_h;
       }

       res_h    = (sum_h >> Qpt);
       *out_hdata++ = res_h;
    }
}

/* ======================================================================== */
/*  End of file:  img_wave_vert.c                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
yc_demux_0.c/   1066929162  0     0     0       7583      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Sat Mar 16 03:10:25 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_yc_demux_be16 -- De-interleave a 4:2:2 BIG ENDIAN video stream  */
/*                       into three separate LITTLE ENDIAN 16-bit planes    */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      02-Oct-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This function is C callable, and is called as follows:              */
/*                                                                          */
/*      void IMG_yc_demux_be16                                              */
/*      (                                                                   */
/*          int n,                     // Number of luma pixels    //       */
/*          const unsigned char * yc,  // Interleaved luma/chroma  //       */
/*          short *restrict y,         // Luma plane (16-bit)      //       */
/*          short *restrict cr,        // Cr chroma plane (16-bit) //       */
/*          short *restrict cb         // Cb chroma plane (16-bit) //       */
/*      );                                                                  */
/*                                                                          */
/*      The input array 'yc' is expected to be an interleaved 4:2:2         */
/*      video stream.  The input is expected in BIG ENDIAN byte order       */
/*      within each 4-byte word.  This is consistent with reading the       */
/*      video stream from a word-oriented BIG ENDIAN device while the       */
/*      C6000 device is in a LITTLE ENDIAN configuration.                   */
/*                                                                          */
/*      In other words, the expected pixel order is:                        */
/*                                                                          */
/*                  Word 0           Word 1          Word 2                 */
/*             +---------------+---------------+---------------+--          */
/*       Byte# | 0   1   2   3 | 4   5   6   7 | 8   9  10  11 |...         */
/*             |cb0 y1  cr0 y0 |cb2 y3  cr2 y2 |cb4 y5  cr4 y4 |...         */
/*             +---------------+---------------+---------------+--          */
/*                                                                          */
/*      The output arrays 'y', 'cr', and 'cb' are expected to not           */
/*      overlap.  The de-interleaved pixels are written as half-words       */
/*      in LITTLE ENDIAN order.                                             */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This function reads the byte-oriented pixel data, zero-extends      */
/*      it, and then writes it to the appropriate result array.  Both       */
/*      the luma and chroma values are expected to be unsigned.             */
/*                                                                          */
/*      The data is expected to be in an order consistent with              */
/*      reading byte oriented data from a word-oriented peripheral          */
/*      that is operating in BIG ENDIAN mode, while the CPU is              */
/*      in LITTLE ENDIAN mode.  This results in a pixel ordering            */
/*      which is not immediately obvious.  This function correctly          */
/*      reorders the pixel values so that further processing may            */
/*      proceed in LITTLE ENDIAN mode.                                      */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

#include "IMG_yc_demux_be16.h"

void IMG_yc_demux_be16
(
    int n,                               /* Number of luma pixels    */
    const unsigned char *restrict yc,    /* Interleaved luma/chroma  */
    short *restrict y,                   /* Luma plane (16-bit)      */
    short *restrict cr,                  /* Cr chroma plane (16-bit) */
    short *restrict cb                   /* Cb chroma plane (16-bit) */
)
{
    int i;

    for (i = 0; i < (n >> 1); i++)
    {
        /*  0   1   2   3  */
        /* cb0 y1  cr0  y0 */

        y[2*i+0] = yc[4*i + 3];
        y[2*i+1] = yc[4*i + 1];
        cr[i]    = yc[4*i + 2];
        cb[i]    = yc[4*i + 0];
    }
}

/* ======================================================================== */
/*  End of file:  img_yc_demux_be16.c                                       */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

yc_demux_1.c/   1066929162  0     0     0       7620      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Sat Mar 16 03:57:25 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_yc_demux_le16 -- De-interleave a 4:2:2 LITTLE ENDIAN video stream */
/*                       into three separate LITTLE ENDIAN 16-bit planes    */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      15-Mar-2002                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This function is C callable, and is called as follows:              */
/*                                                                          */
/*      void IMG_yc_demux_le16                                              */
/*      (                                                                   */
/*          int n,                       // Number of luma pixels    //     */
/*          const unsigned char * yc,    // Interleaved luma/chroma  //     */
/*          short *restrict y,           // Luma plane (16-bit)      //     */
/*          short *restrict cr,          // Cr chroma plane (16-bit) //     */
/*          short *restrict cb           // Cb chroma plane (16-bit) //     */
/*      );                                                                  */
/*                                                                          */
/*      The input array 'yc' is expected to be an interleaved 4:2:2         */
/*      video stream.  The input is expected in LITTLE ENDIAN byte          */
/*      order within each 4-byte word.  This is consistent with reading     */
/*      the video stream from a word-oriented LITTLE ENDIAN device          */
/*      while the C6000 device is in a LITTLE ENDIAN configuration.         */
/*                                                                          */
/*      In other words, the expected pixel order is:                        */
/*                                                                          */
/*                  Word 0           Word 1          Word 2                 */
/*             +---------------+---------------+---------------+--          */
/*       Byte# | 0   1   2   3 | 4   5   6   7 | 8   9  10  11 |...         */
/*             | y0 cr0 y1 cb0 | y2 cr2 y3 cb2 | y4 cr4 y5 cb4 |...         */
/*             +---------------+---------------+---------------+--          */
/*                                                                          */
/*      The output arrays 'y', 'cr', and 'cb' are expected to not           */
/*      overlap.  The de-interleaved pixels are written as half-words       */
/*      in LITTLE ENDIAN order.                                             */
/*                                                                          */
/*      Please see the IMGLIB function IMB_yc_demux_be16 for code which     */
/*      handles input coming from a BIG ENDIAN device.                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This function reads the byte-oriented pixel data, zero-extends      */
/*      it, and then writes it to the appropriate result array.  Both       */
/*      the luma and chroma values are expected to be unsigned.             */
/*                                                                          */
/*      The data is expected to be in an order consistent with reading      */
/*      byte oriented data from a word-oriented peripheral that is          */
/*      operating in LITTLE ENDIAN mode, while the CPU is in LITTLE         */
/*      ENDIAN mode.  This function unpacks the byte-oriented data          */
/*      so that further processing may proceed in LITTLE ENDIAN mode.       */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

#include "IMG_yc_demux_le16.h"

void IMG_yc_demux_le16
(
    int n,                      /* Number of luma pixels    */
    const unsigned char *yc,    /* Interleaved luma/chroma  */
    short *restrict y,          /* Luma plane (16-bit)      */
    short *restrict cr,         /* Cr chroma plane (16-bit) */
    short *restrict cb          /* Cb chroma plane (16-bit) */
)
{
    int i;

    for (i = 0; i < (n >> 1); i++)
    {
        /*  0   1   2   3  */
        /*  y0 cr0 y1 cb0  */

        y[2*i+0] = yc[4*i + 0];
        y[2*i+1] = yc[4*i + 2];
        cr[i]    = yc[4*i + 1];
        cb[i]    = yc[4*i + 3];
    }
}

/* ======================================================================== */
/*  End of file:  img_yc_demux_le16.c                                       */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
ycbcr422p_.c/   1066929162  0     0     0       25933     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  IMGLIB  DSP Image/Video Processing Library                              */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.9     Tue Mar 26 19:07:55 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      IMG_ycbcr422p_rgb565 -- Planarized YCbCr 4:2:2 to 16-bit RGB 5:6:5  */
/*                              color space conversion.                     */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      12-Aug-1999                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This function is C callable, and is called according to this        */
/*      C prototype:                                                        */
/*                                                                          */
/*      void IMG_ycbcr422p_rgb565                                           */
/*      (                                                                   */
/*        const short         coeff[5],  // Matrix coefficients.        //  */
/*        const unsigned char *y_data,   // Luminence data  (Y')        //  */
/*        const unsigned char *cb_data,  // Blue color-diff (B'-Y')     //  */
/*        const unsigned char *cr_data,  // Red color-diff  (R'-Y')     //  */
/*        unsigned short                                                    */
/*                   *restrict rgb_data, // RGB 5:6:5 packed pixel out. //  */
/*        unsigned            num_pixels // # of luma pixels to process //  */
/*      );                                                                  */
/*                                                                          */
/*      The 'coeff[]' array contains the color-space-conversion matrix      */
/*      coefficients.  The 'y_data', 'cb_data' and 'cr_data' pointers       */
/*      point to the separate input image planes.  The 'rgb_data' pointer   */
/*      points to the output image buffer.                                  */
/*                                                                          */
/*      The kernel is designed to process arbitrary amounts of 4:2:2        */
/*      image data, although 4:2:0 image data may be processed as well.     */
/*      For 4:2:2 input data, the 'y_data', 'cb_data' and 'cr_data'         */
/*      arrays may hold an arbitrary amount of image data, including        */
/*      multiple scan lines of image data.                                  */
/*                                                                          */
/*      For 4:2:0 input data, only a single scan-line (or portion           */
/*      thereof) may be processed at a time.  This is achieved by           */
/*      calling the function twice using the same row data for              */
/*      'cr_data' and 'cb_data', and providing new row data for             */
/*      'y_data'.  This is numerically equivalent to replicating the Cr     */
/*      and Cb pixels vertically.                                           */
/*                                                                          */
/*      The coefficients in the coeff array must be in signed Q13 form.     */
/*      These coefficients correspond to the following matrix equation:     */
/*                                                                          */
/*          [ coeff[0] 0.0000   coeff[1] ]   [ Y' -  16 ]     [ R']         */
/*          [ coeff[0] coeff[2] coeff[3] ] * [ Cb - 128 ]  =  [ G']         */
/*          [ coeff[0] coeff[4] 0.0000   ]   [ Cr - 128 ]     [ B']         */
/*                                                                          */
/*      The output from this kernel is 16-bit RGB in 5:6:5 format.          */
/*      The RGB components are packed into halfwords as shown below.        */
/*                                                                          */
/*                     15      11 10       5 4        0                     */
/*                    +----------+----------+----------+                    */
/*                    |   Red    |  Green   |   Blue   |                    */
/*                    +----------+----------+----------+                    */
/*                                                                          */
/*      This kernel can also return the red, green, and blue values in      */
/*      the opposite order if a particular application requires it.         */
/*      This is achieved by exchanging the 'cb_data' and 'cr_data'          */
/*      arguments when calling the function, and by reversing the order     */
/*      of coefficients in coeff[1] through coeff[4].  This essentially     */
/*      implements the following matrix multiply:                           */
/*                                                                          */
/*          [ coeff[0] 0.0000   coeff[4] ]   [ Y' -  16 ]     [ B']         */
/*          [ coeff[0] coeff[3] coeff[2] ] * [ Cr - 128 ]  =  [ G']         */
/*          [ coeff[0] coeff[1] 0.0000   ]   [ Cb - 128 ]     [ R']         */
/*                                                                          */
/*      The reversed RGB ordering output by this mode is as follows:        */
/*                                                                          */
/*                     15      11 10       5 4        0                     */
/*                    +----------+----------+----------+                    */
/*                    |   Blue   |  Green   |   Red    |                    */
/*                    +----------+----------+----------+                    */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This kernel performs Y'CbCr to RGB conversion.  From the Color      */
/*      FAQ, http://home.inforamp.net/~poynton/ColorFAQ.html :              */
/*                                                                          */
/*          Various scale factors are applied to (B'-Y') and (R'-Y')        */
/*          for different applications.  The Y'PbPr scale factors are       */
/*          optimized for component analog video.  The Y'CbCr scaling       */
/*          is appropriate for component digital video, JPEG and MPEG.      */
/*          Kodak's PhotoYCC(tm) uses scale factors optimized for the       */
/*          gamut of film colors.  Y'UV scaling is appropriate as an        */
/*          intermediate step in the formation of composite NTSC or PAL     */
/*          video signals, but is not appropriate when the components       */
/*          are keps separate.  Y'UV nomenclature is now used rather        */
/*          loosely, and it sometimes denotes any scaling of (B'-Y')        */
/*          and (R'-Y').  Y'IQ coding is obsolete.                          */
/*                                                                          */
/*      This code can perform various flavors of Y'CbCr to RGB              */
/*      conversion as long as the offsets on Y, Cb, and Cr are -16,         */
/*      -128, and -128, respectively, and the coefficients match the        */
/*      pattern shown.                                                      */
/*                                                                          */
/*      The kernel implements the following matrix form, which involves 5   */
/*      unique coefficients:                                                */
/*                                                                          */
/*          [ coeff[0] 0.0000   coeff[1] ]   [ Y' -  16 ]     [ R']         */
/*          [ coeff[0] coeff[2] coeff[3] ] * [ Cb - 128 ]  =  [ G']         */
/*          [ coeff[0] coeff[4] 0.0000   ]   [ Cr - 128 ]     [ B']         */
/*                                                                          */
/*                                                                          */
/*      Below are some common coefficient sets, along with the matrix       */
/*      equation that they correspond to.   Coefficients are in signed      */
/*      Q13 notation, which gives a suitable balance between precision      */
/*      and range.                                                          */
/*                                                                          */
/*      1.  Y'CbCr -> RGB conversion with RGB levels that correspond to     */
/*          the 219-level range of Y'.  Expected ranges are [16..235] for   */
/*          Y' and [16..240] for Cb and Cr.                                 */
/*                                                                          */
/*          coeff[] = { 0x2000, 0x2BDD, -0x0AC5, -0x1658, 0x3770 };         */
/*                                                                          */
/*          [ 1.0000    0.0000    1.3707 ]   [ Y' -  16 ]     [ R']         */
/*          [ 1.0000   -0.3365   -0.6982 ] * [ Cb - 128 ]  =  [ G']         */
/*          [ 1.0000    1.7324    0.0000 ]   [ Cr - 128 ]     [ B']         */
/*                                                                          */
/*      2.  Y'CbCr -> RGB conversion with the 219-level range of Y'         */
/*          expanded to fill the full RGB dynamic range.  (The matrix       */
/*          has been scaled by 255/219.)  Expected ranges are [16..235]     */
/*          for Y' and [16..240] for Cb and Cr.                             */
/*                                                                          */
/*          coeff[] = { 0x2543, 0x3313, -0x0C8A, -0x1A04, 0x408D };         */
/*                                                                          */
/*          [ 1.1644    0.0000    1.5960 ]   [ Y' -  16 ]     [ R']         */
/*          [ 1.1644   -0.3918   -0.8130 ] * [ Cb - 128 ]  =  [ G']         */
/*          [ 1.1644    2.0172    0.0000 ]   [ Cr - 128 ]     [ B']         */
/*                                                                          */
/*      3.  Y'CbCr -> BGR conversion with RGB levels that correspond to     */
/*          the 219-level range of Y'.  This is equivalent to #1 above,     */
/*          except that the R, G, and B output order in the packed          */
/*          pixels is reversed.  Note:  The 'cr_data' and 'cb_data'         */
/*          input arguments must be exchanged for this example as           */
/*          indicated under USAGE above.                                    */
/*                                                                          */
/*          coeff[] = { 0x2000, 0x3770, -0x1658, -0x0AC5, 0x2BDD };         */
/*                                                                          */
/*          [ 1.0000    0.0000    1.7324 ]   [ Y' -  16 ]     [ B']         */
/*          [ 1.0000   -0.6982   -0.3365 ] * [ Cr - 128 ]  =  [ G']         */
/*          [ 1.0000    1.3707    0.0000 ]   [ Cb - 128 ]     [ R']         */
/*                                                                          */
/*      4.  Y'CbCr -> BGR conversion with the 219-level range of Y'         */
/*          expanded to fill the full RGB dynamic range.  This is           */
/*          equivalent to #2 above, except that the R, G, and B output      */
/*          order in the packed pixels is reversed.  Note:  The             */
/*          'cr_data' and 'cb_data' input arguments must be exchanged       */
/*          for this example as indicated under USAGE above.                */
/*                                                                          */
/*          coeff[] = { 0x2000, 0x408D, -0x1A04, -0x0C8A, 0x3313 };         */
/*                                                                          */
/*          [ 1.0000    0.0000    2.0172 ]   [ Y' -  16 ]     [ B']         */
/*          [ 1.0000   -0.8130   -0.3918 ] * [ Cr - 128 ]  =  [ G']         */
/*          [ 1.0000    1.5960    0.0000 ]   [ Cb - 128 ]     [ R']         */
/*                                                                          */
/*      Other scalings of the color differences (B'-Y') and (R'-Y')         */
/*      (sometimes incorrectly referred to as U and V) are supported, as    */
/*      long as the color differences are unsigned values centered around   */
/*      128 rather than signed values centered around 0, as noted above.    */
/*                                                                          */
/*      In addition to performing plain color-space conversion, color       */
/*      saturation can be adjusted by scaling coeff[1] through coeff[4].    */
/*      Similarly, brightness can be adjusted by scaling coeff[0].          */
/*      General hue adjustment can not be performed, however, due to the    */
/*      two zeros hard-coded in the matrix.                                 */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      Pixel replication is performed implicitly on chroma data to         */
/*      reduce the total number of multiplies required.  The chroma         */
/*      portion of the matrix is calculated once for each Cb, Cr pair,      */
/*      and the result is added to both Y' samples.                         */
/*                                                                          */
/*      Luma is biased downwards to produce R, G, and B values that are     */
/*      signed quantities centered around zero, rather than unsigned qtys.  */
/*  ASSUMPTIONS                                                             */
/*      An even number of luma samples needs to be processed.               */
/*                                                                          */
/*  SOURCE                                                                  */
/*      Poynton, Charles et al.  "The Color FAQ,"  1999.                    */
/*          http://home.inforamp.net/~poynton/ColorFAQ.html                 */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void IMG_ycbcr422p_rgb565
(
    const short             coeff[5],   /* Matrix coefficients.             */
    const unsigned char     *y_data,    /* Luminence data        (Y')       */
    const unsigned char     *cb_data,   /* Blue color-difference (B'-Y')    */
    const unsigned char     *cr_data,   /* Red color-difference  (R'-Y')    */
    unsigned short *restrict rgb_data,  /* RGB 5:6:5 packed pixel output.   */
    unsigned                num_pixels  /* # of luma pixels to process.     */
)
{
    int     i;                      /* Loop counter                     */
    int     y0, y1;                 /* Individual Y components          */
    int     cb, cr;                 /* Color difference components      */
    int     y0t,y1t;                /* Temporary Y values               */
    int     rt, gt, bt;             /* Temporary RGB values             */
    int     r0, g0, b0;             /* Individual RGB components        */
    int     r1, g1, b1;             /* Individual RGB components        */
    int     r0t,g0t,b0t;            /* Truncated RGB components         */
    int     r1t,g1t,b1t;            /* Truncated RGB components         */
    int     r0s,g0s,b0s;            /* Saturated RGB components         */
    int     r1s,g1s,b1s;            /* Saturated RGB components         */

    short   luma = coeff[0];        /* Luma scaling coefficient.        */
    short   r_cr = coeff[1];        /* Cr's contribution to Red.        */
    short   g_cb = coeff[2];        /* Cb's contribution to Green.      */
    short   g_cr = coeff[3];        /* Cr's contribution to Green.      */
    short   b_cb = coeff[4];        /* Cb's contribution to Blue.       */

    unsigned short  rgb0, rgb1;     /* Packed RGB pixel data            */

    /* -------------------------------------------------------------------- */
    /*  Iterate for num_pixels/2 iters, since we process pixels in pairs.   */
    /* -------------------------------------------------------------------- */
    i = num_pixels >> 1;

    while (i-->0)
    {
        /* ---------------------------------------------------------------- */
        /*  Read in YCbCr data from the separate data planes.               */
        /*                                                                  */
        /*  The Cb and Cr channels come in biased upwards by 128, so        */
        /*  subtract the bias here before performing the multiplies for     */
        /*  the color space conversion itself.  Also handle Y's upward      */
        /*  bias of 16 here.                                                */
        /* ---------------------------------------------------------------- */

        y0 = *y_data++  - 16;
        y1 = *y_data++  - 16;
        cb = *cb_data++ - 128;
        cr = *cr_data++ - 128;

        /* ================================================================ */
        /*  Convert YCrCb data to RGB format using the following matrix:    */
        /*                                                                  */
        /*      [ coeff[0] 0.0000   coeff[1] ]   [ Y' -  16 ]     [ R']     */
        /*      [ coeff[0] coeff[2] coeff[3] ] * [ Cb - 128 ]  =  [ G']     */
        /*      [ coeff[0] coeff[4] 0.0000   ]   [ Cr - 128 ]     [ B']     */
        /*                                                                  */
        /*  We use signed Q13 coefficients for the coefficients to make     */
        /*  good use of our 16-bit multiplier.  Although a larger Q-point   */
        /*  may be used with unsigned coefficients, signed coefficients     */
        /*  add a bit of flexibility to the kernel without significant      */
        /*  loss of precision.                                              */
        /* ================================================================ */

        /* ---------------------------------------------------------------- */
        /*  Calculate chroma channel's contribution to RGB.                 */
        /* ---------------------------------------------------------------- */
        rt  = r_cr * (short)cr;
        gt  = g_cb * (short)cb + g_cr * (short)cr;
        bt  = b_cb * (short)cb;

        /* ---------------------------------------------------------------- */
        /*  Calculate intermediate luma values.  Include bias of 16 here.   */
        /* ---------------------------------------------------------------- */
        y0t = luma * (short)y0;
        y1t = luma * (short)y1;

        /* ---------------------------------------------------------------- */
        /*  Mix luma, chroma channels.                                      */
        /* ---------------------------------------------------------------- */
        r0  = y0t + rt; r1 = y1t + rt;
        g0  = y0t + gt; g1 = y1t + gt;
        b0  = y0t + bt; b1 = y1t + bt;

        /* ================================================================ */
        /*  At this point in the calculation, the RGB components are        */
        /*  nominally in the format below.  If the color is outside the     */
        /*  our RGB gamut, some of the sign bits may be non-zero,           */
        /*  triggering saturation.                                          */
        /*                                                                  */
        /*                  3     2 2        1 1                            */
        /*                  1     1 0        3 2         0                  */
        /*                 [ SIGN  | COLOR    | FRACTION ]                  */
        /*                                                                  */
        /*  This gives us an 8-bit range for each of the R, G, and B        */
        /*  components.  (The transform matrix is designed to transform     */
        /*  8-bit Y/C values into 8-bit R,G,B values.)  To get our final    */
        /*  5:6:5 result, we "divide" our R, G and B components by 4, 8,    */
        /*  and 4, respectively, by reinterpreting the numbers in the       */
        /*  format below:                                                   */
        /*                                                                  */
        /*          Red,    3     2 2     1 1                               */
        /*          Blue    1     1 0     6 5            0                  */
        /*                 [ SIGN  | COLOR | FRACTION    ]                  */
        /*                                                                  */
        /*                  3     2 2      1 1                              */
        /*          Green   1     1 0      5 4           0                  */
        /*                 [ SIGN  | COLOR  | FRACTION   ]                  */
        /*                                                                  */
        /*  "Divide" is in quotation marks because this step requires no    */
        /*  actual work.  The code merely treats the numbers as having a    */
        /*  different Q-point.                                              */
        /* ================================================================ */

        /* ---------------------------------------------------------------- */
        /*  Shift away the fractional portion, and then saturate to the     */
        /*  RGB 5:6:5 gamut.                                                */
        /* ---------------------------------------------------------------- */
        r0t = r0 >> 16;
        g0t = g0 >> 15;
        b0t = b0 >> 16;
        r1t = r1 >> 16;
        g1t = g1 >> 15;
        b1t = b1 >> 16;

        r0s = r0t < 0 ? 0 : r0t > 31 ? 31 : r0t;
        g0s = g0t < 0 ? 0 : g0t > 63 ? 63 : g0t;
        b0s = b0t < 0 ? 0 : b0t > 31 ? 31 : b0t;
        r1s = r1t < 0 ? 0 : r1t > 31 ? 31 : r1t;
        g1s = g1t < 0 ? 0 : g1t > 63 ? 63 : g1t;
        b1s = b1t < 0 ? 0 : b1t > 31 ? 31 : b1t;

        /* ---------------------------------------------------------------- */
        /*  Merge values into output pixels.                                */
        /* ---------------------------------------------------------------- */
        rgb0 = (r0s << 11) + (g0s <<  5) + (b0s <<  0);
        rgb1 = (r1s << 11) + (g1s <<  5) + (b1s <<  0);

        /* ---------------------------------------------------------------- */
        /*  Store resulting pixels to memory.                               */
        /* ---------------------------------------------------------------- */
        *rgb_data++ = rgb0;
        *rgb_data++ = rgb1;
    }

    return;
}

/* ======================================================================== */
/*  End of file:  img_ycbcr422p_rgb565.c                                    */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

